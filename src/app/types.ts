export const libs = [{"name":"@airgap/beacon-sdk/clients/beacon-client/BeaconClient.d.ts","dts":"import * as sodium from 'libsodium-wrappers';\nimport { ExposedPromise } from '../../utils/exposed-promise';\nimport { Storage } from '../..';\nimport { BeaconEventHandler } from '../../events';\nimport { BeaconClientOptions } from './BeaconClientOptions';\n/**\n * The beacon client is an abstract client that handles everything that is shared between all other clients.\n * Specifically, it handles managing the beaconId and and the local keypair.\n */\nexport declare abstract class BeaconClient {\n    /**\n     * The name of the client\n     */\n    readonly name: string;\n    /**\n     * The URL of the dApp Icon. This can be used to display the icon of the dApp on in the wallet\n     */\n    readonly iconUrl?: string;\n    /**\n     * The URL of the dApp.\n     */\n    readonly appUrl?: string;\n    /** The beaconId is a public key that is used to identify one specific application (dapp or wallet).\n     * This is used inside a message to specify the sender, for example.\n     */\n    protected _beaconId: ExposedPromise<string>;\n    get beaconId(): Promise<string>;\n    protected storage: Storage;\n    protected readonly events: BeaconEventHandler;\n    /**\n     * The local keypair that is used for the communication encryption\n     */\n    protected _keyPair: ExposedPromise<sodium.KeyPair>;\n    protected get keyPair(): Promise<sodium.KeyPair>;\n    constructor(config: BeaconClientOptions);\n    /**\n     * This resets the SDK. After using this method, this instance is no longer usable. You will have to instanciate a new client.\n     */\n    destroy(): Promise<void>;\n    /**\n     * This method initializes the SDK by setting some values in the storage and generating a keypair.\n     */\n    private initSDK;\n    /**\n     * Removes all beacon values from the storage.\n     */\n    private removeBeaconEntriesFromStorage;\n    /**\n     * This method tries to load the seed from storage, if it doesn't exist, a new one will be created and persisted.\n     */\n    private loadOrCreateBeaconSecret;\n}\n"},{"name":"@airgap/beacon-sdk/clients/beacon-client/BeaconClientOptions.d.ts","dts":"import { Storage } from '../..';\nexport interface BeaconClientOptions {\n    /**\n     * Name of the application\n     */\n    name: string;\n    /**\n     * A URL to the icon of the application\n     */\n    iconUrl?: string;\n    /**\n     * A URL to the website of the application\n     */\n    appUrl?: string;\n    /**\n     * The storage that will be used by the SDK\n     */\n    storage: Storage;\n}\n"},{"name":"@airgap/beacon-sdk/clients/client/Client.d.ts","dts":"import { ExposedPromise } from '../../utils/exposed-promise';\nimport { ConnectionContext } from '../../types/ConnectionContext';\nimport { TransportType, TransportStatus, AccountInfo, PeerInfo, Transport, AppMetadata } from '../..';\nimport { BeaconEventHandler } from '../../events';\nimport { BeaconClient } from '../beacon-client/BeaconClient';\nimport { AccountManager } from '../../managers/AccountManager';\nimport { BeaconRequestMessage } from '../../types/beacon/BeaconRequestMessage';\nimport { ClientOptions } from './ClientOptions';\n/**\n * This abstract class handles the a big part of the logic that is shared between the dapp and wallet client.\n * For example, it selects and manages the transport and accounts.\n */\nexport declare abstract class Client extends BeaconClient {\n    protected readonly accountManager: AccountManager;\n    protected handleResponse: (_event: BeaconRequestMessage, connectionInfo: ConnectionContext) => void;\n    /**\n     * How many requests can be sent after another\n     */\n    protected readonly rateLimit: number;\n    /**\n     * The time window in seconds in which the \"rateLimit\" is checked\n     */\n    protected readonly rateLimitWindowInSeconds: number;\n    /**\n     * Stores the times when requests have been made to determine if the rate limit has been reached\n     */\n    protected requestCounter: number[];\n    protected readonly events: BeaconEventHandler;\n    protected readonly matrixNodes: string[];\n    protected _transport: ExposedPromise<Transport<any>>;\n    protected get transport(): Promise<Transport<any>>;\n    /**\n     * Returns the connection status of the Client\n     */\n    get connectionStatus(): TransportStatus;\n    /**\n     * Returns whether or not the transaport is ready\n     */\n    get ready(): Promise<void>;\n    constructor(config: ClientOptions);\n    /**\n     * Return all locally known accounts\n     */\n    getAccounts(): Promise<AccountInfo[]>;\n    /**\n     * Return the account by ID\n     * @param accountIdentifier The ID of an account\n     */\n    getAccount(accountIdentifier: string): Promise<AccountInfo | undefined>;\n    /**\n     * Remove the account by ID\n     * @param accountIdentifier The ID of an account\n     */\n    removeAccount(accountIdentifier: string): Promise<void>;\n    /**\n     * Remove all locally stored accounts\n     */\n    removeAllAccounts(): Promise<void>;\n    /**\n     * Add a new request (current timestamp) to the pending requests, remove old ones and check if we are above the limit\n     */\n    addRequestAndCheckIfRateLimited(): Promise<boolean>;\n    /**\n     * This method initializes the client. It will check if the connection should be established to a\n     * browser extension or if the P2P transport should be used.\n     *\n     * @param transport A transport that can be provided by the user\n     */\n    init(transport: Transport<any>): Promise<TransportType>;\n    /**\n     * Returns the metadata of this DApp\n     */\n    getOwnAppMetadata(): Promise<AppMetadata>;\n    /**\n     * Return all known peers\n     */\n    getPeers(): Promise<PeerInfo[]>;\n    /**\n     * Add a new peer to the known peers\n     * @param peer The new peer to add\n     */\n    addPeer(peer: PeerInfo): Promise<void>;\n    /**\n     * A \"setter\" for when the transport needs to be changed.\n     */\n    protected setTransport(transport?: Transport<any>): Promise<void>;\n    protected addListener(transport: Transport<any>): Promise<void>;\n    protected sendDisconnectToPeer(peer: PeerInfo, transport?: Transport<any>): Promise<void>;\n}\n"},{"name":"@airgap/beacon-sdk/clients/client/ClientOptions.d.ts","dts":"import { Storage } from '../..';\nimport { BeaconEvent, BeaconEventHandlerFunction, BeaconEventType } from '../../events';\nexport interface ClientOptions {\n    /**\n     * Name of the application\n     */\n    name: string;\n    /**\n     * A URL to the icon of the application\n     */\n    iconUrl?: string;\n    /**\n     * A URL to the website of the application\n     */\n    appUrl?: string;\n    /**\n     * The storage that will be used by the SDK\n     */\n    storage: Storage;\n    /**\n     * An object that will be used to overwrite default event handler behaviour.\n     *\n     * If you plan to overwrite all default events, use \"disableDefaultEvents\" instead.\n     *\n     * This will overwrite the default event handler, so this can lead to unexpected behavior in some cases.\n     * We recommend that you overwrite all handlers if you want to use your own UI.\n     *\n     * If you simply want to be notified of events happening, but do not want to overwrite the default behavior,\n     * please use `subscribeToEvent()` on the DAppClient instead.\n     */\n    eventHandlers?: {\n        [key in BeaconEvent]?: {\n            handler: BeaconEventHandlerFunction<BeaconEventType[key]>;\n        };\n    };\n    /**\n     * Disable all default Events and UI elements. If passed together with \"eventHandlers\",\n     * the default eventHandlers will be removed, and the ones passed by the user will be added.\n     */\n    disableDefaultEvents?: boolean;\n    /**\n     * A list of matrix nodes to connect to. If a non-empty array is passed, the default options will be overwritten.\n     * One node will be randomly selected based on the local keypair and the other nodes will be used as a fallback in case the primary node goes down.\n     *\n     * Only provide the hostname, no https:// prefix. Eg. ['matrix.example.com']\n     */\n    matrixNodes?: string[];\n}\n"},{"name":"@airgap/beacon-sdk/clients/dapp-client/DAppClient.d.ts","dts":"import { BeaconEvent, BeaconEventHandlerFunction, BeaconEventType } from '../../events';\nimport { AccountInfo, Client, TransportType, BeaconMessageType, NetworkType, RequestPermissionInput, RequestSignPayloadInput, RequestOperationInput, RequestBroadcastInput, PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, Transport, DappP2PTransport, DappPostMessageTransport, AppMetadata } from '../..';\nimport { BlockExplorer } from '../../utils/block-explorer';\nimport { ExtendedP2PPairingResponse } from '../../types/P2PPairingResponse';\nimport { ExtendedPostMessagePairingResponse } from '../../types/PostMessagePairingResponse';\nimport { ExtendedPeerInfo } from '../../types/PeerInfo';\nimport { ColorMode } from '../../types/ColorMode';\nimport { DAppClientOptions } from './DAppClientOptions';\n/**\n * The DAppClient has to be used in decentralized applications. It handles all the logic related to connecting to beacon-compatible\n * wallets and sending requests.\n */\nexport declare class DAppClient extends Client {\n    /**\n     * The block explorer used by the SDK\n     */\n    readonly blockExplorer: BlockExplorer;\n    preferredNetwork: NetworkType;\n    protected postMessageTransport: DappPostMessageTransport | undefined;\n    protected p2pTransport: DappP2PTransport | undefined;\n    /**\n     * A map of requests that are currently \"open\", meaning we have sent them to a wallet and are still awaiting a response.\n     */\n    private readonly openRequests;\n    /**\n     * The currently active account. For all requests that are associated to a specific request (operation request, signing request),\n     * the active account is used to determine the network and destination wallet\n     */\n    private _activeAccount;\n    /**\n     * The currently active peer. This is used to address a peer in case the active account is not set. (Eg. for permission requests)\n     */\n    private _activePeer;\n    private _initPromise;\n    private readonly activePeerLoaded;\n    private readonly activeAccountLoaded;\n    private readonly appMetadataManager;\n    constructor(config: DAppClientOptions);\n    initInternalTransports(): Promise<void>;\n    init(transport?: Transport<any>): Promise<TransportType>;\n    /**\n     * Returns the active account\n     */\n    getActiveAccount(): Promise<AccountInfo | undefined>;\n    /**\n     * Sets the active account\n     *\n     * @param account The account that will be set as the active account\n     */\n    setActiveAccount(account?: AccountInfo): Promise<void>;\n    /**\n     * Clear the active account\n     */\n    clearActiveAccount(): Promise<void>;\n    setColorMode(colorMode: ColorMode): Promise<void>;\n    getColorMode(): Promise<ColorMode>;\n    /**\n     * @deprecated\n     *\n     * Use getOwnAppMetadata instead\n     */\n    getAppMetadata(): Promise<AppMetadata>;\n    /**\n     * Will remove the account from the local storage and set a new active account if necessary.\n     *\n     * @param accountIdentifier ID of the account\n     */\n    removeAccount(accountIdentifier: string): Promise<void>;\n    /**\n     * Remove all accounts and set active account to undefined\n     */\n    removeAllAccounts(): Promise<void>;\n    /**\n     * Removes a peer and all the accounts that have been connected through that peer\n     *\n     * @param peer Peer to be removed\n     */\n    removePeer(peer: ExtendedPeerInfo, sendDisconnectToPeer?: boolean): Promise<void>;\n    /**\n     * Remove all peers and all accounts that have been connected through those peers\n     */\n    removeAllPeers(sendDisconnectToPeers?: boolean): Promise<void>;\n    /**\n     * Allows the user to subscribe to specific events that are fired in the SDK\n     *\n     * @param internalEvent The event to subscribe to\n     * @param eventCallback The callback that will be called when the event occurs\n     */\n    subscribeToEvent<K extends BeaconEvent>(internalEvent: K, eventCallback: BeaconEventHandlerFunction<BeaconEventType[K]>): Promise<void>;\n    /**\n     * Check if we have permissions to send the specific message type to the active account.\n     * If no active account is set, only permission requests are allowed.\n     *\n     * @param type The type of the message\n     */\n    checkPermissions(type: BeaconMessageType): Promise<boolean>;\n    /**\n     * Send a permission request to the DApp. This should be done as the first step. The wallet will respond\n     * with an publicKey and permissions that were given. The account returned will be set as the \"activeAccount\"\n     * and will be used for the following requests.\n     *\n     * @param input The message details we need to prepare the PermissionRequest message.\n     */\n    requestPermissions(input?: RequestPermissionInput): Promise<PermissionResponseOutput>;\n    /**\n     * This method will send a \"SignPayloadRequest\" to the wallet. This method is meant to be used to sign\n     * arbitrary data (eg. a string). It will return the signature in the format of \"edsig...\"\n     *\n     * @param input The message details we need to prepare the SignPayloadRequest message.\n     */\n    requestSignPayload(input: RequestSignPayloadInput): Promise<SignPayloadResponseOutput>;\n    /**\n     * This method sends an OperationRequest to the wallet. This method should be used for all kinds of operations,\n     * eg. transaction or delegation. Not all properties have to be provided. Data like \"counter\" and fees will be\n     * fetched and calculated by the wallet (but they can still be provided if required).\n     *\n     * @param input The message details we need to prepare the OperationRequest message.\n     */\n    requestOperation(input: RequestOperationInput): Promise<OperationResponseOutput>;\n    /**\n     * Sends a \"BroadcastRequest\" to the wallet. This method can be used to inject an already signed transaction\n     * to the network.\n     *\n     * @param input The message details we need to prepare the BroadcastRequest message.\n     */\n    requestBroadcast(input: RequestBroadcastInput): Promise<BroadcastResponseOutput>;\n    protected setActivePeer(peer?: ExtendedPostMessagePairingResponse | ExtendedP2PPairingResponse): Promise<void>;\n    /**\n     * A \"setter\" for when the transport needs to be changed.\n     */\n    protected setTransport(transport?: Transport<any>): Promise<void>;\n    /**\n     * This method will emit an internal error message.\n     *\n     * @param errorMessage The error message to send.\n     */\n    private sendInternalError;\n    /**\n     * This method will remove all accounts associated with a specific peer.\n     *\n     * @param peersToRemove An array of peers for which accounts should be removed\n     */\n    private removeAccountsForPeers;\n    /**\n     * This message handles errors that we receive from the wallet.\n     *\n     * @param request The request we sent\n     * @param beaconError The error we received\n     */\n    private handleRequestError;\n    /**\n     * This message will send an event when we receive a successful response to one of the requests we sent.\n     *\n     * @param request The request we sent\n     * @param response The response we received\n     */\n    private notifySuccess;\n    private getWalletInfo;\n    private getPeer;\n    /**\n     * This method handles sending of requests to the DApp. It makes sure that the DAppClient is initialized and connected\n     * to the transport. After that rate limits and permissions will be checked, an ID is attached and the request is sent\n     * to the DApp over the transport.\n     *\n     * @param requestInput The BeaconMessage to be sent to the wallet\n     * @param account The account that the message will be sent to\n     */\n    private makeRequest;\n    /**\n     * Adds a requests to the \"openRequests\" set so we know what messages have already been answered/handled.\n     *\n     * @param id The ID of the message\n     * @param promise A promise that resolves once the response for that specific message is received\n     */\n    private addOpenRequest;\n}\n"},{"name":"@airgap/beacon-sdk/clients/dapp-client/DAppClientOptions.d.ts","dts":"import { NetworkType, Storage } from '../..';\nimport { BeaconEvent, BeaconEventType, BeaconEventHandlerFunction } from '../../events';\nimport { ColorMode } from '../../types/ColorMode';\nimport { BlockExplorer } from '../../utils/block-explorer';\nexport interface DAppClientOptions {\n    /**\n     * Name of the application\n     */\n    name: string;\n    /**\n     * A URL to the icon of the application\n     */\n    iconUrl?: string;\n    /**\n     * A URL to the website of the application\n     */\n    appUrl?: string;\n    /**\n     * The storage that will be used by the SDK\n     */\n    storage?: Storage;\n    /**\n     * An object that will be used to overwrite default event handler behaviour.\n     *\n     * If you plan to overwrite all default events, use \"disableDefaultEvents\" instead.\n     *\n     * This will overwrite the default event handler, so this can lead to unexpected behavior in some cases.\n     * We recommend that you overwrite all handlers if you want to use your own UI.\n     *\n     * If you simply want to be notified of events happening, but do not want to overwrite the default behavior,\n     * please use `subscribeToEvent()` on the DAppClient instead.\n     */\n    eventHandlers?: {\n        [key in BeaconEvent]?: {\n            handler: BeaconEventHandlerFunction<BeaconEventType[key]>;\n        };\n    };\n    /**\n     * Disable all default Events and UI elements. If passed together with \"eventHandlers\",\n     * the default eventHandlers will be removed, and the ones passed by the user will be added.\n     */\n    disableDefaultEvents?: boolean;\n    /**\n     * A list of matrix nodes to connect to. If a non-empty array is passed, the default options will be overwritten.\n     * One node will be randomly selected based on the local keypair and the other nodes will be used as a fallback in case the primary node goes down.\n     *\n     * Only provide the hostname, no https:// prefix. Eg. ['matrix.example.com']\n     */\n    matrixNodes?: string[];\n    /**\n     * The block explorer used by the SDK\n     */\n    blockExplorer?: BlockExplorer;\n    /**\n     * Indicates on which network the DApp is planning to run. This is currently used to adjust the URLs of web-wallets in the pairing alert if they use different URLs for testnets.\n     * You will still have to define the network you intend to use during the permission request.\n     */\n    preferredNetwork?: NetworkType;\n    /**\n     * Set the color mode for the UI elements (alerts and toasts)\n     */\n    colorMode?: ColorMode;\n}\n"},{"name":"@airgap/beacon-sdk/clients/wallet-client/WalletClient.d.ts","dts":"import { Client, WalletClientOptions, TransportType, BeaconRequestOutputMessage, BeaconResponseInputMessage, AppMetadata, PermissionInfo } from '../..';\nimport { ConnectionContext } from '../../types/ConnectionContext';\nimport { ExtendedP2PPairingResponse } from '../../types/P2PPairingResponse';\nimport { ExposedPromise } from '../../utils/exposed-promise';\nimport { PeerInfo } from '../../types/PeerInfo';\n/**\n * The WalletClient has to be used in the wallet. It handles all the logic related to connecting to beacon-compatible\n * dapps and handling/responding to requests.\n */\nexport declare class WalletClient extends Client {\n    /**\n     * Returns whether or not the transport is connected\n     */\n    protected readonly _isConnected: ExposedPromise<boolean>;\n    get isConnected(): Promise<boolean>;\n    private readonly permissionManager;\n    private readonly appMetadataManager;\n    /**\n     * This array stores pending requests, meaning requests we received and have not yet handled / sent a response.\n     */\n    private pendingRequests;\n    constructor(config: WalletClientOptions);\n    init(): Promise<TransportType>;\n    /**\n     * This method initiates a connection to the P2P network and registers a callback that will be called\n     * whenever a message is received.\n     *\n     * @param newMessageCallback The callback that will be invoked for every message the transport receives.\n     */\n    connect(newMessageCallback: (message: BeaconRequestOutputMessage, connectionContext: ConnectionContext) => void): Promise<void>;\n    /**\n     * The method will attempt to initiate a connection using the active transport.\n     */\n    _connect(): Promise<void>;\n    /**\n     * This method sends a response for a specific request back to the DApp\n     *\n     * @param message The BeaconResponseMessage that will be sent back to the DApp\n     */\n    respond(message: BeaconResponseInputMessage): Promise<void>;\n    getAppMetadataList(): Promise<AppMetadata[]>;\n    getAppMetadata(senderId: string): Promise<AppMetadata | undefined>;\n    removeAppMetadata(senderId: string): Promise<void>;\n    removeAllAppMetadata(): Promise<void>;\n    getPermissions(): Promise<PermissionInfo[]>;\n    getPermission(accountIdentifier: string): Promise<PermissionInfo | undefined>;\n    removePermission(accountIdentifier: string): Promise<void>;\n    removeAllPermissions(): Promise<void>;\n    /**\n     * Add a new peer to the known peers\n     * @param peer The new peer to add\n     */\n    addPeer(peer: PeerInfo): Promise<void>;\n    removePeer(peer: ExtendedP2PPairingResponse, sendDisconnectToPeer?: boolean): Promise<void>;\n    removeAllPeers(sendDisconnectToPeers?: boolean): Promise<void>;\n    private removePermissionsForPeers;\n    /**\n     * Send an acknowledge message back to the sender\n     *\n     * @param message The message that was received\n     */\n    private sendAcknowledgeResponse;\n    /**\n     * An internal method to send a BeaconMessage to the DApp\n     *\n     * @param response Send a message back to the DApp\n     */\n    private respondToMessage;\n}\n"},{"name":"@airgap/beacon-sdk/clients/wallet-client/WalletClientOptions.d.ts","dts":"import { Storage } from '../..';\nexport interface WalletClientOptions {\n    /**\n     * Name of the application\n     */\n    name: string;\n    /**\n     * A URL to the icon of the application\n     */\n    iconUrl?: string;\n    /**\n     * A URL to the website of the application\n     */\n    appUrl?: string;\n    /**\n     * The storage that will be used by the SDK\n     */\n    storage?: Storage;\n    /**\n     * A list of matrix nodes to connect to. If a non-empty array is passed, the default options will be overwritten.\n     * One node will be randomly selected based on the local keypair and the other nodes will be used as a fallback in case the primary node goes down.\n     *\n     * Only provide the hostname, no https:// prefix. Eg. ['matrix.example.com']\n     */\n    matrixNodes?: string[];\n}\n"},{"name":"@airgap/beacon-sdk/errors/AbortedBeaconError.d.ts","dts":"import { BeaconError } from '..';\nexport declare class AbortedBeaconError extends BeaconError {\n    name: string;\n    title: string;\n    constructor();\n}\n"},{"name":"@airgap/beacon-sdk/errors/BeaconError.d.ts","dts":"import { BeaconErrorType } from '..';\nexport declare abstract class BeaconError implements Error {\n    name: string;\n    message: string;\n    title: string;\n    description: string;\n    get fullDescription(): string;\n    constructor(errorType: BeaconErrorType, message: string);\n    static getError(errorType: BeaconErrorType, errorData: any): BeaconError;\n}\n"},{"name":"@airgap/beacon-sdk/errors/BroadcastBeaconError.d.ts","dts":"import { BeaconError } from '..';\nexport declare class BroadcastBeaconError extends BeaconError {\n    name: string;\n    title: string;\n    constructor();\n}\n"},{"name":"@airgap/beacon-sdk/errors/NetworkNotSupportedBeaconError.d.ts","dts":"import { BeaconError } from '..';\nexport declare class NetworkNotSupportedBeaconError extends BeaconError {\n    name: string;\n    title: string;\n    constructor();\n}\n"},{"name":"@airgap/beacon-sdk/errors/NoAddressBeaconError.d.ts","dts":"import { BeaconError } from '..';\nexport declare class NoAddressBeaconError extends BeaconError {\n    name: string;\n    title: string;\n    constructor();\n}\n"},{"name":"@airgap/beacon-sdk/errors/NoPrivateKeyBeaconError.d.ts","dts":"import { BeaconError } from '..';\nexport declare class NoPrivateKeyBeaconError extends BeaconError {\n    name: string;\n    title: string;\n    constructor();\n}\n"},{"name":"@airgap/beacon-sdk/errors/NotGrantedBeaconError.d.ts","dts":"import { BeaconError } from '..';\nexport declare class NotGrantedBeaconError extends BeaconError {\n    name: string;\n    title: string;\n    constructor();\n}\n"},{"name":"@airgap/beacon-sdk/errors/ParametersInvalidBeaconError.d.ts","dts":"import { BeaconError } from '..';\nexport declare class ParametersInvalidBeaconError extends BeaconError {\n    name: string;\n    title: string;\n    constructor();\n}\n"},{"name":"@airgap/beacon-sdk/errors/SignatureTypeNotSupportedBeaconError.d.ts","dts":"import { BeaconError } from '..';\nexport declare class SignatureTypeNotSupportedBeaconError extends BeaconError {\n    name: string;\n    title: string;\n    constructor();\n}\n"},{"name":"@airgap/beacon-sdk/errors/TooManyOperationsBeaconError.d.ts","dts":"import { BeaconError } from '..';\nexport declare class TooManyOperationsBeaconError extends BeaconError {\n    name: string;\n    title: string;\n    constructor();\n}\n"},{"name":"@airgap/beacon-sdk/errors/TransactionInvalidBeaconError.d.ts","dts":"import { BeaconError } from '..';\nexport declare class TransactionInvalidBeaconError extends BeaconError {\n    readonly data: any;\n    name: string;\n    title: string;\n    get fullDescription(): string;\n    constructor(data: any);\n}\n"},{"name":"@airgap/beacon-sdk/errors/UnknownBeaconError.d.ts","dts":"import { BeaconError } from '..';\nexport declare class UnknownBeaconError extends BeaconError {\n    name: string;\n    title: string;\n    constructor();\n}\n"},{"name":"@airgap/beacon-sdk/examples/broadcast-request.d.ts","dts":"export {};\n"},{"name":"@airgap/beacon-sdk/examples/custom-block-explorer.d.ts","dts":"export {};\n"},{"name":"@airgap/beacon-sdk/examples/disable-all-ui.d.ts","dts":"export {};\n"},{"name":"@airgap/beacon-sdk/examples/operation-request.d.ts","dts":"export {};\n"},{"name":"@airgap/beacon-sdk/examples/override-default-events.d.ts","dts":"export {};\n"},{"name":"@airgap/beacon-sdk/examples/permission-request.d.ts","dts":"export {};\n"},{"name":"@airgap/beacon-sdk/examples/sign-payload-request.d.ts","dts":"export {};\n"},{"name":"@airgap/beacon-sdk/examples/using-custom-network.d.ts","dts":"export {};\n"},{"name":"@airgap/beacon-sdk/examples/wallet-example.d.ts","dts":"export {};\n"},{"name":"@airgap/beacon-sdk/interceptors/IncomingRequestInterceptor.d.ts","dts":"import { BeaconRequestOutputMessage } from '..';\nimport { ConnectionContext } from '../types/ConnectionContext';\nimport { AppMetadataManager } from '../managers/AppMetadataManager';\nimport { BeaconRequestMessage } from '../types/beacon/BeaconRequestMessage';\ninterface IncomingRequestInterceptorOptions {\n    message: BeaconRequestMessage;\n    connectionInfo: ConnectionContext;\n    appMetadataManager: AppMetadataManager;\n    interceptorCallback(message: BeaconRequestOutputMessage, connectionInfo: ConnectionContext): void;\n}\n/**\n * The IncomingRequestInterceptor is used in the WalletClient to intercept an incoming request and enrich it with data, like app metadata.\n */\nexport declare class IncomingRequestInterceptor {\n    /**\n     * The method that is called during the interception\n     *\n     * @param config\n     */\n    static intercept(config: IncomingRequestInterceptorOptions): Promise<void>;\n    private static getAppMetadata;\n}\nexport {};\n"},{"name":"@airgap/beacon-sdk/interceptors/OutgoingResponseInterceptor.d.ts","dts":"import { BeaconMessage, BeaconResponseInputMessage, AppMetadata } from '..';\nimport { PermissionManager } from '../managers/PermissionManager';\nimport { AppMetadataManager } from '../managers/AppMetadataManager';\nimport { BeaconRequestMessage } from '../types/beacon/BeaconRequestMessage';\ninterface OutgoingResponseInterceptorOptions {\n    senderId: string;\n    request: BeaconRequestMessage;\n    message: BeaconResponseInputMessage;\n    ownAppMetadata: AppMetadata;\n    permissionManager: PermissionManager;\n    appMetadataManager: AppMetadataManager;\n    interceptorCallback(message: BeaconMessage): void;\n}\n/**\n * The OutgoingResponseInterceptor is used in the WalletClient to intercept an outgoing response and enrich it with data.\n */\nexport declare class OutgoingResponseInterceptor {\n    static intercept(config: OutgoingResponseInterceptorOptions): Promise<void>;\n}\nexport {};\n"},{"name":"@airgap/beacon-sdk/managers/AccountManager.d.ts","dts":"import { Storage, AccountInfo, BeaconMessage } from '..';\n/**\n * The AccountManager provides CRUD functionality for account entities and persists them to the provided storage.\n */\nexport declare class AccountManager {\n    private readonly storageManager;\n    constructor(storage: Storage);\n    getAccounts(): Promise<AccountInfo[]>;\n    getAccount(accountIdentifier: string): Promise<AccountInfo | undefined>;\n    addAccount(accountInfo: AccountInfo): Promise<void>;\n    removeAccount(accountIdentifier: string): Promise<void>;\n    removeAccounts(accountIdentifiers: string[]): Promise<void>;\n    removeAllAccounts(): Promise<void>;\n    hasPermission(message: BeaconMessage): Promise<boolean>;\n}\n"},{"name":"@airgap/beacon-sdk/managers/AppMetadataManager.d.ts","dts":"import { Storage, AppMetadata } from '..';\n/**\n * The AppMetadataManager provides CRUD functionality for app-metadata entities and persists them to the provided storage.\n */\nexport declare class AppMetadataManager {\n    private readonly storageManager;\n    constructor(storage: Storage);\n    getAppMetadataList(): Promise<AppMetadata[]>;\n    getAppMetadata(senderId: string): Promise<AppMetadata | undefined>;\n    addAppMetadata(appMetadata: AppMetadata): Promise<void>;\n    removeAppMetadata(senderId: string): Promise<void>;\n    removeAppMetadatas(senderIds: string[]): Promise<void>;\n    removeAllAppMetadata(): Promise<void>;\n}\n"},{"name":"@airgap/beacon-sdk/managers/PeerManager.d.ts","dts":"import { Storage, StorageKey, StorageKeyReturnType } from '..';\nimport { ArrayElem } from './StorageManager';\n/**\n * The PeerManager provides CRUD functionality for peer entities and persists them to the provided storage.\n */\nexport declare class PeerManager<T extends StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET> {\n    private readonly storageManager;\n    constructor(storage: Storage, key: T);\n    hasPeer(publicKey: string): Promise<boolean>;\n    getPeers(): Promise<StorageKeyReturnType[T]>;\n    getPeer(publicKey: string): Promise<ArrayElem<StorageKeyReturnType[T]> | undefined>;\n    addPeer(peerInfo: ArrayElem<StorageKeyReturnType[T]>): Promise<void>;\n    removePeer(publicKey: string): Promise<void>;\n    removePeers(publicKeys: string[]): Promise<void>;\n    removeAllPeers(): Promise<void>;\n}\n"},{"name":"@airgap/beacon-sdk/managers/PermissionManager.d.ts","dts":"import { BeaconMessage, Storage } from '..';\nimport { PermissionInfo } from '../types/PermissionInfo';\n/**\n * The PermissionManager provides CRUD functionality for permission entities and persists them to the provided storage.\n */\nexport declare class PermissionManager {\n    private readonly storageManager;\n    constructor(storage: Storage);\n    getPermissions(): Promise<PermissionInfo[]>;\n    getPermission(accountIdentifier: string): Promise<PermissionInfo | undefined>;\n    addPermission(permissionInfo: PermissionInfo): Promise<void>;\n    removePermission(accountIdentifier: string): Promise<void>;\n    removePermissions(accountIdentifiers: string[]): Promise<void>;\n    removeAllPermissions(): Promise<void>;\n    hasPermission(message: BeaconMessage): Promise<boolean>;\n}\n"},{"name":"@airgap/beacon-sdk/managers/PermissionValidator.d.ts","dts":"import { BeaconMessage } from '..';\nimport { PermissionEntity } from '../types/PermissionEntity';\n/**\n * The PermissionValidator is used to check if permissions for a certain message type have been given\n */\nexport declare class PermissionValidator {\n    /**\n     * Check if permissions were given for a certain message type.\n     *\n     * PermissionRequest and BroadcastRequest will always return true.\n     *\n     * @param message Beacon Message\n     */\n    static hasPermission(message: BeaconMessage, getOne: (id: string) => Promise<PermissionEntity | undefined>, getAll: () => Promise<PermissionEntity[]>): Promise<boolean>;\n}\n"},{"name":"@airgap/beacon-sdk/managers/StorageManager.d.ts","dts":"import { StorageKey, Storage, StorageKeyReturnType } from '..';\n/** Type workaround for https://github.com/Microsoft/TypeScript/issues/7294#issuecomment-465794460 */\nexport declare type ArrayElem<A> = A extends (infer Elem)[] ? Elem : never;\n/**\n * The StorageManager provides CRUD functionality for specific entities and persists them to the provided storage.\n */\nexport declare class StorageManager<T extends StorageKey.ACCOUNTS | StorageKey.APP_METADATA_LIST | StorageKey.PERMISSION_LIST | StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET> {\n    private readonly storage;\n    private readonly storageKey;\n    constructor(storage: Storage, storageKey: T);\n    getAll(): Promise<StorageKeyReturnType[T]>;\n    getOne(predicate: (element: ArrayElem<StorageKeyReturnType[T]>) => boolean): Promise<ArrayElem<StorageKeyReturnType[T]> | undefined>;\n    addOne(element: ArrayElem<StorageKeyReturnType[T]>, predicate: (element: ArrayElem<StorageKeyReturnType[T]>) => boolean, overwrite?: boolean): Promise<void>;\n    remove(predicate: (element: ArrayElem<StorageKeyReturnType[T]>) => boolean): Promise<void>;\n    removeAll(): Promise<void>;\n}\n"},{"name":"@airgap/beacon-sdk/matrix-client/models/api/MatrixEventSend.d.ts","dts":"export interface MatrixEventSendRequest {\n    content: any;\n}\nexport interface MatrixEventSendResponse {\n    type?: 'event_send';\n    event_id: string;\n}\n"},{"name":"@airgap/beacon-sdk/matrix-client/models/api/MatrixLogin.d.ts","dts":"export interface MatrixLoginRequest {\n    type: 'm.login.password';\n    identifier: {\n        type: 'm.id.user';\n        user: string;\n    };\n    password: string;\n    device_id?: string;\n}\nexport interface MatrixLoginResponse {\n    type?: 'login';\n    user_id: string;\n    device_id: string;\n    access_token: string;\n}\n"},{"name":"@airgap/beacon-sdk/matrix-client/models/api/MatrixRequest.d.ts","dts":"import { MatrixLoginRequest, MatrixLoginResponse } from './MatrixLogin';\nimport { MatrixRoomCreateRequest, MatrixRoomCreateResponse } from './MatrixRoomCreate';\nimport { MatrixRoomInviteRequest, MatrixRoomInviteResponse } from './MatrixRoomInvite';\nimport { MatrixRoomJoinRequest, MatrixRoomJoinResponse } from './MatrixRoomJoin';\nimport { MatrixEventSendRequest, MatrixEventSendResponse } from './MatrixEventSend';\nimport { MatrixSyncResponse, MatrixSyncRequestParams } from './MatrixSync';\nexport declare type MatrixRequest<T> = T extends MatrixLoginResponse ? MatrixLoginRequest : T extends MatrixRoomCreateResponse ? MatrixRoomCreateRequest : T extends MatrixRoomInviteResponse ? MatrixRoomInviteRequest : T extends MatrixRoomJoinResponse ? MatrixRoomJoinRequest : T extends MatrixEventSendResponse ? MatrixEventSendRequest : never;\nexport declare type MatrixRequestParams<T> = T extends MatrixSyncResponse ? MatrixSyncRequestParams : never;\n"},{"name":"@airgap/beacon-sdk/matrix-client/models/api/MatrixRoomCreate.d.ts","dts":"export interface MatrixRoomCreateRequest {\n    visibility?: 'public' | 'private';\n    room_alias_name?: string;\n    name?: string;\n    topic?: string;\n    invite?: string[];\n    preset?: 'private_chat' | 'public_chat' | 'trusted_private_chat';\n    is_direct?: boolean;\n}\nexport interface MatrixRoomCreateResponse {\n    type?: 'room_create';\n    room_id: string;\n}\n"},{"name":"@airgap/beacon-sdk/matrix-client/models/api/MatrixRoomInvite.d.ts","dts":"export interface MatrixRoomInviteRequest {\n    user_id: string;\n}\nexport interface MatrixRoomInviteResponse {\n    type?: 'room_invite';\n}\n"},{"name":"@airgap/beacon-sdk/matrix-client/models/api/MatrixRoomJoin.d.ts","dts":"export interface MatrixRoomJoinRequest {\n}\nexport interface MatrixRoomJoinResponse {\n    type?: 'room_join';\n    room_id: string;\n}\n"},{"name":"@airgap/beacon-sdk/matrix-client/models/api/MatrixSync.d.ts","dts":"import { MatrixStateEvent } from '../MatrixStateEvent';\nexport interface MatrixSyncJoinedRoom {\n    state: {\n        events: MatrixStateEvent[];\n    };\n    timeline: {\n        events: MatrixStateEvent[];\n    };\n}\nexport interface MatrixSyncInvitedRoom {\n    invite_state: {\n        events: MatrixStateEvent[];\n    };\n}\nexport interface MatrixSyncLeftRoom {\n    state: {\n        events: MatrixStateEvent[];\n    };\n    timeline: {\n        events: MatrixStateEvent[];\n    };\n}\nexport interface MatrixSyncRooms {\n    join: {\n        [key: string]: MatrixSyncJoinedRoom;\n    };\n    invite: {\n        [key: string]: MatrixSyncInvitedRoom;\n    };\n    leave: {\n        [key: string]: MatrixSyncLeftRoom;\n    };\n}\nexport interface MatrixSyncRequestParams {\n    timeout?: number;\n    since?: string;\n}\nexport interface MatrixSyncResponse {\n    type?: 'sync';\n    next_batch: string;\n    rooms: MatrixSyncRooms;\n}\n"},{"name":"@airgap/beacon-sdk/matrix-client/models/MatrixClientEvent.d.ts","dts":"import { MatrixMessage } from './MatrixMessage';\nexport declare enum MatrixClientEventType {\n    INVITE = \"invite\",\n    MESSAGE = \"message\"\n}\nexport declare type MatrixClientEventContent<T> = T extends MatrixClientEventType.INVITE ? MatrixClientEventInviteContent : T extends MatrixClientEventType.MESSAGE ? MatrixClientEventMessageContent<any> : never;\nexport interface MatrixClientEventInviteContent {\n    roomId: string;\n}\nexport interface MatrixClientEventMessageContent<T> {\n    roomId: string;\n    message: MatrixMessage<T>;\n}\nexport interface MatrixClientEvent<T extends MatrixClientEventType> {\n    type: T;\n    content: MatrixClientEventContent<T>;\n}\n"},{"name":"@airgap/beacon-sdk/matrix-client/models/MatrixMessage.d.ts","dts":"import { MatrixStateEvent } from './MatrixStateEvent';\nexport declare enum MatrixMessageType {\n    TEXT = \"m.text\"\n}\nexport declare class MatrixMessage<T> {\n    readonly type: MatrixMessageType;\n    readonly sender: string;\n    readonly content: T;\n    /**\n     * Construct a message from a message event\n     *\n     * @param event\n     */\n    static from(event: MatrixStateEvent): MatrixMessage<any> | undefined;\n    private constructor();\n}\n"},{"name":"@airgap/beacon-sdk/matrix-client/models/MatrixRoom.d.ts","dts":"import { MatrixSyncRooms } from './api/MatrixSync';\nimport { MatrixMessage } from './MatrixMessage';\nexport declare enum MatrixRoomStatus {\n    UNKNOWN = 0,\n    JOINED = 1,\n    INVITED = 2,\n    LEFT = 3\n}\nexport declare class MatrixRoom {\n    readonly id: string;\n    readonly status: MatrixRoomStatus;\n    readonly members: string[];\n    messages: MatrixMessage<any>[];\n    /**\n     * Reconstruct rooms from a sync response\n     *\n     * @param roomSync\n     */\n    static fromSync(roomSync: MatrixSyncRooms): MatrixRoom[];\n    /**\n     * Reconstruct a room from an ID or object\n     *\n     * @param roomOrId\n     * @param status\n     */\n    static from(roomOrId: string | MatrixRoom, status?: MatrixRoomStatus): MatrixRoom;\n    /**\n     * Merge new and old state and remove duplicates\n     *\n     * @param newState\n     * @param previousState\n     */\n    static merge(newState: MatrixRoom, previousState?: MatrixRoom): MatrixRoom;\n    /**\n     * Create a room from a join\n     *\n     * @param id\n     * @param joined\n     */\n    private static fromJoined;\n    /**\n     * Create a room from an invite\n     *\n     * @param id\n     * @param invited\n     */\n    private static fromInvited;\n    /**\n     * Create a room from a leave\n     *\n     * @param id\n     * @param left\n     */\n    private static fromLeft;\n    /**\n     * Extract members from an event\n     *\n     * @param events\n     */\n    private static getMembersFromEvents;\n    /**\n     * Extract messages from an event\n     *\n     * @param events\n     */\n    private static getMessagesFromEvents;\n    /**\n     * Get unique events and remove duplicates\n     *\n     * @param events\n     */\n    private static getUniqueEvents;\n    private constructor();\n}\n"},{"name":"@airgap/beacon-sdk/matrix-client/models/MatrixStateEvent.d.ts","dts":"import { MatrixMessageType } from './MatrixMessage';\nexport interface MatrixStateEventMessageText extends MatrixStateEventMessage {\n    type: 'm.room.message';\n    content: {\n        msgtype: MatrixMessageType.TEXT;\n        body: string;\n    };\n}\nexport interface MatrixStateEventMessageContent {\n    msgtype: string;\n    body: any;\n    [key: string]: any;\n}\nexport interface MatrixStateEventMessage extends MatrixStateEvent {\n    type: 'm.room.message';\n    content: MatrixStateEventMessageContent;\n}\nexport interface MatrixStateEvent {\n    type: string;\n    sender: string;\n    content: unknown;\n    event_id?: string;\n}\n"},{"name":"@airgap/beacon-sdk/matrix-client/services/MatrixEventService.d.ts","dts":"import { MatrixHttpClient } from '../MatrixHttpClient';\nimport { MatrixEventSendResponse } from '../models/api/MatrixEventSend';\nimport { MatrixSyncResponse } from '../models/api/MatrixSync';\nimport { MatrixStateEventMessageContent } from '../models/MatrixStateEvent';\ninterface MatrixScheduledEvent<T> {\n    accessToken: string;\n    roomId: string;\n    type: MatrixEventType;\n    content: any;\n    txnId: string;\n    onSuccess(response: T): void;\n    onError(error: unknown): void;\n}\ndeclare type MatrixEventType = 'm.room.message';\nexport interface MatrixSyncOptions {\n    syncToken?: string;\n    pollingTimeout?: number;\n}\n/**\n * A service to help with matrix event management\n */\nexport declare class MatrixEventService {\n    private readonly httpClient;\n    private readonly cachedPromises;\n    constructor(httpClient: MatrixHttpClient);\n    /**\n     * Get the latest state from the matrix node\n     *\n     * @param accessToken\n     * @param options\n     */\n    sync(accessToken: string, options?: MatrixSyncOptions): Promise<MatrixSyncResponse>;\n    /**\n     * Send a message to a room\n     *\n     * @param accessToken\n     * @param room\n     * @param content\n     * @param txnId\n     */\n    sendMessage(accessToken: string, roomId: string, content: MatrixStateEventMessageContent, txnId: string): Promise<MatrixEventSendResponse>;\n    /**\n     * Schedules an event to be sent to the node\n     *\n     * @param event\n     */\n    scheduleEvent(event: MatrixScheduledEvent<any>): void;\n    /**\n     * Send an event to the matrix node\n     *\n     * @param scheduledEvent\n     */\n    sendEvent(scheduledEvent: MatrixScheduledEvent<any>): Promise<void>;\n    /**\n     * Check the cache when interacting with the Matrix node, if there is an already ongoing call for the specified key, return its promise instead of duplicating the call.\n     *\n     * @param key\n     * @param promiseProvider\n     */\n    private withCache;\n}\nexport {};\n"},{"name":"@airgap/beacon-sdk/matrix-client/services/MatrixRoomService.d.ts","dts":"import { MatrixHttpClient } from '../MatrixHttpClient';\nimport { MatrixRoom } from '../models/MatrixRoom';\nimport { MatrixRoomCreateRequest, MatrixRoomCreateResponse } from '../models/api/MatrixRoomCreate';\nimport { MatrixRoomInviteResponse } from '../models/api/MatrixRoomInvite';\nimport { MatrixRoomJoinResponse } from '../models/api/MatrixRoomJoin';\n/**\n * A service to help with matrix room management\n */\nexport declare class MatrixRoomService {\n    private readonly httpClient;\n    constructor(httpClient: MatrixHttpClient);\n    /**\n     * Create a room\n     *\n     * @param accessToken\n     * @param config\n     */\n    createRoom(accessToken: string, config?: MatrixRoomCreateRequest): Promise<MatrixRoomCreateResponse>;\n    /**\n     * Invite a user to a room\n     *\n     * @param accessToken\n     * @param user\n     * @param room\n     */\n    inviteToRoom(accessToken: string, user: string, room: MatrixRoom): Promise<MatrixRoomInviteResponse>;\n    /**\n     * Join a specific room\n     *\n     * @param accessToken\n     * @param room\n     */\n    joinRoom(accessToken: string, room: MatrixRoom): Promise<MatrixRoomJoinResponse>;\n    /**\n     * Get all joined rooms\n     *\n     * @param accessToken\n     */\n    getJoinedRooms(accessToken: string): Promise<MatrixRoomJoinResponse>;\n}\n"},{"name":"@airgap/beacon-sdk/matrix-client/services/MatrixUserService.d.ts","dts":"import { MatrixHttpClient } from '../MatrixHttpClient';\nimport { MatrixLoginResponse } from '../models/api/MatrixLogin';\nexport declare class MatrixUserService {\n    private readonly httpClient;\n    constructor(httpClient: MatrixHttpClient);\n    /**\n     * Log in to the matrix node with username and password\n     *\n     * @param user\n     * @param password\n     * @param deviceId\n     */\n    login(user: string, password: string, deviceId: string): Promise<MatrixLoginResponse>;\n}\n"},{"name":"@airgap/beacon-sdk/matrix-client/utils/events.d.ts","dts":"import { MatrixStateEvent, MatrixStateEventMessageText } from '../models/MatrixStateEvent';\n/**\n * Check if an event is a create event\n *\n * @param event MatrixStateEvent\n */\nexport declare const isCreateEvent: (event: MatrixStateEvent) => boolean;\n/**\n * Check if an event is a join event\n *\n * @param event MatrixStateEvent\n */\nexport declare const isJoinEvent: (event: MatrixStateEvent) => boolean;\n/**\n * Check if an event is a message event\n *\n * @param event MatrixStateEvent\n */\nexport declare const isMessageEvent: (event: MatrixStateEvent) => boolean;\n/**\n * Check if an event is a text message event\n *\n * @param event MatrixStateEvent\n */\nexport declare const isTextMessageEvent: (event: MatrixStateEvent) => event is MatrixStateEventMessageText;\n"},{"name":"@airgap/beacon-sdk/matrix-client/MatrixClient.d.ts","dts":"import { Storage } from '../storage/Storage';\nimport { MatrixClientStore } from './MatrixClientStore';\nimport { MatrixRoom } from './models/MatrixRoom';\nimport { MatrixRoomService } from './services/MatrixRoomService';\nimport { MatrixUserService } from './services/MatrixUserService';\nimport { MatrixEventService } from './services/MatrixEventService';\nimport { MatrixClientEventEmitter } from './MatrixClientEventEmitter';\nimport { MatrixClientEventType, MatrixClientEvent } from './models/MatrixClientEvent';\ninterface MatrixClientOptions {\n    baseUrl: string;\n    storage: Storage;\n}\ninterface MatrixLoginConfig {\n    id: string;\n    password: string;\n    deviceId: string;\n}\n/**\n * The matrix client used to connect to the matrix network\n */\nexport declare class MatrixClient {\n    private readonly store;\n    private readonly eventEmitter;\n    private readonly userService;\n    private readonly roomService;\n    private readonly eventService;\n    /**\n     * Create a matrix client based on the options provided\n     *\n     * @param config\n     */\n    static create(config: MatrixClientOptions): MatrixClient;\n    /**\n     * Return all the rooms we are currently part of\n     */\n    get joinedRooms(): MatrixRoom[];\n    /**\n     * Return all the rooms to which we have received invitations\n     */\n    get invitedRooms(): MatrixRoom[];\n    /**\n     * Return all the rooms that we left\n     */\n    get leftRooms(): MatrixRoom[];\n    constructor(store: MatrixClientStore, eventEmitter: MatrixClientEventEmitter, userService: MatrixUserService, roomService: MatrixRoomService, eventService: MatrixEventService);\n    /**\n     * Initiate the connection to the matrix node and log in\n     *\n     * @param user\n     */\n    start(user: MatrixLoginConfig): Promise<void>;\n    /**\n     * Subscribe to new matrix events\n     *\n     * @param event\n     * @param listener\n     */\n    subscribe<T extends MatrixClientEventType>(event: T, listener: (event: MatrixClientEvent<T>) => void): void;\n    /**\n     * Unsubscribe from matrix events\n     *\n     * @param event\n     * @param listener\n     */\n    unsubscribe(event: MatrixClientEventType, listener?: (event: MatrixClientEvent<any>) => void): void;\n    getRoomById(id: string): MatrixRoom;\n    /**\n     * Create a private room with the supplied members\n     *\n     * @param members Members that will be in the room\n     */\n    createTrustedPrivateRoom(...members: string[]): Promise<string>;\n    /**\n     * Invite user to rooms\n     *\n     * @param user The user to be invited\n     * @param roomsOrIds The rooms the user will be invited to\n     */\n    inviteToRooms(user: string, ...roomsOrIds: string[] | MatrixRoom[]): Promise<void>;\n    /**\n     * Join rooms\n     *\n     * @param roomsOrIds\n     */\n    joinRooms(...roomsOrIds: string[] | MatrixRoom[]): Promise<void>;\n    /**\n     * Send a text message\n     *\n     * @param roomOrId\n     * @param message\n     */\n    sendTextMessage(roomId: string, message: string): Promise<void>;\n    /**\n     * Poll the server to get the latest data and get notified of changes\n     *\n     * @param interval\n     * @param onSyncSuccess\n     * @param onSyncError\n     */\n    private poll;\n    /**\n     * Get state from server\n     */\n    private sync;\n    /**\n     * A helper method that makes sure an access token is provided\n     *\n     * @param name\n     * @param action\n     */\n    private requiresAuthorization;\n    /**\n     * Create a transaction ID\n     */\n    private createTxnId;\n}\nexport {};\n"},{"name":"@airgap/beacon-sdk/matrix-client/MatrixClientEventEmitter.d.ts","dts":"/// <reference types=\"node\" />\nimport { EventEmitter } from 'events';\nimport { MatrixStateStore, MatrixStateUpdate } from './MatrixClientStore';\nexport declare class MatrixClientEventEmitter extends EventEmitter {\n    private readonly eventEmitProviders;\n    /**\n     * This method is called every time the state is changed\n     *\n     * @param _oldState\n     * @param _newState\n     * @param stateChange\n     */\n    onStateChanged(_oldState: MatrixStateStore, _newState: MatrixStateStore, stateChange: Partial<MatrixStateUpdate>): void;\n    /**\n     * Emit the message if we have listeners registered for that type\n     *\n     * @param eventType\n     * @param object\n     */\n    private emitIfEvent;\n    /**\n     * Emit a client event\n     *\n     * @param eventType\n     * @param content\n     */\n    private emitClientEvent;\n    /**\n     * Check if event is an invite\n     *\n     * @param stateChange\n     */\n    private isInvite;\n    /**\n     * Emit an invite\n     *\n     * @param eventType\n     * @param stateChange\n     */\n    private emitInvite;\n    /**\n     * Check if event is a message\n     *\n     * @param stateChange\n     */\n    private isMessage;\n    /**\n     * Emit an event to all rooms\n     *\n     * @param eventType\n     * @param stateChange\n     */\n    private emitMessage;\n}\n"},{"name":"@airgap/beacon-sdk/matrix-client/MatrixClientStore.d.ts","dts":"import { MatrixRoom } from './models/MatrixRoom';\nimport { Storage } from '../storage/Storage';\ndeclare type OnStateChangedListener = (oldState: MatrixStateStore, newState: MatrixStateStore, stateChange: Partial<MatrixStateUpdate>) => void;\nexport interface MatrixState {\n    isRunning: boolean;\n    userId: string | undefined;\n    deviceId: string | undefined;\n    txnNo: number;\n    accessToken: string | undefined;\n    syncToken: string | undefined;\n    pollingTimeout: number | undefined;\n    pollingRetries: number;\n    rooms: MatrixRoom[] | Record<string, MatrixRoom>;\n}\nexport interface MatrixStateStore extends MatrixState {\n    rooms: Record<string, MatrixRoom>;\n}\nexport interface MatrixStateUpdate extends MatrixState {\n    rooms: MatrixRoom[];\n}\n/**\n * The class managing the local state of matrix\n */\nexport declare class MatrixClientStore {\n    private readonly storage;\n    /**\n     * The state of the matrix client\n     */\n    private state;\n    /**\n     * Listeners that will be called when the state changes\n     */\n    private readonly onStateChangedListeners;\n    /**\n     * A promise that resolves once the client is ready\n     */\n    private waitReadyPromise;\n    constructor(storage: Storage);\n    /**\n     * Get an item from the state\n     *\n     * @param key\n     */\n    get<T extends keyof MatrixStateStore>(key: T): MatrixStateStore[T];\n    /**\n     * Get the room from an ID or room instance\n     *\n     * @param roomOrId\n     */\n    getRoom(roomOrId: string | MatrixRoom): MatrixRoom;\n    /**\n     * Update the state with a partial state\n     *\n     * @param stateUpdate\n     */\n    update(stateUpdate: Partial<MatrixStateUpdate>): Promise<void>;\n    /**\n     * Register listeners that are called once the state has changed\n     *\n     * @param listener\n     * @param subscribed\n     */\n    onStateChanged(listener: OnStateChangedListener, ...subscribed: (keyof MatrixState)[]): void;\n    /**\n     * A promise that resolves once the client is ready\n     */\n    private waitReady;\n    /**\n     * Read state from storage\n     */\n    private initFromStorage;\n    /**\n     * Prepare data before persisting it in storage\n     *\n     * @param toStore\n     */\n    private prepareData;\n    /**\n     * Persist state in storage\n     *\n     * @param stateUpdate\n     */\n    private updateStorage;\n    /**\n     * Set the state\n     *\n     * @param partialState\n     */\n    private setState;\n    /**\n     * Merge room records and eliminate duplicates\n     *\n     * @param oldRooms\n     * @param _newRooms\n     */\n    private mergeRooms;\n    /**\n     * Notify listeners of state changes\n     *\n     * @param oldState\n     * @param newState\n     * @param stateChange\n     */\n    private notifyListeners;\n}\nexport {};\n"},{"name":"@airgap/beacon-sdk/matrix-client/MatrixHttpClient.d.ts","dts":"import { MatrixRequest, MatrixRequestParams } from './models/api/MatrixRequest';\ninterface HttpOptions {\n    accessToken?: string;\n}\n/**\n * Handling the HTTP connection to the matrix synapse node\n */\nexport declare class MatrixHttpClient {\n    private readonly baseUrl;\n    constructor(baseUrl: string);\n    /**\n     * Get data from the synapse node\n     *\n     * @param endpoint\n     * @param options\n     */\n    get<T>(endpoint: string, params?: MatrixRequestParams<T>, options?: HttpOptions): Promise<T>;\n    /**\n     * Post data to the synapse node\n     *\n     * @param endpoint\n     * @param body\n     * @param options\n     * @param params\n     */\n    post<T>(endpoint: string, body: MatrixRequest<T>, options?: HttpOptions, params?: MatrixRequestParams<T>): Promise<T>;\n    /**\n     * Put data to the synapse node\n     *\n     * @param endpoint\n     * @param body\n     * @param options\n     * @param params\n     */\n    put<T>(endpoint: string, body: MatrixRequest<T>, options?: HttpOptions, params?: MatrixRequestParams<T>): Promise<T>;\n    /**\n     * Send a request to the synapse node\n     *\n     * @param method\n     * @param endpoint\n     * @param config\n     * @param requestParams\n     * @param data\n     */\n    private send;\n    /**\n     * Get the headers based on the options object\n     *\n     * @param options\n     */\n    private getHeaders;\n    /**\n     * Get parameters\n     *\n     * @param _params\n     */\n    private getParams;\n    /**\n     * Construct API URL\n     */\n    private apiUrl;\n}\nexport {};\n"},{"name":"@airgap/beacon-sdk/migrations/migrate-0.7.0.d.ts","dts":"import { PermissionScope, AccountIdentifier, Origin, Network } from '..';\nexport interface AccountInfoOld {\n    accountIdentifier: AccountIdentifier;\n    beaconId: string;\n    origin: {\n        type: Origin;\n        id: string;\n    };\n    address: string;\n    pubkey: string;\n    network: Network;\n    scopes: PermissionScope[];\n    connectedAt: Date;\n}\nexport interface P2PPairingRequestOld {\n    name: string;\n    pubKey: string;\n    relayServer: string;\n}\nexport declare const migrate_0_7_0: (storage: Storage) => Promise<void>;\n"},{"name":"@airgap/beacon-sdk/migrations/migrations.d.ts","dts":"import { Storage } from '..';\nexport declare const migrate: (storage: Storage) => Promise<void>;\n"},{"name":"@airgap/beacon-sdk/scripts/index.d.ts","dts":"// Generated by dts-bundle v0.7.5\n// Dependencies for this module:\n//   ../../../../../libsodium-wrappers\n//   ../../../../../events\n//   scripts/index.d.ts\n//   test.d.ts\n\ndeclare module 'beacon' {\n    export * from 'beacon/beacon-message-events';\n    export * from 'beacon/clients/beacon-client/BeaconClient';\n    export * from 'beacon/clients/beacon-client/BeaconClientOptions';\n    export * from 'beacon/clients/client/Client';\n    export * from 'beacon/clients/client/ClientOptions';\n    export * from 'beacon/clients/dapp-client/DAppClient';\n    export * from 'beacon/clients/dapp-client/DAppClientOptions';\n    export * from 'beacon/clients/wallet-client/WalletClient';\n    export * from 'beacon/clients/wallet-client/WalletClientOptions';\n    export * from 'beacon/colorMode';\n    export * from 'beacon/constants';\n    export * from 'beacon/debug';\n    export * from 'beacon/dts-bundle.tmp.beacon';\n    export * from 'beacon/dts-bundle.tmp.test';\n    export * from 'beacon/errors/AbortedBeaconError';\n    export * from 'beacon/errors/BeaconError';\n    export * from 'beacon/errors/BroadcastBeaconError';\n    export * from 'beacon/errors/NetworkNotSupportedBeaconError';\n    export * from 'beacon/errors/NoAddressBeaconError';\n    export * from 'beacon/errors/NoPrivateKeyBeaconError';\n    export * from 'beacon/errors/NotGrantedBeaconError';\n    export * from 'beacon/errors/ParametersInvalidBeaconError';\n    export * from 'beacon/errors/SignatureTypeNotSupportedBeaconError';\n    export * from 'beacon/errors/TooManyOperationsBeaconError';\n    export * from 'beacon/errors/TransactionInvalidBeaconError';\n    export * from 'beacon/errors/UnknownBeaconError';\n    export * from 'beacon/events';\n    export * from 'beacon/examples/broadcast-request';\n    export * from 'beacon/examples/custom-block-explorer';\n    export * from 'beacon/examples/disable-all-ui';\n    export * from 'beacon/examples/operation-request';\n    export * from 'beacon/examples/override-default-events';\n    export * from 'beacon/examples/permission-request';\n    export * from 'beacon/examples/sign-payload-request';\n    export * from 'beacon/examples/using-custom-network';\n    export * from 'beacon/examples/wallet-example';\n    export * from 'beacon/index';\n    export * from 'beacon/interceptors/IncomingRequestInterceptor';\n    export * from 'beacon/interceptors/OutgoingResponseInterceptor';\n    export * from 'beacon/managers/AccountManager';\n    export * from 'beacon/managers/AppMetadataManager';\n    export * from 'beacon/managers/PeerManager';\n    export * from 'beacon/managers/PermissionManager';\n    export * from 'beacon/managers/PermissionValidator';\n    export * from 'beacon/managers/StorageManager';\n    export * from 'beacon/matrix-client/MatrixClient';\n    export * from 'beacon/matrix-client/MatrixClientEventEmitter';\n    export * from 'beacon/matrix-client/MatrixClientStore';\n    export * from 'beacon/matrix-client/MatrixHttpClient';\n    export * from 'beacon/matrix-client/models/api/MatrixEventSend';\n    export * from 'beacon/matrix-client/models/api/MatrixLogin';\n    export * from 'beacon/matrix-client/models/api/MatrixRequest';\n    export * from 'beacon/matrix-client/models/api/MatrixRoomCreate';\n    export * from 'beacon/matrix-client/models/api/MatrixRoomInvite';\n    export * from 'beacon/matrix-client/models/api/MatrixRoomJoin';\n    export * from 'beacon/matrix-client/models/api/MatrixSync';\n    export * from 'beacon/matrix-client/models/MatrixClientEvent';\n    export * from 'beacon/matrix-client/models/MatrixMessage';\n    export * from 'beacon/matrix-client/models/MatrixRoom';\n    export * from 'beacon/matrix-client/models/MatrixStateEvent';\n    export * from 'beacon/matrix-client/services/MatrixEventService';\n    export * from 'beacon/matrix-client/services/MatrixRoomService';\n    export * from 'beacon/matrix-client/services/MatrixUserService';\n    export * from 'beacon/matrix-client/utils/events';\n    export * from 'beacon/migrations/migrate-0.7.0';\n    export * from 'beacon/migrations/migrations';\n    export * from 'beacon/MockWindow';\n    export * from 'beacon/scripts/index';\n    export * from 'beacon/Serializer';\n    export * from 'beacon/storage/ChromeStorage';\n    export * from 'beacon/storage/getStorage';\n    export * from 'beacon/storage/LocalStorage';\n    export * from 'beacon/storage/Storage';\n    export * from 'beacon/test';\n    export * from 'beacon/transports/clients/CommunicationClient';\n    export * from 'beacon/transports/clients/MessageBasedClient';\n    export * from 'beacon/transports/clients/P2PCommunicationClient';\n    export * from 'beacon/transports/clients/PostMessageClient';\n    export * from 'beacon/transports/DappP2PTransport';\n    export * from 'beacon/transports/DappPostMessageTransport';\n    export * from 'beacon/transports/P2PTransport';\n    export * from 'beacon/transports/PostMessageTransport';\n    export * from 'beacon/transports/Transport';\n    export * from 'beacon/transports/WalletP2PTransport';\n    export * from 'beacon/transports/WalletPostMessageTransport';\n    export * from 'beacon/types/AccountInfo';\n    export * from 'beacon/types/beacon/AppMetadata';\n    export * from 'beacon/types/beacon/BeaconBaseMessage';\n    export * from 'beacon/types/beacon/BeaconMessage';\n    export * from 'beacon/types/beacon/BeaconMessageType';\n    export * from 'beacon/types/beacon/BeaconRequestMessage';\n    export * from 'beacon/types/beacon/BeaconResponseMessage';\n    export * from 'beacon/types/beacon/messages/AcknowledgeResponse';\n    export * from 'beacon/types/beacon/messages/BeaconRequestInputMessage';\n    export * from 'beacon/types/beacon/messages/BeaconRequestOutputMessage';\n    export * from 'beacon/types/beacon/messages/BeaconResponseInputMessage';\n    export * from 'beacon/types/beacon/messages/BeaconResponseOutputMessage';\n    export * from 'beacon/types/beacon/messages/BroadcastRequest';\n    export * from 'beacon/types/beacon/messages/BroadcastResponse';\n    export * from 'beacon/types/beacon/messages/DisconnectMessage';\n    export * from 'beacon/types/beacon/messages/ErrorResponse';\n    export * from 'beacon/types/beacon/messages/OperationRequest';\n    export * from 'beacon/types/beacon/messages/OperationResponse';\n    export * from 'beacon/types/beacon/messages/PermissionRequest';\n    export * from 'beacon/types/beacon/messages/PermissionResponse';\n    export * from 'beacon/types/beacon/messages/SignPayloadRequest';\n    export * from 'beacon/types/beacon/messages/SignPayloadResponse';\n    export * from 'beacon/types/beacon/Network';\n    export * from 'beacon/types/beacon/NetworkType';\n    export * from 'beacon/types/beacon/PermissionScope';\n    export * from 'beacon/types/beacon/SigningType';\n    export * from 'beacon/types/beacon/Threshold';\n    export * from 'beacon/types/BeaconErrorType';\n    export * from 'beacon/types/ColorMode';\n    export * from 'beacon/types/ConnectionContext';\n    export * from 'beacon/types/Extension';\n    export * from 'beacon/types/ExtensionMessage';\n    export * from 'beacon/types/ExtensionMessageTarget';\n    export * from 'beacon/types/Origin';\n    export * from 'beacon/types/P2PPairingRequest';\n    export * from 'beacon/types/P2PPairingResponse';\n    export * from 'beacon/types/PeerInfo';\n    export * from 'beacon/types/PermissionEntity';\n    export * from 'beacon/types/PermissionInfo';\n    export * from 'beacon/types/PostMessagePairingRequest';\n    export * from 'beacon/types/PostMessagePairingResponse';\n    export * from 'beacon/types/RequestBroadcastInput';\n    export * from 'beacon/types/RequestOperationInput';\n    export * from 'beacon/types/RequestPermissionInput';\n    export * from 'beacon/types/RequestSignPayloadInput';\n    export * from 'beacon/types/storage/StorageKey';\n    export * from 'beacon/types/storage/StorageKeyReturnDefaults';\n    export * from 'beacon/types/storage/StorageKeyReturnType';\n    export * from 'beacon/types/tezos/MichelineMichelsonV1Expression';\n    export * from 'beacon/types/tezos/MichelsonPrimitives';\n    export * from 'beacon/types/tezos/operations/ActivateAccount';\n    export * from 'beacon/types/tezos/operations/Ballot';\n    export * from 'beacon/types/tezos/operations/Delegation';\n    export * from 'beacon/types/tezos/operations/DoubleBakingEvidence';\n    export * from 'beacon/types/tezos/operations/DoubleEndorsementEvidence';\n    export * from 'beacon/types/tezos/operations/Endorsement';\n    export * from 'beacon/types/tezos/operations/Origination';\n    export * from 'beacon/types/tezos/operations/Proposal';\n    export * from 'beacon/types/tezos/operations/Reveal';\n    export * from 'beacon/types/tezos/operations/SeedNonceRevelation';\n    export * from 'beacon/types/tezos/operations/Transaction';\n    export * from 'beacon/types/tezos/OperationTypes';\n    export * from 'beacon/types/tezos/PartialTezosOperation';\n    export * from 'beacon/types/tezos/TezosBaseOperation';\n    export * from 'beacon/types/tezos/TezosBlockHeader';\n    export * from 'beacon/types/tezos/TezosOperation';\n    export * from 'beacon/types/tezos/TezosTransactionParameters';\n    export * from 'beacon/types/transport/TransportStatus';\n    export * from 'beacon/types/transport/TransportType';\n    export * from 'beacon/ui/alert/alert-templates';\n    export * from 'beacon/ui/alert/Alert';\n    export * from 'beacon/ui/alert/Pairing';\n    export * from 'beacon/ui/alert/PairingAlert';\n    export * from 'beacon/ui/alert/wallet-lists';\n    export * from 'beacon/ui/toast/toast-templates';\n    export * from 'beacon/ui/toast/Toast';\n    export * from 'beacon/utils/assert-never';\n    export * from 'beacon/utils/available-transports';\n    export * from 'beacon/utils/block-explorer';\n    export * from 'beacon/utils/crypto';\n    export * from 'beacon/utils/exposed-promise';\n    export * from 'beacon/utils/generate-uuid';\n    export * from 'beacon/utils/get-account-identifier';\n    export * from 'beacon/utils/get-sender-id';\n    export * from 'beacon/utils/get-tzip10-link';\n    export * from 'beacon/utils/Logger';\n    export * from 'beacon/utils/platform';\n    export * from 'beacon/utils/qr';\n    export * from 'beacon/utils/replace-in-template';\n    export * from 'beacon/utils/shorten-string';\n    export * from 'beacon/utils/tezblock-blockexplorer';\n    export * from 'beacon/utils/utils';\n}\n\ndeclare module 'beacon/beacon-message-events' {\n    import { BeaconEvent } from 'beacon/events';\n    import { BeaconMessageType } from 'beacon/';\n    export const messageEvents: {\n        [key in BeaconMessageType]: {\n            sent: BeaconEvent;\n            success: BeaconEvent;\n            error: BeaconEvent;\n        };\n    };\n}\n\ndeclare module 'beacon/clients/beacon-client/BeaconClient' {\n    import * as sodium from 'libsodium-wrappers';\n    import { ExposedPromise } from 'beacon/utils/exposed-promise';\n    import { Storage } from 'beacon/';\n    import { BeaconEventHandler } from 'beacon/events';\n    import { BeaconClientOptions } from 'beacon/clients/beacon-client/BeaconClientOptions';\n    /**\n      * The beacon client is an abstract client that handles everything that is shared between all other clients.\n      * Specifically, it handles managing the beaconId and and the local keypair.\n      */\n    export abstract class BeaconClient {\n        /**\n          * The name of the client\n          */\n        readonly name: string;\n        /**\n          * The URL of the dApp Icon. This can be used to display the icon of the dApp on in the wallet\n          */\n        readonly iconUrl?: string;\n        /**\n          * The URL of the dApp.\n          */\n        readonly appUrl?: string;\n        /** The beaconId is a public key that is used to identify one specific application (dapp or wallet).\n          * This is used inside a message to specify the sender, for example.\n          */\n        protected _beaconId: ExposedPromise<string>;\n        get beaconId(): Promise<string>;\n        protected storage: Storage;\n        protected readonly events: BeaconEventHandler;\n        /**\n          * The local keypair that is used for the communication encryption\n          */\n        protected _keyPair: ExposedPromise<sodium.KeyPair>;\n        protected get keyPair(): Promise<sodium.KeyPair>;\n        constructor(config: BeaconClientOptions);\n        /**\n          * This resets the SDK. After using this method, this instance is no longer usable. You will have to instanciate a new client.\n          */\n        destroy(): Promise<void>;\n    }\n}\n\ndeclare module 'beacon/clients/beacon-client/BeaconClientOptions' {\n    import { Storage } from 'beacon/';\n    export interface BeaconClientOptions {\n        /**\n          * Name of the application\n          */\n        name: string;\n        /**\n          * A URL to the icon of the application\n          */\n        iconUrl?: string;\n        /**\n          * A URL to the website of the application\n          */\n        appUrl?: string;\n        /**\n          * The storage that will be used by the SDK\n          */\n        storage: Storage;\n    }\n}\n\ndeclare module 'beacon/clients/client/Client' {\n    import { ExposedPromise } from 'beacon/utils/exposed-promise';\n    import { ConnectionContext } from 'beacon/types/ConnectionContext';\n    import { TransportType, TransportStatus, AccountInfo, PeerInfo, Transport, AppMetadata } from 'beacon/';\n    import { BeaconEventHandler } from 'beacon/events';\n    import { BeaconClient } from 'beacon/clients/beacon-client/BeaconClient';\n    import { AccountManager } from 'beacon/managers/AccountManager';\n    import { BeaconRequestMessage } from 'beacon/types/beacon/BeaconRequestMessage';\n    import { ClientOptions } from 'beacon/clients/client/ClientOptions';\n    /**\n      * This abstract class handles the a big part of the logic that is shared between the dapp and wallet client.\n      * For example, it selects and manages the transport and accounts.\n      */\n    export abstract class Client extends BeaconClient {\n        protected readonly accountManager: AccountManager;\n        protected handleResponse: (_event: BeaconRequestMessage, connectionInfo: ConnectionContext) => void;\n        /**\n          * How many requests can be sent after another\n          */\n        protected readonly rateLimit: number;\n        /**\n          * The time window in seconds in which the \"rateLimit\" is checked\n          */\n        protected readonly rateLimitWindowInSeconds: number;\n        /**\n          * Stores the times when requests have been made to determine if the rate limit has been reached\n          */\n        protected requestCounter: number[];\n        protected readonly events: BeaconEventHandler;\n        protected readonly matrixNodes: string[];\n        protected _transport: ExposedPromise<Transport<any>>;\n        protected get transport(): Promise<Transport<any>>;\n        /**\n          * Returns the connection status of the Client\n          */\n        get connectionStatus(): TransportStatus;\n        /**\n          * Returns whether or not the transaport is ready\n          */\n        get ready(): Promise<void>;\n        constructor(config: ClientOptions);\n        /**\n          * Return all locally known accounts\n          */\n        getAccounts(): Promise<AccountInfo[]>;\n        /**\n          * Return the account by ID\n          * @param accountIdentifier The ID of an account\n          */\n        getAccount(accountIdentifier: string): Promise<AccountInfo | undefined>;\n        /**\n          * Remove the account by ID\n          * @param accountIdentifier The ID of an account\n          */\n        removeAccount(accountIdentifier: string): Promise<void>;\n        /**\n          * Remove all locally stored accounts\n          */\n        removeAllAccounts(): Promise<void>;\n        /**\n          * Add a new request (current timestamp) to the pending requests, remove old ones and check if we are above the limit\n          */\n        addRequestAndCheckIfRateLimited(): Promise<boolean>;\n        /**\n          * This method initializes the client. It will check if the connection should be established to a\n          * browser extension or if the P2P transport should be used.\n          *\n          * @param transport A transport that can be provided by the user\n          */\n        init(transport: Transport<any>): Promise<TransportType>;\n        /**\n          * Returns the metadata of this DApp\n          */\n        getOwnAppMetadata(): Promise<AppMetadata>;\n        /**\n          * Return all known peers\n          */\n        getPeers(): Promise<PeerInfo[]>;\n        /**\n          * Add a new peer to the known peers\n          * @param peer The new peer to add\n          */\n        addPeer(peer: PeerInfo): Promise<void>;\n        /**\n          * A \"setter\" for when the transport needs to be changed.\n          */\n        protected setTransport(transport?: Transport<any>): Promise<void>;\n        protected addListener(transport: Transport<any>): Promise<void>;\n        protected sendDisconnectToPeer(peer: PeerInfo, transport?: Transport<any>): Promise<void>;\n    }\n}\n\ndeclare module 'beacon/clients/client/ClientOptions' {\n    import { Storage } from 'beacon/';\n    import { BeaconEvent, BeaconEventHandlerFunction, BeaconEventType } from 'beacon/events';\n    export interface ClientOptions {\n        /**\n          * Name of the application\n          */\n        name: string;\n        /**\n          * A URL to the icon of the application\n          */\n        iconUrl?: string;\n        /**\n          * A URL to the website of the application\n          */\n        appUrl?: string;\n        /**\n          * The storage that will be used by the SDK\n          */\n        storage: Storage;\n        /**\n          * An object that will be used to overwrite default event handler behaviour.\n          *\n          * If you plan to overwrite all default events, use \"disableDefaultEvents\" instead.\n          *\n          * This will overwrite the default event handler, so this can lead to unexpected behavior in some cases.\n          * We recommend that you overwrite all handlers if you want to use your own UI.\n          *\n          * If you simply want to be notified of events happening, but do not want to overwrite the default behavior,\n          * please use `subscribeToEvent()` on the DAppClient instead.\n          */\n        eventHandlers?: {\n            [key in BeaconEvent]?: {\n                handler: BeaconEventHandlerFunction<BeaconEventType[key]>;\n            };\n        };\n        /**\n          * Disable all default Events and UI elements. If passed together with \"eventHandlers\",\n          * the default eventHandlers will be removed, and the ones passed by the user will be added.\n          */\n        disableDefaultEvents?: boolean;\n        /**\n          * A list of matrix nodes to connect to. If a non-empty array is passed, the default options will be overwritten.\n          * One node will be randomly selected based on the local keypair and the other nodes will be used as a fallback in case the primary node goes down.\n          *\n          * Only provide the hostname, no https:// prefix. Eg. ['matrix.example.com']\n          */\n        matrixNodes?: string[];\n    }\n}\n\ndeclare module 'beacon/clients/dapp-client/DAppClient' {\n    import { BeaconEvent, BeaconEventHandlerFunction, BeaconEventType } from 'beacon/events';\n    import { AccountInfo, Client, TransportType, BeaconMessageType, NetworkType, RequestPermissionInput, RequestSignPayloadInput, RequestOperationInput, RequestBroadcastInput, PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, Transport, DappP2PTransport, DappPostMessageTransport, AppMetadata } from 'beacon/';\n    import { BlockExplorer } from 'beacon/utils/block-explorer';\n    import { ExtendedP2PPairingResponse } from 'beacon/types/P2PPairingResponse';\n    import { ExtendedPostMessagePairingResponse } from 'beacon/types/PostMessagePairingResponse';\n    import { ExtendedPeerInfo } from 'beacon/types/PeerInfo';\n    import { ColorMode } from 'beacon/types/ColorMode';\n    import { DAppClientOptions } from 'beacon/clients/dapp-client/DAppClientOptions';\n    /**\n      * The DAppClient has to be used in decentralized applications. It handles all the logic related to connecting to beacon-compatible\n      * wallets and sending requests.\n      */\n    export class DAppClient extends Client {\n        /**\n          * The block explorer used by the SDK\n          */\n        readonly blockExplorer: BlockExplorer;\n        preferredNetwork: NetworkType;\n        protected postMessageTransport: DappPostMessageTransport | undefined;\n        protected p2pTransport: DappP2PTransport | undefined;\n        constructor(config: DAppClientOptions);\n        initInternalTransports(): Promise<void>;\n        init(transport?: Transport<any>): Promise<TransportType>;\n        /**\n          * Returns the active account\n          */\n        getActiveAccount(): Promise<AccountInfo | undefined>;\n        /**\n          * Sets the active account\n          *\n          * @param account The account that will be set as the active account\n          */\n        setActiveAccount(account?: AccountInfo): Promise<void>;\n        /**\n          * Clear the active account\n          */\n        clearActiveAccount(): Promise<void>;\n        setColorMode(colorMode: ColorMode): Promise<void>;\n        getColorMode(): Promise<ColorMode>;\n        /**\n          * @deprecated\n          *\n          * Use getOwnAppMetadata instead\n          */\n        getAppMetadata(): Promise<AppMetadata>;\n        /**\n          * Will remove the account from the local storage and set a new active account if necessary.\n          *\n          * @param accountIdentifier ID of the account\n          */\n        removeAccount(accountIdentifier: string): Promise<void>;\n        /**\n          * Remove all accounts and set active account to undefined\n          */\n        removeAllAccounts(): Promise<void>;\n        /**\n          * Removes a peer and all the accounts that have been connected through that peer\n          *\n          * @param peer Peer to be removed\n          */\n        removePeer(peer: ExtendedPeerInfo, sendDisconnectToPeer?: boolean): Promise<void>;\n        /**\n          * Remove all peers and all accounts that have been connected through those peers\n          */\n        removeAllPeers(sendDisconnectToPeers?: boolean): Promise<void>;\n        /**\n          * Allows the user to subscribe to specific events that are fired in the SDK\n          *\n          * @param internalEvent The event to subscribe to\n          * @param eventCallback The callback that will be called when the event occurs\n          */\n        subscribeToEvent<K extends BeaconEvent>(internalEvent: K, eventCallback: BeaconEventHandlerFunction<BeaconEventType[K]>): Promise<void>;\n        /**\n          * Check if we have permissions to send the specific message type to the active account.\n          * If no active account is set, only permission requests are allowed.\n          *\n          * @param type The type of the message\n          */\n        checkPermissions(type: BeaconMessageType): Promise<boolean>;\n        /**\n          * Send a permission request to the DApp. This should be done as the first step. The wallet will respond\n          * with an publicKey and permissions that were given. The account returned will be set as the \"activeAccount\"\n          * and will be used for the following requests.\n          *\n          * @param input The message details we need to prepare the PermissionRequest message.\n          */\n        requestPermissions(input?: RequestPermissionInput): Promise<PermissionResponseOutput>;\n        /**\n          * This method will send a \"SignPayloadRequest\" to the wallet. This method is meant to be used to sign\n          * arbitrary data (eg. a string). It will return the signature in the format of \"edsig...\"\n          *\n          * @param input The message details we need to prepare the SignPayloadRequest message.\n          */\n        requestSignPayload(input: RequestSignPayloadInput): Promise<SignPayloadResponseOutput>;\n        /**\n          * This method sends an OperationRequest to the wallet. This method should be used for all kinds of operations,\n          * eg. transaction or delegation. Not all properties have to be provided. Data like \"counter\" and fees will be\n          * fetched and calculated by the wallet (but they can still be provided if required).\n          *\n          * @param input The message details we need to prepare the OperationRequest message.\n          */\n        requestOperation(input: RequestOperationInput): Promise<OperationResponseOutput>;\n        /**\n          * Sends a \"BroadcastRequest\" to the wallet. This method can be used to inject an already signed transaction\n          * to the network.\n          *\n          * @param input The message details we need to prepare the BroadcastRequest message.\n          */\n        requestBroadcast(input: RequestBroadcastInput): Promise<BroadcastResponseOutput>;\n        protected setActivePeer(peer?: ExtendedPostMessagePairingResponse | ExtendedP2PPairingResponse): Promise<void>;\n        /**\n          * A \"setter\" for when the transport needs to be changed.\n          */\n        protected setTransport(transport?: Transport<any>): Promise<void>;\n    }\n}\n\ndeclare module 'beacon/clients/dapp-client/DAppClientOptions' {\n    import { NetworkType, Storage } from 'beacon/';\n    import { BeaconEvent, BeaconEventType, BeaconEventHandlerFunction } from 'beacon/events';\n    import { ColorMode } from 'beacon/types/ColorMode';\n    import { BlockExplorer } from 'beacon/utils/block-explorer';\n    export interface DAppClientOptions {\n        /**\n          * Name of the application\n          */\n        name: string;\n        /**\n          * A URL to the icon of the application\n          */\n        iconUrl?: string;\n        /**\n          * A URL to the website of the application\n          */\n        appUrl?: string;\n        /**\n          * The storage that will be used by the SDK\n          */\n        storage?: Storage;\n        /**\n          * An object that will be used to overwrite default event handler behaviour.\n          *\n          * If you plan to overwrite all default events, use \"disableDefaultEvents\" instead.\n          *\n          * This will overwrite the default event handler, so this can lead to unexpected behavior in some cases.\n          * We recommend that you overwrite all handlers if you want to use your own UI.\n          *\n          * If you simply want to be notified of events happening, but do not want to overwrite the default behavior,\n          * please use `subscribeToEvent()` on the DAppClient instead.\n          */\n        eventHandlers?: {\n            [key in BeaconEvent]?: {\n                handler: BeaconEventHandlerFunction<BeaconEventType[key]>;\n            };\n        };\n        /**\n          * Disable all default Events and UI elements. If passed together with \"eventHandlers\",\n          * the default eventHandlers will be removed, and the ones passed by the user will be added.\n          */\n        disableDefaultEvents?: boolean;\n        /**\n          * A list of matrix nodes to connect to. If a non-empty array is passed, the default options will be overwritten.\n          * One node will be randomly selected based on the local keypair and the other nodes will be used as a fallback in case the primary node goes down.\n          *\n          * Only provide the hostname, no https:// prefix. Eg. ['matrix.example.com']\n          */\n        matrixNodes?: string[];\n        /**\n          * The block explorer used by the SDK\n          */\n        blockExplorer?: BlockExplorer;\n        /**\n          * Indicates on which network the DApp is planning to run. This is currently used to adjust the URLs of web-wallets in the pairing alert if they use different URLs for testnets.\n          * You will still have to define the network you intend to use during the permission request.\n          */\n        preferredNetwork?: NetworkType;\n        /**\n          * Set the color mode for the UI elements (alerts and toasts)\n          */\n        colorMode?: ColorMode;\n    }\n}\n\ndeclare module 'beacon/clients/wallet-client/WalletClient' {\n    import { Client, WalletClientOptions, TransportType, BeaconRequestOutputMessage, BeaconResponseInputMessage, AppMetadata, PermissionInfo } from 'beacon/';\n    import { ConnectionContext } from 'beacon/types/ConnectionContext';\n    import { ExtendedP2PPairingResponse } from 'beacon/types/P2PPairingResponse';\n    import { ExposedPromise } from 'beacon/utils/exposed-promise';\n    import { PeerInfo } from 'beacon/types/PeerInfo';\n    /**\n      * The WalletClient has to be used in the wallet. It handles all the logic related to connecting to beacon-compatible\n      * dapps and handling/responding to requests.\n      */\n    export class WalletClient extends Client {\n        /**\n          * Returns whether or not the transport is connected\n          */\n        protected readonly _isConnected: ExposedPromise<boolean>;\n        get isConnected(): Promise<boolean>;\n        constructor(config: WalletClientOptions);\n        init(): Promise<TransportType>;\n        /**\n          * This method initiates a connection to the P2P network and registers a callback that will be called\n          * whenever a message is received.\n          *\n          * @param newMessageCallback The callback that will be invoked for every message the transport receives.\n          */\n        connect(newMessageCallback: (message: BeaconRequestOutputMessage, connectionContext: ConnectionContext) => void): Promise<void>;\n        /**\n          * The method will attempt to initiate a connection using the active transport.\n          */\n        _connect(): Promise<void>;\n        /**\n          * This method sends a response for a specific request back to the DApp\n          *\n          * @param message The BeaconResponseMessage that will be sent back to the DApp\n          */\n        respond(message: BeaconResponseInputMessage): Promise<void>;\n        getAppMetadataList(): Promise<AppMetadata[]>;\n        getAppMetadata(senderId: string): Promise<AppMetadata | undefined>;\n        removeAppMetadata(senderId: string): Promise<void>;\n        removeAllAppMetadata(): Promise<void>;\n        getPermissions(): Promise<PermissionInfo[]>;\n        getPermission(accountIdentifier: string): Promise<PermissionInfo | undefined>;\n        removePermission(accountIdentifier: string): Promise<void>;\n        removeAllPermissions(): Promise<void>;\n        /**\n          * Add a new peer to the known peers\n          * @param peer The new peer to add\n          */\n        addPeer(peer: PeerInfo): Promise<void>;\n        removePeer(peer: ExtendedP2PPairingResponse, sendDisconnectToPeer?: boolean): Promise<void>;\n        removeAllPeers(sendDisconnectToPeers?: boolean): Promise<void>;\n    }\n}\n\ndeclare module 'beacon/clients/wallet-client/WalletClientOptions' {\n    import { Storage } from 'beacon/';\n    export interface WalletClientOptions {\n        /**\n          * Name of the application\n          */\n        name: string;\n        /**\n          * A URL to the icon of the application\n          */\n        iconUrl?: string;\n        /**\n          * A URL to the website of the application\n          */\n        appUrl?: string;\n        /**\n          * The storage that will be used by the SDK\n          */\n        storage?: Storage;\n        /**\n          * A list of matrix nodes to connect to. If a non-empty array is passed, the default options will be overwritten.\n          * One node will be randomly selected based on the local keypair and the other nodes will be used as a fallback in case the primary node goes down.\n          *\n          * Only provide the hostname, no https:// prefix. Eg. ['matrix.example.com']\n          */\n        matrixNodes?: string[];\n    }\n}\n\ndeclare module 'beacon/colorMode' {\n    import { ColorMode } from 'beacon/types/ColorMode';\n    export const setColorMode: (mode: ColorMode) => void;\n    export const getColorMode: () => ColorMode;\n}\n\ndeclare module 'beacon/constants' {\n    export const SDK_VERSION: string;\n    export const BEACON_VERSION: string;\n}\n\ndeclare module 'beacon/debug' {\n    export const setDebugEnabled: (enabled: boolean) => void;\n    export const getDebugEnabled: () => boolean;\n}\n\ndeclare module 'beacon/dts-bundle.tmp.test' {\n    export * from 'beacon/beacon-message-events';\n    export * from 'beacon/clients/beacon-client/BeaconClient';\n    export * from 'beacon/clients/beacon-client/BeaconClientOptions';\n    export * from 'beacon/clients/client/Client';\n    export * from 'beacon/clients/client/ClientOptions';\n    export * from 'beacon/clients/dapp-client/DAppClient';\n    export * from 'beacon/clients/dapp-client/DAppClientOptions';\n    export * from 'beacon/clients/wallet-client/WalletClient';\n    export * from 'beacon/clients/wallet-client/WalletClientOptions';\n    export * from 'beacon/colorMode';\n    export * from 'beacon/constants';\n    export * from 'beacon/debug';\n    export * from 'beacon/errors/AbortedBeaconError';\n    export * from 'beacon/errors/BeaconError';\n    export * from 'beacon/errors/BroadcastBeaconError';\n    export * from 'beacon/errors/NetworkNotSupportedBeaconError';\n    export * from 'beacon/errors/NoAddressBeaconError';\n    export * from 'beacon/errors/NoPrivateKeyBeaconError';\n    export * from 'beacon/errors/NotGrantedBeaconError';\n    export * from 'beacon/errors/ParametersInvalidBeaconError';\n    export * from 'beacon/errors/SignatureTypeNotSupportedBeaconError';\n    export * from 'beacon/errors/TooManyOperationsBeaconError';\n    export * from 'beacon/errors/TransactionInvalidBeaconError';\n    export * from 'beacon/errors/UnknownBeaconError';\n    export * from 'beacon/events';\n    export * from 'beacon/examples/broadcast-request';\n    export * from 'beacon/examples/custom-block-explorer';\n    export * from 'beacon/examples/disable-all-ui';\n    export * from 'beacon/examples/operation-request';\n    export * from 'beacon/examples/override-default-events';\n    export * from 'beacon/examples/permission-request';\n    export * from 'beacon/examples/sign-payload-request';\n    export * from 'beacon/examples/using-custom-network';\n    export * from 'beacon/examples/wallet-example';\n    export * from 'beacon/index';\n    export * from 'beacon/interceptors/IncomingRequestInterceptor';\n    export * from 'beacon/interceptors/OutgoingResponseInterceptor';\n    export * from 'beacon/managers/AccountManager';\n    export * from 'beacon/managers/AppMetadataManager';\n    export * from 'beacon/managers/PeerManager';\n    export * from 'beacon/managers/PermissionManager';\n    export * from 'beacon/managers/PermissionValidator';\n    export * from 'beacon/managers/StorageManager';\n    export * from 'beacon/matrix-client/MatrixClient';\n    export * from 'beacon/matrix-client/MatrixClientEventEmitter';\n    export * from 'beacon/matrix-client/MatrixClientStore';\n    export * from 'beacon/matrix-client/MatrixHttpClient';\n    export * from 'beacon/matrix-client/models/api/MatrixEventSend';\n    export * from 'beacon/matrix-client/models/api/MatrixLogin';\n    export * from 'beacon/matrix-client/models/api/MatrixRequest';\n    export * from 'beacon/matrix-client/models/api/MatrixRoomCreate';\n    export * from 'beacon/matrix-client/models/api/MatrixRoomInvite';\n    export * from 'beacon/matrix-client/models/api/MatrixRoomJoin';\n    export * from 'beacon/matrix-client/models/api/MatrixSync';\n    export * from 'beacon/matrix-client/models/MatrixClientEvent';\n    export * from 'beacon/matrix-client/models/MatrixMessage';\n    export * from 'beacon/matrix-client/models/MatrixRoom';\n    export * from 'beacon/matrix-client/models/MatrixStateEvent';\n    export * from 'beacon/matrix-client/services/MatrixEventService';\n    export * from 'beacon/matrix-client/services/MatrixRoomService';\n    export * from 'beacon/matrix-client/services/MatrixUserService';\n    export * from 'beacon/matrix-client/utils/events';\n    export * from 'beacon/migrations/migrate-0.7.0';\n    export * from 'beacon/migrations/migrations';\n    export * from 'beacon/MockWindow';\n    export * from 'beacon/scripts/index';\n    export * from 'beacon/Serializer';\n    export * from 'beacon/storage/ChromeStorage';\n    export * from 'beacon/storage/getStorage';\n    export * from 'beacon/storage/LocalStorage';\n    export * from 'beacon/storage/Storage';\n    export * from 'beacon/test';\n    export * from 'beacon/transports/clients/CommunicationClient';\n    export * from 'beacon/transports/clients/MessageBasedClient';\n    export * from 'beacon/transports/clients/P2PCommunicationClient';\n    export * from 'beacon/transports/clients/PostMessageClient';\n    export * from 'beacon/transports/DappP2PTransport';\n    export * from 'beacon/transports/DappPostMessageTransport';\n    export * from 'beacon/transports/P2PTransport';\n    export * from 'beacon/transports/PostMessageTransport';\n    export * from 'beacon/transports/Transport';\n    export * from 'beacon/transports/WalletP2PTransport';\n    export * from 'beacon/transports/WalletPostMessageTransport';\n    export * from 'beacon/types/AccountInfo';\n    export * from 'beacon/types/beacon/AppMetadata';\n    export * from 'beacon/types/beacon/BeaconBaseMessage';\n    export * from 'beacon/types/beacon/BeaconMessage';\n    export * from 'beacon/types/beacon/BeaconMessageType';\n    export * from 'beacon/types/beacon/BeaconRequestMessage';\n    export * from 'beacon/types/beacon/BeaconResponseMessage';\n    export * from 'beacon/types/beacon/messages/AcknowledgeResponse';\n    export * from 'beacon/types/beacon/messages/BeaconRequestInputMessage';\n    export * from 'beacon/types/beacon/messages/BeaconRequestOutputMessage';\n    export * from 'beacon/types/beacon/messages/BeaconResponseInputMessage';\n    export * from 'beacon/types/beacon/messages/BeaconResponseOutputMessage';\n    export * from 'beacon/types/beacon/messages/BroadcastRequest';\n    export * from 'beacon/types/beacon/messages/BroadcastResponse';\n    export * from 'beacon/types/beacon/messages/DisconnectMessage';\n    export * from 'beacon/types/beacon/messages/ErrorResponse';\n    export * from 'beacon/types/beacon/messages/OperationRequest';\n    export * from 'beacon/types/beacon/messages/OperationResponse';\n    export * from 'beacon/types/beacon/messages/PermissionRequest';\n    export * from 'beacon/types/beacon/messages/PermissionResponse';\n    export * from 'beacon/types/beacon/messages/SignPayloadRequest';\n    export * from 'beacon/types/beacon/messages/SignPayloadResponse';\n    export * from 'beacon/types/beacon/Network';\n    export * from 'beacon/types/beacon/NetworkType';\n    export * from 'beacon/types/beacon/PermissionScope';\n    export * from 'beacon/types/beacon/SigningType';\n    export * from 'beacon/types/beacon/Threshold';\n    export * from 'beacon/types/BeaconErrorType';\n    export * from 'beacon/types/ColorMode';\n    export * from 'beacon/types/ConnectionContext';\n    export * from 'beacon/types/Extension';\n    export * from 'beacon/types/ExtensionMessage';\n    export * from 'beacon/types/ExtensionMessageTarget';\n    export * from 'beacon/types/Origin';\n    export * from 'beacon/types/P2PPairingRequest';\n    export * from 'beacon/types/P2PPairingResponse';\n    export * from 'beacon/types/PeerInfo';\n    export * from 'beacon/types/PermissionEntity';\n    export * from 'beacon/types/PermissionInfo';\n    export * from 'beacon/types/PostMessagePairingRequest';\n    export * from 'beacon/types/PostMessagePairingResponse';\n    export * from 'beacon/types/RequestBroadcastInput';\n    export * from 'beacon/types/RequestOperationInput';\n    export * from 'beacon/types/RequestPermissionInput';\n    export * from 'beacon/types/RequestSignPayloadInput';\n    export * from 'beacon/types/storage/StorageKey';\n    export * from 'beacon/types/storage/StorageKeyReturnDefaults';\n    export * from 'beacon/types/storage/StorageKeyReturnType';\n    export * from 'beacon/types/tezos/MichelineMichelsonV1Expression';\n    export * from 'beacon/types/tezos/MichelsonPrimitives';\n    export * from 'beacon/types/tezos/operations/ActivateAccount';\n    export * from 'beacon/types/tezos/operations/Ballot';\n    export * from 'beacon/types/tezos/operations/Delegation';\n    export * from 'beacon/types/tezos/operations/DoubleBakingEvidence';\n    export * from 'beacon/types/tezos/operations/DoubleEndorsementEvidence';\n    export * from 'beacon/types/tezos/operations/Endorsement';\n    export * from 'beacon/types/tezos/operations/Origination';\n    export * from 'beacon/types/tezos/operations/Proposal';\n    export * from 'beacon/types/tezos/operations/Reveal';\n    export * from 'beacon/types/tezos/operations/SeedNonceRevelation';\n    export * from 'beacon/types/tezos/operations/Transaction';\n    export * from 'beacon/types/tezos/OperationTypes';\n    export * from 'beacon/types/tezos/PartialTezosOperation';\n    export * from 'beacon/types/tezos/TezosBaseOperation';\n    export * from 'beacon/types/tezos/TezosBlockHeader';\n    export * from 'beacon/types/tezos/TezosOperation';\n    export * from 'beacon/types/tezos/TezosTransactionParameters';\n    export * from 'beacon/types/transport/TransportStatus';\n    export * from 'beacon/types/transport/TransportType';\n    export * from 'beacon/ui/alert/alert-templates';\n    export * from 'beacon/ui/alert/Alert';\n    export * from 'beacon/ui/alert/Pairing';\n    export * from 'beacon/ui/alert/PairingAlert';\n    export * from 'beacon/ui/alert/wallet-lists';\n    export * from 'beacon/ui/toast/toast-templates';\n    export * from 'beacon/ui/toast/Toast';\n    export * from 'beacon/utils/assert-never';\n    export * from 'beacon/utils/available-transports';\n    export * from 'beacon/utils/block-explorer';\n    export * from 'beacon/utils/crypto';\n    export * from 'beacon/utils/exposed-promise';\n    export * from 'beacon/utils/generate-uuid';\n    export * from 'beacon/utils/get-account-identifier';\n    export * from 'beacon/utils/get-sender-id';\n    export * from 'beacon/utils/get-tzip10-link';\n    export * from 'beacon/utils/Logger';\n    export * from 'beacon/utils/platform';\n    export * from 'beacon/utils/qr';\n    export * from 'beacon/utils/replace-in-template';\n    export * from 'beacon/utils/shorten-string';\n    export * from 'beacon/utils/tezblock-blockexplorer';\n    export * from 'beacon/utils/utils';\n}\n\ndeclare module 'beacon/errors/AbortedBeaconError' {\n    import { BeaconError } from 'beacon/';\n    export class AbortedBeaconError extends BeaconError {\n        name: string;\n        title: string;\n        constructor();\n    }\n}\n\ndeclare module 'beacon/errors/BeaconError' {\n    import { BeaconErrorType } from 'beacon/';\n    export abstract class BeaconError implements Error {\n        name: string;\n        message: string;\n        title: string;\n        description: string;\n        get fullDescription(): string;\n        constructor(errorType: BeaconErrorType, message: string);\n        static getError(errorType: BeaconErrorType, errorData: any): BeaconError;\n    }\n}\n\ndeclare module 'beacon/errors/BroadcastBeaconError' {\n    import { BeaconError } from 'beacon/';\n    export class BroadcastBeaconError extends BeaconError {\n        name: string;\n        title: string;\n        constructor();\n    }\n}\n\ndeclare module 'beacon/errors/NetworkNotSupportedBeaconError' {\n    import { BeaconError } from 'beacon/';\n    export class NetworkNotSupportedBeaconError extends BeaconError {\n        name: string;\n        title: string;\n        constructor();\n    }\n}\n\ndeclare module 'beacon/errors/NoAddressBeaconError' {\n    import { BeaconError } from 'beacon/';\n    export class NoAddressBeaconError extends BeaconError {\n        name: string;\n        title: string;\n        constructor();\n    }\n}\n\ndeclare module 'beacon/errors/NoPrivateKeyBeaconError' {\n    import { BeaconError } from 'beacon/';\n    export class NoPrivateKeyBeaconError extends BeaconError {\n        name: string;\n        title: string;\n        constructor();\n    }\n}\n\ndeclare module 'beacon/errors/NotGrantedBeaconError' {\n    import { BeaconError } from 'beacon/';\n    export class NotGrantedBeaconError extends BeaconError {\n        name: string;\n        title: string;\n        constructor();\n    }\n}\n\ndeclare module 'beacon/errors/ParametersInvalidBeaconError' {\n    import { BeaconError } from 'beacon/';\n    export class ParametersInvalidBeaconError extends BeaconError {\n        name: string;\n        title: string;\n        constructor();\n    }\n}\n\ndeclare module 'beacon/errors/SignatureTypeNotSupportedBeaconError' {\n    import { BeaconError } from 'beacon/';\n    export class SignatureTypeNotSupportedBeaconError extends BeaconError {\n        name: string;\n        title: string;\n        constructor();\n    }\n}\n\ndeclare module 'beacon/errors/TooManyOperationsBeaconError' {\n    import { BeaconError } from 'beacon/';\n    export class TooManyOperationsBeaconError extends BeaconError {\n        name: string;\n        title: string;\n        constructor();\n    }\n}\n\ndeclare module 'beacon/errors/TransactionInvalidBeaconError' {\n    import { BeaconError } from 'beacon/';\n    export class TransactionInvalidBeaconError extends BeaconError {\n        readonly data: any;\n        name: string;\n        title: string;\n        get fullDescription(): string;\n        constructor(data: any);\n    }\n}\n\ndeclare module 'beacon/errors/UnknownBeaconError' {\n    import { BeaconError } from 'beacon/';\n    export class UnknownBeaconError extends BeaconError {\n        name: string;\n        title: string;\n        constructor();\n    }\n}\n\ndeclare module 'beacon/events' {\n    import { AlertButton } from 'beacon/ui/alert/Alert';\n    import { ExtendedP2PPairingResponse } from 'beacon/types/P2PPairingResponse';\n    import { PostMessagePairingRequest } from 'beacon/types/PostMessagePairingRequest';\n    import { ExtendedPostMessagePairingResponse } from 'beacon/types/PostMessagePairingResponse';\n    import { BlockExplorer } from 'beacon/utils/block-explorer';\n    import { P2PPairingRequest, AccountInfo, ErrorResponse, PermissionResponseOutput, OperationResponseOutput, BroadcastResponseOutput, SignPayloadResponseOutput, Network, ConnectionContext, Transport, NetworkType, AcknowledgeResponse } from 'beacon/';\n    /**\n      * The different events that can be emitted by the beacon-sdk\n      */\n    export enum BeaconEvent {\n        PERMISSION_REQUEST_SENT = \"PERMISSION_REQUEST_SENT\",\n        PERMISSION_REQUEST_SUCCESS = \"PERMISSION_REQUEST_SUCCESS\",\n        PERMISSION_REQUEST_ERROR = \"PERMISSION_REQUEST_ERROR\",\n        OPERATION_REQUEST_SENT = \"OPERATION_REQUEST_SENT\",\n        OPERATION_REQUEST_SUCCESS = \"OPERATION_REQUEST_SUCCESS\",\n        OPERATION_REQUEST_ERROR = \"OPERATION_REQUEST_ERROR\",\n        SIGN_REQUEST_SENT = \"SIGN_REQUEST_SENT\",\n        SIGN_REQUEST_SUCCESS = \"SIGN_REQUEST_SUCCESS\",\n        SIGN_REQUEST_ERROR = \"SIGN_REQUEST_ERROR\",\n        BROADCAST_REQUEST_SENT = \"BROADCAST_REQUEST_SENT\",\n        BROADCAST_REQUEST_SUCCESS = \"BROADCAST_REQUEST_SUCCESS\",\n        BROADCAST_REQUEST_ERROR = \"BROADCAST_REQUEST_ERROR\",\n        ACKNOWLEDGE_RECEIVED = \"ACKNOWLEDGE_RECEIVED\",\n        LOCAL_RATE_LIMIT_REACHED = \"LOCAL_RATE_LIMIT_REACHED\",\n        NO_PERMISSIONS = \"NO_PERMISSIONS\",\n        ACTIVE_ACCOUNT_SET = \"ACTIVE_ACCOUNT_SET\",\n        ACTIVE_TRANSPORT_SET = \"ACTIVE_TRANSPORT_SET\",\n        PAIR_INIT = \"PAIR_INIT\",\n        PAIR_SUCCESS = \"PAIR_SUCCESS\",\n        CHANNEL_CLOSED = \"CHANNEL_CLOSED\",\n        INTERNAL_ERROR = \"INTERNAL_ERROR\",\n        UNKNOWN = \"UNKNOWN\"\n    }\n    export interface WalletInfo {\n        name: string;\n        icon?: string;\n    }\n    export interface ExtraInfo {\n        resetCallback?(): Promise<void>;\n    }\n    interface RequestSentInfo {\n        extraInfo: ExtraInfo;\n        walletInfo: WalletInfo;\n    }\n    /**\n      * The type of the payload of the different BeaconEvents\n      */\n    export interface BeaconEventType {\n        [BeaconEvent.PERMISSION_REQUEST_SENT]: RequestSentInfo;\n        [BeaconEvent.PERMISSION_REQUEST_SUCCESS]: {\n            account: AccountInfo;\n            output: PermissionResponseOutput;\n            blockExplorer: BlockExplorer;\n            connectionContext: ConnectionContext;\n            walletInfo: WalletInfo;\n        };\n        [BeaconEvent.PERMISSION_REQUEST_ERROR]: {\n            errorResponse: ErrorResponse;\n            walletInfo: WalletInfo;\n        };\n        [BeaconEvent.OPERATION_REQUEST_SENT]: RequestSentInfo;\n        [BeaconEvent.OPERATION_REQUEST_SUCCESS]: {\n            account: AccountInfo;\n            output: OperationResponseOutput;\n            blockExplorer: BlockExplorer;\n            connectionContext: ConnectionContext;\n            walletInfo: WalletInfo;\n        };\n        [BeaconEvent.OPERATION_REQUEST_ERROR]: {\n            errorResponse: ErrorResponse;\n            walletInfo: WalletInfo;\n        };\n        [BeaconEvent.SIGN_REQUEST_SENT]: RequestSentInfo;\n        [BeaconEvent.SIGN_REQUEST_SUCCESS]: {\n            output: SignPayloadResponseOutput;\n            connectionContext: ConnectionContext;\n            walletInfo: WalletInfo;\n        };\n        [BeaconEvent.SIGN_REQUEST_ERROR]: {\n            errorResponse: ErrorResponse;\n            walletInfo: WalletInfo;\n        };\n        [BeaconEvent.BROADCAST_REQUEST_SENT]: RequestSentInfo;\n        [BeaconEvent.BROADCAST_REQUEST_SUCCESS]: {\n            network: Network;\n            output: BroadcastResponseOutput;\n            blockExplorer: BlockExplorer;\n            connectionContext: ConnectionContext;\n            walletInfo: WalletInfo;\n        };\n        [BeaconEvent.BROADCAST_REQUEST_ERROR]: {\n            errorResponse: ErrorResponse;\n            walletInfo: WalletInfo;\n        };\n        [BeaconEvent.ACKNOWLEDGE_RECEIVED]: {\n            message: AcknowledgeResponse;\n            extraInfo: ExtraInfo;\n            walletInfo: WalletInfo;\n        };\n        [BeaconEvent.LOCAL_RATE_LIMIT_REACHED]: undefined;\n        [BeaconEvent.NO_PERMISSIONS]: undefined;\n        [BeaconEvent.ACTIVE_ACCOUNT_SET]: AccountInfo;\n        [BeaconEvent.ACTIVE_TRANSPORT_SET]: Transport;\n        [BeaconEvent.PAIR_INIT]: {\n            p2pPeerInfo: P2PPairingRequest;\n            postmessagePeerInfo: PostMessagePairingRequest;\n            preferredNetwork: NetworkType;\n            abortedHandler?(): void;\n        };\n        [BeaconEvent.PAIR_SUCCESS]: ExtendedPostMessagePairingResponse | ExtendedP2PPairingResponse;\n        [BeaconEvent.CHANNEL_CLOSED]: string;\n        [BeaconEvent.INTERNAL_ERROR]: string;\n        [BeaconEvent.UNKNOWN]: undefined;\n    }\n    export type BeaconEventHandlerFunction<T = unknown> = (data: T, eventCallback?: AlertButton[]) => void | Promise<void>;\n    /**\n      * The default event handlers\n      */\n    export const defaultEventCallbacks: {\n        [key in BeaconEvent]: BeaconEventHandlerFunction<BeaconEventType[key]>;\n    };\n    /**\n      * Handles beacon events\n      */\n    export class BeaconEventHandler {\n        constructor(eventsToOverride?: {\n            [key in BeaconEvent]?: {\n                handler: BeaconEventHandlerFunction<BeaconEventType[key]>;\n            };\n        }, overrideAll?: boolean);\n        /**\n          * A method to subscribe to a specific beacon event and register a callback\n          *\n          * @param event The event being emitted\n          * @param eventCallback The callback that will be invoked\n          */\n        on<K extends BeaconEvent>(event: K, eventCallback: BeaconEventHandlerFunction<BeaconEventType[K]>): Promise<void>;\n        /**\n          * Emit a beacon event\n          *\n          * @param event The event being emitted\n          * @param data The data to be emit\n          */\n        emit<K extends BeaconEvent>(event: K, data?: BeaconEventType[K], eventCallback?: AlertButton[]): Promise<void>;\n    }\n    export {};\n}\n\ndeclare module 'beacon/examples/broadcast-request' {\n    export {};\n}\n\ndeclare module 'beacon/examples/custom-block-explorer' {\n    export {};\n}\n\ndeclare module 'beacon/examples/disable-all-ui' {\n    export {};\n}\n\ndeclare module 'beacon/examples/operation-request' {\n    export {};\n}\n\ndeclare module 'beacon/examples/override-default-events' {\n    export {};\n}\n\ndeclare module 'beacon/examples/permission-request' {\n    export {};\n}\n\ndeclare module 'beacon/examples/sign-payload-request' {\n    export {};\n}\n\ndeclare module 'beacon/examples/using-custom-network' {\n    export {};\n}\n\ndeclare module 'beacon/examples/wallet-example' {\n    export {};\n}\n\ndeclare module 'beacon/index' {\n    import { P2PCommunicationClient } from 'beacon/transports/clients/P2PCommunicationClient';\n    import { AppMetadata } from 'beacon/types/beacon/AppMetadata';\n    import { PermissionRequest } from 'beacon/types/beacon/messages/PermissionRequest';\n    import { Network } from 'beacon/types/beacon/Network';\n    import { BeaconBaseMessage } from 'beacon/types/beacon/BeaconBaseMessage';\n    import { BeaconMessageType } from 'beacon/types/beacon/BeaconMessageType';\n    import { PermissionScope } from 'beacon/types/beacon/PermissionScope';\n    import { PermissionResponse } from 'beacon/types/beacon/messages/PermissionResponse';\n    import { OperationRequest } from 'beacon/types/beacon/messages/OperationRequest';\n    import { OperationResponse } from 'beacon/types/beacon/messages/OperationResponse';\n    import { SignPayloadRequest } from 'beacon/types/beacon/messages/SignPayloadRequest';\n    import { SignPayloadResponse } from 'beacon/types/beacon/messages/SignPayloadResponse';\n    import { BroadcastRequest } from 'beacon/types/beacon/messages/BroadcastRequest';\n    import { BroadcastResponse } from 'beacon/types/beacon/messages/BroadcastResponse';\n    import { NetworkType } from 'beacon/types/beacon/NetworkType';\n    import { TezosBaseOperation } from 'beacon/types/tezos/TezosBaseOperation';\n    import { TezosOperationType } from 'beacon/types/tezos/OperationTypes';\n    import { TezosActivateAccountOperation } from 'beacon/types/tezos/operations/ActivateAccount';\n    import { TezosBallotOperation } from 'beacon/types/tezos/operations/Ballot';\n    import { TezosDelegationOperation } from 'beacon/types/tezos/operations/Delegation';\n    import { TezosDoubleBakingEvidenceOperation } from 'beacon/types/tezos/operations/DoubleBakingEvidence';\n    import { TezosBlockHeader } from 'beacon/types/tezos/TezosBlockHeader';\n    import { TezosDoubleEndorsementEvidenceOperation } from 'beacon/types/tezos/operations/DoubleEndorsementEvidence';\n    import { TezosEndorsementOperation } from 'beacon/types/tezos/operations/Endorsement';\n    import { TezosOriginationOperation } from 'beacon/types/tezos/operations/Origination';\n    import { TezosProposalOperation } from 'beacon/types/tezos/operations/Proposal';\n    import { TezosRevealOperation } from 'beacon/types/tezos/operations/Reveal';\n    import { TezosSeedNonceRevelationOperation } from 'beacon/types/tezos/operations/SeedNonceRevelation';\n    import { TezosTransactionOperation } from 'beacon/types/tezos/operations/Transaction';\n    import { MichelsonPrimitives } from 'beacon/types/tezos/MichelsonPrimitives';\n    import { TezosTransactionParameters } from 'beacon/types/tezos/TezosTransactionParameters';\n    import { Origin } from 'beacon/types/Origin';\n    import { AccountInfo, AccountIdentifier } from 'beacon/types/AccountInfo';\n    import { EncryptedExtensionMessage, ExtensionMessage } from 'beacon/types/ExtensionMessage';\n    import { ExtensionMessageTarget } from 'beacon/types/ExtensionMessageTarget';\n    import { TezosOperation } from 'beacon/types/tezos/TezosOperation';\n    import { Client } from 'beacon/clients/client/Client';\n    import { WalletClient } from 'beacon/clients/wallet-client/WalletClient';\n    import { DAppClient } from 'beacon/clients/dapp-client/DAppClient';\n    import { BeaconError } from 'beacon/errors/BeaconError';\n    import { BeaconErrorType } from 'beacon/types/BeaconErrorType';\n    import { BroadcastBeaconError } from 'beacon/errors/BroadcastBeaconError';\n    import { NetworkNotSupportedBeaconError } from 'beacon/errors/NetworkNotSupportedBeaconError';\n    import { NoAddressBeaconError } from 'beacon/errors/NoAddressBeaconError';\n    import { NoPrivateKeyBeaconError } from 'beacon/errors/NoPrivateKeyBeaconError';\n    import { NotGrantedBeaconError } from 'beacon/errors/NotGrantedBeaconError';\n    import { ParametersInvalidBeaconError } from 'beacon/errors/ParametersInvalidBeaconError';\n    import { TooManyOperationsBeaconError } from 'beacon/errors/TooManyOperationsBeaconError';\n    import { TransactionInvalidBeaconError } from 'beacon/errors/TransactionInvalidBeaconError';\n    import { UnknownBeaconError } from 'beacon/errors/UnknownBeaconError';\n    import { ErrorResponse } from 'beacon/types/beacon/messages/ErrorResponse';\n    import { TransportStatus } from 'beacon/types/transport/TransportStatus';\n    import { TransportType } from 'beacon/types/transport/TransportType';\n    import { PostMessageTransport } from 'beacon/transports/PostMessageTransport';\n    import { Transport } from 'beacon/transports/Transport';\n    import { P2PTransport } from 'beacon/transports/P2PTransport';\n    import { Storage } from 'beacon/storage/Storage';\n    import { StorageKey } from 'beacon/types/storage/StorageKey';\n    import { StorageKeyReturnDefaults } from 'beacon/types/storage/StorageKeyReturnDefaults';\n    import { StorageKeyReturnType } from 'beacon/types/storage/StorageKeyReturnType';\n    import { ExtendedP2PPairingRequest, P2PPairingRequest } from 'beacon/types/P2PPairingRequest';\n    import { ChromeStorage } from 'beacon/storage/ChromeStorage';\n    import { LocalStorage } from 'beacon/storage/LocalStorage';\n    import { getStorage } from 'beacon/storage/getStorage';\n    import { BeaconMessage } from 'beacon/types/beacon/BeaconMessage';\n    import { Serializer } from 'beacon/Serializer';\n    import { RequestPermissionInput } from 'beacon/types/RequestPermissionInput';\n    import { RequestSignPayloadInput } from 'beacon/types/RequestSignPayloadInput';\n    import { RequestOperationInput } from 'beacon/types/RequestOperationInput';\n    import { RequestBroadcastInput } from 'beacon/types/RequestBroadcastInput';\n    import { PermissionResponseInput, SignPayloadResponseInput, OperationResponseInput, BroadcastResponseInput, BeaconResponseInputMessage, AcknowledgeResponseInput, ErrorResponseInput } from 'beacon/types/beacon/messages/BeaconResponseInputMessage';\n    import { PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, BeaconResponseOutputMessage } from 'beacon/types/beacon/messages/BeaconResponseOutputMessage';\n    import { PermissionRequestInput, SignPayloadRequestInput, OperationRequestInput, BroadcastRequestInput, BeaconRequestInputMessage } from 'beacon/types/beacon/messages/BeaconRequestInputMessage';\n    import { PermissionRequestOutput, SignPayloadRequestOutput, OperationRequestOutput, BroadcastRequestOutput, BeaconRequestOutputMessage } from 'beacon/types/beacon/messages/BeaconRequestOutputMessage';\n    import { ClientOptions } from 'beacon/clients/client/ClientOptions';\n    import { DAppClientOptions } from 'beacon/clients/dapp-client/DAppClientOptions';\n    import { WalletClientOptions } from 'beacon/clients/wallet-client/WalletClientOptions';\n    import { PermissionInfo } from 'beacon/types/PermissionInfo';\n    import { SDK_VERSION, BEACON_VERSION } from 'beacon/constants';\n    import { AccountManager } from 'beacon/managers/AccountManager';\n    import { AppMetadataManager } from 'beacon/managers/AppMetadataManager';\n    import { PermissionManager } from 'beacon/managers/PermissionManager';\n    import { BeaconEvent, BeaconEventHandler, defaultEventCallbacks } from 'beacon/events';\n    import { getAddressFromPublicKey } from 'beacon/utils/crypto';\n    import { BeaconClient } from 'beacon/clients/beacon-client/BeaconClient';\n    import { BeaconClientOptions } from 'beacon/clients/beacon-client/BeaconClientOptions';\n    import { getAccountIdentifier } from 'beacon/utils/get-account-identifier';\n    import { ConnectionContext } from 'beacon/types/ConnectionContext';\n    import { Threshold } from 'beacon/types/beacon/Threshold';\n    import { PartialTezosTransactionOperation, PartialTezosOperation, PartialTezosDelegationOperation, PartialTezosOriginationOperation, PartialTezosRevealOperation } from 'beacon/types/tezos/PartialTezosOperation';\n    import { AbortedBeaconError } from 'beacon/errors/AbortedBeaconError';\n    import { ExtendedPeerInfo, PeerInfo } from 'beacon/types/PeerInfo';\n    import { availableTransports } from 'beacon/utils/available-transports';\n    import { AcknowledgeResponse } from 'beacon/types/beacon/messages/AcknowledgeResponse';\n    import { DisconnectMessage } from 'beacon/types/beacon/messages/DisconnectMessage';\n    import { DappP2PTransport } from 'beacon/transports/DappP2PTransport';\n    import { DappPostMessageTransport } from 'beacon/transports/DappPostMessageTransport';\n    import { WalletP2PTransport } from 'beacon/transports/WalletP2PTransport';\n    import { WalletPostMessageTransport } from 'beacon/transports/WalletPostMessageTransport';\n    import { getSenderId } from 'beacon/utils/get-sender-id';\n    import { SigningType } from 'beacon/types/beacon/SigningType';\n    import { SignatureTypeNotSupportedBeaconError } from 'beacon/errors/SignatureTypeNotSupportedBeaconError';\n    import { ExtendedP2PPairingResponse } from 'beacon/types/P2PPairingResponse';\n    import { ExtendedPostMessagePairingRequest, PostMessagePairingRequest } from 'beacon/types/PostMessagePairingRequest';\n    import { ExtendedPostMessagePairingResponse } from 'beacon/types/PostMessagePairingResponse';\n    import { PeerManager } from 'beacon/managers/PeerManager';\n    import { MessageBasedClient } from 'beacon/transports/clients/MessageBasedClient';\n    import { BeaconRequestMessage } from 'beacon/types/beacon/BeaconRequestMessage';\n    import { BeaconResponseMessage } from 'beacon/types/beacon/BeaconResponseMessage';\n    import { Pairing } from 'beacon/ui/alert/Pairing';\n    import { BlockExplorer } from 'beacon/utils/block-explorer';\n    import { TezblockBlockExplorer } from 'beacon/utils/tezblock-blockexplorer';\n    import { setDebugEnabled, getDebugEnabled } from 'beacon/debug';\n    import { ColorMode } from 'beacon/types/ColorMode';\n    export { TezosBaseOperation, TezosOperationType, TezosBlockHeader, MichelsonPrimitives, TezosTransactionParameters, TezosOperation };\n    export { TezosActivateAccountOperation, TezosBallotOperation, TezosDelegationOperation, TezosDoubleBakingEvidenceOperation, TezosDoubleEndorsementEvidenceOperation, TezosEndorsementOperation, TezosOriginationOperation, TezosProposalOperation, TezosRevealOperation, TezosSeedNonceRevelationOperation, TezosTransactionOperation, PartialTezosOperation, PartialTezosTransactionOperation, PartialTezosDelegationOperation, PartialTezosOriginationOperation, PartialTezosRevealOperation };\n    export { BeaconClient, BeaconClientOptions, Client, ClientOptions, DAppClient, DAppClientOptions, WalletClient, WalletClientOptions, P2PCommunicationClient };\n    export { AccountIdentifier, AppMetadata, Network, NetworkType, BeaconMessage, PermissionRequest, PermissionResponse, OperationRequest, OperationResponse, SignPayloadRequest, SignPayloadResponse, BroadcastRequest, BroadcastResponse, AcknowledgeResponse, DisconnectMessage, BeaconBaseMessage, BeaconMessageType, PermissionScope, Origin, AccountInfo, Threshold, SigningType, ExtensionMessageTarget, ExtensionMessage, EncryptedExtensionMessage, RequestPermissionInput, RequestSignPayloadInput, RequestOperationInput, RequestBroadcastInput, PermissionInfo };\n    export { PermissionResponseInput, SignPayloadResponseInput, OperationResponseInput, BroadcastResponseInput, AcknowledgeResponseInput, ErrorResponseInput, PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, PermissionRequestInput, SignPayloadRequestInput, OperationRequestInput, BroadcastRequestInput, PermissionRequestOutput, SignPayloadRequestOutput, OperationRequestOutput, BroadcastRequestOutput, BeaconRequestInputMessage, BeaconRequestOutputMessage, BeaconResponseInputMessage, BeaconResponseOutputMessage, BeaconRequestMessage, BeaconResponseMessage };\n    export { BeaconError, BeaconErrorType, ErrorResponse, AbortedBeaconError, BroadcastBeaconError, NetworkNotSupportedBeaconError, NoAddressBeaconError, NoPrivateKeyBeaconError, NotGrantedBeaconError, ParametersInvalidBeaconError, TooManyOperationsBeaconError, TransactionInvalidBeaconError, SignatureTypeNotSupportedBeaconError, UnknownBeaconError };\n    export { TransportStatus, TransportType, Transport, PostMessageTransport, P2PTransport, WalletP2PTransport, WalletPostMessageTransport, DappP2PTransport, DappPostMessageTransport, MessageBasedClient, Pairing };\n    export { BeaconEvent, BeaconEventHandler, defaultEventCallbacks };\n    export { Storage, StorageKey, StorageKeyReturnDefaults, StorageKeyReturnType, ChromeStorage, LocalStorage, getStorage };\n    export { PeerManager, AccountManager, AppMetadataManager, PermissionManager };\n    export { SDK_VERSION, BEACON_VERSION };\n    export { getSenderId, getAccountIdentifier, getAddressFromPublicKey };\n    export { PeerInfo, ExtendedPeerInfo, PostMessagePairingRequest, ExtendedPostMessagePairingRequest, ExtendedPostMessagePairingResponse, P2PPairingRequest, ExtendedP2PPairingRequest, ExtendedP2PPairingResponse };\n    export { BlockExplorer, TezblockBlockExplorer };\n    export { ConnectionContext, Serializer, availableTransports, ColorMode };\n    export { setDebugEnabled, getDebugEnabled };\n}\n\ndeclare module 'beacon/interceptors/IncomingRequestInterceptor' {\n    import { BeaconRequestOutputMessage } from 'beacon/';\n    import { ConnectionContext } from 'beacon/types/ConnectionContext';\n    import { AppMetadataManager } from 'beacon/managers/AppMetadataManager';\n    import { BeaconRequestMessage } from 'beacon/types/beacon/BeaconRequestMessage';\n    interface IncomingRequestInterceptorOptions {\n        message: BeaconRequestMessage;\n        connectionInfo: ConnectionContext;\n        appMetadataManager: AppMetadataManager;\n        interceptorCallback(message: BeaconRequestOutputMessage, connectionInfo: ConnectionContext): void;\n    }\n    /**\n      * The IncomingRequestInterceptor is used in the WalletClient to intercept an incoming request and enrich it with data, like app metadata.\n      */\n    export class IncomingRequestInterceptor {\n        /**\n          * The method that is called during the interception\n          *\n          * @param config\n          */\n        static intercept(config: IncomingRequestInterceptorOptions): Promise<void>;\n    }\n    export {};\n}\n\ndeclare module 'beacon/interceptors/OutgoingResponseInterceptor' {\n    import { BeaconMessage, BeaconResponseInputMessage, AppMetadata } from 'beacon/';\n    import { PermissionManager } from 'beacon/managers/PermissionManager';\n    import { AppMetadataManager } from 'beacon/managers/AppMetadataManager';\n    import { BeaconRequestMessage } from 'beacon/types/beacon/BeaconRequestMessage';\n    interface OutgoingResponseInterceptorOptions {\n        senderId: string;\n        request: BeaconRequestMessage;\n        message: BeaconResponseInputMessage;\n        ownAppMetadata: AppMetadata;\n        permissionManager: PermissionManager;\n        appMetadataManager: AppMetadataManager;\n        interceptorCallback(message: BeaconMessage): void;\n    }\n    /**\n      * The OutgoingResponseInterceptor is used in the WalletClient to intercept an outgoing response and enrich it with data.\n      */\n    export class OutgoingResponseInterceptor {\n        static intercept(config: OutgoingResponseInterceptorOptions): Promise<void>;\n    }\n    export {};\n}\n\ndeclare module 'beacon/managers/AccountManager' {\n    import { Storage, AccountInfo, BeaconMessage } from 'beacon/';\n    /**\n      * The AccountManager provides CRUD functionality for account entities and persists them to the provided storage.\n      */\n    export class AccountManager {\n        constructor(storage: Storage);\n        getAccounts(): Promise<AccountInfo[]>;\n        getAccount(accountIdentifier: string): Promise<AccountInfo | undefined>;\n        addAccount(accountInfo: AccountInfo): Promise<void>;\n        removeAccount(accountIdentifier: string): Promise<void>;\n        removeAccounts(accountIdentifiers: string[]): Promise<void>;\n        removeAllAccounts(): Promise<void>;\n        hasPermission(message: BeaconMessage): Promise<boolean>;\n    }\n}\n\ndeclare module 'beacon/managers/AppMetadataManager' {\n    import { Storage, AppMetadata } from 'beacon/';\n    /**\n      * The AppMetadataManager provides CRUD functionality for app-metadata entities and persists them to the provided storage.\n      */\n    export class AppMetadataManager {\n        constructor(storage: Storage);\n        getAppMetadataList(): Promise<AppMetadata[]>;\n        getAppMetadata(senderId: string): Promise<AppMetadata | undefined>;\n        addAppMetadata(appMetadata: AppMetadata): Promise<void>;\n        removeAppMetadata(senderId: string): Promise<void>;\n        removeAppMetadatas(senderIds: string[]): Promise<void>;\n        removeAllAppMetadata(): Promise<void>;\n    }\n}\n\ndeclare module 'beacon/managers/PeerManager' {\n    import { Storage, StorageKey, StorageKeyReturnType } from 'beacon/';\n    import { ArrayElem } from 'beacon/managers/StorageManager';\n    /**\n      * The PeerManager provides CRUD functionality for peer entities and persists them to the provided storage.\n      */\n    export class PeerManager<T extends StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET> {\n        constructor(storage: Storage, key: T);\n        hasPeer(publicKey: string): Promise<boolean>;\n        getPeers(): Promise<StorageKeyReturnType[T]>;\n        getPeer(publicKey: string): Promise<ArrayElem<StorageKeyReturnType[T]> | undefined>;\n        addPeer(peerInfo: ArrayElem<StorageKeyReturnType[T]>): Promise<void>;\n        removePeer(publicKey: string): Promise<void>;\n        removePeers(publicKeys: string[]): Promise<void>;\n        removeAllPeers(): Promise<void>;\n    }\n}\n\ndeclare module 'beacon/managers/PermissionManager' {\n    import { BeaconMessage, Storage } from 'beacon/';\n    import { PermissionInfo } from 'beacon/types/PermissionInfo';\n    /**\n      * The PermissionManager provides CRUD functionality for permission entities and persists them to the provided storage.\n      */\n    export class PermissionManager {\n        constructor(storage: Storage);\n        getPermissions(): Promise<PermissionInfo[]>;\n        getPermission(accountIdentifier: string): Promise<PermissionInfo | undefined>;\n        addPermission(permissionInfo: PermissionInfo): Promise<void>;\n        removePermission(accountIdentifier: string): Promise<void>;\n        removePermissions(accountIdentifiers: string[]): Promise<void>;\n        removeAllPermissions(): Promise<void>;\n        hasPermission(message: BeaconMessage): Promise<boolean>;\n    }\n}\n\ndeclare module 'beacon/managers/PermissionValidator' {\n    import { BeaconMessage } from 'beacon/';\n    import { PermissionEntity } from 'beacon/types/PermissionEntity';\n    /**\n      * The PermissionValidator is used to check if permissions for a certain message type have been given\n      */\n    export class PermissionValidator {\n        /**\n          * Check if permissions were given for a certain message type.\n          *\n          * PermissionRequest and BroadcastRequest will always return true.\n          *\n          * @param message Beacon Message\n          */\n        static hasPermission(message: BeaconMessage, getOne: (id: string) => Promise<PermissionEntity | undefined>, getAll: () => Promise<PermissionEntity[]>): Promise<boolean>;\n    }\n}\n\ndeclare module 'beacon/managers/StorageManager' {\n    import { StorageKey, Storage, StorageKeyReturnType } from 'beacon/';\n    /** Type workaround for https://github.com/Microsoft/TypeScript/issues/7294#issuecomment-465794460 */\n    export type ArrayElem<A> = A extends (infer Elem)[] ? Elem : never;\n    /**\n      * The StorageManager provides CRUD functionality for specific entities and persists them to the provided storage.\n      */\n    export class StorageManager<T extends StorageKey.ACCOUNTS | StorageKey.APP_METADATA_LIST | StorageKey.PERMISSION_LIST | StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET> {\n        constructor(storage: Storage, storageKey: T);\n        getAll(): Promise<StorageKeyReturnType[T]>;\n        getOne(predicate: (element: ArrayElem<StorageKeyReturnType[T]>) => boolean): Promise<ArrayElem<StorageKeyReturnType[T]> | undefined>;\n        addOne(element: ArrayElem<StorageKeyReturnType[T]>, predicate: (element: ArrayElem<StorageKeyReturnType[T]>) => boolean, overwrite?: boolean): Promise<void>;\n        remove(predicate: (element: ArrayElem<StorageKeyReturnType[T]>) => boolean): Promise<void>;\n        removeAll(): Promise<void>;\n    }\n}\n\ndeclare module 'beacon/matrix-client/MatrixClient' {\n    import { Storage } from 'beacon/storage/Storage';\n    import { MatrixClientStore } from 'beacon/matrix-client/MatrixClientStore';\n    import { MatrixRoom } from 'beacon/matrix-client/models/MatrixRoom';\n    import { MatrixRoomService } from 'beacon/matrix-client/services/MatrixRoomService';\n    import { MatrixUserService } from 'beacon/matrix-client/services/MatrixUserService';\n    import { MatrixEventService } from 'beacon/matrix-client/services/MatrixEventService';\n    import { MatrixClientEventEmitter } from 'beacon/matrix-client/MatrixClientEventEmitter';\n    import { MatrixClientEventType, MatrixClientEvent } from 'beacon/matrix-client/models/MatrixClientEvent';\n    interface MatrixClientOptions {\n        baseUrl: string;\n        storage: Storage;\n    }\n    interface MatrixLoginConfig {\n        id: string;\n        password: string;\n        deviceId: string;\n    }\n    /**\n      * The matrix client used to connect to the matrix network\n      */\n    export class MatrixClient {\n        /**\n          * Create a matrix client based on the options provided\n          *\n          * @param config\n          */\n        static create(config: MatrixClientOptions): MatrixClient;\n        /**\n          * Return all the rooms we are currently part of\n          */\n        get joinedRooms(): MatrixRoom[];\n        /**\n          * Return all the rooms to which we have received invitations\n          */\n        get invitedRooms(): MatrixRoom[];\n        /**\n          * Return all the rooms that we left\n          */\n        get leftRooms(): MatrixRoom[];\n        constructor(store: MatrixClientStore, eventEmitter: MatrixClientEventEmitter, userService: MatrixUserService, roomService: MatrixRoomService, eventService: MatrixEventService);\n        /**\n          * Initiate the connection to the matrix node and log in\n          *\n          * @param user\n          */\n        start(user: MatrixLoginConfig): Promise<void>;\n        /**\n          * Subscribe to new matrix events\n          *\n          * @param event\n          * @param listener\n          */\n        subscribe<T extends MatrixClientEventType>(event: T, listener: (event: MatrixClientEvent<T>) => void): void;\n        /**\n          * Unsubscribe from matrix events\n          *\n          * @param event\n          * @param listener\n          */\n        unsubscribe(event: MatrixClientEventType, listener?: (event: MatrixClientEvent<any>) => void): void;\n        getRoomById(id: string): MatrixRoom;\n        /**\n          * Create a private room with the supplied members\n          *\n          * @param members Members that will be in the room\n          */\n        createTrustedPrivateRoom(...members: string[]): Promise<string>;\n        /**\n          * Invite user to rooms\n          *\n          * @param user The user to be invited\n          * @param roomsOrIds The rooms the user will be invited to\n          */\n        inviteToRooms(user: string, ...roomsOrIds: string[] | MatrixRoom[]): Promise<void>;\n        /**\n          * Join rooms\n          *\n          * @param roomsOrIds\n          */\n        joinRooms(...roomsOrIds: string[] | MatrixRoom[]): Promise<void>;\n        /**\n          * Send a text message\n          *\n          * @param roomOrId\n          * @param message\n          */\n        sendTextMessage(roomId: string, message: string): Promise<void>;\n    }\n    export {};\n}\n\ndeclare module 'beacon/matrix-client/MatrixClientEventEmitter' {\n    import { EventEmitter } from 'events';\n    import { MatrixStateStore, MatrixStateUpdate } from 'beacon/matrix-client/MatrixClientStore';\n    export class MatrixClientEventEmitter extends EventEmitter {\n        /**\n          * This method is called every time the state is changed\n          *\n          * @param _oldState\n          * @param _newState\n          * @param stateChange\n          */\n        onStateChanged(_oldState: MatrixStateStore, _newState: MatrixStateStore, stateChange: Partial<MatrixStateUpdate>): void;\n    }\n}\n\ndeclare module 'beacon/matrix-client/MatrixClientStore' {\n    import { MatrixRoom } from 'beacon/matrix-client/models/MatrixRoom';\n    import { Storage } from 'beacon/storage/Storage';\n    type OnStateChangedListener = (oldState: MatrixStateStore, newState: MatrixStateStore, stateChange: Partial<MatrixStateUpdate>) => void;\n    export interface MatrixState {\n        isRunning: boolean;\n        userId: string | undefined;\n        deviceId: string | undefined;\n        txnNo: number;\n        accessToken: string | undefined;\n        syncToken: string | undefined;\n        pollingTimeout: number | undefined;\n        pollingRetries: number;\n        rooms: MatrixRoom[] | Record<string, MatrixRoom>;\n    }\n    export interface MatrixStateStore extends MatrixState {\n        rooms: Record<string, MatrixRoom>;\n    }\n    export interface MatrixStateUpdate extends MatrixState {\n        rooms: MatrixRoom[];\n    }\n    /**\n      * The class managing the local state of matrix\n      */\n    export class MatrixClientStore {\n        constructor(storage: Storage);\n        /**\n          * Get an item from the state\n          *\n          * @param key\n          */\n        get<T extends keyof MatrixStateStore>(key: T): MatrixStateStore[T];\n        /**\n          * Get the room from an ID or room instance\n          *\n          * @param roomOrId\n          */\n        getRoom(roomOrId: string | MatrixRoom): MatrixRoom;\n        /**\n          * Update the state with a partial state\n          *\n          * @param stateUpdate\n          */\n        update(stateUpdate: Partial<MatrixStateUpdate>): Promise<void>;\n        /**\n          * Register listeners that are called once the state has changed\n          *\n          * @param listener\n          * @param subscribed\n          */\n        onStateChanged(listener: OnStateChangedListener, ...subscribed: (keyof MatrixState)[]): void;\n    }\n    export {};\n}\n\ndeclare module 'beacon/matrix-client/MatrixHttpClient' {\n    import { MatrixRequest, MatrixRequestParams } from 'beacon/matrix-client/models/api/MatrixRequest';\n    interface HttpOptions {\n        accessToken?: string;\n    }\n    /**\n      * Handling the HTTP connection to the matrix synapse node\n      */\n    export class MatrixHttpClient {\n        constructor(baseUrl: string);\n        /**\n          * Get data from the synapse node\n          *\n          * @param endpoint\n          * @param options\n          */\n        get<T>(endpoint: string, params?: MatrixRequestParams<T>, options?: HttpOptions): Promise<T>;\n        /**\n          * Post data to the synapse node\n          *\n          * @param endpoint\n          * @param body\n          * @param options\n          * @param params\n          */\n        post<T>(endpoint: string, body: MatrixRequest<T>, options?: HttpOptions, params?: MatrixRequestParams<T>): Promise<T>;\n        /**\n          * Put data to the synapse node\n          *\n          * @param endpoint\n          * @param body\n          * @param options\n          * @param params\n          */\n        put<T>(endpoint: string, body: MatrixRequest<T>, options?: HttpOptions, params?: MatrixRequestParams<T>): Promise<T>;\n    }\n    export {};\n}\n\ndeclare module 'beacon/matrix-client/models/api/MatrixEventSend' {\n    export interface MatrixEventSendRequest {\n        content: any;\n    }\n    export interface MatrixEventSendResponse {\n        type?: 'event_send';\n        event_id: string;\n    }\n}\n\ndeclare module 'beacon/matrix-client/models/api/MatrixLogin' {\n    export interface MatrixLoginRequest {\n        type: 'm.login.password';\n        identifier: {\n            type: 'm.id.user';\n            user: string;\n        };\n        password: string;\n        device_id?: string;\n    }\n    export interface MatrixLoginResponse {\n        type?: 'login';\n        user_id: string;\n        device_id: string;\n        access_token: string;\n    }\n}\n\ndeclare module 'beacon/matrix-client/models/api/MatrixRequest' {\n    import { MatrixLoginRequest, MatrixLoginResponse } from 'beacon/matrix-client/models/api/MatrixLogin';\n    import { MatrixRoomCreateRequest, MatrixRoomCreateResponse } from 'beacon/matrix-client/models/api/MatrixRoomCreate';\n    import { MatrixRoomInviteRequest, MatrixRoomInviteResponse } from 'beacon/matrix-client/models/api/MatrixRoomInvite';\n    import { MatrixRoomJoinRequest, MatrixRoomJoinResponse } from 'beacon/matrix-client/models/api/MatrixRoomJoin';\n    import { MatrixEventSendRequest, MatrixEventSendResponse } from 'beacon/matrix-client/models/api/MatrixEventSend';\n    import { MatrixSyncResponse, MatrixSyncRequestParams } from 'beacon/matrix-client/models/api/MatrixSync';\n    export type MatrixRequest<T> = T extends MatrixLoginResponse ? MatrixLoginRequest : T extends MatrixRoomCreateResponse ? MatrixRoomCreateRequest : T extends MatrixRoomInviteResponse ? MatrixRoomInviteRequest : T extends MatrixRoomJoinResponse ? MatrixRoomJoinRequest : T extends MatrixEventSendResponse ? MatrixEventSendRequest : never;\n    export type MatrixRequestParams<T> = T extends MatrixSyncResponse ? MatrixSyncRequestParams : never;\n}\n\ndeclare module 'beacon/matrix-client/models/api/MatrixRoomCreate' {\n    export interface MatrixRoomCreateRequest {\n        visibility?: 'public' | 'private';\n        room_alias_name?: string;\n        name?: string;\n        topic?: string;\n        invite?: string[];\n        preset?: 'private_chat' | 'public_chat' | 'trusted_private_chat';\n        is_direct?: boolean;\n    }\n    export interface MatrixRoomCreateResponse {\n        type?: 'room_create';\n        room_id: string;\n    }\n}\n\ndeclare module 'beacon/matrix-client/models/api/MatrixRoomInvite' {\n    export interface MatrixRoomInviteRequest {\n        user_id: string;\n    }\n    export interface MatrixRoomInviteResponse {\n        type?: 'room_invite';\n    }\n}\n\ndeclare module 'beacon/matrix-client/models/api/MatrixRoomJoin' {\n    export interface MatrixRoomJoinRequest {\n    }\n    export interface MatrixRoomJoinResponse {\n        type?: 'room_join';\n        room_id: string;\n    }\n}\n\ndeclare module 'beacon/matrix-client/models/api/MatrixSync' {\n    import { MatrixStateEvent } from 'beacon/matrix-client/models/MatrixStateEvent';\n    export interface MatrixSyncJoinedRoom {\n        state: {\n            events: MatrixStateEvent[];\n        };\n        timeline: {\n            events: MatrixStateEvent[];\n        };\n    }\n    export interface MatrixSyncInvitedRoom {\n        invite_state: {\n            events: MatrixStateEvent[];\n        };\n    }\n    export interface MatrixSyncLeftRoom {\n        state: {\n            events: MatrixStateEvent[];\n        };\n        timeline: {\n            events: MatrixStateEvent[];\n        };\n    }\n    export interface MatrixSyncRooms {\n        join: {\n            [key: string]: MatrixSyncJoinedRoom;\n        };\n        invite: {\n            [key: string]: MatrixSyncInvitedRoom;\n        };\n        leave: {\n            [key: string]: MatrixSyncLeftRoom;\n        };\n    }\n    export interface MatrixSyncRequestParams {\n        timeout?: number;\n        since?: string;\n    }\n    export interface MatrixSyncResponse {\n        type?: 'sync';\n        next_batch: string;\n        rooms: MatrixSyncRooms;\n    }\n}\n\ndeclare module 'beacon/matrix-client/models/MatrixClientEvent' {\n    import { MatrixMessage } from 'beacon/matrix-client/models/MatrixMessage';\n    export enum MatrixClientEventType {\n        INVITE = \"invite\",\n        MESSAGE = \"message\"\n    }\n    export type MatrixClientEventContent<T> = T extends MatrixClientEventType.INVITE ? MatrixClientEventInviteContent : T extends MatrixClientEventType.MESSAGE ? MatrixClientEventMessageContent<any> : never;\n    export interface MatrixClientEventInviteContent {\n        roomId: string;\n    }\n    export interface MatrixClientEventMessageContent<T> {\n        roomId: string;\n        message: MatrixMessage<T>;\n    }\n    export interface MatrixClientEvent<T extends MatrixClientEventType> {\n        type: T;\n        content: MatrixClientEventContent<T>;\n    }\n}\n\ndeclare module 'beacon/matrix-client/models/MatrixMessage' {\n    import { MatrixStateEvent } from 'beacon/matrix-client/models/MatrixStateEvent';\n    export enum MatrixMessageType {\n        TEXT = \"m.text\"\n    }\n    export class MatrixMessage<T> {\n        readonly type: MatrixMessageType;\n        readonly sender: string;\n        readonly content: T;\n        /**\n          * Construct a message from a message event\n          *\n          * @param event\n          */\n        static from(event: MatrixStateEvent): MatrixMessage<any> | undefined;\n    }\n}\n\ndeclare module 'beacon/matrix-client/models/MatrixRoom' {\n    import { MatrixSyncRooms } from 'beacon/matrix-client/models/api/MatrixSync';\n    import { MatrixMessage } from 'beacon/matrix-client/models/MatrixMessage';\n    export enum MatrixRoomStatus {\n        UNKNOWN = 0,\n        JOINED = 1,\n        INVITED = 2,\n        LEFT = 3\n    }\n    export class MatrixRoom {\n        readonly id: string;\n        readonly status: MatrixRoomStatus;\n        readonly members: string[];\n        messages: MatrixMessage<any>[];\n        /**\n          * Reconstruct rooms from a sync response\n          *\n          * @param roomSync\n          */\n        static fromSync(roomSync: MatrixSyncRooms): MatrixRoom[];\n        /**\n          * Reconstruct a room from an ID or object\n          *\n          * @param roomOrId\n          * @param status\n          */\n        static from(roomOrId: string | MatrixRoom, status?: MatrixRoomStatus): MatrixRoom;\n        /**\n          * Merge new and old state and remove duplicates\n          *\n          * @param newState\n          * @param previousState\n          */\n        static merge(newState: MatrixRoom, previousState?: MatrixRoom): MatrixRoom;\n    }\n}\n\ndeclare module 'beacon/matrix-client/models/MatrixStateEvent' {\n    import { MatrixMessageType } from 'beacon/matrix-client/models/MatrixMessage';\n    export interface MatrixStateEventMessageText extends MatrixStateEventMessage {\n        type: 'm.room.message';\n        content: {\n            msgtype: MatrixMessageType.TEXT;\n            body: string;\n        };\n    }\n    export interface MatrixStateEventMessageContent {\n        msgtype: string;\n        body: any;\n        [key: string]: any;\n    }\n    export interface MatrixStateEventMessage extends MatrixStateEvent {\n        type: 'm.room.message';\n        content: MatrixStateEventMessageContent;\n    }\n    export interface MatrixStateEvent {\n        type: string;\n        sender: string;\n        content: unknown;\n        event_id?: string;\n    }\n}\n\ndeclare module 'beacon/matrix-client/services/MatrixEventService' {\n    import { MatrixHttpClient } from 'beacon/matrix-client/MatrixHttpClient';\n    import { MatrixEventSendResponse } from 'beacon/matrix-client/models/api/MatrixEventSend';\n    import { MatrixSyncResponse } from 'beacon/matrix-client/models/api/MatrixSync';\n    import { MatrixStateEventMessageContent } from 'beacon/matrix-client/models/MatrixStateEvent';\n    interface MatrixScheduledEvent<T> {\n        accessToken: string;\n        roomId: string;\n        type: MatrixEventType;\n        content: any;\n        txnId: string;\n        onSuccess(response: T): void;\n        onError(error: unknown): void;\n    }\n    type MatrixEventType = 'm.room.message';\n    export interface MatrixSyncOptions {\n        syncToken?: string;\n        pollingTimeout?: number;\n    }\n    /**\n      * A service to help with matrix event management\n      */\n    export class MatrixEventService {\n        constructor(httpClient: MatrixHttpClient);\n        /**\n          * Get the latest state from the matrix node\n          *\n          * @param accessToken\n          * @param options\n          */\n        sync(accessToken: string, options?: MatrixSyncOptions): Promise<MatrixSyncResponse>;\n        /**\n          * Send a message to a room\n          *\n          * @param accessToken\n          * @param room\n          * @param content\n          * @param txnId\n          */\n        sendMessage(accessToken: string, roomId: string, content: MatrixStateEventMessageContent, txnId: string): Promise<MatrixEventSendResponse>;\n        /**\n          * Schedules an event to be sent to the node\n          *\n          * @param event\n          */\n        scheduleEvent(event: MatrixScheduledEvent<any>): void;\n        /**\n          * Send an event to the matrix node\n          *\n          * @param scheduledEvent\n          */\n        sendEvent(scheduledEvent: MatrixScheduledEvent<any>): Promise<void>;\n    }\n    export {};\n}\n\ndeclare module 'beacon/matrix-client/services/MatrixRoomService' {\n    import { MatrixHttpClient } from 'beacon/matrix-client/MatrixHttpClient';\n    import { MatrixRoom } from 'beacon/matrix-client/models/MatrixRoom';\n    import { MatrixRoomCreateRequest, MatrixRoomCreateResponse } from 'beacon/matrix-client/models/api/MatrixRoomCreate';\n    import { MatrixRoomInviteResponse } from 'beacon/matrix-client/models/api/MatrixRoomInvite';\n    import { MatrixRoomJoinResponse } from 'beacon/matrix-client/models/api/MatrixRoomJoin';\n    /**\n      * A service to help with matrix room management\n      */\n    export class MatrixRoomService {\n        constructor(httpClient: MatrixHttpClient);\n        /**\n          * Create a room\n          *\n          * @param accessToken\n          * @param config\n          */\n        createRoom(accessToken: string, config?: MatrixRoomCreateRequest): Promise<MatrixRoomCreateResponse>;\n        /**\n          * Invite a user to a room\n          *\n          * @param accessToken\n          * @param user\n          * @param room\n          */\n        inviteToRoom(accessToken: string, user: string, room: MatrixRoom): Promise<MatrixRoomInviteResponse>;\n        /**\n          * Join a specific room\n          *\n          * @param accessToken\n          * @param room\n          */\n        joinRoom(accessToken: string, room: MatrixRoom): Promise<MatrixRoomJoinResponse>;\n        /**\n          * Get all joined rooms\n          *\n          * @param accessToken\n          */\n        getJoinedRooms(accessToken: string): Promise<MatrixRoomJoinResponse>;\n    }\n}\n\ndeclare module 'beacon/matrix-client/services/MatrixUserService' {\n    import { MatrixHttpClient } from 'beacon/matrix-client/MatrixHttpClient';\n    import { MatrixLoginResponse } from 'beacon/matrix-client/models/api/MatrixLogin';\n    export class MatrixUserService {\n        constructor(httpClient: MatrixHttpClient);\n        /**\n          * Log in to the matrix node with username and password\n          *\n          * @param user\n          * @param password\n          * @param deviceId\n          */\n        login(user: string, password: string, deviceId: string): Promise<MatrixLoginResponse>;\n    }\n}\n\ndeclare module 'beacon/matrix-client/utils/events' {\n    import { MatrixStateEvent, MatrixStateEventMessageText } from 'beacon/matrix-client/models/MatrixStateEvent';\n    /**\n      * Check if an event is a create event\n      *\n      * @param event MatrixStateEvent\n      */\n    export const isCreateEvent: (event: MatrixStateEvent) => boolean;\n    /**\n      * Check if an event is a join event\n      *\n      * @param event MatrixStateEvent\n      */\n    export const isJoinEvent: (event: MatrixStateEvent) => boolean;\n    /**\n      * Check if an event is a message event\n      *\n      * @param event MatrixStateEvent\n      */\n    export const isMessageEvent: (event: MatrixStateEvent) => boolean;\n    /**\n      * Check if an event is a text message event\n      *\n      * @param event MatrixStateEvent\n      */\n    export const isTextMessageEvent: (event: MatrixStateEvent) => event is MatrixStateEventMessageText;\n}\n\ndeclare module 'beacon/migrations/migrate-0.7.0' {\n    import { PermissionScope, AccountIdentifier, Origin, Network } from 'beacon/';\n    export interface AccountInfoOld {\n        accountIdentifier: AccountIdentifier;\n        beaconId: string;\n        origin: {\n            type: Origin;\n            id: string;\n        };\n        address: string;\n        pubkey: string;\n        network: Network;\n        scopes: PermissionScope[];\n        connectedAt: Date;\n    }\n    export interface P2PPairingRequestOld {\n        name: string;\n        pubKey: string;\n        relayServer: string;\n    }\n    export const migrate_0_7_0: (storage: Storage) => Promise<void>;\n}\n\ndeclare module 'beacon/migrations/migrations' {\n    import { Storage } from 'beacon/';\n    export const migrate: (storage: Storage) => Promise<void>;\n}\n\ndeclare module 'beacon/MockWindow' {\n    type Callback = (message: unknown) => void;\n    /**\n      * A mock for postmessage if run in node.js environment\n      */\n    let windowRef: {\n        postMessage: (message: string | Record<string, unknown>, _target?: string | undefined) => void;\n        addEventListener: (_name: string, eventCallback: Callback) => void;\n        removeEventListener: (_name: string, eventCallback: Callback) => void;\n        location: {\n            origin: string;\n        };\n    };\n    const clearMockWindowState: () => void;\n    export { windowRef, clearMockWindowState };\n}\n\ndeclare module 'beacon/scripts/index' {\n    \n    export * from 'test/beacon-message-events';\n    export * from 'test/clients/beacon-client/BeaconClient';\n    export * from 'test/clients/beacon-client/BeaconClientOptions';\n    export * from 'test/clients/client/Client';\n    export * from 'test/clients/client/ClientOptions';\n    export * from 'test/clients/dapp-client/DAppClient';\n    export * from 'test/clients/dapp-client/DAppClientOptions';\n    export * from 'test/clients/wallet-client/WalletClient';\n    export * from 'test/clients/wallet-client/WalletClientOptions';\n    export * from 'test/colorMode';\n    export * from 'test/constants';\n    export * from 'test/debug';\n    export * from 'test/errors/AbortedBeaconError';\n    export * from 'test/errors/BeaconError';\n    export * from 'test/errors/BroadcastBeaconError';\n    export * from 'test/errors/NetworkNotSupportedBeaconError';\n    export * from 'test/errors/NoAddressBeaconError';\n    export * from 'test/errors/NoPrivateKeyBeaconError';\n    export * from 'test/errors/NotGrantedBeaconError';\n    export * from 'test/errors/ParametersInvalidBeaconError';\n    export * from 'test/errors/SignatureTypeNotSupportedBeaconError';\n    export * from 'test/errors/TooManyOperationsBeaconError';\n    export * from 'test/errors/TransactionInvalidBeaconError';\n    export * from 'test/errors/UnknownBeaconError';\n    export * from 'test/events';\n    export * from 'test/examples/broadcast-request';\n    export * from 'test/examples/custom-block-explorer';\n    export * from 'test/examples/disable-all-ui';\n    export * from 'test/examples/operation-request';\n    export * from 'test/examples/override-default-events';\n    export * from 'test/examples/permission-request';\n    export * from 'test/examples/sign-payload-request';\n    export * from 'test/examples/using-custom-network';\n    export * from 'test/examples/wallet-example';\n    export * from 'test/index';\n    export * from 'test/interceptors/IncomingRequestInterceptor';\n    export * from 'test/interceptors/OutgoingResponseInterceptor';\n    export * from 'test/managers/AccountManager';\n    export * from 'test/managers/AppMetadataManager';\n    export * from 'test/managers/PeerManager';\n    export * from 'test/managers/PermissionManager';\n    export * from 'test/managers/PermissionValidator';\n    export * from 'test/managers/StorageManager';\n    export * from 'test/matrix-client/MatrixClient';\n    export * from 'test/matrix-client/MatrixClientEventEmitter';\n    export * from 'test/matrix-client/MatrixClientStore';\n    export * from 'test/matrix-client/MatrixHttpClient';\n    export * from 'test/matrix-client/models/api/MatrixEventSend';\n    export * from 'test/matrix-client/models/api/MatrixLogin';\n    export * from 'test/matrix-client/models/api/MatrixRequest';\n    export * from 'test/matrix-client/models/api/MatrixRoomCreate';\n    export * from 'test/matrix-client/models/api/MatrixRoomInvite';\n    export * from 'test/matrix-client/models/api/MatrixRoomJoin';\n    export * from 'test/matrix-client/models/api/MatrixSync';\n    export * from 'test/matrix-client/models/MatrixClientEvent';\n    export * from 'test/matrix-client/models/MatrixMessage';\n    export * from 'test/matrix-client/models/MatrixRoom';\n    export * from 'test/matrix-client/models/MatrixStateEvent';\n    export * from 'test/matrix-client/services/MatrixEventService';\n    export * from 'test/matrix-client/services/MatrixRoomService';\n    export * from 'test/matrix-client/services/MatrixUserService';\n    export * from 'test/matrix-client/utils/events';\n    export * from 'test/migrations/migrate-0.7.0';\n    export * from 'test/migrations/migrations';\n    export * from 'test/MockWindow';\n    export * from 'test/Serializer';\n    export * from 'test/storage/ChromeStorage';\n    export * from 'test/storage/getStorage';\n    export * from 'test/storage/LocalStorage';\n    export * from 'test/storage/Storage';\n    export * from 'test/test';\n    export * from 'test/transports/clients/CommunicationClient';\n    export * from 'test/transports/clients/MessageBasedClient';\n    export * from 'test/transports/clients/P2PCommunicationClient';\n    export * from 'test/transports/clients/PostMessageClient';\n    export * from 'test/transports/DappP2PTransport';\n    export * from 'test/transports/DappPostMessageTransport';\n    export * from 'test/transports/P2PTransport';\n    export * from 'test/transports/PostMessageTransport';\n    export * from 'test/transports/Transport';\n    export * from 'test/transports/WalletP2PTransport';\n    export * from 'test/transports/WalletPostMessageTransport';\n    export * from 'test/types/AccountInfo';\n    export * from 'test/types/beacon/AppMetadata';\n    export * from 'test/types/beacon/BeaconBaseMessage';\n    export * from 'test/types/beacon/BeaconMessage';\n    export * from 'test/types/beacon/BeaconMessageType';\n    export * from 'test/types/beacon/BeaconRequestMessage';\n    export * from 'test/types/beacon/BeaconResponseMessage';\n    export * from 'test/types/beacon/messages/AcknowledgeResponse';\n    export * from 'test/types/beacon/messages/BeaconRequestInputMessage';\n    export * from 'test/types/beacon/messages/BeaconRequestOutputMessage';\n    export * from 'test/types/beacon/messages/BeaconResponseInputMessage';\n    export * from 'test/types/beacon/messages/BeaconResponseOutputMessage';\n    export * from 'test/types/beacon/messages/BroadcastRequest';\n    export * from 'test/types/beacon/messages/BroadcastResponse';\n    export * from 'test/types/beacon/messages/DisconnectMessage';\n    export * from 'test/types/beacon/messages/ErrorResponse';\n    export * from 'test/types/beacon/messages/OperationRequest';\n    export * from 'test/types/beacon/messages/OperationResponse';\n    export * from 'test/types/beacon/messages/PermissionRequest';\n    export * from 'test/types/beacon/messages/PermissionResponse';\n    export * from 'test/types/beacon/messages/SignPayloadRequest';\n    export * from 'test/types/beacon/messages/SignPayloadResponse';\n    export * from 'test/types/beacon/Network';\n    export * from 'test/types/beacon/NetworkType';\n    export * from 'test/types/beacon/PermissionScope';\n    export * from 'test/types/beacon/SigningType';\n    export * from 'test/types/beacon/Threshold';\n    export * from 'test/types/BeaconErrorType';\n    export * from 'test/types/ColorMode';\n    export * from 'test/types/ConnectionContext';\n    export * from 'test/types/Extension';\n    export * from 'test/types/ExtensionMessage';\n    export * from 'test/types/ExtensionMessageTarget';\n    export * from 'test/types/Origin';\n    export * from 'test/types/P2PPairingRequest';\n    export * from 'test/types/P2PPairingResponse';\n    export * from 'test/types/PeerInfo';\n    export * from 'test/types/PermissionEntity';\n    export * from 'test/types/PermissionInfo';\n    export * from 'test/types/PostMessagePairingRequest';\n    export * from 'test/types/PostMessagePairingResponse';\n    export * from 'test/types/RequestBroadcastInput';\n    export * from 'test/types/RequestOperationInput';\n    export * from 'test/types/RequestPermissionInput';\n    export * from 'test/types/RequestSignPayloadInput';\n    export * from 'test/types/storage/StorageKey';\n    export * from 'test/types/storage/StorageKeyReturnDefaults';\n    export * from 'test/types/storage/StorageKeyReturnType';\n    export * from 'test/types/tezos/MichelineMichelsonV1Expression';\n    export * from 'test/types/tezos/MichelsonPrimitives';\n    export * from 'test/types/tezos/operations/ActivateAccount';\n    export * from 'test/types/tezos/operations/Ballot';\n    export * from 'test/types/tezos/operations/Delegation';\n    export * from 'test/types/tezos/operations/DoubleBakingEvidence';\n    export * from 'test/types/tezos/operations/DoubleEndorsementEvidence';\n    export * from 'test/types/tezos/operations/Endorsement';\n    export * from 'test/types/tezos/operations/Origination';\n    export * from 'test/types/tezos/operations/Proposal';\n    export * from 'test/types/tezos/operations/Reveal';\n    export * from 'test/types/tezos/operations/SeedNonceRevelation';\n    export * from 'test/types/tezos/operations/Transaction';\n    export * from 'test/types/tezos/OperationTypes';\n    export * from 'test/types/tezos/PartialTezosOperation';\n    export * from 'test/types/tezos/TezosBaseOperation';\n    export * from 'test/types/tezos/TezosBlockHeader';\n    export * from 'test/types/tezos/TezosOperation';\n    export * from 'test/types/tezos/TezosTransactionParameters';\n    export * from 'test/types/transport/TransportStatus';\n    export * from 'test/types/transport/TransportType';\n    export * from 'test/ui/alert/alert-templates';\n    export * from 'test/ui/alert/Alert';\n    export * from 'test/ui/alert/Pairing';\n    export * from 'test/ui/alert/PairingAlert';\n    export * from 'test/ui/alert/wallet-lists';\n    export * from 'test/ui/toast/toast-templates';\n    export * from 'test/ui/toast/Toast';\n    export * from 'test/utils/assert-never';\n    export * from 'test/utils/available-transports';\n    export * from 'test/utils/block-explorer';\n    export * from 'test/utils/crypto';\n    export * from 'test/utils/exposed-promise';\n    export * from 'test/utils/generate-uuid';\n    export * from 'test/utils/get-account-identifier';\n    export * from 'test/utils/get-sender-id';\n    export * from 'test/utils/get-tzip10-link';\n    export * from 'test/utils/Logger';\n    export * from 'test/utils/platform';\n    export * from 'test/utils/qr';\n    export * from 'test/utils/replace-in-template';\n    export * from 'test/utils/shorten-string';\n    export * from 'test/utils/tezblock-blockexplorer';\n    export * from 'test/utils/utils';\n    \n    module 'test/beacon-message-events' {\n        import { BeaconEvent } from 'test/events';\n        import { BeaconMessageType } from 'test/';\n        export const messageEvents: {\n            [key in BeaconMessageType]: {\n                sent: BeaconEvent;\n                success: BeaconEvent;\n                error: BeaconEvent;\n            };\n        };\n    }\n    \n    module 'test/clients/beacon-client/BeaconClient' {\n        import * as sodium from 'libsodium-wrappers';\n        import { ExposedPromise } from 'test/utils/exposed-promise';\n        import { Storage } from 'test/';\n        import { BeaconEventHandler } from 'test/events';\n        import { BeaconClientOptions } from 'test/clients/beacon-client/BeaconClientOptions';\n        /**\n             * The beacon client is an abstract client that handles everything that is shared between all other clients.\n             * Specifically, it handles managing the beaconId and and the local keypair.\n             */\n        export abstract class BeaconClient {\n                /**\n                     * The name of the client\n                     */\n                readonly name: string;\n                /**\n                     * The URL of the dApp Icon. This can be used to display the icon of the dApp on in the wallet\n                     */\n                readonly iconUrl?: string;\n                /**\n                     * The URL of the dApp.\n                     */\n                readonly appUrl?: string;\n                /** The beaconId is a public key that is used to identify one specific application (dapp or wallet).\n                     * This is used inside a message to specify the sender, for example.\n                     */\n                protected _beaconId: ExposedPromise<string>;\n                get beaconId(): Promise<string>;\n                protected storage: Storage;\n                protected readonly events: BeaconEventHandler;\n                /**\n                     * The local keypair that is used for the communication encryption\n                     */\n                protected _keyPair: ExposedPromise<sodium.KeyPair>;\n                protected get keyPair(): Promise<sodium.KeyPair>;\n                constructor(config: BeaconClientOptions);\n                /**\n                     * This resets the SDK. After using this method, this instance is no longer usable. You will have to instanciate a new client.\n                     */\n                destroy(): Promise<void>;\n        }\n    }\n    \n    module 'test/clients/beacon-client/BeaconClientOptions' {\n        import { Storage } from 'test/';\n        export interface BeaconClientOptions {\n                /**\n                     * Name of the application\n                     */\n                name: string;\n                /**\n                     * A URL to the icon of the application\n                     */\n                iconUrl?: string;\n                /**\n                     * A URL to the website of the application\n                     */\n                appUrl?: string;\n                /**\n                     * The storage that will be used by the SDK\n                     */\n                storage: Storage;\n        }\n    }\n    \n    module 'test/clients/client/Client' {\n        import { ExposedPromise } from 'test/utils/exposed-promise';\n        import { ConnectionContext } from 'test/types/ConnectionContext';\n        import { TransportType, TransportStatus, AccountInfo, PeerInfo, Transport, AppMetadata } from 'test/';\n        import { BeaconEventHandler } from 'test/events';\n        import { BeaconClient } from 'test/clients/beacon-client/BeaconClient';\n        import { AccountManager } from 'test/managers/AccountManager';\n        import { BeaconRequestMessage } from 'test/types/beacon/BeaconRequestMessage';\n        import { ClientOptions } from 'test/clients/client/ClientOptions';\n        /**\n             * This abstract class handles the a big part of the logic that is shared between the dapp and wallet client.\n             * For example, it selects and manages the transport and accounts.\n             */\n        export abstract class Client extends BeaconClient {\n                protected readonly accountManager: AccountManager;\n                protected handleResponse: (_event: BeaconRequestMessage, connectionInfo: ConnectionContext) => void;\n                /**\n                     * How many requests can be sent after another\n                     */\n                protected readonly rateLimit: number;\n                /**\n                     * The time window in seconds in which the \"rateLimit\" is checked\n                     */\n                protected readonly rateLimitWindowInSeconds: number;\n                /**\n                     * Stores the times when requests have been made to determine if the rate limit has been reached\n                     */\n                protected requestCounter: number[];\n                protected readonly events: BeaconEventHandler;\n                protected readonly matrixNodes: string[];\n                protected _transport: ExposedPromise<Transport<any>>;\n                protected get transport(): Promise<Transport<any>>;\n                /**\n                     * Returns the connection status of the Client\n                     */\n                get connectionStatus(): TransportStatus;\n                /**\n                     * Returns whether or not the transaport is ready\n                     */\n                get ready(): Promise<void>;\n                constructor(config: ClientOptions);\n                /**\n                     * Return all locally known accounts\n                     */\n                getAccounts(): Promise<AccountInfo[]>;\n                /**\n                     * Return the account by ID\n                     * @param accountIdentifier The ID of an account\n                     */\n                getAccount(accountIdentifier: string): Promise<AccountInfo | undefined>;\n                /**\n                     * Remove the account by ID\n                     * @param accountIdentifier The ID of an account\n                     */\n                removeAccount(accountIdentifier: string): Promise<void>;\n                /**\n                     * Remove all locally stored accounts\n                     */\n                removeAllAccounts(): Promise<void>;\n                /**\n                     * Add a new request (current timestamp) to the pending requests, remove old ones and check if we are above the limit\n                     */\n                addRequestAndCheckIfRateLimited(): Promise<boolean>;\n                /**\n                     * This method initializes the client. It will check if the connection should be established to a\n                     * browser extension or if the P2P transport should be used.\n                     *\n                     * @param transport A transport that can be provided by the user\n                     */\n                init(transport: Transport<any>): Promise<TransportType>;\n                /**\n                     * Returns the metadata of this DApp\n                     */\n                getOwnAppMetadata(): Promise<AppMetadata>;\n                /**\n                     * Return all known peers\n                     */\n                getPeers(): Promise<PeerInfo[]>;\n                /**\n                     * Add a new peer to the known peers\n                     * @param peer The new peer to add\n                     */\n                addPeer(peer: PeerInfo): Promise<void>;\n                /**\n                     * A \"setter\" for when the transport needs to be changed.\n                     */\n                protected setTransport(transport?: Transport<any>): Promise<void>;\n                protected addListener(transport: Transport<any>): Promise<void>;\n                protected sendDisconnectToPeer(peer: PeerInfo, transport?: Transport<any>): Promise<void>;\n        }\n    }\n    \n    module 'test/clients/client/ClientOptions' {\n        import { Storage } from 'test/';\n        import { BeaconEvent, BeaconEventHandlerFunction, BeaconEventType } from 'test/events';\n        export interface ClientOptions {\n                /**\n                     * Name of the application\n                     */\n                name: string;\n                /**\n                     * A URL to the icon of the application\n                     */\n                iconUrl?: string;\n                /**\n                     * A URL to the website of the application\n                     */\n                appUrl?: string;\n                /**\n                     * The storage that will be used by the SDK\n                     */\n                storage: Storage;\n                /**\n                     * An object that will be used to overwrite default event handler behaviour.\n                     *\n                     * If you plan to overwrite all default events, use \"disableDefaultEvents\" instead.\n                     *\n                     * This will overwrite the default event handler, so this can lead to unexpected behavior in some cases.\n                     * We recommend that you overwrite all handlers if you want to use your own UI.\n                     *\n                     * If you simply want to be notified of events happening, but do not want to overwrite the default behavior,\n                     * please use `subscribeToEvent()` on the DAppClient instead.\n                     */\n                eventHandlers?: {\n                        [key in BeaconEvent]?: {\n                                handler: BeaconEventHandlerFunction<BeaconEventType[key]>;\n                        };\n                };\n                /**\n                     * Disable all default Events and UI elements. If passed together with \"eventHandlers\",\n                     * the default eventHandlers will be removed, and the ones passed by the user will be added.\n                     */\n                disableDefaultEvents?: boolean;\n                /**\n                     * A list of matrix nodes to connect to. If a non-empty array is passed, the default options will be overwritten.\n                     * One node will be randomly selected based on the local keypair and the other nodes will be used as a fallback in case the primary node goes down.\n                     *\n                     * Only provide the hostname, no https:// prefix. Eg. ['matrix.example.com']\n                     */\n                matrixNodes?: string[];\n        }\n    }\n    \n    module 'test/clients/dapp-client/DAppClient' {\n        import { BeaconEvent, BeaconEventHandlerFunction, BeaconEventType } from 'test/events';\n        import { AccountInfo, Client, TransportType, BeaconMessageType, NetworkType, RequestPermissionInput, RequestSignPayloadInput, RequestOperationInput, RequestBroadcastInput, PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, Transport, DappP2PTransport, DappPostMessageTransport, AppMetadata } from 'test/';\n        import { BlockExplorer } from 'test/utils/block-explorer';\n        import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n        import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n        import { ExtendedPeerInfo } from 'test/types/PeerInfo';\n        import { ColorMode } from 'test/types/ColorMode';\n        import { DAppClientOptions } from 'test/clients/dapp-client/DAppClientOptions';\n        /**\n             * The DAppClient has to be used in decentralized applications. It handles all the logic related to connecting to beacon-compatible\n             * wallets and sending requests.\n             */\n        export class DAppClient extends Client {\n                /**\n                     * The block explorer used by the SDK\n                     */\n                readonly blockExplorer: BlockExplorer;\n                preferredNetwork: NetworkType;\n                protected postMessageTransport: DappPostMessageTransport | undefined;\n                protected p2pTransport: DappP2PTransport | undefined;\n                constructor(config: DAppClientOptions);\n                initInternalTransports(): Promise<void>;\n                init(transport?: Transport<any>): Promise<TransportType>;\n                /**\n                     * Returns the active account\n                     */\n                getActiveAccount(): Promise<AccountInfo | undefined>;\n                /**\n                     * Sets the active account\n                     *\n                     * @param account The account that will be set as the active account\n                     */\n                setActiveAccount(account?: AccountInfo): Promise<void>;\n                /**\n                     * Clear the active account\n                     */\n                clearActiveAccount(): Promise<void>;\n                setColorMode(colorMode: ColorMode): Promise<void>;\n                getColorMode(): Promise<ColorMode>;\n                /**\n                     * @deprecated\n                     *\n                     * Use getOwnAppMetadata instead\n                     */\n                getAppMetadata(): Promise<AppMetadata>;\n                /**\n                     * Will remove the account from the local storage and set a new active account if necessary.\n                     *\n                     * @param accountIdentifier ID of the account\n                     */\n                removeAccount(accountIdentifier: string): Promise<void>;\n                /**\n                     * Remove all accounts and set active account to undefined\n                     */\n                removeAllAccounts(): Promise<void>;\n                /**\n                     * Removes a peer and all the accounts that have been connected through that peer\n                     *\n                     * @param peer Peer to be removed\n                     */\n                removePeer(peer: ExtendedPeerInfo, sendDisconnectToPeer?: boolean): Promise<void>;\n                /**\n                     * Remove all peers and all accounts that have been connected through those peers\n                     */\n                removeAllPeers(sendDisconnectToPeers?: boolean): Promise<void>;\n                /**\n                     * Allows the user to subscribe to specific events that are fired in the SDK\n                     *\n                     * @param internalEvent The event to subscribe to\n                     * @param eventCallback The callback that will be called when the event occurs\n                     */\n                subscribeToEvent<K extends BeaconEvent>(internalEvent: K, eventCallback: BeaconEventHandlerFunction<BeaconEventType[K]>): Promise<void>;\n                /**\n                     * Check if we have permissions to send the specific message type to the active account.\n                     * If no active account is set, only permission requests are allowed.\n                     *\n                     * @param type The type of the message\n                     */\n                checkPermissions(type: BeaconMessageType): Promise<boolean>;\n                /**\n                     * Send a permission request to the DApp. This should be done as the first step. The wallet will respond\n                     * with an publicKey and permissions that were given. The account returned will be set as the \"activeAccount\"\n                     * and will be used for the following requests.\n                     *\n                     * @param input The message details we need to prepare the PermissionRequest message.\n                     */\n                requestPermissions(input?: RequestPermissionInput): Promise<PermissionResponseOutput>;\n                /**\n                     * This method will send a \"SignPayloadRequest\" to the wallet. This method is meant to be used to sign\n                     * arbitrary data (eg. a string). It will return the signature in the format of \"edsig...\"\n                     *\n                     * @param input The message details we need to prepare the SignPayloadRequest message.\n                     */\n                requestSignPayload(input: RequestSignPayloadInput): Promise<SignPayloadResponseOutput>;\n                /**\n                     * This method sends an OperationRequest to the wallet. This method should be used for all kinds of operations,\n                     * eg. transaction or delegation. Not all properties have to be provided. Data like \"counter\" and fees will be\n                     * fetched and calculated by the wallet (but they can still be provided if required).\n                     *\n                     * @param input The message details we need to prepare the OperationRequest message.\n                     */\n                requestOperation(input: RequestOperationInput): Promise<OperationResponseOutput>;\n                /**\n                     * Sends a \"BroadcastRequest\" to the wallet. This method can be used to inject an already signed transaction\n                     * to the network.\n                     *\n                     * @param input The message details we need to prepare the BroadcastRequest message.\n                     */\n                requestBroadcast(input: RequestBroadcastInput): Promise<BroadcastResponseOutput>;\n                protected setActivePeer(peer?: ExtendedPostMessagePairingResponse | ExtendedP2PPairingResponse): Promise<void>;\n                /**\n                     * A \"setter\" for when the transport needs to be changed.\n                     */\n                protected setTransport(transport?: Transport<any>): Promise<void>;\n        }\n    }\n    \n    module 'test/clients/dapp-client/DAppClientOptions' {\n        import { NetworkType, Storage } from 'test/';\n        import { BeaconEvent, BeaconEventType, BeaconEventHandlerFunction } from 'test/events';\n        import { ColorMode } from 'test/types/ColorMode';\n        import { BlockExplorer } from 'test/utils/block-explorer';\n        export interface DAppClientOptions {\n                /**\n                     * Name of the application\n                     */\n                name: string;\n                /**\n                     * A URL to the icon of the application\n                     */\n                iconUrl?: string;\n                /**\n                     * A URL to the website of the application\n                     */\n                appUrl?: string;\n                /**\n                     * The storage that will be used by the SDK\n                     */\n                storage?: Storage;\n                /**\n                     * An object that will be used to overwrite default event handler behaviour.\n                     *\n                     * If you plan to overwrite all default events, use \"disableDefaultEvents\" instead.\n                     *\n                     * This will overwrite the default event handler, so this can lead to unexpected behavior in some cases.\n                     * We recommend that you overwrite all handlers if you want to use your own UI.\n                     *\n                     * If you simply want to be notified of events happening, but do not want to overwrite the default behavior,\n                     * please use `subscribeToEvent()` on the DAppClient instead.\n                     */\n                eventHandlers?: {\n                        [key in BeaconEvent]?: {\n                                handler: BeaconEventHandlerFunction<BeaconEventType[key]>;\n                        };\n                };\n                /**\n                     * Disable all default Events and UI elements. If passed together with \"eventHandlers\",\n                     * the default eventHandlers will be removed, and the ones passed by the user will be added.\n                     */\n                disableDefaultEvents?: boolean;\n                /**\n                     * A list of matrix nodes to connect to. If a non-empty array is passed, the default options will be overwritten.\n                     * One node will be randomly selected based on the local keypair and the other nodes will be used as a fallback in case the primary node goes down.\n                     *\n                     * Only provide the hostname, no https:// prefix. Eg. ['matrix.example.com']\n                     */\n                matrixNodes?: string[];\n                /**\n                     * The block explorer used by the SDK\n                     */\n                blockExplorer?: BlockExplorer;\n                /**\n                     * Indicates on which network the DApp is planning to run. This is currently used to adjust the URLs of web-wallets in the pairing alert if they use different URLs for testnets.\n                     * You will still have to define the network you intend to use during the permission request.\n                     */\n                preferredNetwork?: NetworkType;\n                /**\n                     * Set the color mode for the UI elements (alerts and toasts)\n                     */\n                colorMode?: ColorMode;\n        }\n    }\n    \n    module 'test/clients/wallet-client/WalletClient' {\n        import { Client, WalletClientOptions, TransportType, BeaconRequestOutputMessage, BeaconResponseInputMessage, AppMetadata, PermissionInfo } from 'test/';\n        import { ConnectionContext } from 'test/types/ConnectionContext';\n        import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n        import { ExposedPromise } from 'test/utils/exposed-promise';\n        import { PeerInfo } from 'test/types/PeerInfo';\n        /**\n             * The WalletClient has to be used in the wallet. It handles all the logic related to connecting to beacon-compatible\n             * dapps and handling/responding to requests.\n             */\n        export class WalletClient extends Client {\n                /**\n                     * Returns whether or not the transport is connected\n                     */\n                protected readonly _isConnected: ExposedPromise<boolean>;\n                get isConnected(): Promise<boolean>;\n                constructor(config: WalletClientOptions);\n                init(): Promise<TransportType>;\n                /**\n                     * This method initiates a connection to the P2P network and registers a callback that will be called\n                     * whenever a message is received.\n                     *\n                     * @param newMessageCallback The callback that will be invoked for every message the transport receives.\n                     */\n                connect(newMessageCallback: (message: BeaconRequestOutputMessage, connectionContext: ConnectionContext) => void): Promise<void>;\n                /**\n                     * The method will attempt to initiate a connection using the active transport.\n                     */\n                _connect(): Promise<void>;\n                /**\n                     * This method sends a response for a specific request back to the DApp\n                     *\n                     * @param message The BeaconResponseMessage that will be sent back to the DApp\n                     */\n                respond(message: BeaconResponseInputMessage): Promise<void>;\n                getAppMetadataList(): Promise<AppMetadata[]>;\n                getAppMetadata(senderId: string): Promise<AppMetadata | undefined>;\n                removeAppMetadata(senderId: string): Promise<void>;\n                removeAllAppMetadata(): Promise<void>;\n                getPermissions(): Promise<PermissionInfo[]>;\n                getPermission(accountIdentifier: string): Promise<PermissionInfo | undefined>;\n                removePermission(accountIdentifier: string): Promise<void>;\n                removeAllPermissions(): Promise<void>;\n                /**\n                     * Add a new peer to the known peers\n                     * @param peer The new peer to add\n                     */\n                addPeer(peer: PeerInfo): Promise<void>;\n                removePeer(peer: ExtendedP2PPairingResponse, sendDisconnectToPeer?: boolean): Promise<void>;\n                removeAllPeers(sendDisconnectToPeers?: boolean): Promise<void>;\n        }\n    }\n    \n    module 'test/clients/wallet-client/WalletClientOptions' {\n        import { Storage } from 'test/';\n        export interface WalletClientOptions {\n                /**\n                     * Name of the application\n                     */\n                name: string;\n                /**\n                     * A URL to the icon of the application\n                     */\n                iconUrl?: string;\n                /**\n                     * A URL to the website of the application\n                     */\n                appUrl?: string;\n                /**\n                     * The storage that will be used by the SDK\n                     */\n                storage?: Storage;\n                /**\n                     * A list of matrix nodes to connect to. If a non-empty array is passed, the default options will be overwritten.\n                     * One node will be randomly selected based on the local keypair and the other nodes will be used as a fallback in case the primary node goes down.\n                     *\n                     * Only provide the hostname, no https:// prefix. Eg. ['matrix.example.com']\n                     */\n                matrixNodes?: string[];\n        }\n    }\n    \n    module 'test/colorMode' {\n        import { ColorMode } from 'test/types/ColorMode';\n        export const setColorMode: (mode: ColorMode) => void;\n        export const getColorMode: () => ColorMode;\n    }\n    \n    module 'test/constants' {\n        export const SDK_VERSION: string;\n        export const BEACON_VERSION: string;\n    }\n    \n    module 'test/debug' {\n        export const setDebugEnabled: (enabled: boolean) => void;\n        export const getDebugEnabled: () => boolean;\n    }\n    \n    module 'test/errors/AbortedBeaconError' {\n        import { BeaconError } from 'test/';\n        export class AbortedBeaconError extends BeaconError {\n            name: string;\n            title: string;\n            constructor();\n        }\n    }\n    \n    module 'test/errors/BeaconError' {\n        import { BeaconErrorType } from 'test/';\n        export abstract class BeaconError implements Error {\n            name: string;\n            message: string;\n            title: string;\n            description: string;\n            get fullDescription(): string;\n            constructor(errorType: BeaconErrorType, message: string);\n            static getError(errorType: BeaconErrorType, errorData: any): BeaconError;\n        }\n    }\n    \n    module 'test/errors/BroadcastBeaconError' {\n        import { BeaconError } from 'test/';\n        export class BroadcastBeaconError extends BeaconError {\n            name: string;\n            title: string;\n            constructor();\n        }\n    }\n    \n    module 'test/errors/NetworkNotSupportedBeaconError' {\n        import { BeaconError } from 'test/';\n        export class NetworkNotSupportedBeaconError extends BeaconError {\n            name: string;\n            title: string;\n            constructor();\n        }\n    }\n    \n    module 'test/errors/NoAddressBeaconError' {\n        import { BeaconError } from 'test/';\n        export class NoAddressBeaconError extends BeaconError {\n            name: string;\n            title: string;\n            constructor();\n        }\n    }\n    \n    module 'test/errors/NoPrivateKeyBeaconError' {\n        import { BeaconError } from 'test/';\n        export class NoPrivateKeyBeaconError extends BeaconError {\n            name: string;\n            title: string;\n            constructor();\n        }\n    }\n    \n    module 'test/errors/NotGrantedBeaconError' {\n        import { BeaconError } from 'test/';\n        export class NotGrantedBeaconError extends BeaconError {\n            name: string;\n            title: string;\n            constructor();\n        }\n    }\n    \n    module 'test/errors/ParametersInvalidBeaconError' {\n        import { BeaconError } from 'test/';\n        export class ParametersInvalidBeaconError extends BeaconError {\n            name: string;\n            title: string;\n            constructor();\n        }\n    }\n    \n    module 'test/errors/SignatureTypeNotSupportedBeaconError' {\n        import { BeaconError } from 'test/';\n        export class SignatureTypeNotSupportedBeaconError extends BeaconError {\n            name: string;\n            title: string;\n            constructor();\n        }\n    }\n    \n    module 'test/errors/TooManyOperationsBeaconError' {\n        import { BeaconError } from 'test/';\n        export class TooManyOperationsBeaconError extends BeaconError {\n            name: string;\n            title: string;\n            constructor();\n        }\n    }\n    \n    module 'test/errors/TransactionInvalidBeaconError' {\n        import { BeaconError } from 'test/';\n        export class TransactionInvalidBeaconError extends BeaconError {\n            readonly data: any;\n            name: string;\n            title: string;\n            get fullDescription(): string;\n            constructor(data: any);\n        }\n    }\n    \n    module 'test/errors/UnknownBeaconError' {\n        import { BeaconError } from 'test/';\n        export class UnknownBeaconError extends BeaconError {\n            name: string;\n            title: string;\n            constructor();\n        }\n    }\n    \n    module 'test/events' {\n        import { AlertButton } from 'test/ui/alert/Alert';\n        import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n        import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n        import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n        import { BlockExplorer } from 'test/utils/block-explorer';\n        import { P2PPairingRequest, AccountInfo, ErrorResponse, PermissionResponseOutput, OperationResponseOutput, BroadcastResponseOutput, SignPayloadResponseOutput, Network, ConnectionContext, Transport, NetworkType, AcknowledgeResponse } from 'test/';\n        /**\n             * The different events that can be emitted by the beacon-sdk\n             */\n        export enum BeaconEvent {\n                PERMISSION_REQUEST_SENT = \"PERMISSION_REQUEST_SENT\",\n                PERMISSION_REQUEST_SUCCESS = \"PERMISSION_REQUEST_SUCCESS\",\n                PERMISSION_REQUEST_ERROR = \"PERMISSION_REQUEST_ERROR\",\n                OPERATION_REQUEST_SENT = \"OPERATION_REQUEST_SENT\",\n                OPERATION_REQUEST_SUCCESS = \"OPERATION_REQUEST_SUCCESS\",\n                OPERATION_REQUEST_ERROR = \"OPERATION_REQUEST_ERROR\",\n                SIGN_REQUEST_SENT = \"SIGN_REQUEST_SENT\",\n                SIGN_REQUEST_SUCCESS = \"SIGN_REQUEST_SUCCESS\",\n                SIGN_REQUEST_ERROR = \"SIGN_REQUEST_ERROR\",\n                BROADCAST_REQUEST_SENT = \"BROADCAST_REQUEST_SENT\",\n                BROADCAST_REQUEST_SUCCESS = \"BROADCAST_REQUEST_SUCCESS\",\n                BROADCAST_REQUEST_ERROR = \"BROADCAST_REQUEST_ERROR\",\n                ACKNOWLEDGE_RECEIVED = \"ACKNOWLEDGE_RECEIVED\",\n                LOCAL_RATE_LIMIT_REACHED = \"LOCAL_RATE_LIMIT_REACHED\",\n                NO_PERMISSIONS = \"NO_PERMISSIONS\",\n                ACTIVE_ACCOUNT_SET = \"ACTIVE_ACCOUNT_SET\",\n                ACTIVE_TRANSPORT_SET = \"ACTIVE_TRANSPORT_SET\",\n                PAIR_INIT = \"PAIR_INIT\",\n                PAIR_SUCCESS = \"PAIR_SUCCESS\",\n                CHANNEL_CLOSED = \"CHANNEL_CLOSED\",\n                INTERNAL_ERROR = \"INTERNAL_ERROR\",\n                UNKNOWN = \"UNKNOWN\"\n        }\n        export interface WalletInfo {\n                name: string;\n                icon?: string;\n        }\n        export interface ExtraInfo {\n                resetCallback?(): Promise<void>;\n        }\n        interface RequestSentInfo {\n                extraInfo: ExtraInfo;\n                walletInfo: WalletInfo;\n        }\n        /**\n             * The type of the payload of the different BeaconEvents\n             */\n        export interface BeaconEventType {\n                [BeaconEvent.PERMISSION_REQUEST_SENT]: RequestSentInfo;\n                [BeaconEvent.PERMISSION_REQUEST_SUCCESS]: {\n                        account: AccountInfo;\n                        output: PermissionResponseOutput;\n                        blockExplorer: BlockExplorer;\n                        connectionContext: ConnectionContext;\n                        walletInfo: WalletInfo;\n                };\n                [BeaconEvent.PERMISSION_REQUEST_ERROR]: {\n                        errorResponse: ErrorResponse;\n                        walletInfo: WalletInfo;\n                };\n                [BeaconEvent.OPERATION_REQUEST_SENT]: RequestSentInfo;\n                [BeaconEvent.OPERATION_REQUEST_SUCCESS]: {\n                        account: AccountInfo;\n                        output: OperationResponseOutput;\n                        blockExplorer: BlockExplorer;\n                        connectionContext: ConnectionContext;\n                        walletInfo: WalletInfo;\n                };\n                [BeaconEvent.OPERATION_REQUEST_ERROR]: {\n                        errorResponse: ErrorResponse;\n                        walletInfo: WalletInfo;\n                };\n                [BeaconEvent.SIGN_REQUEST_SENT]: RequestSentInfo;\n                [BeaconEvent.SIGN_REQUEST_SUCCESS]: {\n                        output: SignPayloadResponseOutput;\n                        connectionContext: ConnectionContext;\n                        walletInfo: WalletInfo;\n                };\n                [BeaconEvent.SIGN_REQUEST_ERROR]: {\n                        errorResponse: ErrorResponse;\n                        walletInfo: WalletInfo;\n                };\n                [BeaconEvent.BROADCAST_REQUEST_SENT]: RequestSentInfo;\n                [BeaconEvent.BROADCAST_REQUEST_SUCCESS]: {\n                        network: Network;\n                        output: BroadcastResponseOutput;\n                        blockExplorer: BlockExplorer;\n                        connectionContext: ConnectionContext;\n                        walletInfo: WalletInfo;\n                };\n                [BeaconEvent.BROADCAST_REQUEST_ERROR]: {\n                        errorResponse: ErrorResponse;\n                        walletInfo: WalletInfo;\n                };\n                [BeaconEvent.ACKNOWLEDGE_RECEIVED]: {\n                        message: AcknowledgeResponse;\n                        extraInfo: ExtraInfo;\n                        walletInfo: WalletInfo;\n                };\n                [BeaconEvent.LOCAL_RATE_LIMIT_REACHED]: undefined;\n                [BeaconEvent.NO_PERMISSIONS]: undefined;\n                [BeaconEvent.ACTIVE_ACCOUNT_SET]: AccountInfo;\n                [BeaconEvent.ACTIVE_TRANSPORT_SET]: Transport;\n                [BeaconEvent.PAIR_INIT]: {\n                        p2pPeerInfo: P2PPairingRequest;\n                        postmessagePeerInfo: PostMessagePairingRequest;\n                        preferredNetwork: NetworkType;\n                        abortedHandler?(): void;\n                };\n                [BeaconEvent.PAIR_SUCCESS]: ExtendedPostMessagePairingResponse | ExtendedP2PPairingResponse;\n                [BeaconEvent.CHANNEL_CLOSED]: string;\n                [BeaconEvent.INTERNAL_ERROR]: string;\n                [BeaconEvent.UNKNOWN]: undefined;\n        }\n        export type BeaconEventHandlerFunction<T = unknown> = (data: T, eventCallback?: AlertButton[]) => void | Promise<void>;\n        /**\n             * The default event handlers\n             */\n        export const defaultEventCallbacks: {\n                [key in BeaconEvent]: BeaconEventHandlerFunction<BeaconEventType[key]>;\n        };\n        /**\n             * Handles beacon events\n             */\n        export class BeaconEventHandler {\n                constructor(eventsToOverride?: {\n                        [key in BeaconEvent]?: {\n                                handler: BeaconEventHandlerFunction<BeaconEventType[key]>;\n                        };\n                }, overrideAll?: boolean);\n                /**\n                     * A method to subscribe to a specific beacon event and register a callback\n                     *\n                     * @param event The event being emitted\n                     * @param eventCallback The callback that will be invoked\n                     */\n                on<K extends BeaconEvent>(event: K, eventCallback: BeaconEventHandlerFunction<BeaconEventType[K]>): Promise<void>;\n                /**\n                     * Emit a beacon event\n                     *\n                     * @param event The event being emitted\n                     * @param data The data to be emit\n                     */\n                emit<K extends BeaconEvent>(event: K, data?: BeaconEventType[K], eventCallback?: AlertButton[]): Promise<void>;\n        }\n        export {};\n    }\n    \n    module 'test/examples/broadcast-request' {\n        export {};\n    }\n    \n    module 'test/examples/custom-block-explorer' {\n        export {};\n    }\n    \n    module 'test/examples/disable-all-ui' {\n        export {};\n    }\n    \n    module 'test/examples/operation-request' {\n        export {};\n    }\n    \n    module 'test/examples/override-default-events' {\n        export {};\n    }\n    \n    module 'test/examples/permission-request' {\n        export {};\n    }\n    \n    module 'test/examples/sign-payload-request' {\n        export {};\n    }\n    \n    module 'test/examples/using-custom-network' {\n        export {};\n    }\n    \n    module 'test/examples/wallet-example' {\n        export {};\n    }\n    \n    module 'test/index' {\n        import { P2PCommunicationClient } from 'test/transports/clients/P2PCommunicationClient';\n        import { AppMetadata } from 'test/types/beacon/AppMetadata';\n        import { PermissionRequest } from 'test/types/beacon/messages/PermissionRequest';\n        import { Network } from 'test/types/beacon/Network';\n        import { BeaconBaseMessage } from 'test/types/beacon/BeaconBaseMessage';\n        import { BeaconMessageType } from 'test/types/beacon/BeaconMessageType';\n        import { PermissionScope } from 'test/types/beacon/PermissionScope';\n        import { PermissionResponse } from 'test/types/beacon/messages/PermissionResponse';\n        import { OperationRequest } from 'test/types/beacon/messages/OperationRequest';\n        import { OperationResponse } from 'test/types/beacon/messages/OperationResponse';\n        import { SignPayloadRequest } from 'test/types/beacon/messages/SignPayloadRequest';\n        import { SignPayloadResponse } from 'test/types/beacon/messages/SignPayloadResponse';\n        import { BroadcastRequest } from 'test/types/beacon/messages/BroadcastRequest';\n        import { BroadcastResponse } from 'test/types/beacon/messages/BroadcastResponse';\n        import { NetworkType } from 'test/types/beacon/NetworkType';\n        import { TezosBaseOperation } from 'test/types/tezos/TezosBaseOperation';\n        import { TezosOperationType } from 'test/types/tezos/OperationTypes';\n        import { TezosActivateAccountOperation } from 'test/types/tezos/operations/ActivateAccount';\n        import { TezosBallotOperation } from 'test/types/tezos/operations/Ballot';\n        import { TezosDelegationOperation } from 'test/types/tezos/operations/Delegation';\n        import { TezosDoubleBakingEvidenceOperation } from 'test/types/tezos/operations/DoubleBakingEvidence';\n        import { TezosBlockHeader } from 'test/types/tezos/TezosBlockHeader';\n        import { TezosDoubleEndorsementEvidenceOperation } from 'test/types/tezos/operations/DoubleEndorsementEvidence';\n        import { TezosEndorsementOperation } from 'test/types/tezos/operations/Endorsement';\n        import { TezosOriginationOperation } from 'test/types/tezos/operations/Origination';\n        import { TezosProposalOperation } from 'test/types/tezos/operations/Proposal';\n        import { TezosRevealOperation } from 'test/types/tezos/operations/Reveal';\n        import { TezosSeedNonceRevelationOperation } from 'test/types/tezos/operations/SeedNonceRevelation';\n        import { TezosTransactionOperation } from 'test/types/tezos/operations/Transaction';\n        import { MichelsonPrimitives } from 'test/types/tezos/MichelsonPrimitives';\n        import { TezosTransactionParameters } from 'test/types/tezos/TezosTransactionParameters';\n        import { Origin } from 'test/types/Origin';\n        import { AccountInfo, AccountIdentifier } from 'test/types/AccountInfo';\n        import { EncryptedExtensionMessage, ExtensionMessage } from 'test/types/ExtensionMessage';\n        import { ExtensionMessageTarget } from 'test/types/ExtensionMessageTarget';\n        import { TezosOperation } from 'test/types/tezos/TezosOperation';\n        import { Client } from 'test/clients/client/Client';\n        import { WalletClient } from 'test/clients/wallet-client/WalletClient';\n        import { DAppClient } from 'test/clients/dapp-client/DAppClient';\n        import { BeaconError } from 'test/errors/BeaconError';\n        import { BeaconErrorType } from 'test/types/BeaconErrorType';\n        import { BroadcastBeaconError } from 'test/errors/BroadcastBeaconError';\n        import { NetworkNotSupportedBeaconError } from 'test/errors/NetworkNotSupportedBeaconError';\n        import { NoAddressBeaconError } from 'test/errors/NoAddressBeaconError';\n        import { NoPrivateKeyBeaconError } from 'test/errors/NoPrivateKeyBeaconError';\n        import { NotGrantedBeaconError } from 'test/errors/NotGrantedBeaconError';\n        import { ParametersInvalidBeaconError } from 'test/errors/ParametersInvalidBeaconError';\n        import { TooManyOperationsBeaconError } from 'test/errors/TooManyOperationsBeaconError';\n        import { TransactionInvalidBeaconError } from 'test/errors/TransactionInvalidBeaconError';\n        import { UnknownBeaconError } from 'test/errors/UnknownBeaconError';\n        import { ErrorResponse } from 'test/types/beacon/messages/ErrorResponse';\n        import { TransportStatus } from 'test/types/transport/TransportStatus';\n        import { TransportType } from 'test/types/transport/TransportType';\n        import { PostMessageTransport } from 'test/transports/PostMessageTransport';\n        import { Transport } from 'test/transports/Transport';\n        import { P2PTransport } from 'test/transports/P2PTransport';\n        import { Storage } from 'test/storage/Storage';\n        import { StorageKey } from 'test/types/storage/StorageKey';\n        import { StorageKeyReturnDefaults } from 'test/types/storage/StorageKeyReturnDefaults';\n        import { StorageKeyReturnType } from 'test/types/storage/StorageKeyReturnType';\n        import { ExtendedP2PPairingRequest, P2PPairingRequest } from 'test/types/P2PPairingRequest';\n        import { ChromeStorage } from 'test/storage/ChromeStorage';\n        import { LocalStorage } from 'test/storage/LocalStorage';\n        import { getStorage } from 'test/storage/getStorage';\n        import { BeaconMessage } from 'test/types/beacon/BeaconMessage';\n        import { Serializer } from 'test/Serializer';\n        import { RequestPermissionInput } from 'test/types/RequestPermissionInput';\n        import { RequestSignPayloadInput } from 'test/types/RequestSignPayloadInput';\n        import { RequestOperationInput } from 'test/types/RequestOperationInput';\n        import { RequestBroadcastInput } from 'test/types/RequestBroadcastInput';\n        import { PermissionResponseInput, SignPayloadResponseInput, OperationResponseInput, BroadcastResponseInput, BeaconResponseInputMessage, AcknowledgeResponseInput, ErrorResponseInput } from 'test/types/beacon/messages/BeaconResponseInputMessage';\n        import { PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, BeaconResponseOutputMessage } from 'test/types/beacon/messages/BeaconResponseOutputMessage';\n        import { PermissionRequestInput, SignPayloadRequestInput, OperationRequestInput, BroadcastRequestInput, BeaconRequestInputMessage } from 'test/types/beacon/messages/BeaconRequestInputMessage';\n        import { PermissionRequestOutput, SignPayloadRequestOutput, OperationRequestOutput, BroadcastRequestOutput, BeaconRequestOutputMessage } from 'test/types/beacon/messages/BeaconRequestOutputMessage';\n        import { ClientOptions } from 'test/clients/client/ClientOptions';\n        import { DAppClientOptions } from 'test/clients/dapp-client/DAppClientOptions';\n        import { WalletClientOptions } from 'test/clients/wallet-client/WalletClientOptions';\n        import { PermissionInfo } from 'test/types/PermissionInfo';\n        import { SDK_VERSION, BEACON_VERSION } from 'test/constants';\n        import { AccountManager } from 'test/managers/AccountManager';\n        import { AppMetadataManager } from 'test/managers/AppMetadataManager';\n        import { PermissionManager } from 'test/managers/PermissionManager';\n        import { BeaconEvent, BeaconEventHandler, defaultEventCallbacks } from 'test/events';\n        import { getAddressFromPublicKey } from 'test/utils/crypto';\n        import { BeaconClient } from 'test/clients/beacon-client/BeaconClient';\n        import { BeaconClientOptions } from 'test/clients/beacon-client/BeaconClientOptions';\n        import { getAccountIdentifier } from 'test/utils/get-account-identifier';\n        import { ConnectionContext } from 'test/types/ConnectionContext';\n        import { Threshold } from 'test/types/beacon/Threshold';\n        import { PartialTezosTransactionOperation, PartialTezosOperation, PartialTezosDelegationOperation, PartialTezosOriginationOperation, PartialTezosRevealOperation } from 'test/types/tezos/PartialTezosOperation';\n        import { AbortedBeaconError } from 'test/errors/AbortedBeaconError';\n        import { ExtendedPeerInfo, PeerInfo } from 'test/types/PeerInfo';\n        import { availableTransports } from 'test/utils/available-transports';\n        import { AcknowledgeResponse } from 'test/types/beacon/messages/AcknowledgeResponse';\n        import { DisconnectMessage } from 'test/types/beacon/messages/DisconnectMessage';\n        import { DappP2PTransport } from 'test/transports/DappP2PTransport';\n        import { DappPostMessageTransport } from 'test/transports/DappPostMessageTransport';\n        import { WalletP2PTransport } from 'test/transports/WalletP2PTransport';\n        import { WalletPostMessageTransport } from 'test/transports/WalletPostMessageTransport';\n        import { getSenderId } from 'test/utils/get-sender-id';\n        import { SigningType } from 'test/types/beacon/SigningType';\n        import { SignatureTypeNotSupportedBeaconError } from 'test/errors/SignatureTypeNotSupportedBeaconError';\n        import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n        import { ExtendedPostMessagePairingRequest, PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n        import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n        import { PeerManager } from 'test/managers/PeerManager';\n        import { MessageBasedClient } from 'test/transports/clients/MessageBasedClient';\n        import { BeaconRequestMessage } from 'test/types/beacon/BeaconRequestMessage';\n        import { BeaconResponseMessage } from 'test/types/beacon/BeaconResponseMessage';\n        import { Pairing } from 'test/ui/alert/Pairing';\n        import { BlockExplorer } from 'test/utils/block-explorer';\n        import { TezblockBlockExplorer } from 'test/utils/tezblock-blockexplorer';\n        import { setDebugEnabled, getDebugEnabled } from 'test/debug';\n        import { ColorMode } from 'test/types/ColorMode';\n        export { TezosBaseOperation, TezosOperationType, TezosBlockHeader, MichelsonPrimitives, TezosTransactionParameters, TezosOperation };\n        export { TezosActivateAccountOperation, TezosBallotOperation, TezosDelegationOperation, TezosDoubleBakingEvidenceOperation, TezosDoubleEndorsementEvidenceOperation, TezosEndorsementOperation, TezosOriginationOperation, TezosProposalOperation, TezosRevealOperation, TezosSeedNonceRevelationOperation, TezosTransactionOperation, PartialTezosOperation, PartialTezosTransactionOperation, PartialTezosDelegationOperation, PartialTezosOriginationOperation, PartialTezosRevealOperation };\n        export { BeaconClient, BeaconClientOptions, Client, ClientOptions, DAppClient, DAppClientOptions, WalletClient, WalletClientOptions, P2PCommunicationClient };\n        export { AccountIdentifier, AppMetadata, Network, NetworkType, BeaconMessage, PermissionRequest, PermissionResponse, OperationRequest, OperationResponse, SignPayloadRequest, SignPayloadResponse, BroadcastRequest, BroadcastResponse, AcknowledgeResponse, DisconnectMessage, BeaconBaseMessage, BeaconMessageType, PermissionScope, Origin, AccountInfo, Threshold, SigningType, ExtensionMessageTarget, ExtensionMessage, EncryptedExtensionMessage, RequestPermissionInput, RequestSignPayloadInput, RequestOperationInput, RequestBroadcastInput, PermissionInfo };\n        export { PermissionResponseInput, SignPayloadResponseInput, OperationResponseInput, BroadcastResponseInput, AcknowledgeResponseInput, ErrorResponseInput, PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, PermissionRequestInput, SignPayloadRequestInput, OperationRequestInput, BroadcastRequestInput, PermissionRequestOutput, SignPayloadRequestOutput, OperationRequestOutput, BroadcastRequestOutput, BeaconRequestInputMessage, BeaconRequestOutputMessage, BeaconResponseInputMessage, BeaconResponseOutputMessage, BeaconRequestMessage, BeaconResponseMessage };\n        export { BeaconError, BeaconErrorType, ErrorResponse, AbortedBeaconError, BroadcastBeaconError, NetworkNotSupportedBeaconError, NoAddressBeaconError, NoPrivateKeyBeaconError, NotGrantedBeaconError, ParametersInvalidBeaconError, TooManyOperationsBeaconError, TransactionInvalidBeaconError, SignatureTypeNotSupportedBeaconError, UnknownBeaconError };\n        export { TransportStatus, TransportType, Transport, PostMessageTransport, P2PTransport, WalletP2PTransport, WalletPostMessageTransport, DappP2PTransport, DappPostMessageTransport, MessageBasedClient, Pairing };\n        export { BeaconEvent, BeaconEventHandler, defaultEventCallbacks };\n        export { Storage, StorageKey, StorageKeyReturnDefaults, StorageKeyReturnType, ChromeStorage, LocalStorage, getStorage };\n        export { PeerManager, AccountManager, AppMetadataManager, PermissionManager };\n        export { SDK_VERSION, BEACON_VERSION };\n        export { getSenderId, getAccountIdentifier, getAddressFromPublicKey };\n        export { PeerInfo, ExtendedPeerInfo, PostMessagePairingRequest, ExtendedPostMessagePairingRequest, ExtendedPostMessagePairingResponse, P2PPairingRequest, ExtendedP2PPairingRequest, ExtendedP2PPairingResponse };\n        export { BlockExplorer, TezblockBlockExplorer };\n        export { ConnectionContext, Serializer, availableTransports, ColorMode };\n        export { setDebugEnabled, getDebugEnabled };\n    }\n    \n    module 'test/interceptors/IncomingRequestInterceptor' {\n        import { BeaconRequestOutputMessage } from 'test/';\n        import { ConnectionContext } from 'test/types/ConnectionContext';\n        import { AppMetadataManager } from 'test/managers/AppMetadataManager';\n        import { BeaconRequestMessage } from 'test/types/beacon/BeaconRequestMessage';\n        interface IncomingRequestInterceptorOptions {\n                message: BeaconRequestMessage;\n                connectionInfo: ConnectionContext;\n                appMetadataManager: AppMetadataManager;\n                interceptorCallback(message: BeaconRequestOutputMessage, connectionInfo: ConnectionContext): void;\n        }\n        /**\n             * The IncomingRequestInterceptor is used in the WalletClient to intercept an incoming request and enrich it with data, like app metadata.\n             */\n        export class IncomingRequestInterceptor {\n                /**\n                     * The method that is called during the interception\n                     *\n                     * @param config\n                     */\n                static intercept(config: IncomingRequestInterceptorOptions): Promise<void>;\n        }\n        export {};\n    }\n    \n    module 'test/interceptors/OutgoingResponseInterceptor' {\n        import { BeaconMessage, BeaconResponseInputMessage, AppMetadata } from 'test/';\n        import { PermissionManager } from 'test/managers/PermissionManager';\n        import { AppMetadataManager } from 'test/managers/AppMetadataManager';\n        import { BeaconRequestMessage } from 'test/types/beacon/BeaconRequestMessage';\n        interface OutgoingResponseInterceptorOptions {\n            senderId: string;\n            request: BeaconRequestMessage;\n            message: BeaconResponseInputMessage;\n            ownAppMetadata: AppMetadata;\n            permissionManager: PermissionManager;\n            appMetadataManager: AppMetadataManager;\n            interceptorCallback(message: BeaconMessage): void;\n        }\n        /**\n           * The OutgoingResponseInterceptor is used in the WalletClient to intercept an outgoing response and enrich it with data.\n           */\n        export class OutgoingResponseInterceptor {\n            static intercept(config: OutgoingResponseInterceptorOptions): Promise<void>;\n        }\n        export {};\n    }\n    \n    module 'test/managers/AccountManager' {\n        import { Storage, AccountInfo, BeaconMessage } from 'test/';\n        /**\n           * The AccountManager provides CRUD functionality for account entities and persists them to the provided storage.\n           */\n        export class AccountManager {\n            constructor(storage: Storage);\n            getAccounts(): Promise<AccountInfo[]>;\n            getAccount(accountIdentifier: string): Promise<AccountInfo | undefined>;\n            addAccount(accountInfo: AccountInfo): Promise<void>;\n            removeAccount(accountIdentifier: string): Promise<void>;\n            removeAccounts(accountIdentifiers: string[]): Promise<void>;\n            removeAllAccounts(): Promise<void>;\n            hasPermission(message: BeaconMessage): Promise<boolean>;\n        }\n    }\n    \n    module 'test/managers/AppMetadataManager' {\n        import { Storage, AppMetadata } from 'test/';\n        /**\n           * The AppMetadataManager provides CRUD functionality for app-metadata entities and persists them to the provided storage.\n           */\n        export class AppMetadataManager {\n            constructor(storage: Storage);\n            getAppMetadataList(): Promise<AppMetadata[]>;\n            getAppMetadata(senderId: string): Promise<AppMetadata | undefined>;\n            addAppMetadata(appMetadata: AppMetadata): Promise<void>;\n            removeAppMetadata(senderId: string): Promise<void>;\n            removeAppMetadatas(senderIds: string[]): Promise<void>;\n            removeAllAppMetadata(): Promise<void>;\n        }\n    }\n    \n    module 'test/managers/PeerManager' {\n        import { Storage, StorageKey, StorageKeyReturnType } from 'test/';\n        import { ArrayElem } from 'test/managers/StorageManager';\n        /**\n           * The PeerManager provides CRUD functionality for peer entities and persists them to the provided storage.\n           */\n        export class PeerManager<T extends StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET> {\n            constructor(storage: Storage, key: T);\n            hasPeer(publicKey: string): Promise<boolean>;\n            getPeers(): Promise<StorageKeyReturnType[T]>;\n            getPeer(publicKey: string): Promise<ArrayElem<StorageKeyReturnType[T]> | undefined>;\n            addPeer(peerInfo: ArrayElem<StorageKeyReturnType[T]>): Promise<void>;\n            removePeer(publicKey: string): Promise<void>;\n            removePeers(publicKeys: string[]): Promise<void>;\n            removeAllPeers(): Promise<void>;\n        }\n    }\n    \n    module 'test/managers/PermissionManager' {\n        import { BeaconMessage, Storage } from 'test/';\n        import { PermissionInfo } from 'test/types/PermissionInfo';\n        /**\n           * The PermissionManager provides CRUD functionality for permission entities and persists them to the provided storage.\n           */\n        export class PermissionManager {\n            constructor(storage: Storage);\n            getPermissions(): Promise<PermissionInfo[]>;\n            getPermission(accountIdentifier: string): Promise<PermissionInfo | undefined>;\n            addPermission(permissionInfo: PermissionInfo): Promise<void>;\n            removePermission(accountIdentifier: string): Promise<void>;\n            removePermissions(accountIdentifiers: string[]): Promise<void>;\n            removeAllPermissions(): Promise<void>;\n            hasPermission(message: BeaconMessage): Promise<boolean>;\n        }\n    }\n    \n    module 'test/managers/PermissionValidator' {\n        import { BeaconMessage } from 'test/';\n        import { PermissionEntity } from 'test/types/PermissionEntity';\n        /**\n             * The PermissionValidator is used to check if permissions for a certain message type have been given\n             */\n        export class PermissionValidator {\n                /**\n                     * Check if permissions were given for a certain message type.\n                     *\n                     * PermissionRequest and BroadcastRequest will always return true.\n                     *\n                     * @param message Beacon Message\n                     */\n                static hasPermission(message: BeaconMessage, getOne: (id: string) => Promise<PermissionEntity | undefined>, getAll: () => Promise<PermissionEntity[]>): Promise<boolean>;\n        }\n    }\n    \n    module 'test/managers/StorageManager' {\n        import { StorageKey, Storage, StorageKeyReturnType } from 'test/';\n        /** Type workaround for https://github.com/Microsoft/TypeScript/issues/7294#issuecomment-465794460 */\n        export type ArrayElem<A> = A extends (infer Elem)[] ? Elem : never;\n        /**\n             * The StorageManager provides CRUD functionality for specific entities and persists them to the provided storage.\n             */\n        export class StorageManager<T extends StorageKey.ACCOUNTS | StorageKey.APP_METADATA_LIST | StorageKey.PERMISSION_LIST | StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET> {\n                constructor(storage: Storage, storageKey: T);\n                getAll(): Promise<StorageKeyReturnType[T]>;\n                getOne(predicate: (element: ArrayElem<StorageKeyReturnType[T]>) => boolean): Promise<ArrayElem<StorageKeyReturnType[T]> | undefined>;\n                addOne(element: ArrayElem<StorageKeyReturnType[T]>, predicate: (element: ArrayElem<StorageKeyReturnType[T]>) => boolean, overwrite?: boolean): Promise<void>;\n                remove(predicate: (element: ArrayElem<StorageKeyReturnType[T]>) => boolean): Promise<void>;\n                removeAll(): Promise<void>;\n        }\n    }\n    \n    module 'test/matrix-client/MatrixClient' {\n        import { Storage } from 'test/storage/Storage';\n        import { MatrixClientStore } from 'test/matrix-client/MatrixClientStore';\n        import { MatrixRoom } from 'test/matrix-client/models/MatrixRoom';\n        import { MatrixRoomService } from 'test/matrix-client/services/MatrixRoomService';\n        import { MatrixUserService } from 'test/matrix-client/services/MatrixUserService';\n        import { MatrixEventService } from 'test/matrix-client/services/MatrixEventService';\n        import { MatrixClientEventEmitter } from 'test/matrix-client/MatrixClientEventEmitter';\n        import { MatrixClientEventType, MatrixClientEvent } from 'test/matrix-client/models/MatrixClientEvent';\n        interface MatrixClientOptions {\n                baseUrl: string;\n                storage: Storage;\n        }\n        interface MatrixLoginConfig {\n                id: string;\n                password: string;\n                deviceId: string;\n        }\n        /**\n             * The matrix client used to connect to the matrix network\n             */\n        export class MatrixClient {\n                /**\n                     * Create a matrix client based on the options provided\n                     *\n                     * @param config\n                     */\n                static create(config: MatrixClientOptions): MatrixClient;\n                /**\n                     * Return all the rooms we are currently part of\n                     */\n                get joinedRooms(): MatrixRoom[];\n                /**\n                     * Return all the rooms to which we have received invitations\n                     */\n                get invitedRooms(): MatrixRoom[];\n                /**\n                     * Return all the rooms that we left\n                     */\n                get leftRooms(): MatrixRoom[];\n                constructor(store: MatrixClientStore, eventEmitter: MatrixClientEventEmitter, userService: MatrixUserService, roomService: MatrixRoomService, eventService: MatrixEventService);\n                /**\n                     * Initiate the connection to the matrix node and log in\n                     *\n                     * @param user\n                     */\n                start(user: MatrixLoginConfig): Promise<void>;\n                /**\n                     * Subscribe to new matrix events\n                     *\n                     * @param event\n                     * @param listener\n                     */\n                subscribe<T extends MatrixClientEventType>(event: T, listener: (event: MatrixClientEvent<T>) => void): void;\n                /**\n                     * Unsubscribe from matrix events\n                     *\n                     * @param event\n                     * @param listener\n                     */\n                unsubscribe(event: MatrixClientEventType, listener?: (event: MatrixClientEvent<any>) => void): void;\n                getRoomById(id: string): MatrixRoom;\n                /**\n                     * Create a private room with the supplied members\n                     *\n                     * @param members Members that will be in the room\n                     */\n                createTrustedPrivateRoom(...members: string[]): Promise<string>;\n                /**\n                     * Invite user to rooms\n                     *\n                     * @param user The user to be invited\n                     * @param roomsOrIds The rooms the user will be invited to\n                     */\n                inviteToRooms(user: string, ...roomsOrIds: string[] | MatrixRoom[]): Promise<void>;\n                /**\n                     * Join rooms\n                     *\n                     * @param roomsOrIds\n                     */\n                joinRooms(...roomsOrIds: string[] | MatrixRoom[]): Promise<void>;\n                /**\n                     * Send a text message\n                     *\n                     * @param roomOrId\n                     * @param message\n                     */\n                sendTextMessage(roomId: string, message: string): Promise<void>;\n        }\n        export {};\n    }\n    \n    module 'test/matrix-client/MatrixClientEventEmitter' {\n        import { EventEmitter } from 'events';\n        import { MatrixStateStore, MatrixStateUpdate } from 'test/matrix-client/MatrixClientStore';\n        export class MatrixClientEventEmitter extends EventEmitter {\n                /**\n                     * This method is called every time the state is changed\n                     *\n                     * @param _oldState\n                     * @param _newState\n                     * @param stateChange\n                     */\n                onStateChanged(_oldState: MatrixStateStore, _newState: MatrixStateStore, stateChange: Partial<MatrixStateUpdate>): void;\n        }\n    }\n    \n    module 'test/matrix-client/MatrixClientStore' {\n        import { MatrixRoom } from 'test/matrix-client/models/MatrixRoom';\n        import { Storage } from 'test/storage/Storage';\n        type OnStateChangedListener = (oldState: MatrixStateStore, newState: MatrixStateStore, stateChange: Partial<MatrixStateUpdate>) => void;\n        export interface MatrixState {\n                isRunning: boolean;\n                userId: string | undefined;\n                deviceId: string | undefined;\n                txnNo: number;\n                accessToken: string | undefined;\n                syncToken: string | undefined;\n                pollingTimeout: number | undefined;\n                pollingRetries: number;\n                rooms: MatrixRoom[] | Record<string, MatrixRoom>;\n        }\n        export interface MatrixStateStore extends MatrixState {\n                rooms: Record<string, MatrixRoom>;\n        }\n        export interface MatrixStateUpdate extends MatrixState {\n                rooms: MatrixRoom[];\n        }\n        /**\n             * The class managing the local state of matrix\n             */\n        export class MatrixClientStore {\n                constructor(storage: Storage);\n                /**\n                     * Get an item from the state\n                     *\n                     * @param key\n                     */\n                get<T extends keyof MatrixStateStore>(key: T): MatrixStateStore[T];\n                /**\n                     * Get the room from an ID or room instance\n                     *\n                     * @param roomOrId\n                     */\n                getRoom(roomOrId: string | MatrixRoom): MatrixRoom;\n                /**\n                     * Update the state with a partial state\n                     *\n                     * @param stateUpdate\n                     */\n                update(stateUpdate: Partial<MatrixStateUpdate>): Promise<void>;\n                /**\n                     * Register listeners that are called once the state has changed\n                     *\n                     * @param listener\n                     * @param subscribed\n                     */\n                onStateChanged(listener: OnStateChangedListener, ...subscribed: (keyof MatrixState)[]): void;\n        }\n        export {};\n    }\n    \n    module 'test/matrix-client/MatrixHttpClient' {\n        import { MatrixRequest, MatrixRequestParams } from 'test/matrix-client/models/api/MatrixRequest';\n        interface HttpOptions {\n                accessToken?: string;\n        }\n        /**\n             * Handling the HTTP connection to the matrix synapse node\n             */\n        export class MatrixHttpClient {\n                constructor(baseUrl: string);\n                /**\n                     * Get data from the synapse node\n                     *\n                     * @param endpoint\n                     * @param options\n                     */\n                get<T>(endpoint: string, params?: MatrixRequestParams<T>, options?: HttpOptions): Promise<T>;\n                /**\n                     * Post data to the synapse node\n                     *\n                     * @param endpoint\n                     * @param body\n                     * @param options\n                     * @param params\n                     */\n                post<T>(endpoint: string, body: MatrixRequest<T>, options?: HttpOptions, params?: MatrixRequestParams<T>): Promise<T>;\n                /**\n                     * Put data to the synapse node\n                     *\n                     * @param endpoint\n                     * @param body\n                     * @param options\n                     * @param params\n                     */\n                put<T>(endpoint: string, body: MatrixRequest<T>, options?: HttpOptions, params?: MatrixRequestParams<T>): Promise<T>;\n        }\n        export {};\n    }\n    \n    module 'test/matrix-client/models/api/MatrixEventSend' {\n        export interface MatrixEventSendRequest {\n            content: any;\n        }\n        export interface MatrixEventSendResponse {\n            type?: 'event_send';\n            event_id: string;\n        }\n    }\n    \n    module 'test/matrix-client/models/api/MatrixLogin' {\n        export interface MatrixLoginRequest {\n            type: 'm.login.password';\n            identifier: {\n                type: 'm.id.user';\n                user: string;\n            };\n            password: string;\n            device_id?: string;\n        }\n        export interface MatrixLoginResponse {\n            type?: 'login';\n            user_id: string;\n            device_id: string;\n            access_token: string;\n        }\n    }\n    \n    module 'test/matrix-client/models/api/MatrixRequest' {\n        import { MatrixLoginRequest, MatrixLoginResponse } from 'test/matrix-client/models/api/MatrixLogin';\n        import { MatrixRoomCreateRequest, MatrixRoomCreateResponse } from 'test/matrix-client/models/api/MatrixRoomCreate';\n        import { MatrixRoomInviteRequest, MatrixRoomInviteResponse } from 'test/matrix-client/models/api/MatrixRoomInvite';\n        import { MatrixRoomJoinRequest, MatrixRoomJoinResponse } from 'test/matrix-client/models/api/MatrixRoomJoin';\n        import { MatrixEventSendRequest, MatrixEventSendResponse } from 'test/matrix-client/models/api/MatrixEventSend';\n        import { MatrixSyncResponse, MatrixSyncRequestParams } from 'test/matrix-client/models/api/MatrixSync';\n        export type MatrixRequest<T> = T extends MatrixLoginResponse ? MatrixLoginRequest : T extends MatrixRoomCreateResponse ? MatrixRoomCreateRequest : T extends MatrixRoomInviteResponse ? MatrixRoomInviteRequest : T extends MatrixRoomJoinResponse ? MatrixRoomJoinRequest : T extends MatrixEventSendResponse ? MatrixEventSendRequest : never;\n        export type MatrixRequestParams<T> = T extends MatrixSyncResponse ? MatrixSyncRequestParams : never;\n    }\n    \n    module 'test/matrix-client/models/api/MatrixRoomCreate' {\n        export interface MatrixRoomCreateRequest {\n            visibility?: 'public' | 'private';\n            room_alias_name?: string;\n            name?: string;\n            topic?: string;\n            invite?: string[];\n            preset?: 'private_chat' | 'public_chat' | 'trusted_private_chat';\n            is_direct?: boolean;\n        }\n        export interface MatrixRoomCreateResponse {\n            type?: 'room_create';\n            room_id: string;\n        }\n    }\n    \n    module 'test/matrix-client/models/api/MatrixRoomInvite' {\n        export interface MatrixRoomInviteRequest {\n            user_id: string;\n        }\n        export interface MatrixRoomInviteResponse {\n            type?: 'room_invite';\n        }\n    }\n    \n    module 'test/matrix-client/models/api/MatrixRoomJoin' {\n        export interface MatrixRoomJoinRequest {\n        }\n        export interface MatrixRoomJoinResponse {\n            type?: 'room_join';\n            room_id: string;\n        }\n    }\n    \n    module 'test/matrix-client/models/api/MatrixSync' {\n        import { MatrixStateEvent } from 'test/matrix-client/models/MatrixStateEvent';\n        export interface MatrixSyncJoinedRoom {\n            state: {\n                events: MatrixStateEvent[];\n            };\n            timeline: {\n                events: MatrixStateEvent[];\n            };\n        }\n        export interface MatrixSyncInvitedRoom {\n            invite_state: {\n                events: MatrixStateEvent[];\n            };\n        }\n        export interface MatrixSyncLeftRoom {\n            state: {\n                events: MatrixStateEvent[];\n            };\n            timeline: {\n                events: MatrixStateEvent[];\n            };\n        }\n        export interface MatrixSyncRooms {\n            join: {\n                [key: string]: MatrixSyncJoinedRoom;\n            };\n            invite: {\n                [key: string]: MatrixSyncInvitedRoom;\n            };\n            leave: {\n                [key: string]: MatrixSyncLeftRoom;\n            };\n        }\n        export interface MatrixSyncRequestParams {\n            timeout?: number;\n            since?: string;\n        }\n        export interface MatrixSyncResponse {\n            type?: 'sync';\n            next_batch: string;\n            rooms: MatrixSyncRooms;\n        }\n    }\n    \n    module 'test/matrix-client/models/MatrixClientEvent' {\n        import { MatrixMessage } from 'test/matrix-client/models/MatrixMessage';\n        export enum MatrixClientEventType {\n            INVITE = \"invite\",\n            MESSAGE = \"message\"\n        }\n        export type MatrixClientEventContent<T> = T extends MatrixClientEventType.INVITE ? MatrixClientEventInviteContent : T extends MatrixClientEventType.MESSAGE ? MatrixClientEventMessageContent<any> : never;\n        export interface MatrixClientEventInviteContent {\n            roomId: string;\n        }\n        export interface MatrixClientEventMessageContent<T> {\n            roomId: string;\n            message: MatrixMessage<T>;\n        }\n        export interface MatrixClientEvent<T extends MatrixClientEventType> {\n            type: T;\n            content: MatrixClientEventContent<T>;\n        }\n    }\n    \n    module 'test/matrix-client/models/MatrixMessage' {\n        import { MatrixStateEvent } from 'test/matrix-client/models/MatrixStateEvent';\n        export enum MatrixMessageType {\n            TEXT = \"m.text\"\n        }\n        export class MatrixMessage<T> {\n            readonly type: MatrixMessageType;\n            readonly sender: string;\n            readonly content: T;\n            /**\n               * Construct a message from a message event\n               *\n               * @param event\n               */\n            static from(event: MatrixStateEvent): MatrixMessage<any> | undefined;\n        }\n    }\n    \n    module 'test/matrix-client/models/MatrixRoom' {\n        import { MatrixSyncRooms } from 'test/matrix-client/models/api/MatrixSync';\n        import { MatrixMessage } from 'test/matrix-client/models/MatrixMessage';\n        export enum MatrixRoomStatus {\n                UNKNOWN = 0,\n                JOINED = 1,\n                INVITED = 2,\n                LEFT = 3\n        }\n        export class MatrixRoom {\n                readonly id: string;\n                readonly status: MatrixRoomStatus;\n                readonly members: string[];\n                messages: MatrixMessage<any>[];\n                /**\n                     * Reconstruct rooms from a sync response\n                     *\n                     * @param roomSync\n                     */\n                static fromSync(roomSync: MatrixSyncRooms): MatrixRoom[];\n                /**\n                     * Reconstruct a room from an ID or object\n                     *\n                     * @param roomOrId\n                     * @param status\n                     */\n                static from(roomOrId: string | MatrixRoom, status?: MatrixRoomStatus): MatrixRoom;\n                /**\n                     * Merge new and old state and remove duplicates\n                     *\n                     * @param newState\n                     * @param previousState\n                     */\n                static merge(newState: MatrixRoom, previousState?: MatrixRoom): MatrixRoom;\n        }\n    }\n    \n    module 'test/matrix-client/models/MatrixStateEvent' {\n        import { MatrixMessageType } from 'test/matrix-client/models/MatrixMessage';\n        export interface MatrixStateEventMessageText extends MatrixStateEventMessage {\n            type: 'm.room.message';\n            content: {\n                msgtype: MatrixMessageType.TEXT;\n                body: string;\n            };\n        }\n        export interface MatrixStateEventMessageContent {\n            msgtype: string;\n            body: any;\n            [key: string]: any;\n        }\n        export interface MatrixStateEventMessage extends MatrixStateEvent {\n            type: 'm.room.message';\n            content: MatrixStateEventMessageContent;\n        }\n        export interface MatrixStateEvent {\n            type: string;\n            sender: string;\n            content: unknown;\n            event_id?: string;\n        }\n    }\n    \n    module 'test/matrix-client/services/MatrixEventService' {\n        import { MatrixHttpClient } from 'test/matrix-client/MatrixHttpClient';\n        import { MatrixEventSendResponse } from 'test/matrix-client/models/api/MatrixEventSend';\n        import { MatrixSyncResponse } from 'test/matrix-client/models/api/MatrixSync';\n        import { MatrixStateEventMessageContent } from 'test/matrix-client/models/MatrixStateEvent';\n        interface MatrixScheduledEvent<T> {\n                accessToken: string;\n                roomId: string;\n                type: MatrixEventType;\n                content: any;\n                txnId: string;\n                onSuccess(response: T): void;\n                onError(error: unknown): void;\n        }\n        type MatrixEventType = 'm.room.message';\n        export interface MatrixSyncOptions {\n                syncToken?: string;\n                pollingTimeout?: number;\n        }\n        /**\n             * A service to help with matrix event management\n             */\n        export class MatrixEventService {\n                constructor(httpClient: MatrixHttpClient);\n                /**\n                     * Get the latest state from the matrix node\n                     *\n                     * @param accessToken\n                     * @param options\n                     */\n                sync(accessToken: string, options?: MatrixSyncOptions): Promise<MatrixSyncResponse>;\n                /**\n                     * Send a message to a room\n                     *\n                     * @param accessToken\n                     * @param room\n                     * @param content\n                     * @param txnId\n                     */\n                sendMessage(accessToken: string, roomId: string, content: MatrixStateEventMessageContent, txnId: string): Promise<MatrixEventSendResponse>;\n                /**\n                     * Schedules an event to be sent to the node\n                     *\n                     * @param event\n                     */\n                scheduleEvent(event: MatrixScheduledEvent<any>): void;\n                /**\n                     * Send an event to the matrix node\n                     *\n                     * @param scheduledEvent\n                     */\n                sendEvent(scheduledEvent: MatrixScheduledEvent<any>): Promise<void>;\n        }\n        export {};\n    }\n    \n    module 'test/matrix-client/services/MatrixRoomService' {\n        import { MatrixHttpClient } from 'test/matrix-client/MatrixHttpClient';\n        import { MatrixRoom } from 'test/matrix-client/models/MatrixRoom';\n        import { MatrixRoomCreateRequest, MatrixRoomCreateResponse } from 'test/matrix-client/models/api/MatrixRoomCreate';\n        import { MatrixRoomInviteResponse } from 'test/matrix-client/models/api/MatrixRoomInvite';\n        import { MatrixRoomJoinResponse } from 'test/matrix-client/models/api/MatrixRoomJoin';\n        /**\n             * A service to help with matrix room management\n             */\n        export class MatrixRoomService {\n                constructor(httpClient: MatrixHttpClient);\n                /**\n                     * Create a room\n                     *\n                     * @param accessToken\n                     * @param config\n                     */\n                createRoom(accessToken: string, config?: MatrixRoomCreateRequest): Promise<MatrixRoomCreateResponse>;\n                /**\n                     * Invite a user to a room\n                     *\n                     * @param accessToken\n                     * @param user\n                     * @param room\n                     */\n                inviteToRoom(accessToken: string, user: string, room: MatrixRoom): Promise<MatrixRoomInviteResponse>;\n                /**\n                     * Join a specific room\n                     *\n                     * @param accessToken\n                     * @param room\n                     */\n                joinRoom(accessToken: string, room: MatrixRoom): Promise<MatrixRoomJoinResponse>;\n                /**\n                     * Get all joined rooms\n                     *\n                     * @param accessToken\n                     */\n                getJoinedRooms(accessToken: string): Promise<MatrixRoomJoinResponse>;\n        }\n    }\n    \n    module 'test/matrix-client/services/MatrixUserService' {\n        import { MatrixHttpClient } from 'test/matrix-client/MatrixHttpClient';\n        import { MatrixLoginResponse } from 'test/matrix-client/models/api/MatrixLogin';\n        export class MatrixUserService {\n            constructor(httpClient: MatrixHttpClient);\n            /**\n               * Log in to the matrix node with username and password\n               *\n               * @param user\n               * @param password\n               * @param deviceId\n               */\n            login(user: string, password: string, deviceId: string): Promise<MatrixLoginResponse>;\n        }\n    }\n    \n    module 'test/matrix-client/utils/events' {\n        import { MatrixStateEvent, MatrixStateEventMessageText } from 'test/matrix-client/models/MatrixStateEvent';\n        /**\n             * Check if an event is a create event\n             *\n             * @param event MatrixStateEvent\n             */\n        export const isCreateEvent: (event: MatrixStateEvent) => boolean;\n        /**\n             * Check if an event is a join event\n             *\n             * @param event MatrixStateEvent\n             */\n        export const isJoinEvent: (event: MatrixStateEvent) => boolean;\n        /**\n             * Check if an event is a message event\n             *\n             * @param event MatrixStateEvent\n             */\n        export const isMessageEvent: (event: MatrixStateEvent) => boolean;\n        /**\n             * Check if an event is a text message event\n             *\n             * @param event MatrixStateEvent\n             */\n        export const isTextMessageEvent: (event: MatrixStateEvent) => event is MatrixStateEventMessageText;\n    }\n    \n    module 'test/migrations/migrate-0.7.0' {\n        import { PermissionScope, AccountIdentifier, Origin, Network } from 'test/';\n        export interface AccountInfoOld {\n            accountIdentifier: AccountIdentifier;\n            beaconId: string;\n            origin: {\n                type: Origin;\n                id: string;\n            };\n            address: string;\n            pubkey: string;\n            network: Network;\n            scopes: PermissionScope[];\n            connectedAt: Date;\n        }\n        export interface P2PPairingRequestOld {\n            name: string;\n            pubKey: string;\n            relayServer: string;\n        }\n        export const migrate_0_7_0: (storage: Storage) => Promise<void>;\n    }\n    \n    module 'test/migrations/migrations' {\n        import { Storage } from 'test/';\n        export const migrate: (storage: Storage) => Promise<void>;\n    }\n    \n    module 'test/MockWindow' {\n        type Callback = (message: unknown) => void;\n        /**\n           * A mock for postmessage if run in node.js environment\n           */\n        let windowRef: {\n            postMessage: (message: string | Record<string, unknown>, _target?: string | undefined) => void;\n            addEventListener: (_name: string, eventCallback: Callback) => void;\n            removeEventListener: (_name: string, eventCallback: Callback) => void;\n            location: {\n                origin: string;\n            };\n        };\n        const clearMockWindowState: () => void;\n        export { windowRef, clearMockWindowState };\n    }\n    \n    module 'test/Serializer' {\n        /**\n             * The Serializer is used to serialize / deserialize JSON objects and encode them with bs58check\n             */\n        export class Serializer {\n                /**\n                     * Serialize and bs58check encode an object\n                     *\n                     * @param message JSON object to serialize\n                     */\n                serialize(message: unknown): Promise<string>;\n                /**\n                     * Deserialize a bs58check encoded string\n                     *\n                     * @param encoded String to be deserialized\n                     */\n                deserialize(encoded: string): Promise<unknown>;\n        }\n    }\n    \n    module 'test/storage/ChromeStorage' {\n        import { Storage, StorageKey, StorageKeyReturnType } from 'test/';\n        export class ChromeStorage implements Storage {\n            static isSupported(): Promise<boolean>;\n            get<K extends StorageKey>(key: K): Promise<StorageKeyReturnType[K]>;\n            set<K extends StorageKey>(key: K, value: StorageKeyReturnType[K]): Promise<void>;\n            delete<K extends StorageKey>(key: K): Promise<void>;\n        }\n    }\n    \n    module 'test/storage/getStorage' {\n        import { Storage } from 'test/';\n        /**\n           * Get a supported storage on this platform\n           */\n        export const getStorage: () => Promise<Storage>;\n    }\n    \n    module 'test/storage/LocalStorage' {\n        import { Storage, StorageKey, StorageKeyReturnType } from 'test/';\n        export class LocalStorage implements Storage {\n            constructor(prefix?: string | undefined);\n            static isSupported(): Promise<boolean>;\n            get<K extends StorageKey>(key: K): Promise<StorageKeyReturnType[K]>;\n            set<K extends StorageKey>(key: K, value: StorageKeyReturnType[K]): Promise<void>;\n            delete<K extends StorageKey>(key: K): Promise<void>;\n        }\n    }\n    \n    module 'test/storage/Storage' {\n        import { StorageKey } from 'test/types/storage/StorageKey';\n        import { StorageKeyReturnType } from 'test/types/storage/StorageKeyReturnType';\n        /**\n             * The storage used in the SDK\n             */\n        export abstract class Storage {\n                /**\n                     * Returns a promise that resolves to true if the storage option is available on this platform.\n                     */\n                static isSupported(): Promise<boolean>;\n                /**\n                     * Gets a value from storage and returns it\n                     *\n                     * @param key The storage key\n                     */\n                abstract get<K extends StorageKey>(key: K): Promise<StorageKeyReturnType[K]>;\n                /**\n                     * Sets a value in the storage and persist it\n                     *\n                     * @param key The storage key\n                     * @param value The value to be persisted\n                     */\n                abstract set<K extends StorageKey>(key: K, value: StorageKeyReturnType[K]): Promise<void>;\n                /**\n                     * Delete a key from storage\n                     *\n                     * @param key The storage key\n                     */\n                abstract delete<K extends StorageKey>(key: K): Promise<void>;\n        }\n    }\n    \n    module 'test/test' {\n    \n        export * from 'test/beacon-message-events';\n        export * from 'test/clients/beacon-client/BeaconClient';\n        export * from 'test/clients/beacon-client/BeaconClientOptions';\n        export * from 'test/clients/client/Client';\n        export * from 'test/clients/client/ClientOptions';\n        export * from 'test/clients/dapp-client/DAppClient';\n        export * from 'test/clients/dapp-client/DAppClientOptions';\n        export * from 'test/clients/wallet-client/WalletClient';\n        export * from 'test/clients/wallet-client/WalletClientOptions';\n        export * from 'test/colorMode';\n        export * from 'test/constants';\n        export * from 'test/debug';\n        export * from 'test/errors/AbortedBeaconError';\n        export * from 'test/errors/BeaconError';\n        export * from 'test/errors/BroadcastBeaconError';\n        export * from 'test/errors/NetworkNotSupportedBeaconError';\n        export * from 'test/errors/NoAddressBeaconError';\n        export * from 'test/errors/NoPrivateKeyBeaconError';\n        export * from 'test/errors/NotGrantedBeaconError';\n        export * from 'test/errors/ParametersInvalidBeaconError';\n        export * from 'test/errors/SignatureTypeNotSupportedBeaconError';\n        export * from 'test/errors/TooManyOperationsBeaconError';\n        export * from 'test/errors/TransactionInvalidBeaconError';\n        export * from 'test/errors/UnknownBeaconError';\n        export * from 'test/events';\n        export * from 'test/examples/broadcast-request';\n        export * from 'test/examples/custom-block-explorer';\n        export * from 'test/examples/disable-all-ui';\n        export * from 'test/examples/operation-request';\n        export * from 'test/examples/override-default-events';\n        export * from 'test/examples/permission-request';\n        export * from 'test/examples/sign-payload-request';\n        export * from 'test/examples/using-custom-network';\n        export * from 'test/examples/wallet-example';\n        export * from 'test/index';\n        export * from 'test/interceptors/IncomingRequestInterceptor';\n        export * from 'test/interceptors/OutgoingResponseInterceptor';\n        export * from 'test/managers/AccountManager';\n        export * from 'test/managers/AppMetadataManager';\n        export * from 'test/managers/PeerManager';\n        export * from 'test/managers/PermissionManager';\n        export * from 'test/managers/PermissionValidator';\n        export * from 'test/managers/StorageManager';\n        export * from 'test/matrix-client/MatrixClient';\n        export * from 'test/matrix-client/MatrixClientEventEmitter';\n        export * from 'test/matrix-client/MatrixClientStore';\n        export * from 'test/matrix-client/MatrixHttpClient';\n        export * from 'test/matrix-client/models/api/MatrixEventSend';\n        export * from 'test/matrix-client/models/api/MatrixLogin';\n        export * from 'test/matrix-client/models/api/MatrixRequest';\n        export * from 'test/matrix-client/models/api/MatrixRoomCreate';\n        export * from 'test/matrix-client/models/api/MatrixRoomInvite';\n        export * from 'test/matrix-client/models/api/MatrixRoomJoin';\n        export * from 'test/matrix-client/models/api/MatrixSync';\n        export * from 'test/matrix-client/models/MatrixClientEvent';\n        export * from 'test/matrix-client/models/MatrixMessage';\n        export * from 'test/matrix-client/models/MatrixRoom';\n        export * from 'test/matrix-client/models/MatrixStateEvent';\n        export * from 'test/matrix-client/services/MatrixEventService';\n        export * from 'test/matrix-client/services/MatrixRoomService';\n        export * from 'test/matrix-client/services/MatrixUserService';\n        export * from 'test/matrix-client/utils/events';\n        export * from 'test/migrations/migrate-0.7.0';\n        export * from 'test/migrations/migrations';\n        export * from 'test/MockWindow';\n        export * from 'test/Serializer';\n        export * from 'test/storage/ChromeStorage';\n        export * from 'test/storage/getStorage';\n        export * from 'test/storage/LocalStorage';\n        export * from 'test/storage/Storage';\n        export * from 'test/test';\n        export * from 'test/transports/clients/CommunicationClient';\n        export * from 'test/transports/clients/MessageBasedClient';\n        export * from 'test/transports/clients/P2PCommunicationClient';\n        export * from 'test/transports/clients/PostMessageClient';\n        export * from 'test/transports/DappP2PTransport';\n        export * from 'test/transports/DappPostMessageTransport';\n        export * from 'test/transports/P2PTransport';\n        export * from 'test/transports/PostMessageTransport';\n        export * from 'test/transports/Transport';\n        export * from 'test/transports/WalletP2PTransport';\n        export * from 'test/transports/WalletPostMessageTransport';\n        export * from 'test/types/AccountInfo';\n        export * from 'test/types/beacon/AppMetadata';\n        export * from 'test/types/beacon/BeaconBaseMessage';\n        export * from 'test/types/beacon/BeaconMessage';\n        export * from 'test/types/beacon/BeaconMessageType';\n        export * from 'test/types/beacon/BeaconRequestMessage';\n        export * from 'test/types/beacon/BeaconResponseMessage';\n        export * from 'test/types/beacon/messages/AcknowledgeResponse';\n        export * from 'test/types/beacon/messages/BeaconRequestInputMessage';\n        export * from 'test/types/beacon/messages/BeaconRequestOutputMessage';\n        export * from 'test/types/beacon/messages/BeaconResponseInputMessage';\n        export * from 'test/types/beacon/messages/BeaconResponseOutputMessage';\n        export * from 'test/types/beacon/messages/BroadcastRequest';\n        export * from 'test/types/beacon/messages/BroadcastResponse';\n        export * from 'test/types/beacon/messages/DisconnectMessage';\n        export * from 'test/types/beacon/messages/ErrorResponse';\n        export * from 'test/types/beacon/messages/OperationRequest';\n        export * from 'test/types/beacon/messages/OperationResponse';\n        export * from 'test/types/beacon/messages/PermissionRequest';\n        export * from 'test/types/beacon/messages/PermissionResponse';\n        export * from 'test/types/beacon/messages/SignPayloadRequest';\n        export * from 'test/types/beacon/messages/SignPayloadResponse';\n        export * from 'test/types/beacon/Network';\n        export * from 'test/types/beacon/NetworkType';\n        export * from 'test/types/beacon/PermissionScope';\n        export * from 'test/types/beacon/SigningType';\n        export * from 'test/types/beacon/Threshold';\n        export * from 'test/types/BeaconErrorType';\n        export * from 'test/types/ColorMode';\n        export * from 'test/types/ConnectionContext';\n        export * from 'test/types/Extension';\n        export * from 'test/types/ExtensionMessage';\n        export * from 'test/types/ExtensionMessageTarget';\n        export * from 'test/types/Origin';\n        export * from 'test/types/P2PPairingRequest';\n        export * from 'test/types/P2PPairingResponse';\n        export * from 'test/types/PeerInfo';\n        export * from 'test/types/PermissionEntity';\n        export * from 'test/types/PermissionInfo';\n        export * from 'test/types/PostMessagePairingRequest';\n        export * from 'test/types/PostMessagePairingResponse';\n        export * from 'test/types/RequestBroadcastInput';\n        export * from 'test/types/RequestOperationInput';\n        export * from 'test/types/RequestPermissionInput';\n        export * from 'test/types/RequestSignPayloadInput';\n        export * from 'test/types/storage/StorageKey';\n        export * from 'test/types/storage/StorageKeyReturnDefaults';\n        export * from 'test/types/storage/StorageKeyReturnType';\n        export * from 'test/types/tezos/MichelineMichelsonV1Expression';\n        export * from 'test/types/tezos/MichelsonPrimitives';\n        export * from 'test/types/tezos/operations/ActivateAccount';\n        export * from 'test/types/tezos/operations/Ballot';\n        export * from 'test/types/tezos/operations/Delegation';\n        export * from 'test/types/tezos/operations/DoubleBakingEvidence';\n        export * from 'test/types/tezos/operations/DoubleEndorsementEvidence';\n        export * from 'test/types/tezos/operations/Endorsement';\n        export * from 'test/types/tezos/operations/Origination';\n        export * from 'test/types/tezos/operations/Proposal';\n        export * from 'test/types/tezos/operations/Reveal';\n        export * from 'test/types/tezos/operations/SeedNonceRevelation';\n        export * from 'test/types/tezos/operations/Transaction';\n        export * from 'test/types/tezos/OperationTypes';\n        export * from 'test/types/tezos/PartialTezosOperation';\n        export * from 'test/types/tezos/TezosBaseOperation';\n        export * from 'test/types/tezos/TezosBlockHeader';\n        export * from 'test/types/tezos/TezosOperation';\n        export * from 'test/types/tezos/TezosTransactionParameters';\n        export * from 'test/types/transport/TransportStatus';\n        export * from 'test/types/transport/TransportType';\n        export * from 'test/ui/alert/alert-templates';\n        export * from 'test/ui/alert/Alert';\n        export * from 'test/ui/alert/Pairing';\n        export * from 'test/ui/alert/PairingAlert';\n        export * from 'test/ui/alert/wallet-lists';\n        export * from 'test/ui/toast/toast-templates';\n        export * from 'test/ui/toast/Toast';\n        export * from 'test/utils/assert-never';\n        export * from 'test/utils/available-transports';\n        export * from 'test/utils/block-explorer';\n        export * from 'test/utils/crypto';\n        export * from 'test/utils/exposed-promise';\n        export * from 'test/utils/generate-uuid';\n        export * from 'test/utils/get-account-identifier';\n        export * from 'test/utils/get-sender-id';\n        export * from 'test/utils/get-tzip10-link';\n        export * from 'test/utils/Logger';\n        export * from 'test/utils/platform';\n        export * from 'test/utils/qr';\n        export * from 'test/utils/replace-in-template';\n        export * from 'test/utils/shorten-string';\n        export * from 'test/utils/tezblock-blockexplorer';\n        export * from 'test/utils/utils';\n    \n        module 'test/beacon-message-events' {\n                import { BeaconEvent } from 'test/events';\n                import { BeaconMessageType } from 'test/';\n                export const messageEvents: {\n                        [key in BeaconMessageType]: {\n                                sent: BeaconEvent;\n                                success: BeaconEvent;\n                                error: BeaconEvent;\n                        };\n                };\n        }\n    \n        module 'test/clients/beacon-client/BeaconClient' {\n                import * as sodium from 'libsodium-wrappers';\n                import { ExposedPromise } from 'test/utils/exposed-promise';\n                import { Storage } from 'test/';\n                import { BeaconEventHandler } from 'test/events';\n                import { BeaconClientOptions } from 'test/clients/beacon-client/BeaconClientOptions';\n                /**\n                          * The beacon client is an abstract client that handles everything that is shared between all other clients.\n                          * Specifically, it handles managing the beaconId and and the local keypair.\n                          */\n                export abstract class BeaconClient {\n                                /**\n                                          * The name of the client\n                                          */\n                                readonly name: string;\n                                /**\n                                          * The URL of the dApp Icon. This can be used to display the icon of the dApp on in the wallet\n                                          */\n                                readonly iconUrl?: string;\n                                /**\n                                          * The URL of the dApp.\n                                          */\n                                readonly appUrl?: string;\n                                /** The beaconId is a public key that is used to identify one specific application (dapp or wallet).\n                                          * This is used inside a message to specify the sender, for example.\n                                          */\n                                protected _beaconId: ExposedPromise<string>;\n                                get beaconId(): Promise<string>;\n                                protected storage: Storage;\n                                protected readonly events: BeaconEventHandler;\n                                /**\n                                          * The local keypair that is used for the communication encryption\n                                          */\n                                protected _keyPair: ExposedPromise<sodium.KeyPair>;\n                                protected get keyPair(): Promise<sodium.KeyPair>;\n                                constructor(config: BeaconClientOptions);\n                                /**\n                                          * This resets the SDK. After using this method, this instance is no longer usable. You will have to instanciate a new client.\n                                          */\n                                destroy(): Promise<void>;\n                }\n        }\n    \n        module 'test/clients/beacon-client/BeaconClientOptions' {\n                import { Storage } from 'test/';\n                export interface BeaconClientOptions {\n                                /**\n                                          * Name of the application\n                                          */\n                                name: string;\n                                /**\n                                          * A URL to the icon of the application\n                                          */\n                                iconUrl?: string;\n                                /**\n                                          * A URL to the website of the application\n                                          */\n                                appUrl?: string;\n                                /**\n                                          * The storage that will be used by the SDK\n                                          */\n                                storage: Storage;\n                }\n        }\n    \n        module 'test/clients/client/Client' {\n                import { ExposedPromise } from 'test/utils/exposed-promise';\n                import { ConnectionContext } from 'test/types/ConnectionContext';\n                import { TransportType, TransportStatus, AccountInfo, PeerInfo, Transport, AppMetadata } from 'test/';\n                import { BeaconEventHandler } from 'test/events';\n                import { BeaconClient } from 'test/clients/beacon-client/BeaconClient';\n                import { AccountManager } from 'test/managers/AccountManager';\n                import { BeaconRequestMessage } from 'test/types/beacon/BeaconRequestMessage';\n                import { ClientOptions } from 'test/clients/client/ClientOptions';\n                /**\n                          * This abstract class handles the a big part of the logic that is shared between the dapp and wallet client.\n                          * For example, it selects and manages the transport and accounts.\n                          */\n                export abstract class Client extends BeaconClient {\n                                protected readonly accountManager: AccountManager;\n                                protected handleResponse: (_event: BeaconRequestMessage, connectionInfo: ConnectionContext) => void;\n                                /**\n                                          * How many requests can be sent after another\n                                          */\n                                protected readonly rateLimit: number;\n                                /**\n                                          * The time window in seconds in which the \"rateLimit\" is checked\n                                          */\n                                protected readonly rateLimitWindowInSeconds: number;\n                                /**\n                                          * Stores the times when requests have been made to determine if the rate limit has been reached\n                                          */\n                                protected requestCounter: number[];\n                                protected readonly events: BeaconEventHandler;\n                                protected readonly matrixNodes: string[];\n                                protected _transport: ExposedPromise<Transport<any>>;\n                                protected get transport(): Promise<Transport<any>>;\n                                /**\n                                          * Returns the connection status of the Client\n                                          */\n                                get connectionStatus(): TransportStatus;\n                                /**\n                                          * Returns whether or not the transaport is ready\n                                          */\n                                get ready(): Promise<void>;\n                                constructor(config: ClientOptions);\n                                /**\n                                          * Return all locally known accounts\n                                          */\n                                getAccounts(): Promise<AccountInfo[]>;\n                                /**\n                                          * Return the account by ID\n                                          * @param accountIdentifier The ID of an account\n                                          */\n                                getAccount(accountIdentifier: string): Promise<AccountInfo | undefined>;\n                                /**\n                                          * Remove the account by ID\n                                          * @param accountIdentifier The ID of an account\n                                          */\n                                removeAccount(accountIdentifier: string): Promise<void>;\n                                /**\n                                          * Remove all locally stored accounts\n                                          */\n                                removeAllAccounts(): Promise<void>;\n                                /**\n                                          * Add a new request (current timestamp) to the pending requests, remove old ones and check if we are above the limit\n                                          */\n                                addRequestAndCheckIfRateLimited(): Promise<boolean>;\n                                /**\n                                          * This method initializes the client. It will check if the connection should be established to a\n                                          * browser extension or if the P2P transport should be used.\n                                          *\n                                          * @param transport A transport that can be provided by the user\n                                          */\n                                init(transport: Transport<any>): Promise<TransportType>;\n                                /**\n                                          * Returns the metadata of this DApp\n                                          */\n                                getOwnAppMetadata(): Promise<AppMetadata>;\n                                /**\n                                          * Return all known peers\n                                          */\n                                getPeers(): Promise<PeerInfo[]>;\n                                /**\n                                          * Add a new peer to the known peers\n                                          * @param peer The new peer to add\n                                          */\n                                addPeer(peer: PeerInfo): Promise<void>;\n                                /**\n                                          * A \"setter\" for when the transport needs to be changed.\n                                          */\n                                protected setTransport(transport?: Transport<any>): Promise<void>;\n                                protected addListener(transport: Transport<any>): Promise<void>;\n                                protected sendDisconnectToPeer(peer: PeerInfo, transport?: Transport<any>): Promise<void>;\n                }\n        }\n    \n        module 'test/clients/client/ClientOptions' {\n                import { Storage } from 'test/';\n                import { BeaconEvent, BeaconEventHandlerFunction, BeaconEventType } from 'test/events';\n                export interface ClientOptions {\n                                /**\n                                          * Name of the application\n                                          */\n                                name: string;\n                                /**\n                                          * A URL to the icon of the application\n                                          */\n                                iconUrl?: string;\n                                /**\n                                          * A URL to the website of the application\n                                          */\n                                appUrl?: string;\n                                /**\n                                          * The storage that will be used by the SDK\n                                          */\n                                storage: Storage;\n                                /**\n                                          * An object that will be used to overwrite default event handler behaviour.\n                                          *\n                                          * If you plan to overwrite all default events, use \"disableDefaultEvents\" instead.\n                                          *\n                                          * This will overwrite the default event handler, so this can lead to unexpected behavior in some cases.\n                                          * We recommend that you overwrite all handlers if you want to use your own UI.\n                                          *\n                                          * If you simply want to be notified of events happening, but do not want to overwrite the default behavior,\n                                          * please use `subscribeToEvent()` on the DAppClient instead.\n                                          */\n                                eventHandlers?: {\n                                                [key in BeaconEvent]?: {\n                                                                handler: BeaconEventHandlerFunction<BeaconEventType[key]>;\n                                                };\n                                };\n                                /**\n                                          * Disable all default Events and UI elements. If passed together with \"eventHandlers\",\n                                          * the default eventHandlers will be removed, and the ones passed by the user will be added.\n                                          */\n                                disableDefaultEvents?: boolean;\n                                /**\n                                          * A list of matrix nodes to connect to. If a non-empty array is passed, the default options will be overwritten.\n                                          * One node will be randomly selected based on the local keypair and the other nodes will be used as a fallback in case the primary node goes down.\n                                          *\n                                          * Only provide the hostname, no https:// prefix. Eg. ['matrix.example.com']\n                                          */\n                                matrixNodes?: string[];\n                }\n        }\n    \n        module 'test/clients/dapp-client/DAppClient' {\n                import { BeaconEvent, BeaconEventHandlerFunction, BeaconEventType } from 'test/events';\n                import { AccountInfo, Client, TransportType, BeaconMessageType, NetworkType, RequestPermissionInput, RequestSignPayloadInput, RequestOperationInput, RequestBroadcastInput, PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, Transport, DappP2PTransport, DappPostMessageTransport, AppMetadata } from 'test/';\n                import { BlockExplorer } from 'test/utils/block-explorer';\n                import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n                import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n                import { ExtendedPeerInfo } from 'test/types/PeerInfo';\n                import { ColorMode } from 'test/types/ColorMode';\n                import { DAppClientOptions } from 'test/clients/dapp-client/DAppClientOptions';\n                /**\n                          * The DAppClient has to be used in decentralized applications. It handles all the logic related to connecting to beacon-compatible\n                          * wallets and sending requests.\n                          */\n                export class DAppClient extends Client {\n                                /**\n                                          * The block explorer used by the SDK\n                                          */\n                                readonly blockExplorer: BlockExplorer;\n                                preferredNetwork: NetworkType;\n                                protected postMessageTransport: DappPostMessageTransport | undefined;\n                                protected p2pTransport: DappP2PTransport | undefined;\n                                constructor(config: DAppClientOptions);\n                                initInternalTransports(): Promise<void>;\n                                init(transport?: Transport<any>): Promise<TransportType>;\n                                /**\n                                          * Returns the active account\n                                          */\n                                getActiveAccount(): Promise<AccountInfo | undefined>;\n                                /**\n                                          * Sets the active account\n                                          *\n                                          * @param account The account that will be set as the active account\n                                          */\n                                setActiveAccount(account?: AccountInfo): Promise<void>;\n                                /**\n                                          * Clear the active account\n                                          */\n                                clearActiveAccount(): Promise<void>;\n                                setColorMode(colorMode: ColorMode): Promise<void>;\n                                getColorMode(): Promise<ColorMode>;\n                                /**\n                                          * @deprecated\n                                          *\n                                          * Use getOwnAppMetadata instead\n                                          */\n                                getAppMetadata(): Promise<AppMetadata>;\n                                /**\n                                          * Will remove the account from the local storage and set a new active account if necessary.\n                                          *\n                                          * @param accountIdentifier ID of the account\n                                          */\n                                removeAccount(accountIdentifier: string): Promise<void>;\n                                /**\n                                          * Remove all accounts and set active account to undefined\n                                          */\n                                removeAllAccounts(): Promise<void>;\n                                /**\n                                          * Removes a peer and all the accounts that have been connected through that peer\n                                          *\n                                          * @param peer Peer to be removed\n                                          */\n                                removePeer(peer: ExtendedPeerInfo, sendDisconnectToPeer?: boolean): Promise<void>;\n                                /**\n                                          * Remove all peers and all accounts that have been connected through those peers\n                                          */\n                                removeAllPeers(sendDisconnectToPeers?: boolean): Promise<void>;\n                                /**\n                                          * Allows the user to subscribe to specific events that are fired in the SDK\n                                          *\n                                          * @param internalEvent The event to subscribe to\n                                          * @param eventCallback The callback that will be called when the event occurs\n                                          */\n                                subscribeToEvent<K extends BeaconEvent>(internalEvent: K, eventCallback: BeaconEventHandlerFunction<BeaconEventType[K]>): Promise<void>;\n                                /**\n                                          * Check if we have permissions to send the specific message type to the active account.\n                                          * If no active account is set, only permission requests are allowed.\n                                          *\n                                          * @param type The type of the message\n                                          */\n                                checkPermissions(type: BeaconMessageType): Promise<boolean>;\n                                /**\n                                          * Send a permission request to the DApp. This should be done as the first step. The wallet will respond\n                                          * with an publicKey and permissions that were given. The account returned will be set as the \"activeAccount\"\n                                          * and will be used for the following requests.\n                                          *\n                                          * @param input The message details we need to prepare the PermissionRequest message.\n                                          */\n                                requestPermissions(input?: RequestPermissionInput): Promise<PermissionResponseOutput>;\n                                /**\n                                          * This method will send a \"SignPayloadRequest\" to the wallet. This method is meant to be used to sign\n                                          * arbitrary data (eg. a string). It will return the signature in the format of \"edsig...\"\n                                          *\n                                          * @param input The message details we need to prepare the SignPayloadRequest message.\n                                          */\n                                requestSignPayload(input: RequestSignPayloadInput): Promise<SignPayloadResponseOutput>;\n                                /**\n                                          * This method sends an OperationRequest to the wallet. This method should be used for all kinds of operations,\n                                          * eg. transaction or delegation. Not all properties have to be provided. Data like \"counter\" and fees will be\n                                          * fetched and calculated by the wallet (but they can still be provided if required).\n                                          *\n                                          * @param input The message details we need to prepare the OperationRequest message.\n                                          */\n                                requestOperation(input: RequestOperationInput): Promise<OperationResponseOutput>;\n                                /**\n                                          * Sends a \"BroadcastRequest\" to the wallet. This method can be used to inject an already signed transaction\n                                          * to the network.\n                                          *\n                                          * @param input The message details we need to prepare the BroadcastRequest message.\n                                          */\n                                requestBroadcast(input: RequestBroadcastInput): Promise<BroadcastResponseOutput>;\n                                protected setActivePeer(peer?: ExtendedPostMessagePairingResponse | ExtendedP2PPairingResponse): Promise<void>;\n                                /**\n                                          * A \"setter\" for when the transport needs to be changed.\n                                          */\n                                protected setTransport(transport?: Transport<any>): Promise<void>;\n                }\n        }\n    \n        module 'test/clients/dapp-client/DAppClientOptions' {\n                import { NetworkType, Storage } from 'test/';\n                import { BeaconEvent, BeaconEventType, BeaconEventHandlerFunction } from 'test/events';\n                import { ColorMode } from 'test/types/ColorMode';\n                import { BlockExplorer } from 'test/utils/block-explorer';\n                export interface DAppClientOptions {\n                                /**\n                                          * Name of the application\n                                          */\n                                name: string;\n                                /**\n                                          * A URL to the icon of the application\n                                          */\n                                iconUrl?: string;\n                                /**\n                                          * A URL to the website of the application\n                                          */\n                                appUrl?: string;\n                                /**\n                                          * The storage that will be used by the SDK\n                                          */\n                                storage?: Storage;\n                                /**\n                                          * An object that will be used to overwrite default event handler behaviour.\n                                          *\n                                          * If you plan to overwrite all default events, use \"disableDefaultEvents\" instead.\n                                          *\n                                          * This will overwrite the default event handler, so this can lead to unexpected behavior in some cases.\n                                          * We recommend that you overwrite all handlers if you want to use your own UI.\n                                          *\n                                          * If you simply want to be notified of events happening, but do not want to overwrite the default behavior,\n                                          * please use `subscribeToEvent()` on the DAppClient instead.\n                                          */\n                                eventHandlers?: {\n                                                [key in BeaconEvent]?: {\n                                                                handler: BeaconEventHandlerFunction<BeaconEventType[key]>;\n                                                };\n                                };\n                                /**\n                                          * Disable all default Events and UI elements. If passed together with \"eventHandlers\",\n                                          * the default eventHandlers will be removed, and the ones passed by the user will be added.\n                                          */\n                                disableDefaultEvents?: boolean;\n                                /**\n                                          * A list of matrix nodes to connect to. If a non-empty array is passed, the default options will be overwritten.\n                                          * One node will be randomly selected based on the local keypair and the other nodes will be used as a fallback in case the primary node goes down.\n                                          *\n                                          * Only provide the hostname, no https:// prefix. Eg. ['matrix.example.com']\n                                          */\n                                matrixNodes?: string[];\n                                /**\n                                          * The block explorer used by the SDK\n                                          */\n                                blockExplorer?: BlockExplorer;\n                                /**\n                                          * Indicates on which network the DApp is planning to run. This is currently used to adjust the URLs of web-wallets in the pairing alert if they use different URLs for testnets.\n                                          * You will still have to define the network you intend to use during the permission request.\n                                          */\n                                preferredNetwork?: NetworkType;\n                                /**\n                                          * Set the color mode for the UI elements (alerts and toasts)\n                                          */\n                                colorMode?: ColorMode;\n                }\n        }\n    \n        module 'test/clients/wallet-client/WalletClient' {\n                import { Client, WalletClientOptions, TransportType, BeaconRequestOutputMessage, BeaconResponseInputMessage, AppMetadata, PermissionInfo } from 'test/';\n                import { ConnectionContext } from 'test/types/ConnectionContext';\n                import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n                import { ExposedPromise } from 'test/utils/exposed-promise';\n                import { PeerInfo } from 'test/types/PeerInfo';\n                /**\n                          * The WalletClient has to be used in the wallet. It handles all the logic related to connecting to beacon-compatible\n                          * dapps and handling/responding to requests.\n                          */\n                export class WalletClient extends Client {\n                                /**\n                                          * Returns whether or not the transport is connected\n                                          */\n                                protected readonly _isConnected: ExposedPromise<boolean>;\n                                get isConnected(): Promise<boolean>;\n                                constructor(config: WalletClientOptions);\n                                init(): Promise<TransportType>;\n                                /**\n                                          * This method initiates a connection to the P2P network and registers a callback that will be called\n                                          * whenever a message is received.\n                                          *\n                                          * @param newMessageCallback The callback that will be invoked for every message the transport receives.\n                                          */\n                                connect(newMessageCallback: (message: BeaconRequestOutputMessage, connectionContext: ConnectionContext) => void): Promise<void>;\n                                /**\n                                          * The method will attempt to initiate a connection using the active transport.\n                                          */\n                                _connect(): Promise<void>;\n                                /**\n                                          * This method sends a response for a specific request back to the DApp\n                                          *\n                                          * @param message The BeaconResponseMessage that will be sent back to the DApp\n                                          */\n                                respond(message: BeaconResponseInputMessage): Promise<void>;\n                                getAppMetadataList(): Promise<AppMetadata[]>;\n                                getAppMetadata(senderId: string): Promise<AppMetadata | undefined>;\n                                removeAppMetadata(senderId: string): Promise<void>;\n                                removeAllAppMetadata(): Promise<void>;\n                                getPermissions(): Promise<PermissionInfo[]>;\n                                getPermission(accountIdentifier: string): Promise<PermissionInfo | undefined>;\n                                removePermission(accountIdentifier: string): Promise<void>;\n                                removeAllPermissions(): Promise<void>;\n                                /**\n                                          * Add a new peer to the known peers\n                                          * @param peer The new peer to add\n                                          */\n                                addPeer(peer: PeerInfo): Promise<void>;\n                                removePeer(peer: ExtendedP2PPairingResponse, sendDisconnectToPeer?: boolean): Promise<void>;\n                                removeAllPeers(sendDisconnectToPeers?: boolean): Promise<void>;\n                }\n        }\n    \n        module 'test/clients/wallet-client/WalletClientOptions' {\n                import { Storage } from 'test/';\n                export interface WalletClientOptions {\n                                /**\n                                          * Name of the application\n                                          */\n                                name: string;\n                                /**\n                                          * A URL to the icon of the application\n                                          */\n                                iconUrl?: string;\n                                /**\n                                          * A URL to the website of the application\n                                          */\n                                appUrl?: string;\n                                /**\n                                          * The storage that will be used by the SDK\n                                          */\n                                storage?: Storage;\n                                /**\n                                          * A list of matrix nodes to connect to. If a non-empty array is passed, the default options will be overwritten.\n                                          * One node will be randomly selected based on the local keypair and the other nodes will be used as a fallback in case the primary node goes down.\n                                          *\n                                          * Only provide the hostname, no https:// prefix. Eg. ['matrix.example.com']\n                                          */\n                                matrixNodes?: string[];\n                }\n        }\n    \n        module 'test/colorMode' {\n                import { ColorMode } from 'test/types/ColorMode';\n                export const setColorMode: (mode: ColorMode) => void;\n                export const getColorMode: () => ColorMode;\n        }\n    \n        module 'test/constants' {\n                export const SDK_VERSION: string;\n                export const BEACON_VERSION: string;\n        }\n    \n        module 'test/debug' {\n                export const setDebugEnabled: (enabled: boolean) => void;\n                export const getDebugEnabled: () => boolean;\n        }\n    \n        module 'test/errors/AbortedBeaconError' {\n                import { BeaconError } from 'test/';\n                export class AbortedBeaconError extends BeaconError {\n                        name: string;\n                        title: string;\n                        constructor();\n                }\n        }\n    \n        module 'test/errors/BeaconError' {\n                import { BeaconErrorType } from 'test/';\n                export abstract class BeaconError implements Error {\n                        name: string;\n                        message: string;\n                        title: string;\n                        description: string;\n                        get fullDescription(): string;\n                        constructor(errorType: BeaconErrorType, message: string);\n                        static getError(errorType: BeaconErrorType, errorData: any): BeaconError;\n                }\n        }\n    \n        module 'test/errors/BroadcastBeaconError' {\n                import { BeaconError } from 'test/';\n                export class BroadcastBeaconError extends BeaconError {\n                        name: string;\n                        title: string;\n                        constructor();\n                }\n        }\n    \n        module 'test/errors/NetworkNotSupportedBeaconError' {\n                import { BeaconError } from 'test/';\n                export class NetworkNotSupportedBeaconError extends BeaconError {\n                        name: string;\n                        title: string;\n                        constructor();\n                }\n        }\n    \n        module 'test/errors/NoAddressBeaconError' {\n                import { BeaconError } from 'test/';\n                export class NoAddressBeaconError extends BeaconError {\n                        name: string;\n                        title: string;\n                        constructor();\n                }\n        }\n    \n        module 'test/errors/NoPrivateKeyBeaconError' {\n                import { BeaconError } from 'test/';\n                export class NoPrivateKeyBeaconError extends BeaconError {\n                        name: string;\n                        title: string;\n                        constructor();\n                }\n        }\n    \n        module 'test/errors/NotGrantedBeaconError' {\n                import { BeaconError } from 'test/';\n                export class NotGrantedBeaconError extends BeaconError {\n                        name: string;\n                        title: string;\n                        constructor();\n                }\n        }\n    \n        module 'test/errors/ParametersInvalidBeaconError' {\n                import { BeaconError } from 'test/';\n                export class ParametersInvalidBeaconError extends BeaconError {\n                        name: string;\n                        title: string;\n                        constructor();\n                }\n        }\n    \n        module 'test/errors/SignatureTypeNotSupportedBeaconError' {\n                import { BeaconError } from 'test/';\n                export class SignatureTypeNotSupportedBeaconError extends BeaconError {\n                        name: string;\n                        title: string;\n                        constructor();\n                }\n        }\n    \n        module 'test/errors/TooManyOperationsBeaconError' {\n                import { BeaconError } from 'test/';\n                export class TooManyOperationsBeaconError extends BeaconError {\n                        name: string;\n                        title: string;\n                        constructor();\n                }\n        }\n    \n        module 'test/errors/TransactionInvalidBeaconError' {\n                import { BeaconError } from 'test/';\n                export class TransactionInvalidBeaconError extends BeaconError {\n                        readonly data: any;\n                        name: string;\n                        title: string;\n                        get fullDescription(): string;\n                        constructor(data: any);\n                }\n        }\n    \n        module 'test/errors/UnknownBeaconError' {\n                import { BeaconError } from 'test/';\n                export class UnknownBeaconError extends BeaconError {\n                        name: string;\n                        title: string;\n                        constructor();\n                }\n        }\n    \n        module 'test/events' {\n                import { AlertButton } from 'test/ui/alert/Alert';\n                import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n                import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n                import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n                import { BlockExplorer } from 'test/utils/block-explorer';\n                import { P2PPairingRequest, AccountInfo, ErrorResponse, PermissionResponseOutput, OperationResponseOutput, BroadcastResponseOutput, SignPayloadResponseOutput, Network, ConnectionContext, Transport, NetworkType, AcknowledgeResponse } from 'test/';\n                /**\n                          * The different events that can be emitted by the beacon-sdk\n                          */\n                export enum BeaconEvent {\n                                PERMISSION_REQUEST_SENT = \"PERMISSION_REQUEST_SENT\",\n                                PERMISSION_REQUEST_SUCCESS = \"PERMISSION_REQUEST_SUCCESS\",\n                                PERMISSION_REQUEST_ERROR = \"PERMISSION_REQUEST_ERROR\",\n                                OPERATION_REQUEST_SENT = \"OPERATION_REQUEST_SENT\",\n                                OPERATION_REQUEST_SUCCESS = \"OPERATION_REQUEST_SUCCESS\",\n                                OPERATION_REQUEST_ERROR = \"OPERATION_REQUEST_ERROR\",\n                                SIGN_REQUEST_SENT = \"SIGN_REQUEST_SENT\",\n                                SIGN_REQUEST_SUCCESS = \"SIGN_REQUEST_SUCCESS\",\n                                SIGN_REQUEST_ERROR = \"SIGN_REQUEST_ERROR\",\n                                BROADCAST_REQUEST_SENT = \"BROADCAST_REQUEST_SENT\",\n                                BROADCAST_REQUEST_SUCCESS = \"BROADCAST_REQUEST_SUCCESS\",\n                                BROADCAST_REQUEST_ERROR = \"BROADCAST_REQUEST_ERROR\",\n                                ACKNOWLEDGE_RECEIVED = \"ACKNOWLEDGE_RECEIVED\",\n                                LOCAL_RATE_LIMIT_REACHED = \"LOCAL_RATE_LIMIT_REACHED\",\n                                NO_PERMISSIONS = \"NO_PERMISSIONS\",\n                                ACTIVE_ACCOUNT_SET = \"ACTIVE_ACCOUNT_SET\",\n                                ACTIVE_TRANSPORT_SET = \"ACTIVE_TRANSPORT_SET\",\n                                PAIR_INIT = \"PAIR_INIT\",\n                                PAIR_SUCCESS = \"PAIR_SUCCESS\",\n                                CHANNEL_CLOSED = \"CHANNEL_CLOSED\",\n                                INTERNAL_ERROR = \"INTERNAL_ERROR\",\n                                UNKNOWN = \"UNKNOWN\"\n                }\n                export interface WalletInfo {\n                                name: string;\n                                icon?: string;\n                }\n                export interface ExtraInfo {\n                                resetCallback?(): Promise<void>;\n                }\n                interface RequestSentInfo {\n                                extraInfo: ExtraInfo;\n                                walletInfo: WalletInfo;\n                }\n                /**\n                          * The type of the payload of the different BeaconEvents\n                          */\n                export interface BeaconEventType {\n                                [BeaconEvent.PERMISSION_REQUEST_SENT]: RequestSentInfo;\n                                [BeaconEvent.PERMISSION_REQUEST_SUCCESS]: {\n                                                account: AccountInfo;\n                                                output: PermissionResponseOutput;\n                                                blockExplorer: BlockExplorer;\n                                                connectionContext: ConnectionContext;\n                                                walletInfo: WalletInfo;\n                                };\n                                [BeaconEvent.PERMISSION_REQUEST_ERROR]: {\n                                                errorResponse: ErrorResponse;\n                                                walletInfo: WalletInfo;\n                                };\n                                [BeaconEvent.OPERATION_REQUEST_SENT]: RequestSentInfo;\n                                [BeaconEvent.OPERATION_REQUEST_SUCCESS]: {\n                                                account: AccountInfo;\n                                                output: OperationResponseOutput;\n                                                blockExplorer: BlockExplorer;\n                                                connectionContext: ConnectionContext;\n                                                walletInfo: WalletInfo;\n                                };\n                                [BeaconEvent.OPERATION_REQUEST_ERROR]: {\n                                                errorResponse: ErrorResponse;\n                                                walletInfo: WalletInfo;\n                                };\n                                [BeaconEvent.SIGN_REQUEST_SENT]: RequestSentInfo;\n                                [BeaconEvent.SIGN_REQUEST_SUCCESS]: {\n                                                output: SignPayloadResponseOutput;\n                                                connectionContext: ConnectionContext;\n                                                walletInfo: WalletInfo;\n                                };\n                                [BeaconEvent.SIGN_REQUEST_ERROR]: {\n                                                errorResponse: ErrorResponse;\n                                                walletInfo: WalletInfo;\n                                };\n                                [BeaconEvent.BROADCAST_REQUEST_SENT]: RequestSentInfo;\n                                [BeaconEvent.BROADCAST_REQUEST_SUCCESS]: {\n                                                network: Network;\n                                                output: BroadcastResponseOutput;\n                                                blockExplorer: BlockExplorer;\n                                                connectionContext: ConnectionContext;\n                                                walletInfo: WalletInfo;\n                                };\n                                [BeaconEvent.BROADCAST_REQUEST_ERROR]: {\n                                                errorResponse: ErrorResponse;\n                                                walletInfo: WalletInfo;\n                                };\n                                [BeaconEvent.ACKNOWLEDGE_RECEIVED]: {\n                                                message: AcknowledgeResponse;\n                                                extraInfo: ExtraInfo;\n                                                walletInfo: WalletInfo;\n                                };\n                                [BeaconEvent.LOCAL_RATE_LIMIT_REACHED]: undefined;\n                                [BeaconEvent.NO_PERMISSIONS]: undefined;\n                                [BeaconEvent.ACTIVE_ACCOUNT_SET]: AccountInfo;\n                                [BeaconEvent.ACTIVE_TRANSPORT_SET]: Transport;\n                                [BeaconEvent.PAIR_INIT]: {\n                                                p2pPeerInfo: P2PPairingRequest;\n                                                postmessagePeerInfo: PostMessagePairingRequest;\n                                                preferredNetwork: NetworkType;\n                                                abortedHandler?(): void;\n                                };\n                                [BeaconEvent.PAIR_SUCCESS]: ExtendedPostMessagePairingResponse | ExtendedP2PPairingResponse;\n                                [BeaconEvent.CHANNEL_CLOSED]: string;\n                                [BeaconEvent.INTERNAL_ERROR]: string;\n                                [BeaconEvent.UNKNOWN]: undefined;\n                }\n                export type BeaconEventHandlerFunction<T = unknown> = (data: T, eventCallback?: AlertButton[]) => void | Promise<void>;\n                /**\n                          * The default event handlers\n                          */\n                export const defaultEventCallbacks: {\n                                [key in BeaconEvent]: BeaconEventHandlerFunction<BeaconEventType[key]>;\n                };\n                /**\n                          * Handles beacon events\n                          */\n                export class BeaconEventHandler {\n                                constructor(eventsToOverride?: {\n                                                [key in BeaconEvent]?: {\n                                                                handler: BeaconEventHandlerFunction<BeaconEventType[key]>;\n                                                };\n                                }, overrideAll?: boolean);\n                                /**\n                                          * A method to subscribe to a specific beacon event and register a callback\n                                          *\n                                          * @param event The event being emitted\n                                          * @param eventCallback The callback that will be invoked\n                                          */\n                                on<K extends BeaconEvent>(event: K, eventCallback: BeaconEventHandlerFunction<BeaconEventType[K]>): Promise<void>;\n                                /**\n                                          * Emit a beacon event\n                                          *\n                                          * @param event The event being emitted\n                                          * @param data The data to be emit\n                                          */\n                                emit<K extends BeaconEvent>(event: K, data?: BeaconEventType[K], eventCallback?: AlertButton[]): Promise<void>;\n                }\n                export {};\n        }\n    \n        module 'test/examples/broadcast-request' {\n                export {};\n        }\n    \n        module 'test/examples/custom-block-explorer' {\n                export {};\n        }\n    \n        module 'test/examples/disable-all-ui' {\n                export {};\n        }\n    \n        module 'test/examples/operation-request' {\n                export {};\n        }\n    \n        module 'test/examples/override-default-events' {\n                export {};\n        }\n    \n        module 'test/examples/permission-request' {\n                export {};\n        }\n    \n        module 'test/examples/sign-payload-request' {\n                export {};\n        }\n    \n        module 'test/examples/using-custom-network' {\n                export {};\n        }\n    \n        module 'test/examples/wallet-example' {\n                export {};\n        }\n    \n        module 'test/index' {\n                import { P2PCommunicationClient } from 'test/transports/clients/P2PCommunicationClient';\n                import { AppMetadata } from 'test/types/beacon/AppMetadata';\n                import { PermissionRequest } from 'test/types/beacon/messages/PermissionRequest';\n                import { Network } from 'test/types/beacon/Network';\n                import { BeaconBaseMessage } from 'test/types/beacon/BeaconBaseMessage';\n                import { BeaconMessageType } from 'test/types/beacon/BeaconMessageType';\n                import { PermissionScope } from 'test/types/beacon/PermissionScope';\n                import { PermissionResponse } from 'test/types/beacon/messages/PermissionResponse';\n                import { OperationRequest } from 'test/types/beacon/messages/OperationRequest';\n                import { OperationResponse } from 'test/types/beacon/messages/OperationResponse';\n                import { SignPayloadRequest } from 'test/types/beacon/messages/SignPayloadRequest';\n                import { SignPayloadResponse } from 'test/types/beacon/messages/SignPayloadResponse';\n                import { BroadcastRequest } from 'test/types/beacon/messages/BroadcastRequest';\n                import { BroadcastResponse } from 'test/types/beacon/messages/BroadcastResponse';\n                import { NetworkType } from 'test/types/beacon/NetworkType';\n                import { TezosBaseOperation } from 'test/types/tezos/TezosBaseOperation';\n                import { TezosOperationType } from 'test/types/tezos/OperationTypes';\n                import { TezosActivateAccountOperation } from 'test/types/tezos/operations/ActivateAccount';\n                import { TezosBallotOperation } from 'test/types/tezos/operations/Ballot';\n                import { TezosDelegationOperation } from 'test/types/tezos/operations/Delegation';\n                import { TezosDoubleBakingEvidenceOperation } from 'test/types/tezos/operations/DoubleBakingEvidence';\n                import { TezosBlockHeader } from 'test/types/tezos/TezosBlockHeader';\n                import { TezosDoubleEndorsementEvidenceOperation } from 'test/types/tezos/operations/DoubleEndorsementEvidence';\n                import { TezosEndorsementOperation } from 'test/types/tezos/operations/Endorsement';\n                import { TezosOriginationOperation } from 'test/types/tezos/operations/Origination';\n                import { TezosProposalOperation } from 'test/types/tezos/operations/Proposal';\n                import { TezosRevealOperation } from 'test/types/tezos/operations/Reveal';\n                import { TezosSeedNonceRevelationOperation } from 'test/types/tezos/operations/SeedNonceRevelation';\n                import { TezosTransactionOperation } from 'test/types/tezos/operations/Transaction';\n                import { MichelsonPrimitives } from 'test/types/tezos/MichelsonPrimitives';\n                import { TezosTransactionParameters } from 'test/types/tezos/TezosTransactionParameters';\n                import { Origin } from 'test/types/Origin';\n                import { AccountInfo, AccountIdentifier } from 'test/types/AccountInfo';\n                import { EncryptedExtensionMessage, ExtensionMessage } from 'test/types/ExtensionMessage';\n                import { ExtensionMessageTarget } from 'test/types/ExtensionMessageTarget';\n                import { TezosOperation } from 'test/types/tezos/TezosOperation';\n                import { Client } from 'test/clients/client/Client';\n                import { WalletClient } from 'test/clients/wallet-client/WalletClient';\n                import { DAppClient } from 'test/clients/dapp-client/DAppClient';\n                import { BeaconError } from 'test/errors/BeaconError';\n                import { BeaconErrorType } from 'test/types/BeaconErrorType';\n                import { BroadcastBeaconError } from 'test/errors/BroadcastBeaconError';\n                import { NetworkNotSupportedBeaconError } from 'test/errors/NetworkNotSupportedBeaconError';\n                import { NoAddressBeaconError } from 'test/errors/NoAddressBeaconError';\n                import { NoPrivateKeyBeaconError } from 'test/errors/NoPrivateKeyBeaconError';\n                import { NotGrantedBeaconError } from 'test/errors/NotGrantedBeaconError';\n                import { ParametersInvalidBeaconError } from 'test/errors/ParametersInvalidBeaconError';\n                import { TooManyOperationsBeaconError } from 'test/errors/TooManyOperationsBeaconError';\n                import { TransactionInvalidBeaconError } from 'test/errors/TransactionInvalidBeaconError';\n                import { UnknownBeaconError } from 'test/errors/UnknownBeaconError';\n                import { ErrorResponse } from 'test/types/beacon/messages/ErrorResponse';\n                import { TransportStatus } from 'test/types/transport/TransportStatus';\n                import { TransportType } from 'test/types/transport/TransportType';\n                import { PostMessageTransport } from 'test/transports/PostMessageTransport';\n                import { Transport } from 'test/transports/Transport';\n                import { P2PTransport } from 'test/transports/P2PTransport';\n                import { Storage } from 'test/storage/Storage';\n                import { StorageKey } from 'test/types/storage/StorageKey';\n                import { StorageKeyReturnDefaults } from 'test/types/storage/StorageKeyReturnDefaults';\n                import { StorageKeyReturnType } from 'test/types/storage/StorageKeyReturnType';\n                import { ExtendedP2PPairingRequest, P2PPairingRequest } from 'test/types/P2PPairingRequest';\n                import { ChromeStorage } from 'test/storage/ChromeStorage';\n                import { LocalStorage } from 'test/storage/LocalStorage';\n                import { getStorage } from 'test/storage/getStorage';\n                import { BeaconMessage } from 'test/types/beacon/BeaconMessage';\n                import { Serializer } from 'test/Serializer';\n                import { RequestPermissionInput } from 'test/types/RequestPermissionInput';\n                import { RequestSignPayloadInput } from 'test/types/RequestSignPayloadInput';\n                import { RequestOperationInput } from 'test/types/RequestOperationInput';\n                import { RequestBroadcastInput } from 'test/types/RequestBroadcastInput';\n                import { PermissionResponseInput, SignPayloadResponseInput, OperationResponseInput, BroadcastResponseInput, BeaconResponseInputMessage, AcknowledgeResponseInput, ErrorResponseInput } from 'test/types/beacon/messages/BeaconResponseInputMessage';\n                import { PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, BeaconResponseOutputMessage } from 'test/types/beacon/messages/BeaconResponseOutputMessage';\n                import { PermissionRequestInput, SignPayloadRequestInput, OperationRequestInput, BroadcastRequestInput, BeaconRequestInputMessage } from 'test/types/beacon/messages/BeaconRequestInputMessage';\n                import { PermissionRequestOutput, SignPayloadRequestOutput, OperationRequestOutput, BroadcastRequestOutput, BeaconRequestOutputMessage } from 'test/types/beacon/messages/BeaconRequestOutputMessage';\n                import { ClientOptions } from 'test/clients/client/ClientOptions';\n                import { DAppClientOptions } from 'test/clients/dapp-client/DAppClientOptions';\n                import { WalletClientOptions } from 'test/clients/wallet-client/WalletClientOptions';\n                import { PermissionInfo } from 'test/types/PermissionInfo';\n                import { SDK_VERSION, BEACON_VERSION } from 'test/constants';\n                import { AccountManager } from 'test/managers/AccountManager';\n                import { AppMetadataManager } from 'test/managers/AppMetadataManager';\n                import { PermissionManager } from 'test/managers/PermissionManager';\n                import { BeaconEvent, BeaconEventHandler, defaultEventCallbacks } from 'test/events';\n                import { getAddressFromPublicKey } from 'test/utils/crypto';\n                import { BeaconClient } from 'test/clients/beacon-client/BeaconClient';\n                import { BeaconClientOptions } from 'test/clients/beacon-client/BeaconClientOptions';\n                import { getAccountIdentifier } from 'test/utils/get-account-identifier';\n                import { ConnectionContext } from 'test/types/ConnectionContext';\n                import { Threshold } from 'test/types/beacon/Threshold';\n                import { PartialTezosTransactionOperation, PartialTezosOperation, PartialTezosDelegationOperation, PartialTezosOriginationOperation, PartialTezosRevealOperation } from 'test/types/tezos/PartialTezosOperation';\n                import { AbortedBeaconError } from 'test/errors/AbortedBeaconError';\n                import { ExtendedPeerInfo, PeerInfo } from 'test/types/PeerInfo';\n                import { availableTransports } from 'test/utils/available-transports';\n                import { AcknowledgeResponse } from 'test/types/beacon/messages/AcknowledgeResponse';\n                import { DisconnectMessage } from 'test/types/beacon/messages/DisconnectMessage';\n                import { DappP2PTransport } from 'test/transports/DappP2PTransport';\n                import { DappPostMessageTransport } from 'test/transports/DappPostMessageTransport';\n                import { WalletP2PTransport } from 'test/transports/WalletP2PTransport';\n                import { WalletPostMessageTransport } from 'test/transports/WalletPostMessageTransport';\n                import { getSenderId } from 'test/utils/get-sender-id';\n                import { SigningType } from 'test/types/beacon/SigningType';\n                import { SignatureTypeNotSupportedBeaconError } from 'test/errors/SignatureTypeNotSupportedBeaconError';\n                import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n                import { ExtendedPostMessagePairingRequest, PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n                import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n                import { PeerManager } from 'test/managers/PeerManager';\n                import { MessageBasedClient } from 'test/transports/clients/MessageBasedClient';\n                import { BeaconRequestMessage } from 'test/types/beacon/BeaconRequestMessage';\n                import { BeaconResponseMessage } from 'test/types/beacon/BeaconResponseMessage';\n                import { Pairing } from 'test/ui/alert/Pairing';\n                import { BlockExplorer } from 'test/utils/block-explorer';\n                import { TezblockBlockExplorer } from 'test/utils/tezblock-blockexplorer';\n                import { setDebugEnabled, getDebugEnabled } from 'test/debug';\n                import { ColorMode } from 'test/types/ColorMode';\n                export { TezosBaseOperation, TezosOperationType, TezosBlockHeader, MichelsonPrimitives, TezosTransactionParameters, TezosOperation };\n                export { TezosActivateAccountOperation, TezosBallotOperation, TezosDelegationOperation, TezosDoubleBakingEvidenceOperation, TezosDoubleEndorsementEvidenceOperation, TezosEndorsementOperation, TezosOriginationOperation, TezosProposalOperation, TezosRevealOperation, TezosSeedNonceRevelationOperation, TezosTransactionOperation, PartialTezosOperation, PartialTezosTransactionOperation, PartialTezosDelegationOperation, PartialTezosOriginationOperation, PartialTezosRevealOperation };\n                export { BeaconClient, BeaconClientOptions, Client, ClientOptions, DAppClient, DAppClientOptions, WalletClient, WalletClientOptions, P2PCommunicationClient };\n                export { AccountIdentifier, AppMetadata, Network, NetworkType, BeaconMessage, PermissionRequest, PermissionResponse, OperationRequest, OperationResponse, SignPayloadRequest, SignPayloadResponse, BroadcastRequest, BroadcastResponse, AcknowledgeResponse, DisconnectMessage, BeaconBaseMessage, BeaconMessageType, PermissionScope, Origin, AccountInfo, Threshold, SigningType, ExtensionMessageTarget, ExtensionMessage, EncryptedExtensionMessage, RequestPermissionInput, RequestSignPayloadInput, RequestOperationInput, RequestBroadcastInput, PermissionInfo };\n                export { PermissionResponseInput, SignPayloadResponseInput, OperationResponseInput, BroadcastResponseInput, AcknowledgeResponseInput, ErrorResponseInput, PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, PermissionRequestInput, SignPayloadRequestInput, OperationRequestInput, BroadcastRequestInput, PermissionRequestOutput, SignPayloadRequestOutput, OperationRequestOutput, BroadcastRequestOutput, BeaconRequestInputMessage, BeaconRequestOutputMessage, BeaconResponseInputMessage, BeaconResponseOutputMessage, BeaconRequestMessage, BeaconResponseMessage };\n                export { BeaconError, BeaconErrorType, ErrorResponse, AbortedBeaconError, BroadcastBeaconError, NetworkNotSupportedBeaconError, NoAddressBeaconError, NoPrivateKeyBeaconError, NotGrantedBeaconError, ParametersInvalidBeaconError, TooManyOperationsBeaconError, TransactionInvalidBeaconError, SignatureTypeNotSupportedBeaconError, UnknownBeaconError };\n                export { TransportStatus, TransportType, Transport, PostMessageTransport, P2PTransport, WalletP2PTransport, WalletPostMessageTransport, DappP2PTransport, DappPostMessageTransport, MessageBasedClient, Pairing };\n                export { BeaconEvent, BeaconEventHandler, defaultEventCallbacks };\n                export { Storage, StorageKey, StorageKeyReturnDefaults, StorageKeyReturnType, ChromeStorage, LocalStorage, getStorage };\n                export { PeerManager, AccountManager, AppMetadataManager, PermissionManager };\n                export { SDK_VERSION, BEACON_VERSION };\n                export { getSenderId, getAccountIdentifier, getAddressFromPublicKey };\n                export { PeerInfo, ExtendedPeerInfo, PostMessagePairingRequest, ExtendedPostMessagePairingRequest, ExtendedPostMessagePairingResponse, P2PPairingRequest, ExtendedP2PPairingRequest, ExtendedP2PPairingResponse };\n                export { BlockExplorer, TezblockBlockExplorer };\n                export { ConnectionContext, Serializer, availableTransports, ColorMode };\n                export { setDebugEnabled, getDebugEnabled };\n        }\n    \n        module 'test/interceptors/IncomingRequestInterceptor' {\n                import { BeaconRequestOutputMessage } from 'test/';\n                import { ConnectionContext } from 'test/types/ConnectionContext';\n                import { AppMetadataManager } from 'test/managers/AppMetadataManager';\n                import { BeaconRequestMessage } from 'test/types/beacon/BeaconRequestMessage';\n                interface IncomingRequestInterceptorOptions {\n                                message: BeaconRequestMessage;\n                                connectionInfo: ConnectionContext;\n                                appMetadataManager: AppMetadataManager;\n                                interceptorCallback(message: BeaconRequestOutputMessage, connectionInfo: ConnectionContext): void;\n                }\n                /**\n                          * The IncomingRequestInterceptor is used in the WalletClient to intercept an incoming request and enrich it with data, like app metadata.\n                          */\n                export class IncomingRequestInterceptor {\n                                /**\n                                          * The method that is called during the interception\n                                          *\n                                          * @param config\n                                          */\n                                static intercept(config: IncomingRequestInterceptorOptions): Promise<void>;\n                }\n                export {};\n        }\n    \n        module 'test/interceptors/OutgoingResponseInterceptor' {\n                import { BeaconMessage, BeaconResponseInputMessage, AppMetadata } from 'test/';\n                import { PermissionManager } from 'test/managers/PermissionManager';\n                import { AppMetadataManager } from 'test/managers/AppMetadataManager';\n                import { BeaconRequestMessage } from 'test/types/beacon/BeaconRequestMessage';\n                interface OutgoingResponseInterceptorOptions {\n                        senderId: string;\n                        request: BeaconRequestMessage;\n                        message: BeaconResponseInputMessage;\n                        ownAppMetadata: AppMetadata;\n                        permissionManager: PermissionManager;\n                        appMetadataManager: AppMetadataManager;\n                        interceptorCallback(message: BeaconMessage): void;\n                }\n                /**\n                      * The OutgoingResponseInterceptor is used in the WalletClient to intercept an outgoing response and enrich it with data.\n                      */\n                export class OutgoingResponseInterceptor {\n                        static intercept(config: OutgoingResponseInterceptorOptions): Promise<void>;\n                }\n                export {};\n        }\n    \n        module 'test/managers/AccountManager' {\n                import { Storage, AccountInfo, BeaconMessage } from 'test/';\n                /**\n                      * The AccountManager provides CRUD functionality for account entities and persists them to the provided storage.\n                      */\n                export class AccountManager {\n                        constructor(storage: Storage);\n                        getAccounts(): Promise<AccountInfo[]>;\n                        getAccount(accountIdentifier: string): Promise<AccountInfo | undefined>;\n                        addAccount(accountInfo: AccountInfo): Promise<void>;\n                        removeAccount(accountIdentifier: string): Promise<void>;\n                        removeAccounts(accountIdentifiers: string[]): Promise<void>;\n                        removeAllAccounts(): Promise<void>;\n                        hasPermission(message: BeaconMessage): Promise<boolean>;\n                }\n        }\n    \n        module 'test/managers/AppMetadataManager' {\n                import { Storage, AppMetadata } from 'test/';\n                /**\n                      * The AppMetadataManager provides CRUD functionality for app-metadata entities and persists them to the provided storage.\n                      */\n                export class AppMetadataManager {\n                        constructor(storage: Storage);\n                        getAppMetadataList(): Promise<AppMetadata[]>;\n                        getAppMetadata(senderId: string): Promise<AppMetadata | undefined>;\n                        addAppMetadata(appMetadata: AppMetadata): Promise<void>;\n                        removeAppMetadata(senderId: string): Promise<void>;\n                        removeAppMetadatas(senderIds: string[]): Promise<void>;\n                        removeAllAppMetadata(): Promise<void>;\n                }\n        }\n    \n        module 'test/managers/PeerManager' {\n                import { Storage, StorageKey, StorageKeyReturnType } from 'test/';\n                import { ArrayElem } from 'test/managers/StorageManager';\n                /**\n                      * The PeerManager provides CRUD functionality for peer entities and persists them to the provided storage.\n                      */\n                export class PeerManager<T extends StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET> {\n                        constructor(storage: Storage, key: T);\n                        hasPeer(publicKey: string): Promise<boolean>;\n                        getPeers(): Promise<StorageKeyReturnType[T]>;\n                        getPeer(publicKey: string): Promise<ArrayElem<StorageKeyReturnType[T]> | undefined>;\n                        addPeer(peerInfo: ArrayElem<StorageKeyReturnType[T]>): Promise<void>;\n                        removePeer(publicKey: string): Promise<void>;\n                        removePeers(publicKeys: string[]): Promise<void>;\n                        removeAllPeers(): Promise<void>;\n                }\n        }\n    \n        module 'test/managers/PermissionManager' {\n                import { BeaconMessage, Storage } from 'test/';\n                import { PermissionInfo } from 'test/types/PermissionInfo';\n                /**\n                      * The PermissionManager provides CRUD functionality for permission entities and persists them to the provided storage.\n                      */\n                export class PermissionManager {\n                        constructor(storage: Storage);\n                        getPermissions(): Promise<PermissionInfo[]>;\n                        getPermission(accountIdentifier: string): Promise<PermissionInfo | undefined>;\n                        addPermission(permissionInfo: PermissionInfo): Promise<void>;\n                        removePermission(accountIdentifier: string): Promise<void>;\n                        removePermissions(accountIdentifiers: string[]): Promise<void>;\n                        removeAllPermissions(): Promise<void>;\n                        hasPermission(message: BeaconMessage): Promise<boolean>;\n                }\n        }\n    \n        module 'test/managers/PermissionValidator' {\n                import { BeaconMessage } from 'test/';\n                import { PermissionEntity } from 'test/types/PermissionEntity';\n                /**\n                          * The PermissionValidator is used to check if permissions for a certain message type have been given\n                          */\n                export class PermissionValidator {\n                                /**\n                                          * Check if permissions were given for a certain message type.\n                                          *\n                                          * PermissionRequest and BroadcastRequest will always return true.\n                                          *\n                                          * @param message Beacon Message\n                                          */\n                                static hasPermission(message: BeaconMessage, getOne: (id: string) => Promise<PermissionEntity | undefined>, getAll: () => Promise<PermissionEntity[]>): Promise<boolean>;\n                }\n        }\n    \n        module 'test/managers/StorageManager' {\n                import { StorageKey, Storage, StorageKeyReturnType } from 'test/';\n                /** Type workaround for https://github.com/Microsoft/TypeScript/issues/7294#issuecomment-465794460 */\n                export type ArrayElem<A> = A extends (infer Elem)[] ? Elem : never;\n                /**\n                          * The StorageManager provides CRUD functionality for specific entities and persists them to the provided storage.\n                          */\n                export class StorageManager<T extends StorageKey.ACCOUNTS | StorageKey.APP_METADATA_LIST | StorageKey.PERMISSION_LIST | StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET> {\n                                constructor(storage: Storage, storageKey: T);\n                                getAll(): Promise<StorageKeyReturnType[T]>;\n                                getOne(predicate: (element: ArrayElem<StorageKeyReturnType[T]>) => boolean): Promise<ArrayElem<StorageKeyReturnType[T]> | undefined>;\n                                addOne(element: ArrayElem<StorageKeyReturnType[T]>, predicate: (element: ArrayElem<StorageKeyReturnType[T]>) => boolean, overwrite?: boolean): Promise<void>;\n                                remove(predicate: (element: ArrayElem<StorageKeyReturnType[T]>) => boolean): Promise<void>;\n                                removeAll(): Promise<void>;\n                }\n        }\n    \n        module 'test/matrix-client/MatrixClient' {\n                import { Storage } from 'test/storage/Storage';\n                import { MatrixClientStore } from 'test/matrix-client/MatrixClientStore';\n                import { MatrixRoom } from 'test/matrix-client/models/MatrixRoom';\n                import { MatrixRoomService } from 'test/matrix-client/services/MatrixRoomService';\n                import { MatrixUserService } from 'test/matrix-client/services/MatrixUserService';\n                import { MatrixEventService } from 'test/matrix-client/services/MatrixEventService';\n                import { MatrixClientEventEmitter } from 'test/matrix-client/MatrixClientEventEmitter';\n                import { MatrixClientEventType, MatrixClientEvent } from 'test/matrix-client/models/MatrixClientEvent';\n                interface MatrixClientOptions {\n                                baseUrl: string;\n                                storage: Storage;\n                }\n                interface MatrixLoginConfig {\n                                id: string;\n                                password: string;\n                                deviceId: string;\n                }\n                /**\n                          * The matrix client used to connect to the matrix network\n                          */\n                export class MatrixClient {\n                                /**\n                                          * Create a matrix client based on the options provided\n                                          *\n                                          * @param config\n                                          */\n                                static create(config: MatrixClientOptions): MatrixClient;\n                                /**\n                                          * Return all the rooms we are currently part of\n                                          */\n                                get joinedRooms(): MatrixRoom[];\n                                /**\n                                          * Return all the rooms to which we have received invitations\n                                          */\n                                get invitedRooms(): MatrixRoom[];\n                                /**\n                                          * Return all the rooms that we left\n                                          */\n                                get leftRooms(): MatrixRoom[];\n                                constructor(store: MatrixClientStore, eventEmitter: MatrixClientEventEmitter, userService: MatrixUserService, roomService: MatrixRoomService, eventService: MatrixEventService);\n                                /**\n                                          * Initiate the connection to the matrix node and log in\n                                          *\n                                          * @param user\n                                          */\n                                start(user: MatrixLoginConfig): Promise<void>;\n                                /**\n                                          * Subscribe to new matrix events\n                                          *\n                                          * @param event\n                                          * @param listener\n                                          */\n                                subscribe<T extends MatrixClientEventType>(event: T, listener: (event: MatrixClientEvent<T>) => void): void;\n                                /**\n                                          * Unsubscribe from matrix events\n                                          *\n                                          * @param event\n                                          * @param listener\n                                          */\n                                unsubscribe(event: MatrixClientEventType, listener?: (event: MatrixClientEvent<any>) => void): void;\n                                getRoomById(id: string): MatrixRoom;\n                                /**\n                                          * Create a private room with the supplied members\n                                          *\n                                          * @param members Members that will be in the room\n                                          */\n                                createTrustedPrivateRoom(...members: string[]): Promise<string>;\n                                /**\n                                          * Invite user to rooms\n                                          *\n                                          * @param user The user to be invited\n                                          * @param roomsOrIds The rooms the user will be invited to\n                                          */\n                                inviteToRooms(user: string, ...roomsOrIds: string[] | MatrixRoom[]): Promise<void>;\n                                /**\n                                          * Join rooms\n                                          *\n                                          * @param roomsOrIds\n                                          */\n                                joinRooms(...roomsOrIds: string[] | MatrixRoom[]): Promise<void>;\n                                /**\n                                          * Send a text message\n                                          *\n                                          * @param roomOrId\n                                          * @param message\n                                          */\n                                sendTextMessage(roomId: string, message: string): Promise<void>;\n                }\n                export {};\n        }\n    \n        module 'test/matrix-client/MatrixClientEventEmitter' {\n                import { EventEmitter } from 'events';\n                import { MatrixStateStore, MatrixStateUpdate } from 'test/matrix-client/MatrixClientStore';\n                export class MatrixClientEventEmitter extends EventEmitter {\n                                /**\n                                          * This method is called every time the state is changed\n                                          *\n                                          * @param _oldState\n                                          * @param _newState\n                                          * @param stateChange\n                                          */\n                                onStateChanged(_oldState: MatrixStateStore, _newState: MatrixStateStore, stateChange: Partial<MatrixStateUpdate>): void;\n                }\n        }\n    \n        module 'test/matrix-client/MatrixClientStore' {\n                import { MatrixRoom } from 'test/matrix-client/models/MatrixRoom';\n                import { Storage } from 'test/storage/Storage';\n                type OnStateChangedListener = (oldState: MatrixStateStore, newState: MatrixStateStore, stateChange: Partial<MatrixStateUpdate>) => void;\n                export interface MatrixState {\n                                isRunning: boolean;\n                                userId: string | undefined;\n                                deviceId: string | undefined;\n                                txnNo: number;\n                                accessToken: string | undefined;\n                                syncToken: string | undefined;\n                                pollingTimeout: number | undefined;\n                                pollingRetries: number;\n                                rooms: MatrixRoom[] | Record<string, MatrixRoom>;\n                }\n                export interface MatrixStateStore extends MatrixState {\n                                rooms: Record<string, MatrixRoom>;\n                }\n                export interface MatrixStateUpdate extends MatrixState {\n                                rooms: MatrixRoom[];\n                }\n                /**\n                          * The class managing the local state of matrix\n                          */\n                export class MatrixClientStore {\n                                constructor(storage: Storage);\n                                /**\n                                          * Get an item from the state\n                                          *\n                                          * @param key\n                                          */\n                                get<T extends keyof MatrixStateStore>(key: T): MatrixStateStore[T];\n                                /**\n                                          * Get the room from an ID or room instance\n                                          *\n                                          * @param roomOrId\n                                          */\n                                getRoom(roomOrId: string | MatrixRoom): MatrixRoom;\n                                /**\n                                          * Update the state with a partial state\n                                          *\n                                          * @param stateUpdate\n                                          */\n                                update(stateUpdate: Partial<MatrixStateUpdate>): Promise<void>;\n                                /**\n                                          * Register listeners that are called once the state has changed\n                                          *\n                                          * @param listener\n                                          * @param subscribed\n                                          */\n                                onStateChanged(listener: OnStateChangedListener, ...subscribed: (keyof MatrixState)[]): void;\n                }\n                export {};\n        }\n    \n        module 'test/matrix-client/MatrixHttpClient' {\n                import { MatrixRequest, MatrixRequestParams } from 'test/matrix-client/models/api/MatrixRequest';\n                interface HttpOptions {\n                                accessToken?: string;\n                }\n                /**\n                          * Handling the HTTP connection to the matrix synapse node\n                          */\n                export class MatrixHttpClient {\n                                constructor(baseUrl: string);\n                                /**\n                                          * Get data from the synapse node\n                                          *\n                                          * @param endpoint\n                                          * @param options\n                                          */\n                                get<T>(endpoint: string, params?: MatrixRequestParams<T>, options?: HttpOptions): Promise<T>;\n                                /**\n                                          * Post data to the synapse node\n                                          *\n                                          * @param endpoint\n                                          * @param body\n                                          * @param options\n                                          * @param params\n                                          */\n                                post<T>(endpoint: string, body: MatrixRequest<T>, options?: HttpOptions, params?: MatrixRequestParams<T>): Promise<T>;\n                                /**\n                                          * Put data to the synapse node\n                                          *\n                                          * @param endpoint\n                                          * @param body\n                                          * @param options\n                                          * @param params\n                                          */\n                                put<T>(endpoint: string, body: MatrixRequest<T>, options?: HttpOptions, params?: MatrixRequestParams<T>): Promise<T>;\n                }\n                export {};\n        }\n    \n        module 'test/matrix-client/models/api/MatrixEventSend' {\n                export interface MatrixEventSendRequest {\n                        content: any;\n                }\n                export interface MatrixEventSendResponse {\n                        type?: 'event_send';\n                        event_id: string;\n                }\n        }\n    \n        module 'test/matrix-client/models/api/MatrixLogin' {\n                export interface MatrixLoginRequest {\n                        type: 'm.login.password';\n                        identifier: {\n                                type: 'm.id.user';\n                                user: string;\n                        };\n                        password: string;\n                        device_id?: string;\n                }\n                export interface MatrixLoginResponse {\n                        type?: 'login';\n                        user_id: string;\n                        device_id: string;\n                        access_token: string;\n                }\n        }\n    \n        module 'test/matrix-client/models/api/MatrixRequest' {\n                import { MatrixLoginRequest, MatrixLoginResponse } from 'test/matrix-client/models/api/MatrixLogin';\n                import { MatrixRoomCreateRequest, MatrixRoomCreateResponse } from 'test/matrix-client/models/api/MatrixRoomCreate';\n                import { MatrixRoomInviteRequest, MatrixRoomInviteResponse } from 'test/matrix-client/models/api/MatrixRoomInvite';\n                import { MatrixRoomJoinRequest, MatrixRoomJoinResponse } from 'test/matrix-client/models/api/MatrixRoomJoin';\n                import { MatrixEventSendRequest, MatrixEventSendResponse } from 'test/matrix-client/models/api/MatrixEventSend';\n                import { MatrixSyncResponse, MatrixSyncRequestParams } from 'test/matrix-client/models/api/MatrixSync';\n                export type MatrixRequest<T> = T extends MatrixLoginResponse ? MatrixLoginRequest : T extends MatrixRoomCreateResponse ? MatrixRoomCreateRequest : T extends MatrixRoomInviteResponse ? MatrixRoomInviteRequest : T extends MatrixRoomJoinResponse ? MatrixRoomJoinRequest : T extends MatrixEventSendResponse ? MatrixEventSendRequest : never;\n                export type MatrixRequestParams<T> = T extends MatrixSyncResponse ? MatrixSyncRequestParams : never;\n        }\n    \n        module 'test/matrix-client/models/api/MatrixRoomCreate' {\n                export interface MatrixRoomCreateRequest {\n                        visibility?: 'public' | 'private';\n                        room_alias_name?: string;\n                        name?: string;\n                        topic?: string;\n                        invite?: string[];\n                        preset?: 'private_chat' | 'public_chat' | 'trusted_private_chat';\n                        is_direct?: boolean;\n                }\n                export interface MatrixRoomCreateResponse {\n                        type?: 'room_create';\n                        room_id: string;\n                }\n        }\n    \n        module 'test/matrix-client/models/api/MatrixRoomInvite' {\n                export interface MatrixRoomInviteRequest {\n                        user_id: string;\n                }\n                export interface MatrixRoomInviteResponse {\n                        type?: 'room_invite';\n                }\n        }\n    \n        module 'test/matrix-client/models/api/MatrixRoomJoin' {\n                export interface MatrixRoomJoinRequest {\n                }\n                export interface MatrixRoomJoinResponse {\n                        type?: 'room_join';\n                        room_id: string;\n                }\n        }\n    \n        module 'test/matrix-client/models/api/MatrixSync' {\n                import { MatrixStateEvent } from 'test/matrix-client/models/MatrixStateEvent';\n                export interface MatrixSyncJoinedRoom {\n                        state: {\n                                events: MatrixStateEvent[];\n                        };\n                        timeline: {\n                                events: MatrixStateEvent[];\n                        };\n                }\n                export interface MatrixSyncInvitedRoom {\n                        invite_state: {\n                                events: MatrixStateEvent[];\n                        };\n                }\n                export interface MatrixSyncLeftRoom {\n                        state: {\n                                events: MatrixStateEvent[];\n                        };\n                        timeline: {\n                                events: MatrixStateEvent[];\n                        };\n                }\n                export interface MatrixSyncRooms {\n                        join: {\n                                [key: string]: MatrixSyncJoinedRoom;\n                        };\n                        invite: {\n                                [key: string]: MatrixSyncInvitedRoom;\n                        };\n                        leave: {\n                                [key: string]: MatrixSyncLeftRoom;\n                        };\n                }\n                export interface MatrixSyncRequestParams {\n                        timeout?: number;\n                        since?: string;\n                }\n                export interface MatrixSyncResponse {\n                        type?: 'sync';\n                        next_batch: string;\n                        rooms: MatrixSyncRooms;\n                }\n        }\n    \n        module 'test/matrix-client/models/MatrixClientEvent' {\n                import { MatrixMessage } from 'test/matrix-client/models/MatrixMessage';\n                export enum MatrixClientEventType {\n                        INVITE = \"invite\",\n                        MESSAGE = \"message\"\n                }\n                export type MatrixClientEventContent<T> = T extends MatrixClientEventType.INVITE ? MatrixClientEventInviteContent : T extends MatrixClientEventType.MESSAGE ? MatrixClientEventMessageContent<any> : never;\n                export interface MatrixClientEventInviteContent {\n                        roomId: string;\n                }\n                export interface MatrixClientEventMessageContent<T> {\n                        roomId: string;\n                        message: MatrixMessage<T>;\n                }\n                export interface MatrixClientEvent<T extends MatrixClientEventType> {\n                        type: T;\n                        content: MatrixClientEventContent<T>;\n                }\n        }\n    \n        module 'test/matrix-client/models/MatrixMessage' {\n                import { MatrixStateEvent } from 'test/matrix-client/models/MatrixStateEvent';\n                export enum MatrixMessageType {\n                        TEXT = \"m.text\"\n                }\n                export class MatrixMessage<T> {\n                        readonly type: MatrixMessageType;\n                        readonly sender: string;\n                        readonly content: T;\n                        /**\n                              * Construct a message from a message event\n                              *\n                              * @param event\n                              */\n                        static from(event: MatrixStateEvent): MatrixMessage<any> | undefined;\n                }\n        }\n    \n        module 'test/matrix-client/models/MatrixRoom' {\n                import { MatrixSyncRooms } from 'test/matrix-client/models/api/MatrixSync';\n                import { MatrixMessage } from 'test/matrix-client/models/MatrixMessage';\n                export enum MatrixRoomStatus {\n                                UNKNOWN = 0,\n                                JOINED = 1,\n                                INVITED = 2,\n                                LEFT = 3\n                }\n                export class MatrixRoom {\n                                readonly id: string;\n                                readonly status: MatrixRoomStatus;\n                                readonly members: string[];\n                                messages: MatrixMessage<any>[];\n                                /**\n                                          * Reconstruct rooms from a sync response\n                                          *\n                                          * @param roomSync\n                                          */\n                                static fromSync(roomSync: MatrixSyncRooms): MatrixRoom[];\n                                /**\n                                          * Reconstruct a room from an ID or object\n                                          *\n                                          * @param roomOrId\n                                          * @param status\n                                          */\n                                static from(roomOrId: string | MatrixRoom, status?: MatrixRoomStatus): MatrixRoom;\n                                /**\n                                          * Merge new and old state and remove duplicates\n                                          *\n                                          * @param newState\n                                          * @param previousState\n                                          */\n                                static merge(newState: MatrixRoom, previousState?: MatrixRoom): MatrixRoom;\n                }\n        }\n    \n        module 'test/matrix-client/models/MatrixStateEvent' {\n                import { MatrixMessageType } from 'test/matrix-client/models/MatrixMessage';\n                export interface MatrixStateEventMessageText extends MatrixStateEventMessage {\n                        type: 'm.room.message';\n                        content: {\n                                msgtype: MatrixMessageType.TEXT;\n                                body: string;\n                        };\n                }\n                export interface MatrixStateEventMessageContent {\n                        msgtype: string;\n                        body: any;\n                        [key: string]: any;\n                }\n                export interface MatrixStateEventMessage extends MatrixStateEvent {\n                        type: 'm.room.message';\n                        content: MatrixStateEventMessageContent;\n                }\n                export interface MatrixStateEvent {\n                        type: string;\n                        sender: string;\n                        content: unknown;\n                        event_id?: string;\n                }\n        }\n    \n        module 'test/matrix-client/services/MatrixEventService' {\n                import { MatrixHttpClient } from 'test/matrix-client/MatrixHttpClient';\n                import { MatrixEventSendResponse } from 'test/matrix-client/models/api/MatrixEventSend';\n                import { MatrixSyncResponse } from 'test/matrix-client/models/api/MatrixSync';\n                import { MatrixStateEventMessageContent } from 'test/matrix-client/models/MatrixStateEvent';\n                interface MatrixScheduledEvent<T> {\n                                accessToken: string;\n                                roomId: string;\n                                type: MatrixEventType;\n                                content: any;\n                                txnId: string;\n                                onSuccess(response: T): void;\n                                onError(error: unknown): void;\n                }\n                type MatrixEventType = 'm.room.message';\n                export interface MatrixSyncOptions {\n                                syncToken?: string;\n                                pollingTimeout?: number;\n                }\n                /**\n                          * A service to help with matrix event management\n                          */\n                export class MatrixEventService {\n                                constructor(httpClient: MatrixHttpClient);\n                                /**\n                                          * Get the latest state from the matrix node\n                                          *\n                                          * @param accessToken\n                                          * @param options\n                                          */\n                                sync(accessToken: string, options?: MatrixSyncOptions): Promise<MatrixSyncResponse>;\n                                /**\n                                          * Send a message to a room\n                                          *\n                                          * @param accessToken\n                                          * @param room\n                                          * @param content\n                                          * @param txnId\n                                          */\n                                sendMessage(accessToken: string, roomId: string, content: MatrixStateEventMessageContent, txnId: string): Promise<MatrixEventSendResponse>;\n                                /**\n                                          * Schedules an event to be sent to the node\n                                          *\n                                          * @param event\n                                          */\n                                scheduleEvent(event: MatrixScheduledEvent<any>): void;\n                                /**\n                                          * Send an event to the matrix node\n                                          *\n                                          * @param scheduledEvent\n                                          */\n                                sendEvent(scheduledEvent: MatrixScheduledEvent<any>): Promise<void>;\n                }\n                export {};\n        }\n    \n        module 'test/matrix-client/services/MatrixRoomService' {\n                import { MatrixHttpClient } from 'test/matrix-client/MatrixHttpClient';\n                import { MatrixRoom } from 'test/matrix-client/models/MatrixRoom';\n                import { MatrixRoomCreateRequest, MatrixRoomCreateResponse } from 'test/matrix-client/models/api/MatrixRoomCreate';\n                import { MatrixRoomInviteResponse } from 'test/matrix-client/models/api/MatrixRoomInvite';\n                import { MatrixRoomJoinResponse } from 'test/matrix-client/models/api/MatrixRoomJoin';\n                /**\n                          * A service to help with matrix room management\n                          */\n                export class MatrixRoomService {\n                                constructor(httpClient: MatrixHttpClient);\n                                /**\n                                          * Create a room\n                                          *\n                                          * @param accessToken\n                                          * @param config\n                                          */\n                                createRoom(accessToken: string, config?: MatrixRoomCreateRequest): Promise<MatrixRoomCreateResponse>;\n                                /**\n                                          * Invite a user to a room\n                                          *\n                                          * @param accessToken\n                                          * @param user\n                                          * @param room\n                                          */\n                                inviteToRoom(accessToken: string, user: string, room: MatrixRoom): Promise<MatrixRoomInviteResponse>;\n                                /**\n                                          * Join a specific room\n                                          *\n                                          * @param accessToken\n                                          * @param room\n                                          */\n                                joinRoom(accessToken: string, room: MatrixRoom): Promise<MatrixRoomJoinResponse>;\n                                /**\n                                          * Get all joined rooms\n                                          *\n                                          * @param accessToken\n                                          */\n                                getJoinedRooms(accessToken: string): Promise<MatrixRoomJoinResponse>;\n                }\n        }\n    \n        module 'test/matrix-client/services/MatrixUserService' {\n                import { MatrixHttpClient } from 'test/matrix-client/MatrixHttpClient';\n                import { MatrixLoginResponse } from 'test/matrix-client/models/api/MatrixLogin';\n                export class MatrixUserService {\n                        constructor(httpClient: MatrixHttpClient);\n                        /**\n                              * Log in to the matrix node with username and password\n                              *\n                              * @param user\n                              * @param password\n                              * @param deviceId\n                              */\n                        login(user: string, password: string, deviceId: string): Promise<MatrixLoginResponse>;\n                }\n        }\n    \n        module 'test/matrix-client/utils/events' {\n                import { MatrixStateEvent, MatrixStateEventMessageText } from 'test/matrix-client/models/MatrixStateEvent';\n                /**\n                          * Check if an event is a create event\n                          *\n                          * @param event MatrixStateEvent\n                          */\n                export const isCreateEvent: (event: MatrixStateEvent) => boolean;\n                /**\n                          * Check if an event is a join event\n                          *\n                          * @param event MatrixStateEvent\n                          */\n                export const isJoinEvent: (event: MatrixStateEvent) => boolean;\n                /**\n                          * Check if an event is a message event\n                          *\n                          * @param event MatrixStateEvent\n                          */\n                export const isMessageEvent: (event: MatrixStateEvent) => boolean;\n                /**\n                          * Check if an event is a text message event\n                          *\n                          * @param event MatrixStateEvent\n                          */\n                export const isTextMessageEvent: (event: MatrixStateEvent) => event is MatrixStateEventMessageText;\n        }\n    \n        module 'test/migrations/migrate-0.7.0' {\n                import { PermissionScope, AccountIdentifier, Origin, Network } from 'test/';\n                export interface AccountInfoOld {\n                        accountIdentifier: AccountIdentifier;\n                        beaconId: string;\n                        origin: {\n                                type: Origin;\n                                id: string;\n                        };\n                        address: string;\n                        pubkey: string;\n                        network: Network;\n                        scopes: PermissionScope[];\n                        connectedAt: Date;\n                }\n                export interface P2PPairingRequestOld {\n                        name: string;\n                        pubKey: string;\n                        relayServer: string;\n                }\n                export const migrate_0_7_0: (storage: Storage) => Promise<void>;\n        }\n    \n        module 'test/migrations/migrations' {\n                import { Storage } from 'test/';\n                export const migrate: (storage: Storage) => Promise<void>;\n        }\n    \n        module 'test/MockWindow' {\n                type Callback = (message: unknown) => void;\n                /**\n                      * A mock for postmessage if run in node.js environment\n                      */\n                let windowRef: {\n                        postMessage: (message: string | Record<string, unknown>, _target?: string | undefined) => void;\n                        addEventListener: (_name: string, eventCallback: Callback) => void;\n                        removeEventListener: (_name: string, eventCallback: Callback) => void;\n                        location: {\n                                origin: string;\n                        };\n                };\n                const clearMockWindowState: () => void;\n                export { windowRef, clearMockWindowState };\n        }\n    \n        module 'test/Serializer' {\n                /**\n                          * The Serializer is used to serialize / deserialize JSON objects and encode them with bs58check\n                          */\n                export class Serializer {\n                                /**\n                                          * Serialize and bs58check encode an object\n                                          *\n                                          * @param message JSON object to serialize\n                                          */\n                                serialize(message: unknown): Promise<string>;\n                                /**\n                                          * Deserialize a bs58check encoded string\n                                          *\n                                          * @param encoded String to be deserialized\n                                          */\n                                deserialize(encoded: string): Promise<unknown>;\n                }\n        }\n    \n        module 'test/storage/ChromeStorage' {\n                import { Storage, StorageKey, StorageKeyReturnType } from 'test/';\n                export class ChromeStorage implements Storage {\n                        static isSupported(): Promise<boolean>;\n                        get<K extends StorageKey>(key: K): Promise<StorageKeyReturnType[K]>;\n                        set<K extends StorageKey>(key: K, value: StorageKeyReturnType[K]): Promise<void>;\n                        delete<K extends StorageKey>(key: K): Promise<void>;\n                }\n        }\n    \n        module 'test/storage/getStorage' {\n                import { Storage } from 'test/';\n                /**\n                      * Get a supported storage on this platform\n                      */\n                export const getStorage: () => Promise<Storage>;\n        }\n    \n        module 'test/storage/LocalStorage' {\n                import { Storage, StorageKey, StorageKeyReturnType } from 'test/';\n                export class LocalStorage implements Storage {\n                        constructor(prefix?: string | undefined);\n                        static isSupported(): Promise<boolean>;\n                        get<K extends StorageKey>(key: K): Promise<StorageKeyReturnType[K]>;\n                        set<K extends StorageKey>(key: K, value: StorageKeyReturnType[K]): Promise<void>;\n                        delete<K extends StorageKey>(key: K): Promise<void>;\n                }\n        }\n    \n        module 'test/storage/Storage' {\n                import { StorageKey } from 'test/types/storage/StorageKey';\n                import { StorageKeyReturnType } from 'test/types/storage/StorageKeyReturnType';\n                /**\n                          * The storage used in the SDK\n                          */\n                export abstract class Storage {\n                                /**\n                                          * Returns a promise that resolves to true if the storage option is available on this platform.\n                                          */\n                                static isSupported(): Promise<boolean>;\n                                /**\n                                          * Gets a value from storage and returns it\n                                          *\n                                          * @param key The storage key\n                                          */\n                                abstract get<K extends StorageKey>(key: K): Promise<StorageKeyReturnType[K]>;\n                                /**\n                                          * Sets a value in the storage and persist it\n                                          *\n                                          * @param key The storage key\n                                          * @param value The value to be persisted\n                                          */\n                                abstract set<K extends StorageKey>(key: K, value: StorageKeyReturnType[K]): Promise<void>;\n                                /**\n                                          * Delete a key from storage\n                                          *\n                                          * @param key The storage key\n                                          */\n                                abstract delete<K extends StorageKey>(key: K): Promise<void>;\n                }\n        }\n    \n        module 'test/test' {\n    \n                export * from 'test/beacon-message-events';\n                export * from 'test/clients/beacon-client/BeaconClient';\n                export * from 'test/clients/beacon-client/BeaconClientOptions';\n                export * from 'test/clients/client/Client';\n                export * from 'test/clients/client/ClientOptions';\n                export * from 'test/clients/dapp-client/DAppClient';\n                export * from 'test/clients/dapp-client/DAppClientOptions';\n                export * from 'test/clients/wallet-client/WalletClient';\n                export * from 'test/clients/wallet-client/WalletClientOptions';\n                export * from 'test/colorMode';\n                export * from 'test/constants';\n                export * from 'test/debug';\n                export * from 'test/errors/AbortedBeaconError';\n                export * from 'test/errors/BeaconError';\n                export * from 'test/errors/BroadcastBeaconError';\n                export * from 'test/errors/NetworkNotSupportedBeaconError';\n                export * from 'test/errors/NoAddressBeaconError';\n                export * from 'test/errors/NoPrivateKeyBeaconError';\n                export * from 'test/errors/NotGrantedBeaconError';\n                export * from 'test/errors/ParametersInvalidBeaconError';\n                export * from 'test/errors/SignatureTypeNotSupportedBeaconError';\n                export * from 'test/errors/TooManyOperationsBeaconError';\n                export * from 'test/errors/TransactionInvalidBeaconError';\n                export * from 'test/errors/UnknownBeaconError';\n                export * from 'test/events';\n                export * from 'test/examples/broadcast-request';\n                export * from 'test/examples/custom-block-explorer';\n                export * from 'test/examples/disable-all-ui';\n                export * from 'test/examples/operation-request';\n                export * from 'test/examples/override-default-events';\n                export * from 'test/examples/permission-request';\n                export * from 'test/examples/sign-payload-request';\n                export * from 'test/examples/using-custom-network';\n                export * from 'test/examples/wallet-example';\n                export * from 'test/index';\n                export * from 'test/interceptors/IncomingRequestInterceptor';\n                export * from 'test/interceptors/OutgoingResponseInterceptor';\n                export * from 'test/managers/AccountManager';\n                export * from 'test/managers/AppMetadataManager';\n                export * from 'test/managers/PeerManager';\n                export * from 'test/managers/PermissionManager';\n                export * from 'test/managers/PermissionValidator';\n                export * from 'test/managers/StorageManager';\n                export * from 'test/matrix-client/MatrixClient';\n                export * from 'test/matrix-client/MatrixClientEventEmitter';\n                export * from 'test/matrix-client/MatrixClientStore';\n                export * from 'test/matrix-client/MatrixHttpClient';\n                export * from 'test/matrix-client/models/api/MatrixEventSend';\n                export * from 'test/matrix-client/models/api/MatrixLogin';\n                export * from 'test/matrix-client/models/api/MatrixRequest';\n                export * from 'test/matrix-client/models/api/MatrixRoomCreate';\n                export * from 'test/matrix-client/models/api/MatrixRoomInvite';\n                export * from 'test/matrix-client/models/api/MatrixRoomJoin';\n                export * from 'test/matrix-client/models/api/MatrixSync';\n                export * from 'test/matrix-client/models/MatrixClientEvent';\n                export * from 'test/matrix-client/models/MatrixMessage';\n                export * from 'test/matrix-client/models/MatrixRoom';\n                export * from 'test/matrix-client/models/MatrixStateEvent';\n                export * from 'test/matrix-client/services/MatrixEventService';\n                export * from 'test/matrix-client/services/MatrixRoomService';\n                export * from 'test/matrix-client/services/MatrixUserService';\n                export * from 'test/matrix-client/utils/events';\n                export * from 'test/migrations/migrate-0.7.0';\n                export * from 'test/migrations/migrations';\n                export * from 'test/MockWindow';\n                export * from 'test/Serializer';\n                export * from 'test/storage/ChromeStorage';\n                export * from 'test/storage/getStorage';\n                export * from 'test/storage/LocalStorage';\n                export * from 'test/storage/Storage';\n                export * from 'test/transports/clients/CommunicationClient';\n                export * from 'test/transports/clients/MessageBasedClient';\n                export * from 'test/transports/clients/P2PCommunicationClient';\n                export * from 'test/transports/clients/PostMessageClient';\n                export * from 'test/transports/DappP2PTransport';\n                export * from 'test/transports/DappPostMessageTransport';\n                export * from 'test/transports/P2PTransport';\n                export * from 'test/transports/PostMessageTransport';\n                export * from 'test/transports/Transport';\n                export * from 'test/transports/WalletP2PTransport';\n                export * from 'test/transports/WalletPostMessageTransport';\n                export * from 'test/types/AccountInfo';\n                export * from 'test/types/beacon/AppMetadata';\n                export * from 'test/types/beacon/BeaconBaseMessage';\n                export * from 'test/types/beacon/BeaconMessage';\n                export * from 'test/types/beacon/BeaconMessageType';\n                export * from 'test/types/beacon/BeaconRequestMessage';\n                export * from 'test/types/beacon/BeaconResponseMessage';\n                export * from 'test/types/beacon/messages/AcknowledgeResponse';\n                export * from 'test/types/beacon/messages/BeaconRequestInputMessage';\n                export * from 'test/types/beacon/messages/BeaconRequestOutputMessage';\n                export * from 'test/types/beacon/messages/BeaconResponseInputMessage';\n                export * from 'test/types/beacon/messages/BeaconResponseOutputMessage';\n                export * from 'test/types/beacon/messages/BroadcastRequest';\n                export * from 'test/types/beacon/messages/BroadcastResponse';\n                export * from 'test/types/beacon/messages/DisconnectMessage';\n                export * from 'test/types/beacon/messages/ErrorResponse';\n                export * from 'test/types/beacon/messages/OperationRequest';\n                export * from 'test/types/beacon/messages/OperationResponse';\n                export * from 'test/types/beacon/messages/PermissionRequest';\n                export * from 'test/types/beacon/messages/PermissionResponse';\n                export * from 'test/types/beacon/messages/SignPayloadRequest';\n                export * from 'test/types/beacon/messages/SignPayloadResponse';\n                export * from 'test/types/beacon/Network';\n                export * from 'test/types/beacon/NetworkType';\n                export * from 'test/types/beacon/PermissionScope';\n                export * from 'test/types/beacon/SigningType';\n                export * from 'test/types/beacon/Threshold';\n                export * from 'test/types/BeaconErrorType';\n                export * from 'test/types/ColorMode';\n                export * from 'test/types/ConnectionContext';\n                export * from 'test/types/Extension';\n                export * from 'test/types/ExtensionMessage';\n                export * from 'test/types/ExtensionMessageTarget';\n                export * from 'test/types/Origin';\n                export * from 'test/types/P2PPairingRequest';\n                export * from 'test/types/P2PPairingResponse';\n                export * from 'test/types/PeerInfo';\n                export * from 'test/types/PermissionEntity';\n                export * from 'test/types/PermissionInfo';\n                export * from 'test/types/PostMessagePairingRequest';\n                export * from 'test/types/PostMessagePairingResponse';\n                export * from 'test/types/RequestBroadcastInput';\n                export * from 'test/types/RequestOperationInput';\n                export * from 'test/types/RequestPermissionInput';\n                export * from 'test/types/RequestSignPayloadInput';\n                export * from 'test/types/storage/StorageKey';\n                export * from 'test/types/storage/StorageKeyReturnDefaults';\n                export * from 'test/types/storage/StorageKeyReturnType';\n                export * from 'test/types/tezos/MichelineMichelsonV1Expression';\n                export * from 'test/types/tezos/MichelsonPrimitives';\n                export * from 'test/types/tezos/operations/ActivateAccount';\n                export * from 'test/types/tezos/operations/Ballot';\n                export * from 'test/types/tezos/operations/Delegation';\n                export * from 'test/types/tezos/operations/DoubleBakingEvidence';\n                export * from 'test/types/tezos/operations/DoubleEndorsementEvidence';\n                export * from 'test/types/tezos/operations/Endorsement';\n                export * from 'test/types/tezos/operations/Origination';\n                export * from 'test/types/tezos/operations/Proposal';\n                export * from 'test/types/tezos/operations/Reveal';\n                export * from 'test/types/tezos/operations/SeedNonceRevelation';\n                export * from 'test/types/tezos/operations/Transaction';\n                export * from 'test/types/tezos/OperationTypes';\n                export * from 'test/types/tezos/PartialTezosOperation';\n                export * from 'test/types/tezos/TezosBaseOperation';\n                export * from 'test/types/tezos/TezosBlockHeader';\n                export * from 'test/types/tezos/TezosOperation';\n                export * from 'test/types/tezos/TezosTransactionParameters';\n                export * from 'test/types/transport/TransportStatus';\n                export * from 'test/types/transport/TransportType';\n                export * from 'test/ui/alert/alert-templates';\n                export * from 'test/ui/alert/Alert';\n                export * from 'test/ui/alert/Pairing';\n                export * from 'test/ui/alert/PairingAlert';\n                export * from 'test/ui/alert/wallet-lists';\n                export * from 'test/ui/toast/toast-templates';\n                export * from 'test/ui/toast/Toast';\n                export * from 'test/utils/assert-never';\n                export * from 'test/utils/available-transports';\n                export * from 'test/utils/block-explorer';\n                export * from 'test/utils/crypto';\n                export * from 'test/utils/exposed-promise';\n                export * from 'test/utils/generate-uuid';\n                export * from 'test/utils/get-account-identifier';\n                export * from 'test/utils/get-sender-id';\n                export * from 'test/utils/get-tzip10-link';\n                export * from 'test/utils/Logger';\n                export * from 'test/utils/platform';\n                export * from 'test/utils/qr';\n                export * from 'test/utils/replace-in-template';\n                export * from 'test/utils/shorten-string';\n                export * from 'test/utils/tezblock-blockexplorer';\n                export * from 'test/utils/utils';\n    \n                module 'test/beacon-message-events' {\n                                import { BeaconEvent } from 'test/events';\n                                import { BeaconMessageType } from 'test/';\n                                export const messageEvents: {\n                                                [key in BeaconMessageType]: {\n                                                                sent: BeaconEvent;\n                                                                success: BeaconEvent;\n                                                                error: BeaconEvent;\n                                                };\n                                };\n                }\n    \n                module 'test/clients/beacon-client/BeaconClient' {\n                                import * as sodium from 'libsodium-wrappers';\n                                import { ExposedPromise } from 'test/utils/exposed-promise';\n                                import { Storage } from 'test/';\n                                import { BeaconEventHandler } from 'test/events';\n                                import { BeaconClientOptions } from 'test/clients/beacon-client/BeaconClientOptions';\n                                /**\n                                                     * The beacon client is an abstract client that handles everything that is shared between all other clients.\n                                                     * Specifically, it handles managing the beaconId and and the local keypair.\n                                                     */\n                                export abstract class BeaconClient {\n                                                                /**\n                                                                                     * The name of the client\n                                                                                     */\n                                                                readonly name: string;\n                                                                /**\n                                                                                     * The URL of the dApp Icon. This can be used to display the icon of the dApp on in the wallet\n                                                                                     */\n                                                                readonly iconUrl?: string;\n                                                                /**\n                                                                                     * The URL of the dApp.\n                                                                                     */\n                                                                readonly appUrl?: string;\n                                                                /** The beaconId is a public key that is used to identify one specific application (dapp or wallet).\n                                                                                     * This is used inside a message to specify the sender, for example.\n                                                                                     */\n                                                                protected _beaconId: ExposedPromise<string>;\n                                                                get beaconId(): Promise<string>;\n                                                                protected storage: Storage;\n                                                                protected readonly events: BeaconEventHandler;\n                                                                /**\n                                                                                     * The local keypair that is used for the communication encryption\n                                                                                     */\n                                                                protected _keyPair: ExposedPromise<sodium.KeyPair>;\n                                                                protected get keyPair(): Promise<sodium.KeyPair>;\n                                                                constructor(config: BeaconClientOptions);\n                                                                /**\n                                                                                     * This resets the SDK. After using this method, this instance is no longer usable. You will have to instanciate a new client.\n                                                                                     */\n                                                                destroy(): Promise<void>;\n                                }\n                }\n    \n                module 'test/clients/beacon-client/BeaconClientOptions' {\n                                import { Storage } from 'test/';\n                                export interface BeaconClientOptions {\n                                                                /**\n                                                                                     * Name of the application\n                                                                                     */\n                                                                name: string;\n                                                                /**\n                                                                                     * A URL to the icon of the application\n                                                                                     */\n                                                                iconUrl?: string;\n                                                                /**\n                                                                                     * A URL to the website of the application\n                                                                                     */\n                                                                appUrl?: string;\n                                                                /**\n                                                                                     * The storage that will be used by the SDK\n                                                                                     */\n                                                                storage: Storage;\n                                }\n                }\n    \n                module 'test/clients/client/Client' {\n                                import { ExposedPromise } from 'test/utils/exposed-promise';\n                                import { ConnectionContext } from 'test/types/ConnectionContext';\n                                import { TransportType, TransportStatus, AccountInfo, PeerInfo, Transport, AppMetadata } from 'test/';\n                                import { BeaconEventHandler } from 'test/events';\n                                import { BeaconClient } from 'test/clients/beacon-client/BeaconClient';\n                                import { AccountManager } from 'test/managers/AccountManager';\n                                import { BeaconRequestMessage } from 'test/types/beacon/BeaconRequestMessage';\n                                import { ClientOptions } from 'test/clients/client/ClientOptions';\n                                /**\n                                                     * This abstract class handles the a big part of the logic that is shared between the dapp and wallet client.\n                                                     * For example, it selects and manages the transport and accounts.\n                                                     */\n                                export abstract class Client extends BeaconClient {\n                                                                protected readonly accountManager: AccountManager;\n                                                                protected handleResponse: (_event: BeaconRequestMessage, connectionInfo: ConnectionContext) => void;\n                                                                /**\n                                                                                     * How many requests can be sent after another\n                                                                                     */\n                                                                protected readonly rateLimit: number;\n                                                                /**\n                                                                                     * The time window in seconds in which the \"rateLimit\" is checked\n                                                                                     */\n                                                                protected readonly rateLimitWindowInSeconds: number;\n                                                                /**\n                                                                                     * Stores the times when requests have been made to determine if the rate limit has been reached\n                                                                                     */\n                                                                protected requestCounter: number[];\n                                                                protected readonly events: BeaconEventHandler;\n                                                                protected readonly matrixNodes: string[];\n                                                                protected _transport: ExposedPromise<Transport<any>>;\n                                                                protected get transport(): Promise<Transport<any>>;\n                                                                /**\n                                                                                     * Returns the connection status of the Client\n                                                                                     */\n                                                                get connectionStatus(): TransportStatus;\n                                                                /**\n                                                                                     * Returns whether or not the transaport is ready\n                                                                                     */\n                                                                get ready(): Promise<void>;\n                                                                constructor(config: ClientOptions);\n                                                                /**\n                                                                                     * Return all locally known accounts\n                                                                                     */\n                                                                getAccounts(): Promise<AccountInfo[]>;\n                                                                /**\n                                                                                     * Return the account by ID\n                                                                                     * @param accountIdentifier The ID of an account\n                                                                                     */\n                                                                getAccount(accountIdentifier: string): Promise<AccountInfo | undefined>;\n                                                                /**\n                                                                                     * Remove the account by ID\n                                                                                     * @param accountIdentifier The ID of an account\n                                                                                     */\n                                                                removeAccount(accountIdentifier: string): Promise<void>;\n                                                                /**\n                                                                                     * Remove all locally stored accounts\n                                                                                     */\n                                                                removeAllAccounts(): Promise<void>;\n                                                                /**\n                                                                                     * Add a new request (current timestamp) to the pending requests, remove old ones and check if we are above the limit\n                                                                                     */\n                                                                addRequestAndCheckIfRateLimited(): Promise<boolean>;\n                                                                /**\n                                                                                     * This method initializes the client. It will check if the connection should be established to a\n                                                                                     * browser extension or if the P2P transport should be used.\n                                                                                     *\n                                                                                     * @param transport A transport that can be provided by the user\n                                                                                     */\n                                                                init(transport: Transport<any>): Promise<TransportType>;\n                                                                /**\n                                                                                     * Returns the metadata of this DApp\n                                                                                     */\n                                                                getOwnAppMetadata(): Promise<AppMetadata>;\n                                                                /**\n                                                                                     * Return all known peers\n                                                                                     */\n                                                                getPeers(): Promise<PeerInfo[]>;\n                                                                /**\n                                                                                     * Add a new peer to the known peers\n                                                                                     * @param peer The new peer to add\n                                                                                     */\n                                                                addPeer(peer: PeerInfo): Promise<void>;\n                                                                /**\n                                                                                     * A \"setter\" for when the transport needs to be changed.\n                                                                                     */\n                                                                protected setTransport(transport?: Transport<any>): Promise<void>;\n                                                                protected addListener(transport: Transport<any>): Promise<void>;\n                                                                protected sendDisconnectToPeer(peer: PeerInfo, transport?: Transport<any>): Promise<void>;\n                                }\n                }\n    \n                module 'test/clients/client/ClientOptions' {\n                                import { Storage } from 'test/';\n                                import { BeaconEvent, BeaconEventHandlerFunction, BeaconEventType } from 'test/events';\n                                export interface ClientOptions {\n                                                                /**\n                                                                                     * Name of the application\n                                                                                     */\n                                                                name: string;\n                                                                /**\n                                                                                     * A URL to the icon of the application\n                                                                                     */\n                                                                iconUrl?: string;\n                                                                /**\n                                                                                     * A URL to the website of the application\n                                                                                     */\n                                                                appUrl?: string;\n                                                                /**\n                                                                                     * The storage that will be used by the SDK\n                                                                                     */\n                                                                storage: Storage;\n                                                                /**\n                                                                                     * An object that will be used to overwrite default event handler behaviour.\n                                                                                     *\n                                                                                     * If you plan to overwrite all default events, use \"disableDefaultEvents\" instead.\n                                                                                     *\n                                                                                     * This will overwrite the default event handler, so this can lead to unexpected behavior in some cases.\n                                                                                     * We recommend that you overwrite all handlers if you want to use your own UI.\n                                                                                     *\n                                                                                     * If you simply want to be notified of events happening, but do not want to overwrite the default behavior,\n                                                                                     * please use `subscribeToEvent()` on the DAppClient instead.\n                                                                                     */\n                                                                eventHandlers?: {\n                                                                                                [key in BeaconEvent]?: {\n                                                                                                                                handler: BeaconEventHandlerFunction<BeaconEventType[key]>;\n                                                                                                };\n                                                                };\n                                                                /**\n                                                                                     * Disable all default Events and UI elements. If passed together with \"eventHandlers\",\n                                                                                     * the default eventHandlers will be removed, and the ones passed by the user will be added.\n                                                                                     */\n                                                                disableDefaultEvents?: boolean;\n                                                                /**\n                                                                                     * A list of matrix nodes to connect to. If a non-empty array is passed, the default options will be overwritten.\n                                                                                     * One node will be randomly selected based on the local keypair and the other nodes will be used as a fallback in case the primary node goes down.\n                                                                                     *\n                                                                                     * Only provide the hostname, no https:// prefix. Eg. ['matrix.example.com']\n                                                                                     */\n                                                                matrixNodes?: string[];\n                                }\n                }\n    \n                module 'test/clients/dapp-client/DAppClient' {\n                                import { BeaconEvent, BeaconEventHandlerFunction, BeaconEventType } from 'test/events';\n                                import { AccountInfo, Client, TransportType, BeaconMessageType, NetworkType, RequestPermissionInput, RequestSignPayloadInput, RequestOperationInput, RequestBroadcastInput, PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, Transport, DappP2PTransport, DappPostMessageTransport, AppMetadata } from 'test/';\n                                import { BlockExplorer } from 'test/utils/block-explorer';\n                                import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n                                import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n                                import { ExtendedPeerInfo } from 'test/types/PeerInfo';\n                                import { ColorMode } from 'test/types/ColorMode';\n                                import { DAppClientOptions } from 'test/clients/dapp-client/DAppClientOptions';\n                                /**\n                                                     * The DAppClient has to be used in decentralized applications. It handles all the logic related to connecting to beacon-compatible\n                                                     * wallets and sending requests.\n                                                     */\n                                export class DAppClient extends Client {\n                                                                /**\n                                                                                     * The block explorer used by the SDK\n                                                                                     */\n                                                                readonly blockExplorer: BlockExplorer;\n                                                                preferredNetwork: NetworkType;\n                                                                protected postMessageTransport: DappPostMessageTransport | undefined;\n                                                                protected p2pTransport: DappP2PTransport | undefined;\n                                                                constructor(config: DAppClientOptions);\n                                                                initInternalTransports(): Promise<void>;\n                                                                init(transport?: Transport<any>): Promise<TransportType>;\n                                                                /**\n                                                                                     * Returns the active account\n                                                                                     */\n                                                                getActiveAccount(): Promise<AccountInfo | undefined>;\n                                                                /**\n                                                                                     * Sets the active account\n                                                                                     *\n                                                                                     * @param account The account that will be set as the active account\n                                                                                     */\n                                                                setActiveAccount(account?: AccountInfo): Promise<void>;\n                                                                /**\n                                                                                     * Clear the active account\n                                                                                     */\n                                                                clearActiveAccount(): Promise<void>;\n                                                                setColorMode(colorMode: ColorMode): Promise<void>;\n                                                                getColorMode(): Promise<ColorMode>;\n                                                                /**\n                                                                                     * @deprecated\n                                                                                     *\n                                                                                     * Use getOwnAppMetadata instead\n                                                                                     */\n                                                                getAppMetadata(): Promise<AppMetadata>;\n                                                                /**\n                                                                                     * Will remove the account from the local storage and set a new active account if necessary.\n                                                                                     *\n                                                                                     * @param accountIdentifier ID of the account\n                                                                                     */\n                                                                removeAccount(accountIdentifier: string): Promise<void>;\n                                                                /**\n                                                                                     * Remove all accounts and set active account to undefined\n                                                                                     */\n                                                                removeAllAccounts(): Promise<void>;\n                                                                /**\n                                                                                     * Removes a peer and all the accounts that have been connected through that peer\n                                                                                     *\n                                                                                     * @param peer Peer to be removed\n                                                                                     */\n                                                                removePeer(peer: ExtendedPeerInfo, sendDisconnectToPeer?: boolean): Promise<void>;\n                                                                /**\n                                                                                     * Remove all peers and all accounts that have been connected through those peers\n                                                                                     */\n                                                                removeAllPeers(sendDisconnectToPeers?: boolean): Promise<void>;\n                                                                /**\n                                                                                     * Allows the user to subscribe to specific events that are fired in the SDK\n                                                                                     *\n                                                                                     * @param internalEvent The event to subscribe to\n                                                                                     * @param eventCallback The callback that will be called when the event occurs\n                                                                                     */\n                                                                subscribeToEvent<K extends BeaconEvent>(internalEvent: K, eventCallback: BeaconEventHandlerFunction<BeaconEventType[K]>): Promise<void>;\n                                                                /**\n                                                                                     * Check if we have permissions to send the specific message type to the active account.\n                                                                                     * If no active account is set, only permission requests are allowed.\n                                                                                     *\n                                                                                     * @param type The type of the message\n                                                                                     */\n                                                                checkPermissions(type: BeaconMessageType): Promise<boolean>;\n                                                                /**\n                                                                                     * Send a permission request to the DApp. This should be done as the first step. The wallet will respond\n                                                                                     * with an publicKey and permissions that were given. The account returned will be set as the \"activeAccount\"\n                                                                                     * and will be used for the following requests.\n                                                                                     *\n                                                                                     * @param input The message details we need to prepare the PermissionRequest message.\n                                                                                     */\n                                                                requestPermissions(input?: RequestPermissionInput): Promise<PermissionResponseOutput>;\n                                                                /**\n                                                                                     * This method will send a \"SignPayloadRequest\" to the wallet. This method is meant to be used to sign\n                                                                                     * arbitrary data (eg. a string). It will return the signature in the format of \"edsig...\"\n                                                                                     *\n                                                                                     * @param input The message details we need to prepare the SignPayloadRequest message.\n                                                                                     */\n                                                                requestSignPayload(input: RequestSignPayloadInput): Promise<SignPayloadResponseOutput>;\n                                                                /**\n                                                                                     * This method sends an OperationRequest to the wallet. This method should be used for all kinds of operations,\n                                                                                     * eg. transaction or delegation. Not all properties have to be provided. Data like \"counter\" and fees will be\n                                                                                     * fetched and calculated by the wallet (but they can still be provided if required).\n                                                                                     *\n                                                                                     * @param input The message details we need to prepare the OperationRequest message.\n                                                                                     */\n                                                                requestOperation(input: RequestOperationInput): Promise<OperationResponseOutput>;\n                                                                /**\n                                                                                     * Sends a \"BroadcastRequest\" to the wallet. This method can be used to inject an already signed transaction\n                                                                                     * to the network.\n                                                                                     *\n                                                                                     * @param input The message details we need to prepare the BroadcastRequest message.\n                                                                                     */\n                                                                requestBroadcast(input: RequestBroadcastInput): Promise<BroadcastResponseOutput>;\n                                                                protected setActivePeer(peer?: ExtendedPostMessagePairingResponse | ExtendedP2PPairingResponse): Promise<void>;\n                                                                /**\n                                                                                     * A \"setter\" for when the transport needs to be changed.\n                                                                                     */\n                                                                protected setTransport(transport?: Transport<any>): Promise<void>;\n                                }\n                }\n    \n                module 'test/clients/dapp-client/DAppClientOptions' {\n                                import { NetworkType, Storage } from 'test/';\n                                import { BeaconEvent, BeaconEventType, BeaconEventHandlerFunction } from 'test/events';\n                                import { ColorMode } from 'test/types/ColorMode';\n                                import { BlockExplorer } from 'test/utils/block-explorer';\n                                export interface DAppClientOptions {\n                                                                /**\n                                                                                     * Name of the application\n                                                                                     */\n                                                                name: string;\n                                                                /**\n                                                                                     * A URL to the icon of the application\n                                                                                     */\n                                                                iconUrl?: string;\n                                                                /**\n                                                                                     * A URL to the website of the application\n                                                                                     */\n                                                                appUrl?: string;\n                                                                /**\n                                                                                     * The storage that will be used by the SDK\n                                                                                     */\n                                                                storage?: Storage;\n                                                                /**\n                                                                                     * An object that will be used to overwrite default event handler behaviour.\n                                                                                     *\n                                                                                     * If you plan to overwrite all default events, use \"disableDefaultEvents\" instead.\n                                                                                     *\n                                                                                     * This will overwrite the default event handler, so this can lead to unexpected behavior in some cases.\n                                                                                     * We recommend that you overwrite all handlers if you want to use your own UI.\n                                                                                     *\n                                                                                     * If you simply want to be notified of events happening, but do not want to overwrite the default behavior,\n                                                                                     * please use `subscribeToEvent()` on the DAppClient instead.\n                                                                                     */\n                                                                eventHandlers?: {\n                                                                                                [key in BeaconEvent]?: {\n                                                                                                                                handler: BeaconEventHandlerFunction<BeaconEventType[key]>;\n                                                                                                };\n                                                                };\n                                                                /**\n                                                                                     * Disable all default Events and UI elements. If passed together with \"eventHandlers\",\n                                                                                     * the default eventHandlers will be removed, and the ones passed by the user will be added.\n                                                                                     */\n                                                                disableDefaultEvents?: boolean;\n                                                                /**\n                                                                                     * A list of matrix nodes to connect to. If a non-empty array is passed, the default options will be overwritten.\n                                                                                     * One node will be randomly selected based on the local keypair and the other nodes will be used as a fallback in case the primary node goes down.\n                                                                                     *\n                                                                                     * Only provide the hostname, no https:// prefix. Eg. ['matrix.example.com']\n                                                                                     */\n                                                                matrixNodes?: string[];\n                                                                /**\n                                                                                     * The block explorer used by the SDK\n                                                                                     */\n                                                                blockExplorer?: BlockExplorer;\n                                                                /**\n                                                                                     * Indicates on which network the DApp is planning to run. This is currently used to adjust the URLs of web-wallets in the pairing alert if they use different URLs for testnets.\n                                                                                     * You will still have to define the network you intend to use during the permission request.\n                                                                                     */\n                                                                preferredNetwork?: NetworkType;\n                                                                /**\n                                                                                     * Set the color mode for the UI elements (alerts and toasts)\n                                                                                     */\n                                                                colorMode?: ColorMode;\n                                }\n                }\n    \n                module 'test/clients/wallet-client/WalletClient' {\n                                import { Client, WalletClientOptions, TransportType, BeaconRequestOutputMessage, BeaconResponseInputMessage, AppMetadata, PermissionInfo } from 'test/';\n                                import { ConnectionContext } from 'test/types/ConnectionContext';\n                                import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n                                import { ExposedPromise } from 'test/utils/exposed-promise';\n                                import { PeerInfo } from 'test/types/PeerInfo';\n                                /**\n                                                     * The WalletClient has to be used in the wallet. It handles all the logic related to connecting to beacon-compatible\n                                                     * dapps and handling/responding to requests.\n                                                     */\n                                export class WalletClient extends Client {\n                                                                /**\n                                                                                     * Returns whether or not the transport is connected\n                                                                                     */\n                                                                protected readonly _isConnected: ExposedPromise<boolean>;\n                                                                get isConnected(): Promise<boolean>;\n                                                                constructor(config: WalletClientOptions);\n                                                                init(): Promise<TransportType>;\n                                                                /**\n                                                                                     * This method initiates a connection to the P2P network and registers a callback that will be called\n                                                                                     * whenever a message is received.\n                                                                                     *\n                                                                                     * @param newMessageCallback The callback that will be invoked for every message the transport receives.\n                                                                                     */\n                                                                connect(newMessageCallback: (message: BeaconRequestOutputMessage, connectionContext: ConnectionContext) => void): Promise<void>;\n                                                                /**\n                                                                                     * The method will attempt to initiate a connection using the active transport.\n                                                                                     */\n                                                                _connect(): Promise<void>;\n                                                                /**\n                                                                                     * This method sends a response for a specific request back to the DApp\n                                                                                     *\n                                                                                     * @param message The BeaconResponseMessage that will be sent back to the DApp\n                                                                                     */\n                                                                respond(message: BeaconResponseInputMessage): Promise<void>;\n                                                                getAppMetadataList(): Promise<AppMetadata[]>;\n                                                                getAppMetadata(senderId: string): Promise<AppMetadata | undefined>;\n                                                                removeAppMetadata(senderId: string): Promise<void>;\n                                                                removeAllAppMetadata(): Promise<void>;\n                                                                getPermissions(): Promise<PermissionInfo[]>;\n                                                                getPermission(accountIdentifier: string): Promise<PermissionInfo | undefined>;\n                                                                removePermission(accountIdentifier: string): Promise<void>;\n                                                                removeAllPermissions(): Promise<void>;\n                                                                /**\n                                                                                     * Add a new peer to the known peers\n                                                                                     * @param peer The new peer to add\n                                                                                     */\n                                                                addPeer(peer: PeerInfo): Promise<void>;\n                                                                removePeer(peer: ExtendedP2PPairingResponse, sendDisconnectToPeer?: boolean): Promise<void>;\n                                                                removeAllPeers(sendDisconnectToPeers?: boolean): Promise<void>;\n                                }\n                }\n    \n                module 'test/clients/wallet-client/WalletClientOptions' {\n                                import { Storage } from 'test/';\n                                export interface WalletClientOptions {\n                                                                /**\n                                                                                     * Name of the application\n                                                                                     */\n                                                                name: string;\n                                                                /**\n                                                                                     * A URL to the icon of the application\n                                                                                     */\n                                                                iconUrl?: string;\n                                                                /**\n                                                                                     * A URL to the website of the application\n                                                                                     */\n                                                                appUrl?: string;\n                                                                /**\n                                                                                     * The storage that will be used by the SDK\n                                                                                     */\n                                                                storage?: Storage;\n                                                                /**\n                                                                                     * A list of matrix nodes to connect to. If a non-empty array is passed, the default options will be overwritten.\n                                                                                     * One node will be randomly selected based on the local keypair and the other nodes will be used as a fallback in case the primary node goes down.\n                                                                                     *\n                                                                                     * Only provide the hostname, no https:// prefix. Eg. ['matrix.example.com']\n                                                                                     */\n                                                                matrixNodes?: string[];\n                                }\n                }\n    \n                module 'test/colorMode' {\n                                import { ColorMode } from 'test/types/ColorMode';\n                                export const setColorMode: (mode: ColorMode) => void;\n                                export const getColorMode: () => ColorMode;\n                }\n    \n                module 'test/constants' {\n                                export const SDK_VERSION: string;\n                                export const BEACON_VERSION: string;\n                }\n    \n                module 'test/debug' {\n                                export const setDebugEnabled: (enabled: boolean) => void;\n                                export const getDebugEnabled: () => boolean;\n                }\n    \n                module 'test/errors/AbortedBeaconError' {\n                                import { BeaconError } from 'test/';\n                                export class AbortedBeaconError extends BeaconError {\n                                                name: string;\n                                                title: string;\n                                                constructor();\n                                }\n                }\n    \n                module 'test/errors/BeaconError' {\n                                import { BeaconErrorType } from 'test/';\n                                export abstract class BeaconError implements Error {\n                                                name: string;\n                                                message: string;\n                                                title: string;\n                                                description: string;\n                                                get fullDescription(): string;\n                                                constructor(errorType: BeaconErrorType, message: string);\n                                                static getError(errorType: BeaconErrorType, errorData: any): BeaconError;\n                                }\n                }\n    \n                module 'test/errors/BroadcastBeaconError' {\n                                import { BeaconError } from 'test/';\n                                export class BroadcastBeaconError extends BeaconError {\n                                                name: string;\n                                                title: string;\n                                                constructor();\n                                }\n                }\n    \n                module 'test/errors/NetworkNotSupportedBeaconError' {\n                                import { BeaconError } from 'test/';\n                                export class NetworkNotSupportedBeaconError extends BeaconError {\n                                                name: string;\n                                                title: string;\n                                                constructor();\n                                }\n                }\n    \n                module 'test/errors/NoAddressBeaconError' {\n                                import { BeaconError } from 'test/';\n                                export class NoAddressBeaconError extends BeaconError {\n                                                name: string;\n                                                title: string;\n                                                constructor();\n                                }\n                }\n    \n                module 'test/errors/NoPrivateKeyBeaconError' {\n                                import { BeaconError } from 'test/';\n                                export class NoPrivateKeyBeaconError extends BeaconError {\n                                                name: string;\n                                                title: string;\n                                                constructor();\n                                }\n                }\n    \n                module 'test/errors/NotGrantedBeaconError' {\n                                import { BeaconError } from 'test/';\n                                export class NotGrantedBeaconError extends BeaconError {\n                                                name: string;\n                                                title: string;\n                                                constructor();\n                                }\n                }\n    \n                module 'test/errors/ParametersInvalidBeaconError' {\n                                import { BeaconError } from 'test/';\n                                export class ParametersInvalidBeaconError extends BeaconError {\n                                                name: string;\n                                                title: string;\n                                                constructor();\n                                }\n                }\n    \n                module 'test/errors/SignatureTypeNotSupportedBeaconError' {\n                                import { BeaconError } from 'test/';\n                                export class SignatureTypeNotSupportedBeaconError extends BeaconError {\n                                                name: string;\n                                                title: string;\n                                                constructor();\n                                }\n                }\n    \n                module 'test/errors/TooManyOperationsBeaconError' {\n                                import { BeaconError } from 'test/';\n                                export class TooManyOperationsBeaconError extends BeaconError {\n                                                name: string;\n                                                title: string;\n                                                constructor();\n                                }\n                }\n    \n                module 'test/errors/TransactionInvalidBeaconError' {\n                                import { BeaconError } from 'test/';\n                                export class TransactionInvalidBeaconError extends BeaconError {\n                                                readonly data: any;\n                                                name: string;\n                                                title: string;\n                                                get fullDescription(): string;\n                                                constructor(data: any);\n                                }\n                }\n    \n                module 'test/errors/UnknownBeaconError' {\n                                import { BeaconError } from 'test/';\n                                export class UnknownBeaconError extends BeaconError {\n                                                name: string;\n                                                title: string;\n                                                constructor();\n                                }\n                }\n    \n                module 'test/events' {\n                                import { AlertButton } from 'test/ui/alert/Alert';\n                                import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n                                import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n                                import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n                                import { BlockExplorer } from 'test/utils/block-explorer';\n                                import { P2PPairingRequest, AccountInfo, ErrorResponse, PermissionResponseOutput, OperationResponseOutput, BroadcastResponseOutput, SignPayloadResponseOutput, Network, ConnectionContext, Transport, NetworkType, AcknowledgeResponse } from 'test/';\n                                /**\n                                                     * The different events that can be emitted by the beacon-sdk\n                                                     */\n                                export enum BeaconEvent {\n                                                                PERMISSION_REQUEST_SENT = \"PERMISSION_REQUEST_SENT\",\n                                                                PERMISSION_REQUEST_SUCCESS = \"PERMISSION_REQUEST_SUCCESS\",\n                                                                PERMISSION_REQUEST_ERROR = \"PERMISSION_REQUEST_ERROR\",\n                                                                OPERATION_REQUEST_SENT = \"OPERATION_REQUEST_SENT\",\n                                                                OPERATION_REQUEST_SUCCESS = \"OPERATION_REQUEST_SUCCESS\",\n                                                                OPERATION_REQUEST_ERROR = \"OPERATION_REQUEST_ERROR\",\n                                                                SIGN_REQUEST_SENT = \"SIGN_REQUEST_SENT\",\n                                                                SIGN_REQUEST_SUCCESS = \"SIGN_REQUEST_SUCCESS\",\n                                                                SIGN_REQUEST_ERROR = \"SIGN_REQUEST_ERROR\",\n                                                                BROADCAST_REQUEST_SENT = \"BROADCAST_REQUEST_SENT\",\n                                                                BROADCAST_REQUEST_SUCCESS = \"BROADCAST_REQUEST_SUCCESS\",\n                                                                BROADCAST_REQUEST_ERROR = \"BROADCAST_REQUEST_ERROR\",\n                                                                ACKNOWLEDGE_RECEIVED = \"ACKNOWLEDGE_RECEIVED\",\n                                                                LOCAL_RATE_LIMIT_REACHED = \"LOCAL_RATE_LIMIT_REACHED\",\n                                                                NO_PERMISSIONS = \"NO_PERMISSIONS\",\n                                                                ACTIVE_ACCOUNT_SET = \"ACTIVE_ACCOUNT_SET\",\n                                                                ACTIVE_TRANSPORT_SET = \"ACTIVE_TRANSPORT_SET\",\n                                                                PAIR_INIT = \"PAIR_INIT\",\n                                                                PAIR_SUCCESS = \"PAIR_SUCCESS\",\n                                                                CHANNEL_CLOSED = \"CHANNEL_CLOSED\",\n                                                                INTERNAL_ERROR = \"INTERNAL_ERROR\",\n                                                                UNKNOWN = \"UNKNOWN\"\n                                }\n                                export interface WalletInfo {\n                                                                name: string;\n                                                                icon?: string;\n                                }\n                                export interface ExtraInfo {\n                                                                resetCallback?(): Promise<void>;\n                                }\n                                interface RequestSentInfo {\n                                                                extraInfo: ExtraInfo;\n                                                                walletInfo: WalletInfo;\n                                }\n                                /**\n                                                     * The type of the payload of the different BeaconEvents\n                                                     */\n                                export interface BeaconEventType {\n                                                                [BeaconEvent.PERMISSION_REQUEST_SENT]: RequestSentInfo;\n                                                                [BeaconEvent.PERMISSION_REQUEST_SUCCESS]: {\n                                                                                                account: AccountInfo;\n                                                                                                output: PermissionResponseOutput;\n                                                                                                blockExplorer: BlockExplorer;\n                                                                                                connectionContext: ConnectionContext;\n                                                                                                walletInfo: WalletInfo;\n                                                                };\n                                                                [BeaconEvent.PERMISSION_REQUEST_ERROR]: {\n                                                                                                errorResponse: ErrorResponse;\n                                                                                                walletInfo: WalletInfo;\n                                                                };\n                                                                [BeaconEvent.OPERATION_REQUEST_SENT]: RequestSentInfo;\n                                                                [BeaconEvent.OPERATION_REQUEST_SUCCESS]: {\n                                                                                                account: AccountInfo;\n                                                                                                output: OperationResponseOutput;\n                                                                                                blockExplorer: BlockExplorer;\n                                                                                                connectionContext: ConnectionContext;\n                                                                                                walletInfo: WalletInfo;\n                                                                };\n                                                                [BeaconEvent.OPERATION_REQUEST_ERROR]: {\n                                                                                                errorResponse: ErrorResponse;\n                                                                                                walletInfo: WalletInfo;\n                                                                };\n                                                                [BeaconEvent.SIGN_REQUEST_SENT]: RequestSentInfo;\n                                                                [BeaconEvent.SIGN_REQUEST_SUCCESS]: {\n                                                                                                output: SignPayloadResponseOutput;\n                                                                                                connectionContext: ConnectionContext;\n                                                                                                walletInfo: WalletInfo;\n                                                                };\n                                                                [BeaconEvent.SIGN_REQUEST_ERROR]: {\n                                                                                                errorResponse: ErrorResponse;\n                                                                                                walletInfo: WalletInfo;\n                                                                };\n                                                                [BeaconEvent.BROADCAST_REQUEST_SENT]: RequestSentInfo;\n                                                                [BeaconEvent.BROADCAST_REQUEST_SUCCESS]: {\n                                                                                                network: Network;\n                                                                                                output: BroadcastResponseOutput;\n                                                                                                blockExplorer: BlockExplorer;\n                                                                                                connectionContext: ConnectionContext;\n                                                                                                walletInfo: WalletInfo;\n                                                                };\n                                                                [BeaconEvent.BROADCAST_REQUEST_ERROR]: {\n                                                                                                errorResponse: ErrorResponse;\n                                                                                                walletInfo: WalletInfo;\n                                                                };\n                                                                [BeaconEvent.ACKNOWLEDGE_RECEIVED]: {\n                                                                                                message: AcknowledgeResponse;\n                                                                                                extraInfo: ExtraInfo;\n                                                                                                walletInfo: WalletInfo;\n                                                                };\n                                                                [BeaconEvent.LOCAL_RATE_LIMIT_REACHED]: undefined;\n                                                                [BeaconEvent.NO_PERMISSIONS]: undefined;\n                                                                [BeaconEvent.ACTIVE_ACCOUNT_SET]: AccountInfo;\n                                                                [BeaconEvent.ACTIVE_TRANSPORT_SET]: Transport;\n                                                                [BeaconEvent.PAIR_INIT]: {\n                                                                                                p2pPeerInfo: P2PPairingRequest;\n                                                                                                postmessagePeerInfo: PostMessagePairingRequest;\n                                                                                                preferredNetwork: NetworkType;\n                                                                                                abortedHandler?(): void;\n                                                                };\n                                                                [BeaconEvent.PAIR_SUCCESS]: ExtendedPostMessagePairingResponse | ExtendedP2PPairingResponse;\n                                                                [BeaconEvent.CHANNEL_CLOSED]: string;\n                                                                [BeaconEvent.INTERNAL_ERROR]: string;\n                                                                [BeaconEvent.UNKNOWN]: undefined;\n                                }\n                                export type BeaconEventHandlerFunction<T = unknown> = (data: T, eventCallback?: AlertButton[]) => void | Promise<void>;\n                                /**\n                                                     * The default event handlers\n                                                     */\n                                export const defaultEventCallbacks: {\n                                                                [key in BeaconEvent]: BeaconEventHandlerFunction<BeaconEventType[key]>;\n                                };\n                                /**\n                                                     * Handles beacon events\n                                                     */\n                                export class BeaconEventHandler {\n                                                                constructor(eventsToOverride?: {\n                                                                                                [key in BeaconEvent]?: {\n                                                                                                                                handler: BeaconEventHandlerFunction<BeaconEventType[key]>;\n                                                                                                };\n                                                                }, overrideAll?: boolean);\n                                                                /**\n                                                                                     * A method to subscribe to a specific beacon event and register a callback\n                                                                                     *\n                                                                                     * @param event The event being emitted\n                                                                                     * @param eventCallback The callback that will be invoked\n                                                                                     */\n                                                                on<K extends BeaconEvent>(event: K, eventCallback: BeaconEventHandlerFunction<BeaconEventType[K]>): Promise<void>;\n                                                                /**\n                                                                                     * Emit a beacon event\n                                                                                     *\n                                                                                     * @param event The event being emitted\n                                                                                     * @param data The data to be emit\n                                                                                     */\n                                                                emit<K extends BeaconEvent>(event: K, data?: BeaconEventType[K], eventCallback?: AlertButton[]): Promise<void>;\n                                }\n                                export {};\n                }\n    \n                module 'test/examples/broadcast-request' {\n                                export {};\n                }\n    \n                module 'test/examples/custom-block-explorer' {\n                                export {};\n                }\n    \n                module 'test/examples/disable-all-ui' {\n                                export {};\n                }\n    \n                module 'test/examples/operation-request' {\n                                export {};\n                }\n    \n                module 'test/examples/override-default-events' {\n                                export {};\n                }\n    \n                module 'test/examples/permission-request' {\n                                export {};\n                }\n    \n                module 'test/examples/sign-payload-request' {\n                                export {};\n                }\n    \n                module 'test/examples/using-custom-network' {\n                                export {};\n                }\n    \n                module 'test/examples/wallet-example' {\n                                export {};\n                }\n    \n                module 'test/index' {\n                                import { P2PCommunicationClient } from 'test/transports/clients/P2PCommunicationClient';\n                                import { AppMetadata } from 'test/types/beacon/AppMetadata';\n                                import { PermissionRequest } from 'test/types/beacon/messages/PermissionRequest';\n                                import { Network } from 'test/types/beacon/Network';\n                                import { BeaconBaseMessage } from 'test/types/beacon/BeaconBaseMessage';\n                                import { BeaconMessageType } from 'test/types/beacon/BeaconMessageType';\n                                import { PermissionScope } from 'test/types/beacon/PermissionScope';\n                                import { PermissionResponse } from 'test/types/beacon/messages/PermissionResponse';\n                                import { OperationRequest } from 'test/types/beacon/messages/OperationRequest';\n                                import { OperationResponse } from 'test/types/beacon/messages/OperationResponse';\n                                import { SignPayloadRequest } from 'test/types/beacon/messages/SignPayloadRequest';\n                                import { SignPayloadResponse } from 'test/types/beacon/messages/SignPayloadResponse';\n                                import { BroadcastRequest } from 'test/types/beacon/messages/BroadcastRequest';\n                                import { BroadcastResponse } from 'test/types/beacon/messages/BroadcastResponse';\n                                import { NetworkType } from 'test/types/beacon/NetworkType';\n                                import { TezosBaseOperation } from 'test/types/tezos/TezosBaseOperation';\n                                import { TezosOperationType } from 'test/types/tezos/OperationTypes';\n                                import { TezosActivateAccountOperation } from 'test/types/tezos/operations/ActivateAccount';\n                                import { TezosBallotOperation } from 'test/types/tezos/operations/Ballot';\n                                import { TezosDelegationOperation } from 'test/types/tezos/operations/Delegation';\n                                import { TezosDoubleBakingEvidenceOperation } from 'test/types/tezos/operations/DoubleBakingEvidence';\n                                import { TezosBlockHeader } from 'test/types/tezos/TezosBlockHeader';\n                                import { TezosDoubleEndorsementEvidenceOperation } from 'test/types/tezos/operations/DoubleEndorsementEvidence';\n                                import { TezosEndorsementOperation } from 'test/types/tezos/operations/Endorsement';\n                                import { TezosOriginationOperation } from 'test/types/tezos/operations/Origination';\n                                import { TezosProposalOperation } from 'test/types/tezos/operations/Proposal';\n                                import { TezosRevealOperation } from 'test/types/tezos/operations/Reveal';\n                                import { TezosSeedNonceRevelationOperation } from 'test/types/tezos/operations/SeedNonceRevelation';\n                                import { TezosTransactionOperation } from 'test/types/tezos/operations/Transaction';\n                                import { MichelsonPrimitives } from 'test/types/tezos/MichelsonPrimitives';\n                                import { TezosTransactionParameters } from 'test/types/tezos/TezosTransactionParameters';\n                                import { Origin } from 'test/types/Origin';\n                                import { AccountInfo, AccountIdentifier } from 'test/types/AccountInfo';\n                                import { EncryptedExtensionMessage, ExtensionMessage } from 'test/types/ExtensionMessage';\n                                import { ExtensionMessageTarget } from 'test/types/ExtensionMessageTarget';\n                                import { TezosOperation } from 'test/types/tezos/TezosOperation';\n                                import { Client } from 'test/clients/client/Client';\n                                import { WalletClient } from 'test/clients/wallet-client/WalletClient';\n                                import { DAppClient } from 'test/clients/dapp-client/DAppClient';\n                                import { BeaconError } from 'test/errors/BeaconError';\n                                import { BeaconErrorType } from 'test/types/BeaconErrorType';\n                                import { BroadcastBeaconError } from 'test/errors/BroadcastBeaconError';\n                                import { NetworkNotSupportedBeaconError } from 'test/errors/NetworkNotSupportedBeaconError';\n                                import { NoAddressBeaconError } from 'test/errors/NoAddressBeaconError';\n                                import { NoPrivateKeyBeaconError } from 'test/errors/NoPrivateKeyBeaconError';\n                                import { NotGrantedBeaconError } from 'test/errors/NotGrantedBeaconError';\n                                import { ParametersInvalidBeaconError } from 'test/errors/ParametersInvalidBeaconError';\n                                import { TooManyOperationsBeaconError } from 'test/errors/TooManyOperationsBeaconError';\n                                import { TransactionInvalidBeaconError } from 'test/errors/TransactionInvalidBeaconError';\n                                import { UnknownBeaconError } from 'test/errors/UnknownBeaconError';\n                                import { ErrorResponse } from 'test/types/beacon/messages/ErrorResponse';\n                                import { TransportStatus } from 'test/types/transport/TransportStatus';\n                                import { TransportType } from 'test/types/transport/TransportType';\n                                import { PostMessageTransport } from 'test/transports/PostMessageTransport';\n                                import { Transport } from 'test/transports/Transport';\n                                import { P2PTransport } from 'test/transports/P2PTransport';\n                                import { Storage } from 'test/storage/Storage';\n                                import { StorageKey } from 'test/types/storage/StorageKey';\n                                import { StorageKeyReturnDefaults } from 'test/types/storage/StorageKeyReturnDefaults';\n                                import { StorageKeyReturnType } from 'test/types/storage/StorageKeyReturnType';\n                                import { ExtendedP2PPairingRequest, P2PPairingRequest } from 'test/types/P2PPairingRequest';\n                                import { ChromeStorage } from 'test/storage/ChromeStorage';\n                                import { LocalStorage } from 'test/storage/LocalStorage';\n                                import { getStorage } from 'test/storage/getStorage';\n                                import { BeaconMessage } from 'test/types/beacon/BeaconMessage';\n                                import { Serializer } from 'test/Serializer';\n                                import { RequestPermissionInput } from 'test/types/RequestPermissionInput';\n                                import { RequestSignPayloadInput } from 'test/types/RequestSignPayloadInput';\n                                import { RequestOperationInput } from 'test/types/RequestOperationInput';\n                                import { RequestBroadcastInput } from 'test/types/RequestBroadcastInput';\n                                import { PermissionResponseInput, SignPayloadResponseInput, OperationResponseInput, BroadcastResponseInput, BeaconResponseInputMessage, AcknowledgeResponseInput, ErrorResponseInput } from 'test/types/beacon/messages/BeaconResponseInputMessage';\n                                import { PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, BeaconResponseOutputMessage } from 'test/types/beacon/messages/BeaconResponseOutputMessage';\n                                import { PermissionRequestInput, SignPayloadRequestInput, OperationRequestInput, BroadcastRequestInput, BeaconRequestInputMessage } from 'test/types/beacon/messages/BeaconRequestInputMessage';\n                                import { PermissionRequestOutput, SignPayloadRequestOutput, OperationRequestOutput, BroadcastRequestOutput, BeaconRequestOutputMessage } from 'test/types/beacon/messages/BeaconRequestOutputMessage';\n                                import { ClientOptions } from 'test/clients/client/ClientOptions';\n                                import { DAppClientOptions } from 'test/clients/dapp-client/DAppClientOptions';\n                                import { WalletClientOptions } from 'test/clients/wallet-client/WalletClientOptions';\n                                import { PermissionInfo } from 'test/types/PermissionInfo';\n                                import { SDK_VERSION, BEACON_VERSION } from 'test/constants';\n                                import { AccountManager } from 'test/managers/AccountManager';\n                                import { AppMetadataManager } from 'test/managers/AppMetadataManager';\n                                import { PermissionManager } from 'test/managers/PermissionManager';\n                                import { BeaconEvent, BeaconEventHandler, defaultEventCallbacks } from 'test/events';\n                                import { getAddressFromPublicKey } from 'test/utils/crypto';\n                                import { BeaconClient } from 'test/clients/beacon-client/BeaconClient';\n                                import { BeaconClientOptions } from 'test/clients/beacon-client/BeaconClientOptions';\n                                import { getAccountIdentifier } from 'test/utils/get-account-identifier';\n                                import { ConnectionContext } from 'test/types/ConnectionContext';\n                                import { Threshold } from 'test/types/beacon/Threshold';\n                                import { PartialTezosTransactionOperation, PartialTezosOperation, PartialTezosDelegationOperation, PartialTezosOriginationOperation, PartialTezosRevealOperation } from 'test/types/tezos/PartialTezosOperation';\n                                import { AbortedBeaconError } from 'test/errors/AbortedBeaconError';\n                                import { ExtendedPeerInfo, PeerInfo } from 'test/types/PeerInfo';\n                                import { availableTransports } from 'test/utils/available-transports';\n                                import { AcknowledgeResponse } from 'test/types/beacon/messages/AcknowledgeResponse';\n                                import { DisconnectMessage } from 'test/types/beacon/messages/DisconnectMessage';\n                                import { DappP2PTransport } from 'test/transports/DappP2PTransport';\n                                import { DappPostMessageTransport } from 'test/transports/DappPostMessageTransport';\n                                import { WalletP2PTransport } from 'test/transports/WalletP2PTransport';\n                                import { WalletPostMessageTransport } from 'test/transports/WalletPostMessageTransport';\n                                import { getSenderId } from 'test/utils/get-sender-id';\n                                import { SigningType } from 'test/types/beacon/SigningType';\n                                import { SignatureTypeNotSupportedBeaconError } from 'test/errors/SignatureTypeNotSupportedBeaconError';\n                                import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n                                import { ExtendedPostMessagePairingRequest, PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n                                import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n                                import { PeerManager } from 'test/managers/PeerManager';\n                                import { MessageBasedClient } from 'test/transports/clients/MessageBasedClient';\n                                import { BeaconRequestMessage } from 'test/types/beacon/BeaconRequestMessage';\n                                import { BeaconResponseMessage } from 'test/types/beacon/BeaconResponseMessage';\n                                import { Pairing } from 'test/ui/alert/Pairing';\n                                import { BlockExplorer } from 'test/utils/block-explorer';\n                                import { TezblockBlockExplorer } from 'test/utils/tezblock-blockexplorer';\n                                import { setDebugEnabled, getDebugEnabled } from 'test/debug';\n                                import { ColorMode } from 'test/types/ColorMode';\n                                export { TezosBaseOperation, TezosOperationType, TezosBlockHeader, MichelsonPrimitives, TezosTransactionParameters, TezosOperation };\n                                export { TezosActivateAccountOperation, TezosBallotOperation, TezosDelegationOperation, TezosDoubleBakingEvidenceOperation, TezosDoubleEndorsementEvidenceOperation, TezosEndorsementOperation, TezosOriginationOperation, TezosProposalOperation, TezosRevealOperation, TezosSeedNonceRevelationOperation, TezosTransactionOperation, PartialTezosOperation, PartialTezosTransactionOperation, PartialTezosDelegationOperation, PartialTezosOriginationOperation, PartialTezosRevealOperation };\n                                export { BeaconClient, BeaconClientOptions, Client, ClientOptions, DAppClient, DAppClientOptions, WalletClient, WalletClientOptions, P2PCommunicationClient };\n                                export { AccountIdentifier, AppMetadata, Network, NetworkType, BeaconMessage, PermissionRequest, PermissionResponse, OperationRequest, OperationResponse, SignPayloadRequest, SignPayloadResponse, BroadcastRequest, BroadcastResponse, AcknowledgeResponse, DisconnectMessage, BeaconBaseMessage, BeaconMessageType, PermissionScope, Origin, AccountInfo, Threshold, SigningType, ExtensionMessageTarget, ExtensionMessage, EncryptedExtensionMessage, RequestPermissionInput, RequestSignPayloadInput, RequestOperationInput, RequestBroadcastInput, PermissionInfo };\n                                export { PermissionResponseInput, SignPayloadResponseInput, OperationResponseInput, BroadcastResponseInput, AcknowledgeResponseInput, ErrorResponseInput, PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, PermissionRequestInput, SignPayloadRequestInput, OperationRequestInput, BroadcastRequestInput, PermissionRequestOutput, SignPayloadRequestOutput, OperationRequestOutput, BroadcastRequestOutput, BeaconRequestInputMessage, BeaconRequestOutputMessage, BeaconResponseInputMessage, BeaconResponseOutputMessage, BeaconRequestMessage, BeaconResponseMessage };\n                                export { BeaconError, BeaconErrorType, ErrorResponse, AbortedBeaconError, BroadcastBeaconError, NetworkNotSupportedBeaconError, NoAddressBeaconError, NoPrivateKeyBeaconError, NotGrantedBeaconError, ParametersInvalidBeaconError, TooManyOperationsBeaconError, TransactionInvalidBeaconError, SignatureTypeNotSupportedBeaconError, UnknownBeaconError };\n                                export { TransportStatus, TransportType, Transport, PostMessageTransport, P2PTransport, WalletP2PTransport, WalletPostMessageTransport, DappP2PTransport, DappPostMessageTransport, MessageBasedClient, Pairing };\n                                export { BeaconEvent, BeaconEventHandler, defaultEventCallbacks };\n                                export { Storage, StorageKey, StorageKeyReturnDefaults, StorageKeyReturnType, ChromeStorage, LocalStorage, getStorage };\n                                export { PeerManager, AccountManager, AppMetadataManager, PermissionManager };\n                                export { SDK_VERSION, BEACON_VERSION };\n                                export { getSenderId, getAccountIdentifier, getAddressFromPublicKey };\n                                export { PeerInfo, ExtendedPeerInfo, PostMessagePairingRequest, ExtendedPostMessagePairingRequest, ExtendedPostMessagePairingResponse, P2PPairingRequest, ExtendedP2PPairingRequest, ExtendedP2PPairingResponse };\n                                export { BlockExplorer, TezblockBlockExplorer };\n                                export { ConnectionContext, Serializer, availableTransports, ColorMode };\n                                export { setDebugEnabled, getDebugEnabled };\n                }\n    \n                module 'test/interceptors/IncomingRequestInterceptor' {\n                                import { BeaconRequestOutputMessage } from 'test/';\n                                import { ConnectionContext } from 'test/types/ConnectionContext';\n                                import { AppMetadataManager } from 'test/managers/AppMetadataManager';\n                                import { BeaconRequestMessage } from 'test/types/beacon/BeaconRequestMessage';\n                                interface IncomingRequestInterceptorOptions {\n                                                                message: BeaconRequestMessage;\n                                                                connectionInfo: ConnectionContext;\n                                                                appMetadataManager: AppMetadataManager;\n                                                                interceptorCallback(message: BeaconRequestOutputMessage, connectionInfo: ConnectionContext): void;\n                                }\n                                /**\n                                                     * The IncomingRequestInterceptor is used in the WalletClient to intercept an incoming request and enrich it with data, like app metadata.\n                                                     */\n                                export class IncomingRequestInterceptor {\n                                                                /**\n                                                                                     * The method that is called during the interception\n                                                                                     *\n                                                                                     * @param config\n                                                                                     */\n                                                                static intercept(config: IncomingRequestInterceptorOptions): Promise<void>;\n                                }\n                                export {};\n                }\n    \n                module 'test/interceptors/OutgoingResponseInterceptor' {\n                                import { BeaconMessage, BeaconResponseInputMessage, AppMetadata } from 'test/';\n                                import { PermissionManager } from 'test/managers/PermissionManager';\n                                import { AppMetadataManager } from 'test/managers/AppMetadataManager';\n                                import { BeaconRequestMessage } from 'test/types/beacon/BeaconRequestMessage';\n                                interface OutgoingResponseInterceptorOptions {\n                                                senderId: string;\n                                                request: BeaconRequestMessage;\n                                                message: BeaconResponseInputMessage;\n                                                ownAppMetadata: AppMetadata;\n                                                permissionManager: PermissionManager;\n                                                appMetadataManager: AppMetadataManager;\n                                                interceptorCallback(message: BeaconMessage): void;\n                                }\n                                /**\n                                             * The OutgoingResponseInterceptor is used in the WalletClient to intercept an outgoing response and enrich it with data.\n                                             */\n                                export class OutgoingResponseInterceptor {\n                                                static intercept(config: OutgoingResponseInterceptorOptions): Promise<void>;\n                                }\n                                export {};\n                }\n    \n                module 'test/managers/AccountManager' {\n                                import { Storage, AccountInfo, BeaconMessage } from 'test/';\n                                /**\n                                             * The AccountManager provides CRUD functionality for account entities and persists them to the provided storage.\n                                             */\n                                export class AccountManager {\n                                                constructor(storage: Storage);\n                                                getAccounts(): Promise<AccountInfo[]>;\n                                                getAccount(accountIdentifier: string): Promise<AccountInfo | undefined>;\n                                                addAccount(accountInfo: AccountInfo): Promise<void>;\n                                                removeAccount(accountIdentifier: string): Promise<void>;\n                                                removeAccounts(accountIdentifiers: string[]): Promise<void>;\n                                                removeAllAccounts(): Promise<void>;\n                                                hasPermission(message: BeaconMessage): Promise<boolean>;\n                                }\n                }\n    \n                module 'test/managers/AppMetadataManager' {\n                                import { Storage, AppMetadata } from 'test/';\n                                /**\n                                             * The AppMetadataManager provides CRUD functionality for app-metadata entities and persists them to the provided storage.\n                                             */\n                                export class AppMetadataManager {\n                                                constructor(storage: Storage);\n                                                getAppMetadataList(): Promise<AppMetadata[]>;\n                                                getAppMetadata(senderId: string): Promise<AppMetadata | undefined>;\n                                                addAppMetadata(appMetadata: AppMetadata): Promise<void>;\n                                                removeAppMetadata(senderId: string): Promise<void>;\n                                                removeAppMetadatas(senderIds: string[]): Promise<void>;\n                                                removeAllAppMetadata(): Promise<void>;\n                                }\n                }\n    \n                module 'test/managers/PeerManager' {\n                                import { Storage, StorageKey, StorageKeyReturnType } from 'test/';\n                                import { ArrayElem } from 'test/managers/StorageManager';\n                                /**\n                                             * The PeerManager provides CRUD functionality for peer entities and persists them to the provided storage.\n                                             */\n                                export class PeerManager<T extends StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET> {\n                                                constructor(storage: Storage, key: T);\n                                                hasPeer(publicKey: string): Promise<boolean>;\n                                                getPeers(): Promise<StorageKeyReturnType[T]>;\n                                                getPeer(publicKey: string): Promise<ArrayElem<StorageKeyReturnType[T]> | undefined>;\n                                                addPeer(peerInfo: ArrayElem<StorageKeyReturnType[T]>): Promise<void>;\n                                                removePeer(publicKey: string): Promise<void>;\n                                                removePeers(publicKeys: string[]): Promise<void>;\n                                                removeAllPeers(): Promise<void>;\n                                }\n                }\n    \n                module 'test/managers/PermissionManager' {\n                                import { BeaconMessage, Storage } from 'test/';\n                                import { PermissionInfo } from 'test/types/PermissionInfo';\n                                /**\n                                             * The PermissionManager provides CRUD functionality for permission entities and persists them to the provided storage.\n                                             */\n                                export class PermissionManager {\n                                                constructor(storage: Storage);\n                                                getPermissions(): Promise<PermissionInfo[]>;\n                                                getPermission(accountIdentifier: string): Promise<PermissionInfo | undefined>;\n                                                addPermission(permissionInfo: PermissionInfo): Promise<void>;\n                                                removePermission(accountIdentifier: string): Promise<void>;\n                                                removePermissions(accountIdentifiers: string[]): Promise<void>;\n                                                removeAllPermissions(): Promise<void>;\n                                                hasPermission(message: BeaconMessage): Promise<boolean>;\n                                }\n                }\n    \n                module 'test/managers/PermissionValidator' {\n                                import { BeaconMessage } from 'test/';\n                                import { PermissionEntity } from 'test/types/PermissionEntity';\n                                /**\n                                                     * The PermissionValidator is used to check if permissions for a certain message type have been given\n                                                     */\n                                export class PermissionValidator {\n                                                                /**\n                                                                                     * Check if permissions were given for a certain message type.\n                                                                                     *\n                                                                                     * PermissionRequest and BroadcastRequest will always return true.\n                                                                                     *\n                                                                                     * @param message Beacon Message\n                                                                                     */\n                                                                static hasPermission(message: BeaconMessage, getOne: (id: string) => Promise<PermissionEntity | undefined>, getAll: () => Promise<PermissionEntity[]>): Promise<boolean>;\n                                }\n                }\n    \n                module 'test/managers/StorageManager' {\n                                import { StorageKey, Storage, StorageKeyReturnType } from 'test/';\n                                /** Type workaround for https://github.com/Microsoft/TypeScript/issues/7294#issuecomment-465794460 */\n                                export type ArrayElem<A> = A extends (infer Elem)[] ? Elem : never;\n                                /**\n                                                     * The StorageManager provides CRUD functionality for specific entities and persists them to the provided storage.\n                                                     */\n                                export class StorageManager<T extends StorageKey.ACCOUNTS | StorageKey.APP_METADATA_LIST | StorageKey.PERMISSION_LIST | StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET> {\n                                                                constructor(storage: Storage, storageKey: T);\n                                                                getAll(): Promise<StorageKeyReturnType[T]>;\n                                                                getOne(predicate: (element: ArrayElem<StorageKeyReturnType[T]>) => boolean): Promise<ArrayElem<StorageKeyReturnType[T]> | undefined>;\n                                                                addOne(element: ArrayElem<StorageKeyReturnType[T]>, predicate: (element: ArrayElem<StorageKeyReturnType[T]>) => boolean, overwrite?: boolean): Promise<void>;\n                                                                remove(predicate: (element: ArrayElem<StorageKeyReturnType[T]>) => boolean): Promise<void>;\n                                                                removeAll(): Promise<void>;\n                                }\n                }\n    \n                module 'test/matrix-client/MatrixClient' {\n                                import { Storage } from 'test/storage/Storage';\n                                import { MatrixClientStore } from 'test/matrix-client/MatrixClientStore';\n                                import { MatrixRoom } from 'test/matrix-client/models/MatrixRoom';\n                                import { MatrixRoomService } from 'test/matrix-client/services/MatrixRoomService';\n                                import { MatrixUserService } from 'test/matrix-client/services/MatrixUserService';\n                                import { MatrixEventService } from 'test/matrix-client/services/MatrixEventService';\n                                import { MatrixClientEventEmitter } from 'test/matrix-client/MatrixClientEventEmitter';\n                                import { MatrixClientEventType, MatrixClientEvent } from 'test/matrix-client/models/MatrixClientEvent';\n                                interface MatrixClientOptions {\n                                                                baseUrl: string;\n                                                                storage: Storage;\n                                }\n                                interface MatrixLoginConfig {\n                                                                id: string;\n                                                                password: string;\n                                                                deviceId: string;\n                                }\n                                /**\n                                                     * The matrix client used to connect to the matrix network\n                                                     */\n                                export class MatrixClient {\n                                                                /**\n                                                                                     * Create a matrix client based on the options provided\n                                                                                     *\n                                                                                     * @param config\n                                                                                     */\n                                                                static create(config: MatrixClientOptions): MatrixClient;\n                                                                /**\n                                                                                     * Return all the rooms we are currently part of\n                                                                                     */\n                                                                get joinedRooms(): MatrixRoom[];\n                                                                /**\n                                                                                     * Return all the rooms to which we have received invitations\n                                                                                     */\n                                                                get invitedRooms(): MatrixRoom[];\n                                                                /**\n                                                                                     * Return all the rooms that we left\n                                                                                     */\n                                                                get leftRooms(): MatrixRoom[];\n                                                                constructor(store: MatrixClientStore, eventEmitter: MatrixClientEventEmitter, userService: MatrixUserService, roomService: MatrixRoomService, eventService: MatrixEventService);\n                                                                /**\n                                                                                     * Initiate the connection to the matrix node and log in\n                                                                                     *\n                                                                                     * @param user\n                                                                                     */\n                                                                start(user: MatrixLoginConfig): Promise<void>;\n                                                                /**\n                                                                                     * Subscribe to new matrix events\n                                                                                     *\n                                                                                     * @param event\n                                                                                     * @param listener\n                                                                                     */\n                                                                subscribe<T extends MatrixClientEventType>(event: T, listener: (event: MatrixClientEvent<T>) => void): void;\n                                                                /**\n                                                                                     * Unsubscribe from matrix events\n                                                                                     *\n                                                                                     * @param event\n                                                                                     * @param listener\n                                                                                     */\n                                                                unsubscribe(event: MatrixClientEventType, listener?: (event: MatrixClientEvent<any>) => void): void;\n                                                                getRoomById(id: string): MatrixRoom;\n                                                                /**\n                                                                                     * Create a private room with the supplied members\n                                                                                     *\n                                                                                     * @param members Members that will be in the room\n                                                                                     */\n                                                                createTrustedPrivateRoom(...members: string[]): Promise<string>;\n                                                                /**\n                                                                                     * Invite user to rooms\n                                                                                     *\n                                                                                     * @param user The user to be invited\n                                                                                     * @param roomsOrIds The rooms the user will be invited to\n                                                                                     */\n                                                                inviteToRooms(user: string, ...roomsOrIds: string[] | MatrixRoom[]): Promise<void>;\n                                                                /**\n                                                                                     * Join rooms\n                                                                                     *\n                                                                                     * @param roomsOrIds\n                                                                                     */\n                                                                joinRooms(...roomsOrIds: string[] | MatrixRoom[]): Promise<void>;\n                                                                /**\n                                                                                     * Send a text message\n                                                                                     *\n                                                                                     * @param roomOrId\n                                                                                     * @param message\n                                                                                     */\n                                                                sendTextMessage(roomId: string, message: string): Promise<void>;\n                                }\n                                export {};\n                }\n    \n                module 'test/matrix-client/MatrixClientEventEmitter' {\n                                import { EventEmitter } from 'events';\n                                import { MatrixStateStore, MatrixStateUpdate } from 'test/matrix-client/MatrixClientStore';\n                                export class MatrixClientEventEmitter extends EventEmitter {\n                                                                /**\n                                                                                     * This method is called every time the state is changed\n                                                                                     *\n                                                                                     * @param _oldState\n                                                                                     * @param _newState\n                                                                                     * @param stateChange\n                                                                                     */\n                                                                onStateChanged(_oldState: MatrixStateStore, _newState: MatrixStateStore, stateChange: Partial<MatrixStateUpdate>): void;\n                                }\n                }\n    \n                module 'test/matrix-client/MatrixClientStore' {\n                                import { MatrixRoom } from 'test/matrix-client/models/MatrixRoom';\n                                import { Storage } from 'test/storage/Storage';\n                                type OnStateChangedListener = (oldState: MatrixStateStore, newState: MatrixStateStore, stateChange: Partial<MatrixStateUpdate>) => void;\n                                export interface MatrixState {\n                                                                isRunning: boolean;\n                                                                userId: string | undefined;\n                                                                deviceId: string | undefined;\n                                                                txnNo: number;\n                                                                accessToken: string | undefined;\n                                                                syncToken: string | undefined;\n                                                                pollingTimeout: number | undefined;\n                                                                pollingRetries: number;\n                                                                rooms: MatrixRoom[] | Record<string, MatrixRoom>;\n                                }\n                                export interface MatrixStateStore extends MatrixState {\n                                                                rooms: Record<string, MatrixRoom>;\n                                }\n                                export interface MatrixStateUpdate extends MatrixState {\n                                                                rooms: MatrixRoom[];\n                                }\n                                /**\n                                                     * The class managing the local state of matrix\n                                                     */\n                                export class MatrixClientStore {\n                                                                constructor(storage: Storage);\n                                                                /**\n                                                                                     * Get an item from the state\n                                                                                     *\n                                                                                     * @param key\n                                                                                     */\n                                                                get<T extends keyof MatrixStateStore>(key: T): MatrixStateStore[T];\n                                                                /**\n                                                                                     * Get the room from an ID or room instance\n                                                                                     *\n                                                                                     * @param roomOrId\n                                                                                     */\n                                                                getRoom(roomOrId: string | MatrixRoom): MatrixRoom;\n                                                                /**\n                                                                                     * Update the state with a partial state\n                                                                                     *\n                                                                                     * @param stateUpdate\n                                                                                     */\n                                                                update(stateUpdate: Partial<MatrixStateUpdate>): Promise<void>;\n                                                                /**\n                                                                                     * Register listeners that are called once the state has changed\n                                                                                     *\n                                                                                     * @param listener\n                                                                                     * @param subscribed\n                                                                                     */\n                                                                onStateChanged(listener: OnStateChangedListener, ...subscribed: (keyof MatrixState)[]): void;\n                                }\n                                export {};\n                }\n    \n                module 'test/matrix-client/MatrixHttpClient' {\n                                import { MatrixRequest, MatrixRequestParams } from 'test/matrix-client/models/api/MatrixRequest';\n                                interface HttpOptions {\n                                                                accessToken?: string;\n                                }\n                                /**\n                                                     * Handling the HTTP connection to the matrix synapse node\n                                                     */\n                                export class MatrixHttpClient {\n                                                                constructor(baseUrl: string);\n                                                                /**\n                                                                                     * Get data from the synapse node\n                                                                                     *\n                                                                                     * @param endpoint\n                                                                                     * @param options\n                                                                                     */\n                                                                get<T>(endpoint: string, params?: MatrixRequestParams<T>, options?: HttpOptions): Promise<T>;\n                                                                /**\n                                                                                     * Post data to the synapse node\n                                                                                     *\n                                                                                     * @param endpoint\n                                                                                     * @param body\n                                                                                     * @param options\n                                                                                     * @param params\n                                                                                     */\n                                                                post<T>(endpoint: string, body: MatrixRequest<T>, options?: HttpOptions, params?: MatrixRequestParams<T>): Promise<T>;\n                                                                /**\n                                                                                     * Put data to the synapse node\n                                                                                     *\n                                                                                     * @param endpoint\n                                                                                     * @param body\n                                                                                     * @param options\n                                                                                     * @param params\n                                                                                     */\n                                                                put<T>(endpoint: string, body: MatrixRequest<T>, options?: HttpOptions, params?: MatrixRequestParams<T>): Promise<T>;\n                                }\n                                export {};\n                }\n    \n                module 'test/matrix-client/models/api/MatrixEventSend' {\n                                export interface MatrixEventSendRequest {\n                                                content: any;\n                                }\n                                export interface MatrixEventSendResponse {\n                                                type?: 'event_send';\n                                                event_id: string;\n                                }\n                }\n    \n                module 'test/matrix-client/models/api/MatrixLogin' {\n                                export interface MatrixLoginRequest {\n                                                type: 'm.login.password';\n                                                identifier: {\n                                                                type: 'm.id.user';\n                                                                user: string;\n                                                };\n                                                password: string;\n                                                device_id?: string;\n                                }\n                                export interface MatrixLoginResponse {\n                                                type?: 'login';\n                                                user_id: string;\n                                                device_id: string;\n                                                access_token: string;\n                                }\n                }\n    \n                module 'test/matrix-client/models/api/MatrixRequest' {\n                                import { MatrixLoginRequest, MatrixLoginResponse } from 'test/matrix-client/models/api/MatrixLogin';\n                                import { MatrixRoomCreateRequest, MatrixRoomCreateResponse } from 'test/matrix-client/models/api/MatrixRoomCreate';\n                                import { MatrixRoomInviteRequest, MatrixRoomInviteResponse } from 'test/matrix-client/models/api/MatrixRoomInvite';\n                                import { MatrixRoomJoinRequest, MatrixRoomJoinResponse } from 'test/matrix-client/models/api/MatrixRoomJoin';\n                                import { MatrixEventSendRequest, MatrixEventSendResponse } from 'test/matrix-client/models/api/MatrixEventSend';\n                                import { MatrixSyncResponse, MatrixSyncRequestParams } from 'test/matrix-client/models/api/MatrixSync';\n                                export type MatrixRequest<T> = T extends MatrixLoginResponse ? MatrixLoginRequest : T extends MatrixRoomCreateResponse ? MatrixRoomCreateRequest : T extends MatrixRoomInviteResponse ? MatrixRoomInviteRequest : T extends MatrixRoomJoinResponse ? MatrixRoomJoinRequest : T extends MatrixEventSendResponse ? MatrixEventSendRequest : never;\n                                export type MatrixRequestParams<T> = T extends MatrixSyncResponse ? MatrixSyncRequestParams : never;\n                }\n    \n                module 'test/matrix-client/models/api/MatrixRoomCreate' {\n                                export interface MatrixRoomCreateRequest {\n                                                visibility?: 'public' | 'private';\n                                                room_alias_name?: string;\n                                                name?: string;\n                                                topic?: string;\n                                                invite?: string[];\n                                                preset?: 'private_chat' | 'public_chat' | 'trusted_private_chat';\n                                                is_direct?: boolean;\n                                }\n                                export interface MatrixRoomCreateResponse {\n                                                type?: 'room_create';\n                                                room_id: string;\n                                }\n                }\n    \n                module 'test/matrix-client/models/api/MatrixRoomInvite' {\n                                export interface MatrixRoomInviteRequest {\n                                                user_id: string;\n                                }\n                                export interface MatrixRoomInviteResponse {\n                                                type?: 'room_invite';\n                                }\n                }\n    \n                module 'test/matrix-client/models/api/MatrixRoomJoin' {\n                                export interface MatrixRoomJoinRequest {\n                                }\n                                export interface MatrixRoomJoinResponse {\n                                                type?: 'room_join';\n                                                room_id: string;\n                                }\n                }\n    \n                module 'test/matrix-client/models/api/MatrixSync' {\n                                import { MatrixStateEvent } from 'test/matrix-client/models/MatrixStateEvent';\n                                export interface MatrixSyncJoinedRoom {\n                                                state: {\n                                                                events: MatrixStateEvent[];\n                                                };\n                                                timeline: {\n                                                                events: MatrixStateEvent[];\n                                                };\n                                }\n                                export interface MatrixSyncInvitedRoom {\n                                                invite_state: {\n                                                                events: MatrixStateEvent[];\n                                                };\n                                }\n                                export interface MatrixSyncLeftRoom {\n                                                state: {\n                                                                events: MatrixStateEvent[];\n                                                };\n                                                timeline: {\n                                                                events: MatrixStateEvent[];\n                                                };\n                                }\n                                export interface MatrixSyncRooms {\n                                                join: {\n                                                                [key: string]: MatrixSyncJoinedRoom;\n                                                };\n                                                invite: {\n                                                                [key: string]: MatrixSyncInvitedRoom;\n                                                };\n                                                leave: {\n                                                                [key: string]: MatrixSyncLeftRoom;\n                                                };\n                                }\n                                export interface MatrixSyncRequestParams {\n                                                timeout?: number;\n                                                since?: string;\n                                }\n                                export interface MatrixSyncResponse {\n                                                type?: 'sync';\n                                                next_batch: string;\n                                                rooms: MatrixSyncRooms;\n                                }\n                }\n    \n                module 'test/matrix-client/models/MatrixClientEvent' {\n                                import { MatrixMessage } from 'test/matrix-client/models/MatrixMessage';\n                                export enum MatrixClientEventType {\n                                                INVITE = \"invite\",\n                                                MESSAGE = \"message\"\n                                }\n                                export type MatrixClientEventContent<T> = T extends MatrixClientEventType.INVITE ? MatrixClientEventInviteContent : T extends MatrixClientEventType.MESSAGE ? MatrixClientEventMessageContent<any> : never;\n                                export interface MatrixClientEventInviteContent {\n                                                roomId: string;\n                                }\n                                export interface MatrixClientEventMessageContent<T> {\n                                                roomId: string;\n                                                message: MatrixMessage<T>;\n                                }\n                                export interface MatrixClientEvent<T extends MatrixClientEventType> {\n                                                type: T;\n                                                content: MatrixClientEventContent<T>;\n                                }\n                }\n    \n                module 'test/matrix-client/models/MatrixMessage' {\n                                import { MatrixStateEvent } from 'test/matrix-client/models/MatrixStateEvent';\n                                export enum MatrixMessageType {\n                                                TEXT = \"m.text\"\n                                }\n                                export class MatrixMessage<T> {\n                                                readonly type: MatrixMessageType;\n                                                readonly sender: string;\n                                                readonly content: T;\n                                                /**\n                                                             * Construct a message from a message event\n                                                             *\n                                                             * @param event\n                                                             */\n                                                static from(event: MatrixStateEvent): MatrixMessage<any> | undefined;\n                                }\n                }\n    \n                module 'test/matrix-client/models/MatrixRoom' {\n                                import { MatrixSyncRooms } from 'test/matrix-client/models/api/MatrixSync';\n                                import { MatrixMessage } from 'test/matrix-client/models/MatrixMessage';\n                                export enum MatrixRoomStatus {\n                                                                UNKNOWN = 0,\n                                                                JOINED = 1,\n                                                                INVITED = 2,\n                                                                LEFT = 3\n                                }\n                                export class MatrixRoom {\n                                                                readonly id: string;\n                                                                readonly status: MatrixRoomStatus;\n                                                                readonly members: string[];\n                                                                messages: MatrixMessage<any>[];\n                                                                /**\n                                                                                     * Reconstruct rooms from a sync response\n                                                                                     *\n                                                                                     * @param roomSync\n                                                                                     */\n                                                                static fromSync(roomSync: MatrixSyncRooms): MatrixRoom[];\n                                                                /**\n                                                                                     * Reconstruct a room from an ID or object\n                                                                                     *\n                                                                                     * @param roomOrId\n                                                                                     * @param status\n                                                                                     */\n                                                                static from(roomOrId: string | MatrixRoom, status?: MatrixRoomStatus): MatrixRoom;\n                                                                /**\n                                                                                     * Merge new and old state and remove duplicates\n                                                                                     *\n                                                                                     * @param newState\n                                                                                     * @param previousState\n                                                                                     */\n                                                                static merge(newState: MatrixRoom, previousState?: MatrixRoom): MatrixRoom;\n                                }\n                }\n    \n                module 'test/matrix-client/models/MatrixStateEvent' {\n                                import { MatrixMessageType } from 'test/matrix-client/models/MatrixMessage';\n                                export interface MatrixStateEventMessageText extends MatrixStateEventMessage {\n                                                type: 'm.room.message';\n                                                content: {\n                                                                msgtype: MatrixMessageType.TEXT;\n                                                                body: string;\n                                                };\n                                }\n                                export interface MatrixStateEventMessageContent {\n                                                msgtype: string;\n                                                body: any;\n                                                [key: string]: any;\n                                }\n                                export interface MatrixStateEventMessage extends MatrixStateEvent {\n                                                type: 'm.room.message';\n                                                content: MatrixStateEventMessageContent;\n                                }\n                                export interface MatrixStateEvent {\n                                                type: string;\n                                                sender: string;\n                                                content: unknown;\n                                                event_id?: string;\n                                }\n                }\n    \n                module 'test/matrix-client/services/MatrixEventService' {\n                                import { MatrixHttpClient } from 'test/matrix-client/MatrixHttpClient';\n                                import { MatrixEventSendResponse } from 'test/matrix-client/models/api/MatrixEventSend';\n                                import { MatrixSyncResponse } from 'test/matrix-client/models/api/MatrixSync';\n                                import { MatrixStateEventMessageContent } from 'test/matrix-client/models/MatrixStateEvent';\n                                interface MatrixScheduledEvent<T> {\n                                                                accessToken: string;\n                                                                roomId: string;\n                                                                type: MatrixEventType;\n                                                                content: any;\n                                                                txnId: string;\n                                                                onSuccess(response: T): void;\n                                                                onError(error: unknown): void;\n                                }\n                                type MatrixEventType = 'm.room.message';\n                                export interface MatrixSyncOptions {\n                                                                syncToken?: string;\n                                                                pollingTimeout?: number;\n                                }\n                                /**\n                                                     * A service to help with matrix event management\n                                                     */\n                                export class MatrixEventService {\n                                                                constructor(httpClient: MatrixHttpClient);\n                                                                /**\n                                                                                     * Get the latest state from the matrix node\n                                                                                     *\n                                                                                     * @param accessToken\n                                                                                     * @param options\n                                                                                     */\n                                                                sync(accessToken: string, options?: MatrixSyncOptions): Promise<MatrixSyncResponse>;\n                                                                /**\n                                                                                     * Send a message to a room\n                                                                                     *\n                                                                                     * @param accessToken\n                                                                                     * @param room\n                                                                                     * @param content\n                                                                                     * @param txnId\n                                                                                     */\n                                                                sendMessage(accessToken: string, roomId: string, content: MatrixStateEventMessageContent, txnId: string): Promise<MatrixEventSendResponse>;\n                                                                /**\n                                                                                     * Schedules an event to be sent to the node\n                                                                                     *\n                                                                                     * @param event\n                                                                                     */\n                                                                scheduleEvent(event: MatrixScheduledEvent<any>): void;\n                                                                /**\n                                                                                     * Send an event to the matrix node\n                                                                                     *\n                                                                                     * @param scheduledEvent\n                                                                                     */\n                                                                sendEvent(scheduledEvent: MatrixScheduledEvent<any>): Promise<void>;\n                                }\n                                export {};\n                }\n    \n                module 'test/matrix-client/services/MatrixRoomService' {\n                                import { MatrixHttpClient } from 'test/matrix-client/MatrixHttpClient';\n                                import { MatrixRoom } from 'test/matrix-client/models/MatrixRoom';\n                                import { MatrixRoomCreateRequest, MatrixRoomCreateResponse } from 'test/matrix-client/models/api/MatrixRoomCreate';\n                                import { MatrixRoomInviteResponse } from 'test/matrix-client/models/api/MatrixRoomInvite';\n                                import { MatrixRoomJoinResponse } from 'test/matrix-client/models/api/MatrixRoomJoin';\n                                /**\n                                                     * A service to help with matrix room management\n                                                     */\n                                export class MatrixRoomService {\n                                                                constructor(httpClient: MatrixHttpClient);\n                                                                /**\n                                                                                     * Create a room\n                                                                                     *\n                                                                                     * @param accessToken\n                                                                                     * @param config\n                                                                                     */\n                                                                createRoom(accessToken: string, config?: MatrixRoomCreateRequest): Promise<MatrixRoomCreateResponse>;\n                                                                /**\n                                                                                     * Invite a user to a room\n                                                                                     *\n                                                                                     * @param accessToken\n                                                                                     * @param user\n                                                                                     * @param room\n                                                                                     */\n                                                                inviteToRoom(accessToken: string, user: string, room: MatrixRoom): Promise<MatrixRoomInviteResponse>;\n                                                                /**\n                                                                                     * Join a specific room\n                                                                                     *\n                                                                                     * @param accessToken\n                                                                                     * @param room\n                                                                                     */\n                                                                joinRoom(accessToken: string, room: MatrixRoom): Promise<MatrixRoomJoinResponse>;\n                                                                /**\n                                                                                     * Get all joined rooms\n                                                                                     *\n                                                                                     * @param accessToken\n                                                                                     */\n                                                                getJoinedRooms(accessToken: string): Promise<MatrixRoomJoinResponse>;\n                                }\n                }\n    \n                module 'test/matrix-client/services/MatrixUserService' {\n                                import { MatrixHttpClient } from 'test/matrix-client/MatrixHttpClient';\n                                import { MatrixLoginResponse } from 'test/matrix-client/models/api/MatrixLogin';\n                                export class MatrixUserService {\n                                                constructor(httpClient: MatrixHttpClient);\n                                                /**\n                                                             * Log in to the matrix node with username and password\n                                                             *\n                                                             * @param user\n                                                             * @param password\n                                                             * @param deviceId\n                                                             */\n                                                login(user: string, password: string, deviceId: string): Promise<MatrixLoginResponse>;\n                                }\n                }\n    \n                module 'test/matrix-client/utils/events' {\n                                import { MatrixStateEvent, MatrixStateEventMessageText } from 'test/matrix-client/models/MatrixStateEvent';\n                                /**\n                                                     * Check if an event is a create event\n                                                     *\n                                                     * @param event MatrixStateEvent\n                                                     */\n                                export const isCreateEvent: (event: MatrixStateEvent) => boolean;\n                                /**\n                                                     * Check if an event is a join event\n                                                     *\n                                                     * @param event MatrixStateEvent\n                                                     */\n                                export const isJoinEvent: (event: MatrixStateEvent) => boolean;\n                                /**\n                                                     * Check if an event is a message event\n                                                     *\n                                                     * @param event MatrixStateEvent\n                                                     */\n                                export const isMessageEvent: (event: MatrixStateEvent) => boolean;\n                                /**\n                                                     * Check if an event is a text message event\n                                                     *\n                                                     * @param event MatrixStateEvent\n                                                     */\n                                export const isTextMessageEvent: (event: MatrixStateEvent) => event is MatrixStateEventMessageText;\n                }\n    \n                module 'test/migrations/migrate-0.7.0' {\n                                import { PermissionScope, AccountIdentifier, Origin, Network } from 'test/';\n                                export interface AccountInfoOld {\n                                                accountIdentifier: AccountIdentifier;\n                                                beaconId: string;\n                                                origin: {\n                                                                type: Origin;\n                                                                id: string;\n                                                };\n                                                address: string;\n                                                pubkey: string;\n                                                network: Network;\n                                                scopes: PermissionScope[];\n                                                connectedAt: Date;\n                                }\n                                export interface P2PPairingRequestOld {\n                                                name: string;\n                                                pubKey: string;\n                                                relayServer: string;\n                                }\n                                export const migrate_0_7_0: (storage: Storage) => Promise<void>;\n                }\n    \n                module 'test/migrations/migrations' {\n                                import { Storage } from 'test/';\n                                export const migrate: (storage: Storage) => Promise<void>;\n                }\n    \n                module 'test/MockWindow' {\n                                type Callback = (message: unknown) => void;\n                                /**\n                                             * A mock for postmessage if run in node.js environment\n                                             */\n                                let windowRef: {\n                                                postMessage: (message: string | Record<string, unknown>, _target?: string | undefined) => void;\n                                                addEventListener: (_name: string, eventCallback: Callback) => void;\n                                                removeEventListener: (_name: string, eventCallback: Callback) => void;\n                                                location: {\n                                                                origin: string;\n                                                };\n                                };\n                                const clearMockWindowState: () => void;\n                                export { windowRef, clearMockWindowState };\n                }\n    \n                module 'test/Serializer' {\n                                /**\n                                                     * The Serializer is used to serialize / deserialize JSON objects and encode them with bs58check\n                                                     */\n                                export class Serializer {\n                                                                /**\n                                                                                     * Serialize and bs58check encode an object\n                                                                                     *\n                                                                                     * @param message JSON object to serialize\n                                                                                     */\n                                                                serialize(message: unknown): Promise<string>;\n                                                                /**\n                                                                                     * Deserialize a bs58check encoded string\n                                                                                     *\n                                                                                     * @param encoded String to be deserialized\n                                                                                     */\n                                                                deserialize(encoded: string): Promise<unknown>;\n                                }\n                }\n    \n                module 'test/storage/ChromeStorage' {\n                                import { Storage, StorageKey, StorageKeyReturnType } from 'test/';\n                                export class ChromeStorage implements Storage {\n                                                static isSupported(): Promise<boolean>;\n                                                get<K extends StorageKey>(key: K): Promise<StorageKeyReturnType[K]>;\n                                                set<K extends StorageKey>(key: K, value: StorageKeyReturnType[K]): Promise<void>;\n                                                delete<K extends StorageKey>(key: K): Promise<void>;\n                                }\n                }\n    \n                module 'test/storage/getStorage' {\n                                import { Storage } from 'test/';\n                                /**\n                                             * Get a supported storage on this platform\n                                             */\n                                export const getStorage: () => Promise<Storage>;\n                }\n    \n                module 'test/storage/LocalStorage' {\n                                import { Storage, StorageKey, StorageKeyReturnType } from 'test/';\n                                export class LocalStorage implements Storage {\n                                                constructor(prefix?: string | undefined);\n                                                static isSupported(): Promise<boolean>;\n                                                get<K extends StorageKey>(key: K): Promise<StorageKeyReturnType[K]>;\n                                                set<K extends StorageKey>(key: K, value: StorageKeyReturnType[K]): Promise<void>;\n                                                delete<K extends StorageKey>(key: K): Promise<void>;\n                                }\n                }\n    \n                module 'test/storage/Storage' {\n                                import { StorageKey } from 'test/types/storage/StorageKey';\n                                import { StorageKeyReturnType } from 'test/types/storage/StorageKeyReturnType';\n                                /**\n                                                     * The storage used in the SDK\n                                                     */\n                                export abstract class Storage {\n                                                                /**\n                                                                                     * Returns a promise that resolves to true if the storage option is available on this platform.\n                                                                                     */\n                                                                static isSupported(): Promise<boolean>;\n                                                                /**\n                                                                                     * Gets a value from storage and returns it\n                                                                                     *\n                                                                                     * @param key The storage key\n                                                                                     */\n                                                                abstract get<K extends StorageKey>(key: K): Promise<StorageKeyReturnType[K]>;\n                                                                /**\n                                                                                     * Sets a value in the storage and persist it\n                                                                                     *\n                                                                                     * @param key The storage key\n                                                                                     * @param value The value to be persisted\n                                                                                     */\n                                                                abstract set<K extends StorageKey>(key: K, value: StorageKeyReturnType[K]): Promise<void>;\n                                                                /**\n                                                                                     * Delete a key from storage\n                                                                                     *\n                                                                                     * @param key The storage key\n                                                                                     */\n                                                                abstract delete<K extends StorageKey>(key: K): Promise<void>;\n                                }\n                }\n    \n                module 'test/transports/clients/CommunicationClient' {\n                                import * as sodium from 'libsodium-wrappers';\n                                import { P2PPairingRequest } from 'test/';\n                                import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n                                import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n                                import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n                                export abstract class CommunicationClient {\n                                                                protected readonly keyPair: sodium.KeyPair;\n                                                                constructor(keyPair: sodium.KeyPair);\n                                                                /**\n                                                                                     * Get the public key\n                                                                                     */\n                                                                getPublicKey(): Promise<string>;\n                                                                /**\n                                                                                     * get the public key hash\n                                                                                     */\n                                                                getPublicKeyHash(): Promise<string>;\n                                                                /**\n                                                                                     * Create a cryptobox shared key\n                                                                                     *\n                                                                                     * @param otherPublicKey\n                                                                                     * @param selfPrivateKey\n                                                                                     */\n                                                                protected createCryptoBox(otherPublicKey: string, selfPrivateKey: Uint8Array): Promise<[Uint8Array, Uint8Array, Uint8Array]>;\n                                                                /**\n                                                                                     * Create a cryptobox server\n                                                                                     *\n                                                                                     * @param otherPublicKey\n                                                                                     * @param selfPrivateKey\n                                                                                     */\n                                                                protected createCryptoBoxServer(otherPublicKey: string, selfPrivateKey: Uint8Array): Promise<sodium.CryptoKX>;\n                                                                /**\n                                                                                     * Create a cryptobox client\n                                                                                     *\n                                                                                     * @param otherPublicKey\n                                                                                     * @param selfPrivateKey\n                                                                                     */\n                                                                protected createCryptoBoxClient(otherPublicKey: string, selfPrivateKey: Uint8Array): Promise<sodium.CryptoKX>;\n                                                                /**\n                                                                                     * Encrypt a message for a specific publicKey (receiver, asymmetric)\n                                                                                     *\n                                                                                     * @param recipientPublicKey\n                                                                                     * @param message\n                                                                                     */\n                                                                protected encryptMessageAsymmetric(recipientPublicKey: string, message: string): Promise<string>;\n                                                                abstract unsubscribeFromEncryptedMessages(): Promise<void>;\n                                                                abstract unsubscribeFromEncryptedMessage(senderPublicKey: string): Promise<void>;\n                                                                abstract sendMessage(message: string, peer?: P2PPairingRequest | ExtendedP2PPairingResponse | PostMessagePairingRequest | ExtendedPostMessagePairingResponse): Promise<void>;\n                                }\n                }\n    \n                module 'test/transports/clients/MessageBasedClient' {\n                                import * as sodium from 'libsodium-wrappers';\n                                import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n                                import { PostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n                                import { CommunicationClient } from 'test/transports/clients/CommunicationClient';\n                                export abstract class MessageBasedClient extends CommunicationClient {\n                                                                protected readonly name: string;\n                                                                /**\n                                                                                     * The listeners that will be notified of new messages\n                                                                                     */\n                                                                protected abstract readonly activeListeners: Map<string, unknown>;\n                                                                constructor(name: string, keyPair: sodium.KeyPair);\n                                                                /**\n                                                                                     * start the client and make sure all dependencies are ready\n                                                                                     */\n                                                                start(): Promise<void>;\n                                                                /**\n                                                                                     * Get the pairing request information. This will be shared with the peer during the connection setup\n                                                                                     */\n                                                                getPairingRequestInfo(): Promise<PostMessagePairingRequest>;\n                                                                /**\n                                                                                     * Get the pairing response information. This will be shared with the peer during the connection setup\n                                                                                     */\n                                                                getPairingResponseInfo(request: PostMessagePairingRequest): Promise<PostMessagePairingResponse>;\n                                                                /**\n                                                                                     * Unsubscribe from encrypted messages from a specific peer\n                                                                                     *\n                                                                                     * @param senderPublicKey\n                                                                                     */\n                                                                unsubscribeFromEncryptedMessage(senderPublicKey: string): Promise<void>;\n                                                                /**\n                                                                                     * Unsubscribe from all encrypted messages\n                                                                                     */\n                                                                unsubscribeFromEncryptedMessages(): Promise<void>;\n                                                                /**\n                                                                                     * Decrypt a message from a specific peer\n                                                                                     *\n                                                                                     * @param senderPublicKey\n                                                                                     * @param payload\n                                                                                     */\n                                                                protected decryptMessage(senderPublicKey: string, payload: string): Promise<string>;\n                                                                /**\n                                                                                     * Encrypt a message for a specific publicKey (receiver)\n                                                                                     *\n                                                                                     * @param recipientPublicKey\n                                                                                     * @param message\n                                                                                     */\n                                                                protected encryptMessage(recipientPublicKey: string, message: string): Promise<string>;\n                                                                /**\n                                                                                     * Initialize the connection\n                                                                                     */\n                                                                abstract init(): Promise<void>;\n                                }\n                }\n    \n                module 'test/transports/clients/P2PCommunicationClient' {\n                                import * as sodium from 'libsodium-wrappers';\n                                import { MatrixClientEvent, MatrixClientEventType, MatrixClientEventMessageContent } from 'test/matrix-client/models/MatrixClientEvent';\n                                import { Storage } from 'test/storage/Storage';\n                                import { P2PPairingRequest } from 'test/';\n                                import { ExtendedP2PPairingResponse, P2PPairingResponse } from 'test/types/P2PPairingResponse';\n                                import { CommunicationClient } from 'test/transports/clients/CommunicationClient';\n                                export class P2PCommunicationClient extends CommunicationClient {\n                                                readonly replicationCount: number;\n                                                constructor(name: string, keyPair: sodium.KeyPair, replicationCount: number, storage: Storage, matrixNodes: string[], iconUrl?: string | undefined, appUrl?: string | undefined);\n                                                getPairingRequestInfo(): Promise<P2PPairingRequest>;\n                                                getPairingResponseInfo(request: P2PPairingRequest): Promise<P2PPairingResponse>;\n                                                getRelayServer(publicKeyHash?: string, nonce?: string): Promise<string>;\n                                                start(): Promise<void>;\n                                                listenForEncryptedMessage(senderPublicKey: string, messageCallback: (message: string) => void): Promise<void>;\n                                                unsubscribeFromEncryptedMessage(senderPublicKey: string): Promise<void>;\n                                                unsubscribeFromEncryptedMessages(): Promise<void>;\n                                                sendMessage(message: string, peer: P2PPairingRequest | ExtendedP2PPairingResponse): Promise<void>;\n                                                deleteRoomIdFromRooms(roomId: string): Promise<void>;\n                                                listenForChannelOpening(messageCallback: (pairingResponse: ExtendedP2PPairingResponse) => void): Promise<void>;\n                                                sendPairingResponse(pairingRequest: P2PPairingRequest): Promise<void>;\n                                                isTextMessage(content: MatrixClientEventMessageContent<any>): content is MatrixClientEventMessageContent<string>;\n                                                isChannelOpenMessage(content: MatrixClientEventMessageContent<string>): Promise<boolean>;\n                                                isSender(event: MatrixClientEvent<MatrixClientEventType.MESSAGE>, senderPublicKey: string): Promise<boolean>;\n                                }\n                }\n    \n                module 'test/transports/clients/PostMessageClient' {\n                                import { ConnectionContext } from 'test/';\n                                import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n                                import { EncryptedExtensionMessage } from 'test/types/ExtensionMessage';\n                                import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n                                import { MessageBasedClient } from 'test/transports/clients/MessageBasedClient';\n                                export class PostMessageClient extends MessageBasedClient {\n                                                protected readonly activeListeners: Map<string, (message: EncryptedExtensionMessage, context: ConnectionContext) => void>;\n                                                init(): Promise<void>;\n                                                listenForEncryptedMessage(senderPublicKey: string, messageCallback: (message: string, context: ConnectionContext) => void): Promise<void>;\n                                                sendMessage(message: string, peer: PostMessagePairingRequest | ExtendedPostMessagePairingResponse): Promise<void>;\n                                                listenForChannelOpening(messageCallback: (pairingResponse: ExtendedPostMessagePairingResponse) => void): Promise<void>;\n                                                sendPairingRequest(id: string): Promise<void>;\n                                                isChannelOpenMessage(message: any): Promise<boolean>;\n                                }\n                }\n    \n                module 'test/transports/DappP2PTransport' {\n                                import * as sodium from 'libsodium-wrappers';\n                                import { Storage, StorageKey, P2PTransport } from 'test/';\n                                import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n                                export class DappP2PTransport extends P2PTransport<ExtendedP2PPairingResponse, StorageKey.TRANSPORT_P2P_PEERS_DAPP> {\n                                                constructor(name: string, keyPair: sodium.KeyPair, storage: Storage, matrixNodes: string[], iconUrl?: string, appUrl?: string);\n                                                startOpenChannelListener(): Promise<void>;\n                                                listenForNewPeer(newPeerListener: (peer: ExtendedP2PPairingResponse) => void): Promise<void>;\n                                                stopListeningForNewPeers(): Promise<void>;\n                                }\n                }\n    \n                module 'test/transports/DappPostMessageTransport' {\n                                import * as sodium from 'libsodium-wrappers';\n                                import { StorageKey, PostMessageTransport, Storage } from 'test/';\n                                import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n                                export class DappPostMessageTransport extends PostMessageTransport<ExtendedPostMessagePairingResponse, StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP> {\n                                                constructor(name: string, keyPair: sodium.KeyPair, storage: Storage);\n                                                startOpenChannelListener(): Promise<void>;\n                                                listenForNewPeer(newPeerListener: (peer: ExtendedPostMessagePairingResponse) => void): Promise<void>;\n                                                stopListeningForNewPeers(): Promise<void>;\n                                }\n                }\n    \n                module 'test/transports/P2PTransport' {\n                                import * as sodium from 'libsodium-wrappers';\n                                import { Storage, StorageKey, Transport, TransportType, P2PCommunicationClient, P2PPairingRequest } from 'test/';\n                                import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n                                export class P2PTransport<T extends P2PPairingRequest | ExtendedP2PPairingResponse, K extends StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET> extends Transport<T, K, P2PCommunicationClient> {\n                                                readonly type: TransportType;\n                                                constructor(name: string, keyPair: sodium.KeyPair, storage: Storage, matrixNodes: string[], storageKey: K, iconUrl?: string, appUrl?: string);\n                                                static isAvailable(): Promise<boolean>;\n                                                connect(): Promise<void>;\n                                                startOpenChannelListener(): Promise<void>;\n                                                getPairingRequestInfo(): Promise<P2PPairingRequest>;\n                                                listen(publicKey: string): Promise<void>;\n                                }\n                }\n    \n                module 'test/transports/PostMessageTransport' {\n                                import * as sodium from 'libsodium-wrappers';\n                                import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n                                import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n                                import { Extension } from 'test/types/Extension';\n                                import { StorageKey } from 'test/types/storage/StorageKey';\n                                import { TransportType } from 'test/types/transport/TransportType';\n                                import { Storage } from 'test/storage/Storage';\n                                import { PostMessageClient } from 'test/transports/clients/PostMessageClient';\n                                import { Transport } from 'test/transports/Transport';\n                                export class PostMessageTransport<T extends PostMessagePairingRequest | ExtendedPostMessagePairingResponse, K extends StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET> extends Transport<T, K, PostMessageClient> {\n                                                readonly type: TransportType;\n                                                constructor(name: string, keyPair: sodium.KeyPair, storage: Storage, storageKey: K);\n                                                static isAvailable(): Promise<boolean>;\n                                                static getAvailableExtensions(): Promise<Extension[]>;\n                                                connect(): Promise<void>;\n                                                startOpenChannelListener(): Promise<void>;\n                                                getPairingRequestInfo(): Promise<PostMessagePairingRequest>;\n                                                listen(publicKey: string): Promise<void>;\n                                }\n                }\n    \n                module 'test/transports/Transport' {\n                                import { ConnectionContext } from 'test/types/ConnectionContext';\n                                import { TransportType, TransportStatus, PeerInfo, StorageKey } from 'test/';\n                                import { PeerManager } from 'test/managers/PeerManager';\n                                import { CommunicationClient } from 'test/transports/clients/CommunicationClient';\n                                export abstract class Transport<T extends PeerInfo = PeerInfo, K extends StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET = any, S extends CommunicationClient = any> {\n                                                                /**\n                                                                                     * The type of the transport\n                                                                                     */\n                                                                readonly type: TransportType;\n                                                                /**\n                                                                                     * The name of the app\n                                                                                     */\n                                                                protected readonly name: string;\n                                                                /**\n                                                                                     * The status of the transport\n                                                                                     */\n                                                                protected _isConnected: TransportStatus;\n                                                                protected readonly peerManager: PeerManager<K>;\n                                                                /**\n                                                                                     * The client handling the encryption/decryption of messages\n                                                                                     */\n                                                                protected client: S;\n                                                                /**\n                                                                                     * The listener that will be invoked when a new peer is connected\n                                                                                     */\n                                                                protected newPeerListener?: (peer: T) => void;\n                                                                /**\n                                                                                     * Return the status of the connection\n                                                                                     */\n                                                                get connectionStatus(): TransportStatus;\n                                                                constructor(name: string, client: S, peerManager: PeerManager<K>);\n                                                                /**\n                                                                                     * Returns a promise that resolves to true if the transport is available, false if it is not\n                                                                                     */\n                                                                static isAvailable(): Promise<boolean>;\n                                                                /**\n                                                                                     * Connect the transport\n                                                                                     */\n                                                                connect(): Promise<void>;\n                                                                /**\n                                                                                     * Send a message through the transport\n                                                                                     *\n                                                                                     * @param message The message to send\n                                                                                     * @param recipient The recipient of the message\n                                                                                     */\n                                                                send(message: string, peer?: PeerInfo): Promise<void>;\n                                                                /**\n                                                                                     * Add a listener to be called when a new message is received\n                                                                                     *\n                                                                                     * @param listener The listener that will be registered\n                                                                                     */\n                                                                addListener(listener: (message: unknown, connectionInfo: ConnectionContext) => void): Promise<void>;\n                                                                /**\n                                                                                     * Remove a listener\n                                                                                     *\n                                                                                     * @param listener\n                                                                                     */\n                                                                removeListener(listener: (message: string, connectionInfo: ConnectionContext) => void): Promise<void>;\n                                                                getPeers(): Promise<T[]>;\n                                                                addPeer(newPeer: T): Promise<void>;\n                                                                removePeer(peerToBeRemoved: T): Promise<void>;\n                                                                removeAllPeers(): Promise<void>;\n                                                                /**\n                                                                                     * Notify the listeners when a new message comes in\n                                                                                     *\n                                                                                     * @param message Message\n                                                                                     * @param connectionInfo Context info about the connection\n                                                                                     */\n                                                                protected notifyListeners(message: unknown, connectionInfo: ConnectionContext): Promise<void>;\n                                                                abstract listen(publicKey: string): Promise<void>;\n                                }\n                }\n    \n                module 'test/transports/WalletP2PTransport' {\n                                import * as sodium from 'libsodium-wrappers';\n                                import { Storage, StorageKey, P2PTransport, P2PPairingRequest } from 'test/';\n                                export class WalletP2PTransport extends P2PTransport<P2PPairingRequest, StorageKey.TRANSPORT_P2P_PEERS_WALLET> {\n                                                constructor(name: string, keyPair: sodium.KeyPair, storage: Storage, matrixNodes: string[], iconUrl?: string, appUrl?: string);\n                                                addPeer(newPeer: P2PPairingRequest): Promise<void>;\n                                }\n                }\n    \n                module 'test/transports/WalletPostMessageTransport' {\n                                import * as sodium from 'libsodium-wrappers';\n                                import { StorageKey, PostMessageTransport, Storage } from 'test/';\n                                import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n                                export class WalletPostMessageTransport extends PostMessageTransport<PostMessagePairingRequest, StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET> {\n                                                constructor(name: string, keyPair: sodium.KeyPair, storage: Storage);\n                                }\n                }\n    \n                module 'test/types/AccountInfo' {\n                                import { Origin } from 'test/';\n                                import { PermissionEntity } from 'test/types/PermissionEntity';\n                                export type AccountIdentifier = string;\n                                export interface AccountInfo extends PermissionEntity {\n                                                accountIdentifier: AccountIdentifier;\n                                                senderId: string;\n                                                origin: {\n                                                                type: Origin;\n                                                                id: string;\n                                                };\n                                                publicKey: string;\n                                                connectedAt: number;\n                                }\n                }\n    \n                module 'test/types/beacon/AppMetadata' {\n                                export interface AppMetadata {\n                                                senderId: string;\n                                                name: string;\n                                                icon?: string;\n                                }\n                }\n    \n                module 'test/types/beacon/BeaconBaseMessage' {\n                                import { BeaconMessageType } from 'test/';\n                                export interface BeaconBaseMessage {\n                                                type: BeaconMessageType;\n                                                version: string;\n                                                id: string;\n                                                senderId: string;\n                                }\n                }\n    \n                module 'test/types/beacon/BeaconMessage' {\n                                import { PermissionResponse, PermissionRequest, OperationRequest, OperationResponse, SignPayloadRequest, SignPayloadResponse, BroadcastRequest, BroadcastResponse, AcknowledgeResponse, DisconnectMessage, ErrorResponse } from 'test/';\n                                export type BeaconMessage = PermissionRequest | PermissionResponse | OperationRequest | OperationResponse | SignPayloadRequest | SignPayloadResponse | BroadcastRequest | BroadcastResponse | AcknowledgeResponse | DisconnectMessage | ErrorResponse;\n                }\n    \n                module 'test/types/beacon/BeaconMessageType' {\n                                export enum BeaconMessageType {\n                                                PermissionRequest = \"permission_request\",\n                                                SignPayloadRequest = \"sign_payload_request\",\n                                                OperationRequest = \"operation_request\",\n                                                BroadcastRequest = \"broadcast_request\",\n                                                PermissionResponse = \"permission_response\",\n                                                SignPayloadResponse = \"sign_payload_response\",\n                                                OperationResponse = \"operation_response\",\n                                                BroadcastResponse = \"broadcast_response\",\n                                                Acknowledge = \"acknowledge\",\n                                                Disconnect = \"disconnect\",\n                                                Error = \"error\"\n                                }\n                }\n    \n                module 'test/types/beacon/BeaconRequestMessage' {\n                                import { PermissionRequest, OperationRequest, SignPayloadRequest, BroadcastRequest } from 'test/';\n                                export type BeaconRequestMessage = PermissionRequest | OperationRequest | SignPayloadRequest | BroadcastRequest;\n                }\n    \n                module 'test/types/beacon/BeaconResponseMessage' {\n                                import { PermissionResponse, OperationResponse, SignPayloadResponse, BroadcastResponse } from 'test/';\n                                import { ErrorResponse } from 'test/types/beacon/messages/ErrorResponse';\n                                export type BeaconResponseMessage = PermissionResponse | OperationResponse | SignPayloadResponse | BroadcastResponse | ErrorResponse;\n                }\n    \n                module 'test/types/beacon/messages/AcknowledgeResponse' {\n                                import { BeaconBaseMessage, BeaconMessageType } from 'test/';\n                                export interface AcknowledgeResponse extends BeaconBaseMessage {\n                                                type: BeaconMessageType.Acknowledge;\n                                }\n                }\n    \n                module 'test/types/beacon/messages/BeaconRequestInputMessage' {\n                                import { PermissionRequest, OperationRequest, SignPayloadRequest, BroadcastRequest } from 'test/';\n                                export type IgnoredRequestInputProperties = 'id' | 'senderId' | 'version';\n                                export type PermissionRequestInput = Omit<PermissionRequest, IgnoredRequestInputProperties>;\n                                export type OperationRequestInput = Omit<OperationRequest, IgnoredRequestInputProperties>;\n                                export type SignPayloadRequestInput = Omit<SignPayloadRequest, IgnoredRequestInputProperties>;\n                                export type BroadcastRequestInput = Omit<BroadcastRequest, IgnoredRequestInputProperties>;\n                                export type BeaconRequestInputMessage = PermissionRequestInput | OperationRequestInput | SignPayloadRequestInput | BroadcastRequestInput;\n                }\n    \n                module 'test/types/beacon/messages/BeaconRequestOutputMessage' {\n                                import { AppMetadata, PermissionRequest, OperationRequest, SignPayloadRequest, BroadcastRequest } from 'test/';\n                                export type IgnoredRequestOutputProperties = 'version';\n                                export interface ExtraResponseOutputProperties {\n                                                appMetadata: AppMetadata;\n                                }\n                                export type PermissionRequestOutput = Omit<PermissionRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n                                export type OperationRequestOutput = Omit<OperationRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n                                export type SignPayloadRequestOutput = Omit<SignPayloadRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n                                export type BroadcastRequestOutput = Omit<BroadcastRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n                                export type BeaconRequestOutputMessage = PermissionRequestOutput | OperationRequestOutput | SignPayloadRequestOutput | BroadcastRequestOutput;\n                }\n    \n                module 'test/types/beacon/messages/BeaconResponseInputMessage' {\n                                import { PermissionResponse, OperationResponse, SignPayloadResponse, BroadcastResponse, AcknowledgeResponse, ErrorResponse } from 'test/';\n                                export type IgnoredResponseInputProperties = 'senderId' | 'version' | 'appMetadata';\n                                export type PermissionResponseInput = Omit<PermissionResponse, IgnoredResponseInputProperties>;\n                                export type OperationResponseInput = Omit<OperationResponse, IgnoredResponseInputProperties>;\n                                export type SignPayloadResponseInput = Omit<SignPayloadResponse, IgnoredResponseInputProperties>;\n                                export type BroadcastResponseInput = Omit<BroadcastResponse, IgnoredResponseInputProperties>;\n                                export type AcknowledgeResponseInput = Omit<AcknowledgeResponse, IgnoredResponseInputProperties>;\n                                export type ErrorResponseInput = Omit<ErrorResponse, IgnoredResponseInputProperties>;\n                                export type BeaconResponseInputMessage = PermissionResponseInput | OperationResponseInput | SignPayloadResponseInput | BroadcastResponseInput | AcknowledgeResponseInput | ErrorResponseInput;\n                }\n    \n                module 'test/types/beacon/messages/BeaconResponseOutputMessage' {\n                                import { PermissionResponse, OperationResponse, SignPayloadResponse, BroadcastResponse, AccountInfo } from 'test/';\n                                export type IgnoredResponseOutputProperties = 'id' | 'version' | 'type';\n                                export type PermissionResponseOutput = PermissionResponse & {\n                                                address: string;\n                                                accountInfo: AccountInfo;\n                                };\n                                export type OperationResponseOutput = OperationResponse;\n                                export type SignPayloadResponseOutput = SignPayloadResponse;\n                                export type BroadcastResponseOutput = BroadcastResponse;\n                                export type BeaconResponseOutputMessage = PermissionResponseOutput | OperationResponseOutput | SignPayloadResponseOutput | BroadcastResponseOutput;\n                }\n    \n                module 'test/types/beacon/messages/BroadcastRequest' {\n                                import { BeaconBaseMessage, BeaconMessageType, Network } from 'test/';\n                                export interface BroadcastRequest extends BeaconBaseMessage {\n                                                type: BeaconMessageType.BroadcastRequest;\n                                                network: Network;\n                                                signedTransaction: string;\n                                }\n                }\n    \n                module 'test/types/beacon/messages/BroadcastResponse' {\n                                import { BeaconBaseMessage, BeaconMessageType } from 'test/';\n                                export interface BroadcastResponse extends BeaconBaseMessage {\n                                                type: BeaconMessageType.BroadcastResponse;\n                                                transactionHash: string;\n                                }\n                }\n    \n                module 'test/types/beacon/messages/DisconnectMessage' {\n                                import { BeaconBaseMessage, BeaconMessageType } from 'test/';\n                                export interface DisconnectMessage extends BeaconBaseMessage {\n                                                type: BeaconMessageType.Disconnect;\n                                }\n                }\n    \n                module 'test/types/beacon/messages/ErrorResponse' {\n                                import { BeaconBaseMessage, BeaconErrorType, BeaconMessageType } from 'test/';\n                                export interface ErrorResponse extends BeaconBaseMessage {\n                                                type: BeaconMessageType.Error;\n                                                errorType: BeaconErrorType;\n                                                errorData?: any;\n                                }\n                }\n    \n                module 'test/types/beacon/messages/OperationRequest' {\n                                import { BeaconBaseMessage, BeaconMessageType, Network } from 'test/';\n                                import { PartialTezosOperation } from 'test/types/tezos/PartialTezosOperation';\n                                export interface OperationRequest extends BeaconBaseMessage {\n                                                type: BeaconMessageType.OperationRequest;\n                                                network: Network;\n                                                operationDetails: PartialTezosOperation[];\n                                                sourceAddress: string;\n                                }\n                }\n    \n                module 'test/types/beacon/messages/OperationResponse' {\n                                import { BeaconBaseMessage, BeaconMessageType } from 'test/';\n                                export interface OperationResponse extends BeaconBaseMessage {\n                                                type: BeaconMessageType.OperationResponse;\n                                                transactionHash: string;\n                                }\n                }\n    \n                module 'test/types/beacon/messages/PermissionRequest' {\n                                import { BeaconBaseMessage, BeaconMessageType, PermissionScope, AppMetadata, Network } from 'test/';\n                                export interface PermissionRequest extends BeaconBaseMessage {\n                                                type: BeaconMessageType.PermissionRequest;\n                                                appMetadata: AppMetadata;\n                                                network: Network;\n                                                scopes: PermissionScope[];\n                                }\n                }\n    \n                module 'test/types/beacon/messages/PermissionResponse' {\n                                import { AppMetadata, BeaconBaseMessage, BeaconMessageType, Network, PermissionScope, Threshold } from 'test/';\n                                export interface PermissionResponse extends BeaconBaseMessage {\n                                                type: BeaconMessageType.PermissionResponse;\n                                                appMetadata: AppMetadata;\n                                                publicKey: string;\n                                                network: Network;\n                                                scopes: PermissionScope[];\n                                                threshold?: Threshold;\n                                }\n                }\n    \n                module 'test/types/beacon/messages/SignPayloadRequest' {\n                                import { BeaconBaseMessage, BeaconMessageType, SigningType } from 'test/';\n                                export interface SignPayloadRequest extends BeaconBaseMessage {\n                                                type: BeaconMessageType.SignPayloadRequest;\n                                                signingType: SigningType;\n                                                payload: string;\n                                                sourceAddress: string;\n                                }\n                }\n    \n                module 'test/types/beacon/messages/SignPayloadResponse' {\n                                import { BeaconBaseMessage, BeaconMessageType, SigningType } from 'test/';\n                                export interface SignPayloadResponse extends BeaconBaseMessage {\n                                                type: BeaconMessageType.SignPayloadResponse;\n                                                signingType: SigningType;\n                                                signature: string;\n                                }\n                }\n    \n                module 'test/types/beacon/Network' {\n                                import { NetworkType } from 'test/';\n                                export interface Network {\n                                                type: NetworkType;\n                                                name?: string;\n                                                rpcUrl?: string;\n                                }\n                }\n    \n                module 'test/types/beacon/NetworkType' {\n                                export enum NetworkType {\n                                                MAINNET = \"mainnet\",\n                                                DELPHINET = \"delphinet\",\n                                                EDONET = \"edonet\",\n                                                CUSTOM = \"custom\"\n                                }\n                }\n    \n                module 'test/types/beacon/PermissionScope' {\n                                export enum PermissionScope {\n                                                SIGN = \"sign\",\n                                                OPERATION_REQUEST = \"operation_request\",\n                                                THRESHOLD = \"threshold\"\n                                }\n                }\n    \n                module 'test/types/beacon/SigningType' {\n                                export enum SigningType {\n                                                RAW = \"raw\",\n                                                OPERATION = \"operation\",\n                                                MICHELINE = \"micheline\"\n                                }\n                }\n    \n                module 'test/types/beacon/Threshold' {\n                                export interface Threshold {\n                                                amount: string;\n                                                timeframe: string;\n                                }\n                }\n    \n                module 'test/types/BeaconErrorType' {\n                                export enum BeaconErrorType {\n                                                BROADCAST_ERROR = \"BROADCAST_ERROR\",\n                                                NETWORK_NOT_SUPPORTED = \"NETWORK_NOT_SUPPORTED\",\n                                                NO_ADDRESS_ERROR = \"NO_ADDRESS_ERROR\",\n                                                NO_PRIVATE_KEY_FOUND_ERROR = \"NO_PRIVATE_KEY_FOUND_ERROR\",\n                                                NOT_GRANTED_ERROR = \"NOT_GRANTED_ERROR\",\n                                                PARAMETERS_INVALID_ERROR = \"PARAMETERS_INVALID_ERROR\",\n                                                TOO_MANY_OPERATIONS = \"TOO_MANY_OPERATIONS\",\n                                                TRANSACTION_INVALID_ERROR = \"TRANSACTION_INVALID_ERROR\",\n                                                SIGNATURE_TYPE_NOT_SUPPORTED = \"SIGNATURE_TYPE_NOT_SUPPORTED\",\n                                                ABORTED_ERROR = \"ABORTED_ERROR\",\n                                                UNKNOWN_ERROR = \"UNKNOWN_ERROR\"\n                                }\n                }\n    \n                module 'test/types/ColorMode' {\n                                export enum ColorMode {\n                                                LIGHT = \"light\",\n                                                DARK = \"dark\"\n                                }\n                }\n    \n                module 'test/types/ConnectionContext' {\n                                import { Origin } from 'test/';\n                                export interface ConnectionContext {\n                                                origin: Origin;\n                                                id: string;\n                                                extras?: {\n                                                                sender: chrome.runtime.MessageSender;\n                                                                sendResponse(response?: unknown): void;\n                                                };\n                                }\n                }\n    \n                module 'test/types/Extension' {\n                                export interface Extension {\n                                                id: string;\n                                                name: string;\n                                                shortName?: string;\n                                                iconUrl?: string;\n                                                color?: string;\n                                }\n                }\n    \n                module 'test/types/ExtensionMessage' {\n                                import { ExtensionMessageTarget } from 'test/';\n                                export interface ExtensionMessage<T, U = unknown> {\n                                                target: ExtensionMessageTarget;\n                                                targetId?: string;\n                                                sender?: U;\n                                                payload: T;\n                                }\n                                export interface EncryptedExtensionMessage<U = unknown> {\n                                                target: ExtensionMessageTarget;\n                                                targetId?: string;\n                                                sender?: U;\n                                                encryptedPayload: string;\n                                }\n                }\n    \n                module 'test/types/ExtensionMessageTarget' {\n                                export enum ExtensionMessageTarget {\n                                                BACKGROUND = \"toBackground\",\n                                                PAGE = \"toPage\",\n                                                EXTENSION = \"toExtension\"\n                                }\n                }\n    \n                module 'test/types/Origin' {\n                                export enum Origin {\n                                                WEBSITE = \"website\",\n                                                EXTENSION = \"extension\",\n                                                P2P = \"p2p\"\n                                }\n                }\n    \n                module 'test/types/P2PPairingRequest' {\n                                import { PeerInfo } from 'test/types/PeerInfo';\n                                export interface P2PPairingRequest extends PeerInfo {\n                                                id: string;\n                                                type: 'p2p-pairing-request';\n                                                name: string;\n                                                publicKey: string;\n                                                relayServer: string;\n                                                icon?: string;\n                                                appUrl?: string;\n                                }\n                                export type ExtendedP2PPairingRequest = P2PPairingRequest & {\n                                                senderId: string;\n                                };\n                }\n    \n                module 'test/types/P2PPairingResponse' {\n                                import { PeerInfo } from 'test/types/PeerInfo';\n                                export interface P2PPairingResponse extends PeerInfo {\n                                                id: string;\n                                                type: 'p2p-pairing-response';\n                                                name: string;\n                                                publicKey: string;\n                                                relayServer: string;\n                                                icon?: string;\n                                                appUrl?: string;\n                                }\n                                export type ExtendedP2PPairingResponse = P2PPairingResponse & {\n                                                senderId: string;\n                                };\n                }\n    \n                module 'test/types/PeerInfo' {\n                                export interface PeerInfo {\n                                                name: string;\n                                                publicKey: string;\n                                                version: string;\n                                }\n                                export type ExtendedPeerInfo = PeerInfo & {\n                                                senderId: string;\n                                };\n                }\n    \n                module 'test/types/PermissionEntity' {\n                                import { Network, PermissionScope, Threshold } from 'test/';\n                                export interface PermissionEntity {\n                                                address: string;\n                                                network: Network;\n                                                scopes: PermissionScope[];\n                                                threshold?: Threshold;\n                                }\n                }\n    \n                module 'test/types/PermissionInfo' {\n                                import { AppMetadata } from 'test/';\n                                import { PermissionEntity } from 'test/types/PermissionEntity';\n                                export interface PermissionInfo extends PermissionEntity {\n                                                accountIdentifier: string;\n                                                senderId: string;\n                                                appMetadata: AppMetadata;\n                                                website: string;\n                                                publicKey: string;\n                                                connectedAt: number;\n                                }\n                }\n    \n                module 'test/types/PostMessagePairingRequest' {\n                                import { PeerInfo } from 'test/types/PeerInfo';\n                                export interface PostMessagePairingRequest extends PeerInfo {\n                                                id: string;\n                                                type: 'postmessage-pairing-request';\n                                                name: string;\n                                                publicKey: string;\n                                                icon?: string;\n                                                appUrl?: string;\n                                }\n                                export type ExtendedPostMessagePairingRequest = PostMessagePairingRequest & {\n                                                senderId: string;\n                                };\n                }\n    \n                module 'test/types/PostMessagePairingResponse' {\n                                import { PeerInfo } from 'test/types/PeerInfo';\n                                export interface PostMessagePairingResponse extends PeerInfo {\n                                                id: string;\n                                                type: 'postmessage-pairing-response';\n                                                name: string;\n                                                publicKey: string;\n                                                icon?: string;\n                                                appUrl?: string;\n                                }\n                                export type ExtendedPostMessagePairingResponse = PostMessagePairingResponse & {\n                                                senderId: string;\n                                                extensionId: string;\n                                };\n                }\n    \n                module 'test/types/RequestBroadcastInput' {\n                                import { Network } from 'test/';\n                                export interface RequestBroadcastInput {\n                                                network?: Network;\n                                                signedTransaction: string;\n                                }\n                }\n    \n                module 'test/types/RequestOperationInput' {\n                                import { PartialTezosOperation } from 'test/types/tezos/PartialTezosOperation';\n                                export interface RequestOperationInput {\n                                                operationDetails: PartialTezosOperation[];\n                                }\n                }\n    \n                module 'test/types/RequestPermissionInput' {\n                                import { Network, PermissionScope } from 'test/';\n                                export interface RequestPermissionInput {\n                                                network?: Network;\n                                                scopes?: PermissionScope[];\n                                }\n                }\n    \n                module 'test/types/RequestSignPayloadInput' {\n                                import { SigningType } from 'test/';\n                                export interface RequestSignPayloadInput {\n                                                signingType?: SigningType;\n                                                payload: string;\n                                                sourceAddress?: string;\n                                }\n                }\n    \n                module 'test/types/storage/StorageKey' {\n                                export enum StorageKey {\n                                                TRANSPORT_P2P_PEERS_DAPP = \"beacon:communication-peers-dapp\",\n                                                TRANSPORT_P2P_PEERS_WALLET = \"beacon:communication-peers-wallet\",\n                                                TRANSPORT_POSTMESSAGE_PEERS_DAPP = \"beacon:postmessage-peers-dapp\",\n                                                TRANSPORT_POSTMESSAGE_PEERS_WALLET = \"beacon:postmessage-peers-wallet\",\n                                                ACCOUNTS = \"beacon:accounts\",\n                                                ACTIVE_ACCOUNT = \"beacon:active-account\",\n                                                ACTIVE_PEER = \"beacon:active-peer\",\n                                                BEACON_SDK_SECRET_SEED = \"beacon:sdk-secret-seed\",\n                                                APP_METADATA_LIST = \"beacon:app-metadata-list\",\n                                                PERMISSION_LIST = \"beacon:permissions\",\n                                                BEACON_SDK_VERSION = \"beacon:sdk_version\",\n                                                MATRIX_PRESERVED_STATE = \"beacon:sdk-matrix-preserved-state\",\n                                                MATRIX_PEER_ROOM_IDS = \"beacon:matrix-peer-rooms\"\n                                }\n                }\n    \n                module 'test/types/storage/StorageKeyReturnDefaults' {\n                                import { StorageKey, StorageKeyReturnType } from 'test/';\n                                export type StorageKeyReturnDefaults = {\n                                                [key in StorageKey]: StorageKeyReturnType[key];\n                                };\n                                export const defaultValues: StorageKeyReturnDefaults;\n                }\n    \n                module 'test/types/storage/StorageKeyReturnType' {\n                                import { StorageKey, AccountInfo, AccountIdentifier, P2PPairingRequest, AppMetadata, PermissionInfo } from 'test/';\n                                import { MatrixState } from 'test/matrix-client/MatrixClientStore';\n                                import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n                                import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n                                import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n                                export interface StorageKeyReturnType {\n                                                [StorageKey.TRANSPORT_P2P_PEERS_DAPP]: P2PPairingRequest[];\n                                                [StorageKey.TRANSPORT_P2P_PEERS_WALLET]: ExtendedP2PPairingResponse[];\n                                                [StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP]: PostMessagePairingRequest[];\n                                                [StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET]: ExtendedPostMessagePairingResponse[];\n                                                [StorageKey.ACCOUNTS]: AccountInfo[];\n                                                [StorageKey.ACTIVE_ACCOUNT]: AccountIdentifier | undefined;\n                                                [StorageKey.ACTIVE_PEER]: string | undefined;\n                                                [StorageKey.BEACON_SDK_SECRET_SEED]: string | undefined;\n                                                [StorageKey.APP_METADATA_LIST]: AppMetadata[];\n                                                [StorageKey.PERMISSION_LIST]: PermissionInfo[];\n                                                [StorageKey.BEACON_SDK_VERSION]: string | undefined;\n                                                [StorageKey.MATRIX_PRESERVED_STATE]: Partial<MatrixState>;\n                                                [StorageKey.MATRIX_PEER_ROOM_IDS]: {\n                                                                [key: string]: string | undefined;\n                                                };\n                                }\n                }\n    \n                module 'test/types/tezos/MichelineMichelsonV1Expression' {\n                                import { MichelsonPrimitives } from 'test/';\n                                export type MichelineMichelsonV1Expression = {\n                                                int: string;\n                                } | {\n                                                string: string;\n                                } | {\n                                                bytes: string;\n                                } | MichelineMichelsonV1Expression[] | {\n                                                prim: MichelsonPrimitives;\n                                                args?: MichelineMichelsonV1Expression[];\n                                                annots?: string[];\n                                };\n                }\n    \n                module 'test/types/tezos/MichelsonPrimitives' {\n                                export type MichelsonPrimitives = 'ADD' | 'IF_NONE' | 'SWAP' | 'set' | 'nat' | 'CHECK_SIGNATURE' | 'IF_LEFT' | 'LAMBDA' | 'Elt' | 'CREATE_CONTRACT' | 'NEG' | 'big_map' | 'map' | 'or' | 'BLAKE2B' | 'bytes' | 'SHA256' | 'SET_DELEGATE' | 'CONTRACT' | 'LSL' | 'SUB' | 'IMPLICIT_ACCOUNT' | 'PACK' | 'list' | 'PAIR' | 'Right' | 'contract' | 'GT' | 'LEFT' | 'STEPS_TO_QUOTA' | 'storage' | 'TRANSFER_TOKENS' | 'CDR' | 'SLICE' | 'PUSH' | 'False' | 'SHA512' | 'CHAIN_ID' | 'BALANCE' | 'signature' | 'DUG' | 'SELF' | 'EMPTY_BIG_MAP' | 'LSR' | 'OR' | 'XOR' | 'lambda' | 'COMPARE' | 'key' | 'option' | 'Unit' | 'Some' | 'UNPACK' | 'NEQ' | 'INT' | 'pair' | 'AMOUNT' | 'DIP' | 'ABS' | 'ISNAT' | 'EXEC' | 'NOW' | 'LOOP' | 'chain_id' | 'string' | 'MEM' | 'MAP' | 'None' | 'address' | 'CONCAT' | 'EMPTY_SET' | 'MUL' | 'LOOP_LEFT' | 'timestamp' | 'LT' | 'UPDATE' | 'DUP' | 'SOURCE' | 'mutez' | 'SENDER' | 'IF_CONS' | 'RIGHT' | 'CAR' | 'CONS' | 'LE' | 'NONE' | 'IF' | 'SOME' | 'GET' | 'Left' | 'CAST' | 'int' | 'SIZE' | 'key_hash' | 'unit' | 'DROP' | 'EMPTY_MAP' | 'NIL' | 'DIG' | 'APPLY' | 'bool' | 'RENAME' | 'operation' | 'True' | 'FAILWITH' | 'parameter' | 'HASH_KEY' | 'EQ' | 'NOT' | 'UNIT' | 'Pair' | 'ADDRESS' | 'EDIV' | 'CREATE_ACCOUNT' | 'GE' | 'ITER' | 'code' | 'AND';\n                }\n    \n                module 'test/types/tezos/operations/ActivateAccount' {\n                                import { TezosBaseOperation, TezosOperationType } from 'test/';\n                                export interface TezosActivateAccountOperation extends TezosBaseOperation {\n                                                kind: TezosOperationType.ACTIVATE_ACCOUNT;\n                                                pkh: string;\n                                                secret: string;\n                                }\n                }\n    \n                module 'test/types/tezos/operations/Ballot' {\n                                import { TezosBaseOperation, TezosOperationType } from 'test/';\n                                export interface TezosBallotOperation extends TezosBaseOperation {\n                                                kind: TezosOperationType.BALLOT;\n                                                source: string;\n                                                period: string;\n                                                proposal: string;\n                                                ballot: 'nay' | 'yay' | 'pass';\n                                }\n                }\n    \n                module 'test/types/tezos/operations/Delegation' {\n                                import { TezosBaseOperation, TezosOperationType } from 'test/';\n                                export interface TezosDelegationOperation extends TezosBaseOperation {\n                                                kind: TezosOperationType.DELEGATION;\n                                                source: string;\n                                                fee: string;\n                                                counter: string;\n                                                gas_limit: string;\n                                                storage_limit: string;\n                                                delegate?: string;\n                                }\n                }\n    \n                module 'test/types/tezos/operations/DoubleBakingEvidence' {\n                                import { TezosBaseOperation, TezosOperationType, TezosBlockHeader } from 'test/';\n                                export interface InlinedEndorsement {\n                                                branch: string;\n                                                operations: InlinedEndorsementContents;\n                                                signature?: string;\n                                }\n                                export interface InlinedEndorsementContents {\n                                                kind: 'endorsement';\n                                                level: string;\n                                }\n                                export interface TezosDoubleBakingEvidenceOperation extends TezosBaseOperation {\n                                                kind: TezosOperationType.DOUBLE_BAKING_EVIDENCE;\n                                                bh1: TezosBlockHeader;\n                                                bh2: TezosBlockHeader;\n                                }\n                }\n    \n                module 'test/types/tezos/operations/DoubleEndorsementEvidence' {\n                                import { TezosBaseOperation, TezosOperationType } from 'test/';\n                                export interface InlinedEndorsement {\n                                                branch: string;\n                                                operations: InlinedEndorsementContents;\n                                                signature?: string;\n                                }\n                                export interface InlinedEndorsementContents {\n                                                kind: 'endorsement';\n                                                level: string;\n                                }\n                                export interface TezosDoubleEndorsementEvidenceOperation extends TezosBaseOperation {\n                                                kind: TezosOperationType.DOUBLE_ENDORSEMENT_EVIDENCE;\n                                                op1: InlinedEndorsement;\n                                                op2: InlinedEndorsement;\n                                }\n                }\n    \n                module 'test/types/tezos/operations/Endorsement' {\n                                import { TezosBaseOperation, TezosOperationType } from 'test/';\n                                export interface TezosEndorsementOperation extends TezosBaseOperation {\n                                                kind: TezosOperationType.ENDORSEMENT;\n                                                level: string;\n                                }\n                }\n    \n                module 'test/types/tezos/operations/Origination' {\n                                import { TezosBaseOperation, TezosOperationType } from 'test/';\n                                export interface TezosOriginationOperation extends TezosBaseOperation {\n                                                kind: TezosOperationType.ORIGINATION;\n                                                source: string;\n                                                fee: string;\n                                                counter: string;\n                                                gas_limit: string;\n                                                storage_limit: string;\n                                                balance: string;\n                                                delegate?: string;\n                                                script: string;\n                                }\n                }\n    \n                module 'test/types/tezos/operations/Proposal' {\n                                import { TezosBaseOperation, TezosOperationType } from 'test/';\n                                export interface TezosProposalOperation extends TezosBaseOperation {\n                                                kind: TezosOperationType.PROPOSALS;\n                                                period: string;\n                                                proposals: string[];\n                                }\n                }\n    \n                module 'test/types/tezos/operations/Reveal' {\n                                import { TezosBaseOperation, TezosOperationType } from 'test/';\n                                export interface TezosRevealOperation extends TezosBaseOperation {\n                                                kind: TezosOperationType.REVEAL;\n                                                source: string;\n                                                fee: string;\n                                                counter: string;\n                                                gas_limit: string;\n                                                storage_limit: string;\n                                                public_key: string;\n                                }\n                }\n    \n                module 'test/types/tezos/operations/SeedNonceRevelation' {\n                                import { TezosBaseOperation, TezosOperationType } from 'test/';\n                                export interface TezosSeedNonceRevelationOperation extends TezosBaseOperation {\n                                                kind: TezosOperationType.SEED_NONCE_REVELATION;\n                                                level: string;\n                                                nonce: string;\n                                }\n                }\n    \n                module 'test/types/tezos/operations/Transaction' {\n                                import { TezosBaseOperation, TezosOperationType, TezosTransactionParameters } from 'test/';\n                                export interface TezosTransactionOperation extends TezosBaseOperation {\n                                                kind: TezosOperationType.TRANSACTION;\n                                                source: string;\n                                                fee: string;\n                                                counter: string;\n                                                gas_limit: string;\n                                                storage_limit: string;\n                                                amount: string;\n                                                destination: string;\n                                                parameters?: TezosTransactionParameters;\n                                }\n                }\n    \n                module 'test/types/tezos/OperationTypes' {\n                                export enum TezosOperationType {\n                                                ENDORSEMENT = \"endorsement\",\n                                                SEED_NONCE_REVELATION = \"seed_nonce_revelation\",\n                                                DOUBLE_ENDORSEMENT_EVIDENCE = \"double_endorsement_evidence\",\n                                                DOUBLE_BAKING_EVIDENCE = \"double_baking_evidence\",\n                                                ACTIVATE_ACCOUNT = \"activate_account\",\n                                                PROPOSALS = \"proposals\",\n                                                BALLOT = \"ballot\",\n                                                REVEAL = \"reveal\",\n                                                TRANSACTION = \"transaction\",\n                                                ORIGINATION = \"origination\",\n                                                DELEGATION = \"delegation\"\n                                }\n                }\n    \n                module 'test/types/tezos/PartialTezosOperation' {\n                                import { TezosActivateAccountOperation } from 'test/types/tezos/operations/ActivateAccount';\n                                import { TezosBallotOperation } from 'test/types/tezos/operations/Ballot';\n                                import { TezosDelegationOperation } from 'test/types/tezos/operations/Delegation';\n                                import { TezosDoubleBakingEvidenceOperation } from 'test/types/tezos/operations/DoubleBakingEvidence';\n                                import { TezosEndorsementOperation } from 'test/types/tezos/operations/Endorsement';\n                                import { TezosOriginationOperation } from 'test/types/tezos/operations/Origination';\n                                import { TezosProposalOperation } from 'test/types/tezos/operations/Proposal';\n                                import { TezosRevealOperation } from 'test/types/tezos/operations/Reveal';\n                                import { TezosSeedNonceRevelationOperation } from 'test/types/tezos/operations/SeedNonceRevelation';\n                                import { TezosTransactionOperation } from 'test/types/tezos/operations/Transaction';\n                                type omittedProperties = 'source' | 'fee' | 'counter' | 'gas_limit' | 'storage_limit';\n                                export type PartialTezosDelegationOperation = Omit<TezosDelegationOperation, omittedProperties>;\n                                export type PartialTezosOriginationOperation = Omit<TezosOriginationOperation, omittedProperties>;\n                                export type PartialTezosRevealOperation = Omit<TezosRevealOperation, omittedProperties>;\n                                export type PartialTezosTransactionOperation = Omit<TezosTransactionOperation, omittedProperties>;\n                                export type PartialTezosOperation = TezosActivateAccountOperation | TezosBallotOperation | PartialTezosDelegationOperation | TezosDoubleBakingEvidenceOperation | TezosEndorsementOperation | PartialTezosOriginationOperation | TezosProposalOperation | PartialTezosRevealOperation | TezosSeedNonceRevelationOperation | PartialTezosTransactionOperation;\n                                export {};\n                }\n    \n                module 'test/types/tezos/TezosBaseOperation' {\n                                import { TezosOperationType } from 'test/';\n                                export interface TezosBaseOperation {\n                                                kind: TezosOperationType;\n                                }\n                }\n    \n                module 'test/types/tezos/TezosBlockHeader' {\n                                export interface TezosBlockHeader {\n                                                level: number;\n                                                proto: number;\n                                                predecessor: string;\n                                                timestamp: string;\n                                                validation_pass: number;\n                                                operations_hash: string;\n                                                fitness: string[];\n                                                context: string;\n                                                priority: number;\n                                                proof_of_work_nonce: string;\n                                                signature: string;\n                                }\n                }\n    \n                module 'test/types/tezos/TezosOperation' {\n                                import { TezosActivateAccountOperation, TezosBallotOperation, TezosDelegationOperation, TezosDoubleBakingEvidenceOperation, TezosEndorsementOperation, TezosOriginationOperation, TezosProposalOperation, TezosRevealOperation, TezosSeedNonceRevelationOperation, TezosTransactionOperation } from 'test/';\n                                export type TezosOperation = TezosActivateAccountOperation | TezosBallotOperation | TezosDelegationOperation | TezosDoubleBakingEvidenceOperation | TezosEndorsementOperation | TezosOriginationOperation | TezosProposalOperation | TezosRevealOperation | TezosSeedNonceRevelationOperation | TezosTransactionOperation;\n                }\n    \n                module 'test/types/tezos/TezosTransactionParameters' {\n                                import { MichelineMichelsonV1Expression } from 'test/types/tezos/MichelineMichelsonV1Expression';\n                                export interface TezosTransactionParameters {\n                                                entrypoint: 'default' | 'root' | 'do' | 'set_delegate' | 'remove_delegate' | string;\n                                                value: MichelineMichelsonV1Expression;\n                                }\n                }\n    \n                module 'test/types/transport/TransportStatus' {\n                                export enum TransportStatus {\n                                                NOT_CONNECTED = \"NOT_CONNECTED\",\n                                                CONNECTING = \"CONNECTING\",\n                                                CONNECTED = \"CONNECTED\"\n                                }\n                }\n    \n                module 'test/types/transport/TransportType' {\n                                export enum TransportType {\n                                                CHROME_MESSAGE = \"chrome_message\",\n                                                POST_MESSAGE = \"post_message\",\n                                                LEDGER = \"ledger\",\n                                                P2P = \"p2p\"\n                                }\n                }\n    \n                module 'test/ui/alert/alert-templates' {\n                                export const alertTemplates: {\n                                                container: string;\n                                                default: {\n                                                                html: string;\n                                                                css: string;\n                                                };\n                                                pair: {\n                                                                html: string;\n                                                                css: string;\n                                                };\n                                };\n                }\n    \n                module 'test/ui/alert/Alert' {\n                                import { NetworkType } from 'test/';\n                                export interface AlertButton {\n                                                                text: string;\n                                                                style?: 'solid' | 'outline';\n                                                                actionCallback?(): Promise<void>;\n                                }\n                                export interface AlertConfig {\n                                                                title: string;\n                                                                body?: string;\n                                                                timer?: number;\n                                                                buttons?: AlertButton[];\n                                                                pairingPayload?: {\n                                                                                                p2pSyncCode: string;\n                                                                                                postmessageSyncCode: string;\n                                                                                                preferredNetwork: NetworkType;\n                                                                };\n                                                                closeButtonCallback?(): void;\n                                }\n                                /**\n                                                     * Close an alert by ID\n                                                     *\n                                                     * @param id ID of alert\n                                                     */\n                                const closeAlert: (id: string) => Promise<void>;\n                                /**\n                                                     * Close all alerts\n                                                     */\n                                const closeAlerts: () => Promise<void>;\n                                /**\n                                                     * Show an alert\n                                                     *\n                                                     * @param alertConfig The configuration of the alert\n                                                     */\n                                const openAlert: (alertConfig: AlertConfig) => Promise<string>;\n                                export { closeAlert, closeAlerts, openAlert };\n                }\n    \n                module 'test/ui/alert/Pairing' {\n                                import { NetworkType } from 'test/';\n                                export enum Platform {\n                                                DESKTOP = 0,\n                                                IOS = 1,\n                                                ANDROID = 2\n                                }\n                                export enum WalletType {\n                                                IOS = \"ios\",\n                                                ANDROID = \"android\",\n                                                EXTENSION = \"extension\",\n                                                DESKTOP = \"desktop\",\n                                                WEB = \"web\"\n                                }\n                                export interface AppBase {\n                                                name: string;\n                                                shortName: string;\n                                                color: string;\n                                                logo: string;\n                                }\n                                export interface ExtensionApp extends AppBase {\n                                                id: string;\n                                                link: string;\n                                }\n                                export interface WebApp extends AppBase {\n                                                links: {\n                                                                [NetworkType.MAINNET]: string;\n                                                                [NetworkType.DELPHINET]?: string;\n                                                                [NetworkType.EDONET]?: string;\n                                                                [NetworkType.CUSTOM]?: string;\n                                                };\n                                }\n                                export interface DesktopApp extends AppBase {\n                                                deepLink: string;\n                                }\n                                export interface App extends AppBase {\n                                                universalLink: string;\n                                                deepLink?: string;\n                                }\n                                export interface PairingAlertWallet {\n                                                name: string;\n                                                shortName?: string;\n                                                color?: string;\n                                                logo?: string;\n                                                enabled: boolean;\n                                                clickHandler(): void;\n                                }\n                                export interface PairingAlertButton {\n                                                title: string;\n                                                text: string;\n                                                clickHandler(): void;\n                                }\n                                export interface PairingAlertList {\n                                                title: string;\n                                                type: WalletType;\n                                                wallets: PairingAlertWallet[];\n                                }\n                                export interface PairingAlertInfo {\n                                                walletLists: PairingAlertList[];\n                                                buttons: PairingAlertButton[];\n                                                qrData: string;\n                                }\n                                export type StatusUpdateHandler = (walletType: WalletType, app?: PairingAlertWallet) => void;\n                                export class Pairing {\n                                                static getPlatfrom(): Promise<Platform>;\n                                                static getPairingInfo(pairingPayload: {\n                                                                p2pSyncCode: string;\n                                                                postmessageSyncCode: string;\n                                                                preferredNetwork: NetworkType;\n                                                }, statusUpdateHandler: StatusUpdateHandler, platform?: Platform): Promise<PairingAlertInfo>;\n                                }\n                }\n    \n                module 'test/ui/alert/PairingAlert' {\n                                import { NetworkType } from 'test/';\n                                export const preparePairingAlert: (shadowRoot: ShadowRoot, pairingPayload: {\n                                                p2pSyncCode: string;\n                                                postmessageSyncCode: string;\n                                                preferredNetwork: NetworkType;\n                                }) => Promise<void>;\n                }\n    \n                module 'test/ui/alert/wallet-lists' {\n                                import { App, DesktopApp, ExtensionApp, WebApp } from 'test/ui/alert/Pairing';\n                                export const extensionList: ExtensionApp[];\n                                export const desktopList: DesktopApp[];\n                                export const webList: WebApp[];\n                                export const iOSList: App[];\n                }\n    \n                module 'test/ui/toast/toast-templates' {\n                                export const toastTemplates: {\n                                                default: {\n                                                                html: string;\n                                                                css: string;\n                                                                poweredByBeacon: string;\n                                                };\n                                };\n                }\n    \n                module 'test/ui/toast/Toast' {\n                                import { WalletInfo } from 'test/events';\n                                export interface ToastAction {\n                                                                text: string;\n                                                                actionText?: string;\n                                                                actionCallback?(): Promise<void>;\n                                }\n                                export interface ToastConfig {\n                                                                body: string;\n                                                                timer?: number;\n                                                                forceNew?: boolean;\n                                                                state: 'loading' | 'acknowledge' | 'finished';\n                                                                actions?: ToastAction[];\n                                                                walletInfo?: WalletInfo;\n                                }\n                                /**\n                                                     * Close a toast\n                                                     */\n                                const closeToast: () => Promise<void>;\n                                /**\n                                                     * Create a new toast\n                                                     *\n                                                     * @param toastConfig Configuration of the toast\n                                                     */\n                                const openToast: (toastConfig: ToastConfig) => Promise<void>;\n                                export { closeToast, openToast };\n                }\n    \n                module 'test/utils/assert-never' {\n                                /**\n                                             * A helper function to make sure if/elses and switch/cases are exhaustive\n                                             *\n                                             * @param empty The data that has to be empty\n                                             */\n                                export function assertNever(empty: never): never;\n                }\n    \n                module 'test/utils/available-transports' {\n                                /**\n                                             * An object with promises to indicate whether or not that transport is available.\n                                             */\n                                export const availableTransports: {\n                                                extension: Promise<boolean>;\n                                                availableExtensions: Promise<import(\"beacon/types/Extension\").Extension[]>;\n                                };\n                }\n    \n                module 'test/utils/block-explorer' {\n                                import { Network, NetworkType } from 'test/';\n                                export abstract class BlockExplorer {\n                                                                readonly rpcUrls: {\n                                                                                                [key in NetworkType]: string;\n                                                                };\n                                                                constructor(rpcUrls: {\n                                                                                                [key in NetworkType]: string;\n                                                                });\n                                                                protected getLinkForNetwork(network: Network): Promise<string>;\n                                                                /**\n                                                                                     * Return a blockexplorer link for an address\n                                                                                     *\n                                                                                     * @param address The address to be opened\n                                                                                     * @param network The network that was used\n                                                                                     */\n                                                                abstract getAddressLink(address: string, network: Network): Promise<string>;\n                                                                /**\n                                                                                     * Return a blockexplorer link for a transaction hash\n                                                                                     *\n                                                                                     * @param transactionId The hash of the transaction\n                                                                                     * @param network The network that was used\n                                                                                     */\n                                                                abstract getTransactionLink(transactionId: string, network: Network): Promise<string>;\n                                }\n                }\n    \n                module 'test/utils/crypto' {\n                                import * as sodium from 'libsodium-wrappers';\n                                /**\n                                                     * Convert a value to hex\n                                                     *\n                                                     * @param value\n                                                     */\n                                export function toHex(value: any): string;\n                                /**\n                                                     * Get the hex hash of a value\n                                                     *\n                                                     * @param key\n                                                     */\n                                export function getHexHash(key: string | Buffer | Uint8Array): Promise<string>;\n                                /**\n                                                     * Get a keypair from a seed\n                                                     *\n                                                     * @param seed\n                                                     */\n                                export function getKeypairFromSeed(seed: string): Promise<sodium.KeyPair>;\n                                /**\n                                                     * Encrypt a message with a shared key\n                                                     *\n                                                     * @param message\n                                                     * @param sharedKey\n                                                     */\n                                export function encryptCryptoboxPayload(message: string, sharedKey: Uint8Array): Promise<string>;\n                                /**\n                                                     * Decrypt a message with a shared key\n                                                     *\n                                                     * @param payload\n                                                     * @param sharedKey\n                                                     */\n                                export function decryptCryptoboxPayload(payload: Uint8Array, sharedKey: Uint8Array): Promise<string>;\n                                /**\n                                                     * Encrypt a message with a public key\n                                                     *\n                                                     * @param payload\n                                                     * @param publicKey\n                                                     */\n                                export function sealCryptobox(payload: string | Buffer, publicKey: Uint8Array): Promise<string>;\n                                /**\n                                                     * Decrypt a message with public + private key\n                                                     *\n                                                     * @param encryptedPayload\n                                                     * @param publicKey\n                                                     * @param privateKey\n                                                     */\n                                export function openCryptobox(encryptedPayload: string | Buffer, publicKey: Uint8Array, privateKey: Uint8Array): Promise<string>;\n                                /**\n                                                     * Get an address from the public key\n                                                     *\n                                                     * @param publicKey\n                                                     */\n                                export function getAddressFromPublicKey(publicKey: string): Promise<string>;\n                                /**\n                                                     * Get the recipient string used in the matrix message\n                                                     *\n                                                     * @param recipientHash\n                                                     * @param relayServer\n                                                     */\n                                export function recipientString(recipientHash: string, relayServer: string): string;\n                }\n    \n                module 'test/utils/exposed-promise' {\n                                export enum ExposedPromiseStatus {\n                                                PENDING = \"pending\",\n                                                RESOLVED = \"resolved\",\n                                                REJECTED = \"rejected\"\n                                }\n                                type Resolve<T> = (value?: T) => void;\n                                type Reject<U> = (reason?: U) => void;\n                                /**\n                                             * Exposed promise allow you to create a promise and then resolve it later, from the outside\n                                             */\n                                export class ExposedPromise<T = unknown, U = unknown> {\n                                                get promise(): Promise<T>;\n                                                get resolve(): Resolve<T>;\n                                                get reject(): Reject<U>;\n                                                get status(): ExposedPromiseStatus;\n                                                get promiseResult(): T | undefined;\n                                                get promiseError(): U | undefined;\n                                                constructor();\n                                                static resolve<T>(value?: T): ExposedPromise<T>;\n                                                static reject<T = never, U = unknown>(reason?: U): ExposedPromise<T, U>;\n                                                isPending(): boolean;\n                                                isResolved(): boolean;\n                                                isRejected(): boolean;\n                                                isSettled(): boolean;\n                                }\n                                export {};\n                }\n    \n                module 'test/utils/generate-uuid' {\n                                /**\n                                             * Generate a random GUID\n                                             */\n                                export function generateGUID(): Promise<string>;\n                }\n    \n                module 'test/utils/get-account-identifier' {\n                                import { Network } from 'test/';\n                                /**\n                                             * Generate a deterministic account identifier based on an address and a network\n                                             *\n                                             * @param address\n                                             * @param network\n                                             */\n                                export const getAccountIdentifier: (address: string, network: Network) => Promise<string>;\n                }\n    \n                module 'test/utils/get-sender-id' {\n                                /**\n                                             * Generate a deterministic sender identifier based on a public key\n                                             *\n                                             * @param publicKey\n                                             */\n                                export const getSenderId: (publicKey: string) => Promise<string>;\n                }\n    \n                module 'test/utils/get-tzip10-link' {\n                                export const getTzip10Link: (url: string, payload: string) => string;\n                }\n    \n                module 'test/utils/Logger' {\n                                /**\n                                             * The logger that is used internally\n                                             */\n                                export class Logger {\n                                                constructor(service: string);\n                                                debug(method: string, ...args: any[]): void;\n                                                log(method: string, ...args: any[]): void;\n                                                warn(method: string, ...args: any[]): void;\n                                                error(method: string, ...args: any[]): void;\n                                }\n                }\n    \n                module 'test/utils/platform' {\n                                export const testUserAgent: (win: Window, expr: RegExp) => boolean;\n                                export const isMobile: (win: Window) => boolean;\n                                export const isIOS: (win: Window) => boolean;\n                                export const isAndroid: (win: Window) => boolean;\n                                export const isDesktop: (win: Window) => boolean;\n                }\n    \n                module 'test/utils/qr' {\n                                /**\n                                             * Convert data to a QR code\n                                             *\n                                             * @param payload The data to be encoded as a QR code\n                                             * @param type How the QR code will be encoded\n                                             */\n                                export const getQrData: (payload: string, type?: \"data\" | \"svg\" | \"ascii\" | undefined) => string;\n                }\n    \n                module 'test/utils/replace-in-template' {\n                                export const replaceInTemplate: (text: string, placeholder: string, value: string) => string;\n                }\n    \n                module 'test/utils/shorten-string' {\n                                export const shortenString: (text: string) => string;\n                }\n    \n                module 'test/utils/tezblock-blockexplorer' {\n                                import { Network, NetworkType } from 'test/';\n                                import { BlockExplorer } from 'test/utils/block-explorer';\n                                export class TezblockBlockExplorer extends BlockExplorer {\n                                                readonly rpcUrls: {\n                                                                [key in NetworkType]: string;\n                                                };\n                                                constructor(rpcUrls?: {\n                                                                [key in NetworkType]: string;\n                                                });\n                                                getAddressLink(address: string, network: Network): Promise<string>;\n                                                getTransactionLink(transactionId: string, network: Network): Promise<string>;\n                                }\n                }\n    \n                module 'test/utils/utils' {\n                                /**\n                                             * A helper function to improve typings of object keys\n                                             *\n                                             * @param obj Object\n                                             */\n                                export function keys<O extends object>(obj: O): (keyof O)[];\n                }\n    \n                module 'test/' {\n                                import { P2PCommunicationClient } from 'test/transports/clients/P2PCommunicationClient';\n                                import { AppMetadata } from 'test/types/beacon/AppMetadata';\n                                import { PermissionRequest } from 'test/types/beacon/messages/PermissionRequest';\n                                import { Network } from 'test/types/beacon/Network';\n                                import { BeaconBaseMessage } from 'test/types/beacon/BeaconBaseMessage';\n                                import { BeaconMessageType } from 'test/types/beacon/BeaconMessageType';\n                                import { PermissionScope } from 'test/types/beacon/PermissionScope';\n                                import { PermissionResponse } from 'test/types/beacon/messages/PermissionResponse';\n                                import { OperationRequest } from 'test/types/beacon/messages/OperationRequest';\n                                import { OperationResponse } from 'test/types/beacon/messages/OperationResponse';\n                                import { SignPayloadRequest } from 'test/types/beacon/messages/SignPayloadRequest';\n                                import { SignPayloadResponse } from 'test/types/beacon/messages/SignPayloadResponse';\n                                import { BroadcastRequest } from 'test/types/beacon/messages/BroadcastRequest';\n                                import { BroadcastResponse } from 'test/types/beacon/messages/BroadcastResponse';\n                                import { NetworkType } from 'test/types/beacon/NetworkType';\n                                import { TezosBaseOperation } from 'test/types/tezos/TezosBaseOperation';\n                                import { TezosOperationType } from 'test/types/tezos/OperationTypes';\n                                import { TezosActivateAccountOperation } from 'test/types/tezos/operations/ActivateAccount';\n                                import { TezosBallotOperation } from 'test/types/tezos/operations/Ballot';\n                                import { TezosDelegationOperation } from 'test/types/tezos/operations/Delegation';\n                                import { TezosDoubleBakingEvidenceOperation } from 'test/types/tezos/operations/DoubleBakingEvidence';\n                                import { TezosBlockHeader } from 'test/types/tezos/TezosBlockHeader';\n                                import { TezosDoubleEndorsementEvidenceOperation } from 'test/types/tezos/operations/DoubleEndorsementEvidence';\n                                import { TezosEndorsementOperation } from 'test/types/tezos/operations/Endorsement';\n                                import { TezosOriginationOperation } from 'test/types/tezos/operations/Origination';\n                                import { TezosProposalOperation } from 'test/types/tezos/operations/Proposal';\n                                import { TezosRevealOperation } from 'test/types/tezos/operations/Reveal';\n                                import { TezosSeedNonceRevelationOperation } from 'test/types/tezos/operations/SeedNonceRevelation';\n                                import { TezosTransactionOperation } from 'test/types/tezos/operations/Transaction';\n                                import { MichelsonPrimitives } from 'test/types/tezos/MichelsonPrimitives';\n                                import { TezosTransactionParameters } from 'test/types/tezos/TezosTransactionParameters';\n                                import { Origin } from 'test/types/Origin';\n                                import { AccountInfo, AccountIdentifier } from 'test/types/AccountInfo';\n                                import { EncryptedExtensionMessage, ExtensionMessage } from 'test/types/ExtensionMessage';\n                                import { ExtensionMessageTarget } from 'test/types/ExtensionMessageTarget';\n                                import { TezosOperation } from 'test/types/tezos/TezosOperation';\n                                import { Client } from 'test/clients/client/Client';\n                                import { WalletClient } from 'test/clients/wallet-client/WalletClient';\n                                import { DAppClient } from 'test/clients/dapp-client/DAppClient';\n                                import { BeaconError } from 'test/errors/BeaconError';\n                                import { BeaconErrorType } from 'test/types/BeaconErrorType';\n                                import { BroadcastBeaconError } from 'test/errors/BroadcastBeaconError';\n                                import { NetworkNotSupportedBeaconError } from 'test/errors/NetworkNotSupportedBeaconError';\n                                import { NoAddressBeaconError } from 'test/errors/NoAddressBeaconError';\n                                import { NoPrivateKeyBeaconError } from 'test/errors/NoPrivateKeyBeaconError';\n                                import { NotGrantedBeaconError } from 'test/errors/NotGrantedBeaconError';\n                                import { ParametersInvalidBeaconError } from 'test/errors/ParametersInvalidBeaconError';\n                                import { TooManyOperationsBeaconError } from 'test/errors/TooManyOperationsBeaconError';\n                                import { TransactionInvalidBeaconError } from 'test/errors/TransactionInvalidBeaconError';\n                                import { UnknownBeaconError } from 'test/errors/UnknownBeaconError';\n                                import { ErrorResponse } from 'test/types/beacon/messages/ErrorResponse';\n                                import { TransportStatus } from 'test/types/transport/TransportStatus';\n                                import { TransportType } from 'test/types/transport/TransportType';\n                                import { PostMessageTransport } from 'test/transports/PostMessageTransport';\n                                import { Transport } from 'test/transports/Transport';\n                                import { P2PTransport } from 'test/transports/P2PTransport';\n                                import { Storage } from 'test/storage/Storage';\n                                import { StorageKey } from 'test/types/storage/StorageKey';\n                                import { StorageKeyReturnDefaults } from 'test/types/storage/StorageKeyReturnDefaults';\n                                import { StorageKeyReturnType } from 'test/types/storage/StorageKeyReturnType';\n                                import { ExtendedP2PPairingRequest, P2PPairingRequest } from 'test/types/P2PPairingRequest';\n                                import { ChromeStorage } from 'test/storage/ChromeStorage';\n                                import { LocalStorage } from 'test/storage/LocalStorage';\n                                import { getStorage } from 'test/storage/getStorage';\n                                import { BeaconMessage } from 'test/types/beacon/BeaconMessage';\n                                import { Serializer } from 'test/Serializer';\n                                import { RequestPermissionInput } from 'test/types/RequestPermissionInput';\n                                import { RequestSignPayloadInput } from 'test/types/RequestSignPayloadInput';\n                                import { RequestOperationInput } from 'test/types/RequestOperationInput';\n                                import { RequestBroadcastInput } from 'test/types/RequestBroadcastInput';\n                                import { PermissionResponseInput, SignPayloadResponseInput, OperationResponseInput, BroadcastResponseInput, BeaconResponseInputMessage, AcknowledgeResponseInput, ErrorResponseInput } from 'test/types/beacon/messages/BeaconResponseInputMessage';\n                                import { PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, BeaconResponseOutputMessage } from 'test/types/beacon/messages/BeaconResponseOutputMessage';\n                                import { PermissionRequestInput, SignPayloadRequestInput, OperationRequestInput, BroadcastRequestInput, BeaconRequestInputMessage } from 'test/types/beacon/messages/BeaconRequestInputMessage';\n                                import { PermissionRequestOutput, SignPayloadRequestOutput, OperationRequestOutput, BroadcastRequestOutput, BeaconRequestOutputMessage } from 'test/types/beacon/messages/BeaconRequestOutputMessage';\n                                import { ClientOptions } from 'test/clients/client/ClientOptions';\n                                import { DAppClientOptions } from 'test/clients/dapp-client/DAppClientOptions';\n                                import { WalletClientOptions } from 'test/clients/wallet-client/WalletClientOptions';\n                                import { PermissionInfo } from 'test/types/PermissionInfo';\n                                import { SDK_VERSION, BEACON_VERSION } from 'test/constants';\n                                import { AccountManager } from 'test/managers/AccountManager';\n                                import { AppMetadataManager } from 'test/managers/AppMetadataManager';\n                                import { PermissionManager } from 'test/managers/PermissionManager';\n                                import { BeaconEvent, BeaconEventHandler, defaultEventCallbacks } from 'test/events';\n                                import { getAddressFromPublicKey } from 'test/utils/crypto';\n                                import { BeaconClient } from 'test/clients/beacon-client/BeaconClient';\n                                import { BeaconClientOptions } from 'test/clients/beacon-client/BeaconClientOptions';\n                                import { getAccountIdentifier } from 'test/utils/get-account-identifier';\n                                import { ConnectionContext } from 'test/types/ConnectionContext';\n                                import { Threshold } from 'test/types/beacon/Threshold';\n                                import { PartialTezosTransactionOperation, PartialTezosOperation, PartialTezosDelegationOperation, PartialTezosOriginationOperation, PartialTezosRevealOperation } from 'test/types/tezos/PartialTezosOperation';\n                                import { AbortedBeaconError } from 'test/errors/AbortedBeaconError';\n                                import { ExtendedPeerInfo, PeerInfo } from 'test/types/PeerInfo';\n                                import { availableTransports } from 'test/utils/available-transports';\n                                import { AcknowledgeResponse } from 'test/types/beacon/messages/AcknowledgeResponse';\n                                import { DisconnectMessage } from 'test/types/beacon/messages/DisconnectMessage';\n                                import { DappP2PTransport } from 'test/transports/DappP2PTransport';\n                                import { DappPostMessageTransport } from 'test/transports/DappPostMessageTransport';\n                                import { WalletP2PTransport } from 'test/transports/WalletP2PTransport';\n                                import { WalletPostMessageTransport } from 'test/transports/WalletPostMessageTransport';\n                                import { getSenderId } from 'test/utils/get-sender-id';\n                                import { SigningType } from 'test/types/beacon/SigningType';\n                                import { SignatureTypeNotSupportedBeaconError } from 'test/errors/SignatureTypeNotSupportedBeaconError';\n                                import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n                                import { ExtendedPostMessagePairingRequest, PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n                                import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n                                import { PeerManager } from 'test/managers/PeerManager';\n                                import { MessageBasedClient } from 'test/transports/clients/MessageBasedClient';\n                                import { BeaconRequestMessage } from 'test/types/beacon/BeaconRequestMessage';\n                                import { BeaconResponseMessage } from 'test/types/beacon/BeaconResponseMessage';\n                                import { Pairing } from 'test/ui/alert/Pairing';\n                                import { BlockExplorer } from 'test/utils/block-explorer';\n                                import { TezblockBlockExplorer } from 'test/utils/tezblock-blockexplorer';\n                                import { setDebugEnabled, getDebugEnabled } from 'test/debug';\n                                import { ColorMode } from 'test/types/ColorMode';\n                                export { TezosBaseOperation, TezosOperationType, TezosBlockHeader, MichelsonPrimitives, TezosTransactionParameters, TezosOperation };\n                                export { TezosActivateAccountOperation, TezosBallotOperation, TezosDelegationOperation, TezosDoubleBakingEvidenceOperation, TezosDoubleEndorsementEvidenceOperation, TezosEndorsementOperation, TezosOriginationOperation, TezosProposalOperation, TezosRevealOperation, TezosSeedNonceRevelationOperation, TezosTransactionOperation, PartialTezosOperation, PartialTezosTransactionOperation, PartialTezosDelegationOperation, PartialTezosOriginationOperation, PartialTezosRevealOperation };\n                                export { BeaconClient, BeaconClientOptions, Client, ClientOptions, DAppClient, DAppClientOptions, WalletClient, WalletClientOptions, P2PCommunicationClient };\n                                export { AccountIdentifier, AppMetadata, Network, NetworkType, BeaconMessage, PermissionRequest, PermissionResponse, OperationRequest, OperationResponse, SignPayloadRequest, SignPayloadResponse, BroadcastRequest, BroadcastResponse, AcknowledgeResponse, DisconnectMessage, BeaconBaseMessage, BeaconMessageType, PermissionScope, Origin, AccountInfo, Threshold, SigningType, ExtensionMessageTarget, ExtensionMessage, EncryptedExtensionMessage, RequestPermissionInput, RequestSignPayloadInput, RequestOperationInput, RequestBroadcastInput, PermissionInfo };\n                                export { PermissionResponseInput, SignPayloadResponseInput, OperationResponseInput, BroadcastResponseInput, AcknowledgeResponseInput, ErrorResponseInput, PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, PermissionRequestInput, SignPayloadRequestInput, OperationRequestInput, BroadcastRequestInput, PermissionRequestOutput, SignPayloadRequestOutput, OperationRequestOutput, BroadcastRequestOutput, BeaconRequestInputMessage, BeaconRequestOutputMessage, BeaconResponseInputMessage, BeaconResponseOutputMessage, BeaconRequestMessage, BeaconResponseMessage };\n                                export { BeaconError, BeaconErrorType, ErrorResponse, AbortedBeaconError, BroadcastBeaconError, NetworkNotSupportedBeaconError, NoAddressBeaconError, NoPrivateKeyBeaconError, NotGrantedBeaconError, ParametersInvalidBeaconError, TooManyOperationsBeaconError, TransactionInvalidBeaconError, SignatureTypeNotSupportedBeaconError, UnknownBeaconError };\n                                export { TransportStatus, TransportType, Transport, PostMessageTransport, P2PTransport, WalletP2PTransport, WalletPostMessageTransport, DappP2PTransport, DappPostMessageTransport, MessageBasedClient, Pairing };\n                                export { BeaconEvent, BeaconEventHandler, defaultEventCallbacks };\n                                export { Storage, StorageKey, StorageKeyReturnDefaults, StorageKeyReturnType, ChromeStorage, LocalStorage, getStorage };\n                                export { PeerManager, AccountManager, AppMetadataManager, PermissionManager };\n                                export { SDK_VERSION, BEACON_VERSION };\n                                export { getSenderId, getAccountIdentifier, getAddressFromPublicKey };\n                                export { PeerInfo, ExtendedPeerInfo, PostMessagePairingRequest, ExtendedPostMessagePairingRequest, ExtendedPostMessagePairingResponse, P2PPairingRequest, ExtendedP2PPairingRequest, ExtendedP2PPairingResponse };\n                                export { BlockExplorer, TezblockBlockExplorer };\n                                export { ConnectionContext, Serializer, availableTransports, ColorMode };\n                                export { setDebugEnabled, getDebugEnabled };\n                }\n        }\n    \n        module 'test/transports/clients/CommunicationClient' {\n                import * as sodium from 'libsodium-wrappers';\n                import { P2PPairingRequest } from 'test/';\n                import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n                import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n                import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n                export abstract class CommunicationClient {\n                                protected readonly keyPair: sodium.KeyPair;\n                                constructor(keyPair: sodium.KeyPair);\n                                /**\n                                          * Get the public key\n                                          */\n                                getPublicKey(): Promise<string>;\n                                /**\n                                          * get the public key hash\n                                          */\n                                getPublicKeyHash(): Promise<string>;\n                                /**\n                                          * Create a cryptobox shared key\n                                          *\n                                          * @param otherPublicKey\n                                          * @param selfPrivateKey\n                                          */\n                                protected createCryptoBox(otherPublicKey: string, selfPrivateKey: Uint8Array): Promise<[Uint8Array, Uint8Array, Uint8Array]>;\n                                /**\n                                          * Create a cryptobox server\n                                          *\n                                          * @param otherPublicKey\n                                          * @param selfPrivateKey\n                                          */\n                                protected createCryptoBoxServer(otherPublicKey: string, selfPrivateKey: Uint8Array): Promise<sodium.CryptoKX>;\n                                /**\n                                          * Create a cryptobox client\n                                          *\n                                          * @param otherPublicKey\n                                          * @param selfPrivateKey\n                                          */\n                                protected createCryptoBoxClient(otherPublicKey: string, selfPrivateKey: Uint8Array): Promise<sodium.CryptoKX>;\n                                /**\n                                          * Encrypt a message for a specific publicKey (receiver, asymmetric)\n                                          *\n                                          * @param recipientPublicKey\n                                          * @param message\n                                          */\n                                protected encryptMessageAsymmetric(recipientPublicKey: string, message: string): Promise<string>;\n                                abstract unsubscribeFromEncryptedMessages(): Promise<void>;\n                                abstract unsubscribeFromEncryptedMessage(senderPublicKey: string): Promise<void>;\n                                abstract sendMessage(message: string, peer?: P2PPairingRequest | ExtendedP2PPairingResponse | PostMessagePairingRequest | ExtendedPostMessagePairingResponse): Promise<void>;\n                }\n        }\n    \n        module 'test/transports/clients/MessageBasedClient' {\n                import * as sodium from 'libsodium-wrappers';\n                import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n                import { PostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n                import { CommunicationClient } from 'test/transports/clients/CommunicationClient';\n                export abstract class MessageBasedClient extends CommunicationClient {\n                                protected readonly name: string;\n                                /**\n                                          * The listeners that will be notified of new messages\n                                          */\n                                protected abstract readonly activeListeners: Map<string, unknown>;\n                                constructor(name: string, keyPair: sodium.KeyPair);\n                                /**\n                                          * start the client and make sure all dependencies are ready\n                                          */\n                                start(): Promise<void>;\n                                /**\n                                          * Get the pairing request information. This will be shared with the peer during the connection setup\n                                          */\n                                getPairingRequestInfo(): Promise<PostMessagePairingRequest>;\n                                /**\n                                          * Get the pairing response information. This will be shared with the peer during the connection setup\n                                          */\n                                getPairingResponseInfo(request: PostMessagePairingRequest): Promise<PostMessagePairingResponse>;\n                                /**\n                                          * Unsubscribe from encrypted messages from a specific peer\n                                          *\n                                          * @param senderPublicKey\n                                          */\n                                unsubscribeFromEncryptedMessage(senderPublicKey: string): Promise<void>;\n                                /**\n                                          * Unsubscribe from all encrypted messages\n                                          */\n                                unsubscribeFromEncryptedMessages(): Promise<void>;\n                                /**\n                                          * Decrypt a message from a specific peer\n                                          *\n                                          * @param senderPublicKey\n                                          * @param payload\n                                          */\n                                protected decryptMessage(senderPublicKey: string, payload: string): Promise<string>;\n                                /**\n                                          * Encrypt a message for a specific publicKey (receiver)\n                                          *\n                                          * @param recipientPublicKey\n                                          * @param message\n                                          */\n                                protected encryptMessage(recipientPublicKey: string, message: string): Promise<string>;\n                                /**\n                                          * Initialize the connection\n                                          */\n                                abstract init(): Promise<void>;\n                }\n        }\n    \n        module 'test/transports/clients/P2PCommunicationClient' {\n                import * as sodium from 'libsodium-wrappers';\n                import { MatrixClientEvent, MatrixClientEventType, MatrixClientEventMessageContent } from 'test/matrix-client/models/MatrixClientEvent';\n                import { Storage } from 'test/storage/Storage';\n                import { P2PPairingRequest } from 'test/';\n                import { ExtendedP2PPairingResponse, P2PPairingResponse } from 'test/types/P2PPairingResponse';\n                import { CommunicationClient } from 'test/transports/clients/CommunicationClient';\n                export class P2PCommunicationClient extends CommunicationClient {\n                        readonly replicationCount: number;\n                        constructor(name: string, keyPair: sodium.KeyPair, replicationCount: number, storage: Storage, matrixNodes: string[], iconUrl?: string | undefined, appUrl?: string | undefined);\n                        getPairingRequestInfo(): Promise<P2PPairingRequest>;\n                        getPairingResponseInfo(request: P2PPairingRequest): Promise<P2PPairingResponse>;\n                        getRelayServer(publicKeyHash?: string, nonce?: string): Promise<string>;\n                        start(): Promise<void>;\n                        listenForEncryptedMessage(senderPublicKey: string, messageCallback: (message: string) => void): Promise<void>;\n                        unsubscribeFromEncryptedMessage(senderPublicKey: string): Promise<void>;\n                        unsubscribeFromEncryptedMessages(): Promise<void>;\n                        sendMessage(message: string, peer: P2PPairingRequest | ExtendedP2PPairingResponse): Promise<void>;\n                        deleteRoomIdFromRooms(roomId: string): Promise<void>;\n                        listenForChannelOpening(messageCallback: (pairingResponse: ExtendedP2PPairingResponse) => void): Promise<void>;\n                        sendPairingResponse(pairingRequest: P2PPairingRequest): Promise<void>;\n                        isTextMessage(content: MatrixClientEventMessageContent<any>): content is MatrixClientEventMessageContent<string>;\n                        isChannelOpenMessage(content: MatrixClientEventMessageContent<string>): Promise<boolean>;\n                        isSender(event: MatrixClientEvent<MatrixClientEventType.MESSAGE>, senderPublicKey: string): Promise<boolean>;\n                }\n        }\n    \n        module 'test/transports/clients/PostMessageClient' {\n                import { ConnectionContext } from 'test/';\n                import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n                import { EncryptedExtensionMessage } from 'test/types/ExtensionMessage';\n                import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n                import { MessageBasedClient } from 'test/transports/clients/MessageBasedClient';\n                export class PostMessageClient extends MessageBasedClient {\n                        protected readonly activeListeners: Map<string, (message: EncryptedExtensionMessage, context: ConnectionContext) => void>;\n                        init(): Promise<void>;\n                        listenForEncryptedMessage(senderPublicKey: string, messageCallback: (message: string, context: ConnectionContext) => void): Promise<void>;\n                        sendMessage(message: string, peer: PostMessagePairingRequest | ExtendedPostMessagePairingResponse): Promise<void>;\n                        listenForChannelOpening(messageCallback: (pairingResponse: ExtendedPostMessagePairingResponse) => void): Promise<void>;\n                        sendPairingRequest(id: string): Promise<void>;\n                        isChannelOpenMessage(message: any): Promise<boolean>;\n                }\n        }\n    \n        module 'test/transports/DappP2PTransport' {\n                import * as sodium from 'libsodium-wrappers';\n                import { Storage, StorageKey, P2PTransport } from 'test/';\n                import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n                export class DappP2PTransport extends P2PTransport<ExtendedP2PPairingResponse, StorageKey.TRANSPORT_P2P_PEERS_DAPP> {\n                        constructor(name: string, keyPair: sodium.KeyPair, storage: Storage, matrixNodes: string[], iconUrl?: string, appUrl?: string);\n                        startOpenChannelListener(): Promise<void>;\n                        listenForNewPeer(newPeerListener: (peer: ExtendedP2PPairingResponse) => void): Promise<void>;\n                        stopListeningForNewPeers(): Promise<void>;\n                }\n        }\n    \n        module 'test/transports/DappPostMessageTransport' {\n                import * as sodium from 'libsodium-wrappers';\n                import { StorageKey, PostMessageTransport, Storage } from 'test/';\n                import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n                export class DappPostMessageTransport extends PostMessageTransport<ExtendedPostMessagePairingResponse, StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP> {\n                        constructor(name: string, keyPair: sodium.KeyPair, storage: Storage);\n                        startOpenChannelListener(): Promise<void>;\n                        listenForNewPeer(newPeerListener: (peer: ExtendedPostMessagePairingResponse) => void): Promise<void>;\n                        stopListeningForNewPeers(): Promise<void>;\n                }\n        }\n    \n        module 'test/transports/P2PTransport' {\n                import * as sodium from 'libsodium-wrappers';\n                import { Storage, StorageKey, Transport, TransportType, P2PCommunicationClient, P2PPairingRequest } from 'test/';\n                import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n                export class P2PTransport<T extends P2PPairingRequest | ExtendedP2PPairingResponse, K extends StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET> extends Transport<T, K, P2PCommunicationClient> {\n                        readonly type: TransportType;\n                        constructor(name: string, keyPair: sodium.KeyPair, storage: Storage, matrixNodes: string[], storageKey: K, iconUrl?: string, appUrl?: string);\n                        static isAvailable(): Promise<boolean>;\n                        connect(): Promise<void>;\n                        startOpenChannelListener(): Promise<void>;\n                        getPairingRequestInfo(): Promise<P2PPairingRequest>;\n                        listen(publicKey: string): Promise<void>;\n                }\n        }\n    \n        module 'test/transports/PostMessageTransport' {\n                import * as sodium from 'libsodium-wrappers';\n                import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n                import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n                import { Extension } from 'test/types/Extension';\n                import { StorageKey } from 'test/types/storage/StorageKey';\n                import { TransportType } from 'test/types/transport/TransportType';\n                import { Storage } from 'test/storage/Storage';\n                import { PostMessageClient } from 'test/transports/clients/PostMessageClient';\n                import { Transport } from 'test/transports/Transport';\n                export class PostMessageTransport<T extends PostMessagePairingRequest | ExtendedPostMessagePairingResponse, K extends StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET> extends Transport<T, K, PostMessageClient> {\n                        readonly type: TransportType;\n                        constructor(name: string, keyPair: sodium.KeyPair, storage: Storage, storageKey: K);\n                        static isAvailable(): Promise<boolean>;\n                        static getAvailableExtensions(): Promise<Extension[]>;\n                        connect(): Promise<void>;\n                        startOpenChannelListener(): Promise<void>;\n                        getPairingRequestInfo(): Promise<PostMessagePairingRequest>;\n                        listen(publicKey: string): Promise<void>;\n                }\n        }\n    \n        module 'test/transports/Transport' {\n                import { ConnectionContext } from 'test/types/ConnectionContext';\n                import { TransportType, TransportStatus, PeerInfo, StorageKey } from 'test/';\n                import { PeerManager } from 'test/managers/PeerManager';\n                import { CommunicationClient } from 'test/transports/clients/CommunicationClient';\n                export abstract class Transport<T extends PeerInfo = PeerInfo, K extends StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET = any, S extends CommunicationClient = any> {\n                                /**\n                                          * The type of the transport\n                                          */\n                                readonly type: TransportType;\n                                /**\n                                          * The name of the app\n                                          */\n                                protected readonly name: string;\n                                /**\n                                          * The status of the transport\n                                          */\n                                protected _isConnected: TransportStatus;\n                                protected readonly peerManager: PeerManager<K>;\n                                /**\n                                          * The client handling the encryption/decryption of messages\n                                          */\n                                protected client: S;\n                                /**\n                                          * The listener that will be invoked when a new peer is connected\n                                          */\n                                protected newPeerListener?: (peer: T) => void;\n                                /**\n                                          * Return the status of the connection\n                                          */\n                                get connectionStatus(): TransportStatus;\n                                constructor(name: string, client: S, peerManager: PeerManager<K>);\n                                /**\n                                          * Returns a promise that resolves to true if the transport is available, false if it is not\n                                          */\n                                static isAvailable(): Promise<boolean>;\n                                /**\n                                          * Connect the transport\n                                          */\n                                connect(): Promise<void>;\n                                /**\n                                          * Send a message through the transport\n                                          *\n                                          * @param message The message to send\n                                          * @param recipient The recipient of the message\n                                          */\n                                send(message: string, peer?: PeerInfo): Promise<void>;\n                                /**\n                                          * Add a listener to be called when a new message is received\n                                          *\n                                          * @param listener The listener that will be registered\n                                          */\n                                addListener(listener: (message: unknown, connectionInfo: ConnectionContext) => void): Promise<void>;\n                                /**\n                                          * Remove a listener\n                                          *\n                                          * @param listener\n                                          */\n                                removeListener(listener: (message: string, connectionInfo: ConnectionContext) => void): Promise<void>;\n                                getPeers(): Promise<T[]>;\n                                addPeer(newPeer: T): Promise<void>;\n                                removePeer(peerToBeRemoved: T): Promise<void>;\n                                removeAllPeers(): Promise<void>;\n                                /**\n                                          * Notify the listeners when a new message comes in\n                                          *\n                                          * @param message Message\n                                          * @param connectionInfo Context info about the connection\n                                          */\n                                protected notifyListeners(message: unknown, connectionInfo: ConnectionContext): Promise<void>;\n                                abstract listen(publicKey: string): Promise<void>;\n                }\n        }\n    \n        module 'test/transports/WalletP2PTransport' {\n                import * as sodium from 'libsodium-wrappers';\n                import { Storage, StorageKey, P2PTransport, P2PPairingRequest } from 'test/';\n                export class WalletP2PTransport extends P2PTransport<P2PPairingRequest, StorageKey.TRANSPORT_P2P_PEERS_WALLET> {\n                        constructor(name: string, keyPair: sodium.KeyPair, storage: Storage, matrixNodes: string[], iconUrl?: string, appUrl?: string);\n                        addPeer(newPeer: P2PPairingRequest): Promise<void>;\n                }\n        }\n    \n        module 'test/transports/WalletPostMessageTransport' {\n                import * as sodium from 'libsodium-wrappers';\n                import { StorageKey, PostMessageTransport, Storage } from 'test/';\n                import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n                export class WalletPostMessageTransport extends PostMessageTransport<PostMessagePairingRequest, StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET> {\n                        constructor(name: string, keyPair: sodium.KeyPair, storage: Storage);\n                }\n        }\n    \n        module 'test/types/AccountInfo' {\n                import { Origin } from 'test/';\n                import { PermissionEntity } from 'test/types/PermissionEntity';\n                export type AccountIdentifier = string;\n                export interface AccountInfo extends PermissionEntity {\n                        accountIdentifier: AccountIdentifier;\n                        senderId: string;\n                        origin: {\n                                type: Origin;\n                                id: string;\n                        };\n                        publicKey: string;\n                        connectedAt: number;\n                }\n        }\n    \n        module 'test/types/beacon/AppMetadata' {\n                export interface AppMetadata {\n                        senderId: string;\n                        name: string;\n                        icon?: string;\n                }\n        }\n    \n        module 'test/types/beacon/BeaconBaseMessage' {\n                import { BeaconMessageType } from 'test/';\n                export interface BeaconBaseMessage {\n                        type: BeaconMessageType;\n                        version: string;\n                        id: string;\n                        senderId: string;\n                }\n        }\n    \n        module 'test/types/beacon/BeaconMessage' {\n                import { PermissionResponse, PermissionRequest, OperationRequest, OperationResponse, SignPayloadRequest, SignPayloadResponse, BroadcastRequest, BroadcastResponse, AcknowledgeResponse, DisconnectMessage, ErrorResponse } from 'test/';\n                export type BeaconMessage = PermissionRequest | PermissionResponse | OperationRequest | OperationResponse | SignPayloadRequest | SignPayloadResponse | BroadcastRequest | BroadcastResponse | AcknowledgeResponse | DisconnectMessage | ErrorResponse;\n        }\n    \n        module 'test/types/beacon/BeaconMessageType' {\n                export enum BeaconMessageType {\n                        PermissionRequest = \"permission_request\",\n                        SignPayloadRequest = \"sign_payload_request\",\n                        OperationRequest = \"operation_request\",\n                        BroadcastRequest = \"broadcast_request\",\n                        PermissionResponse = \"permission_response\",\n                        SignPayloadResponse = \"sign_payload_response\",\n                        OperationResponse = \"operation_response\",\n                        BroadcastResponse = \"broadcast_response\",\n                        Acknowledge = \"acknowledge\",\n                        Disconnect = \"disconnect\",\n                        Error = \"error\"\n                }\n        }\n    \n        module 'test/types/beacon/BeaconRequestMessage' {\n                import { PermissionRequest, OperationRequest, SignPayloadRequest, BroadcastRequest } from 'test/';\n                export type BeaconRequestMessage = PermissionRequest | OperationRequest | SignPayloadRequest | BroadcastRequest;\n        }\n    \n        module 'test/types/beacon/BeaconResponseMessage' {\n                import { PermissionResponse, OperationResponse, SignPayloadResponse, BroadcastResponse } from 'test/';\n                import { ErrorResponse } from 'test/types/beacon/messages/ErrorResponse';\n                export type BeaconResponseMessage = PermissionResponse | OperationResponse | SignPayloadResponse | BroadcastResponse | ErrorResponse;\n        }\n    \n        module 'test/types/beacon/messages/AcknowledgeResponse' {\n                import { BeaconBaseMessage, BeaconMessageType } from 'test/';\n                export interface AcknowledgeResponse extends BeaconBaseMessage {\n                        type: BeaconMessageType.Acknowledge;\n                }\n        }\n    \n        module 'test/types/beacon/messages/BeaconRequestInputMessage' {\n                import { PermissionRequest, OperationRequest, SignPayloadRequest, BroadcastRequest } from 'test/';\n                export type IgnoredRequestInputProperties = 'id' | 'senderId' | 'version';\n                export type PermissionRequestInput = Omit<PermissionRequest, IgnoredRequestInputProperties>;\n                export type OperationRequestInput = Omit<OperationRequest, IgnoredRequestInputProperties>;\n                export type SignPayloadRequestInput = Omit<SignPayloadRequest, IgnoredRequestInputProperties>;\n                export type BroadcastRequestInput = Omit<BroadcastRequest, IgnoredRequestInputProperties>;\n                export type BeaconRequestInputMessage = PermissionRequestInput | OperationRequestInput | SignPayloadRequestInput | BroadcastRequestInput;\n        }\n    \n        module 'test/types/beacon/messages/BeaconRequestOutputMessage' {\n                import { AppMetadata, PermissionRequest, OperationRequest, SignPayloadRequest, BroadcastRequest } from 'test/';\n                export type IgnoredRequestOutputProperties = 'version';\n                export interface ExtraResponseOutputProperties {\n                        appMetadata: AppMetadata;\n                }\n                export type PermissionRequestOutput = Omit<PermissionRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n                export type OperationRequestOutput = Omit<OperationRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n                export type SignPayloadRequestOutput = Omit<SignPayloadRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n                export type BroadcastRequestOutput = Omit<BroadcastRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n                export type BeaconRequestOutputMessage = PermissionRequestOutput | OperationRequestOutput | SignPayloadRequestOutput | BroadcastRequestOutput;\n        }\n    \n        module 'test/types/beacon/messages/BeaconResponseInputMessage' {\n                import { PermissionResponse, OperationResponse, SignPayloadResponse, BroadcastResponse, AcknowledgeResponse, ErrorResponse } from 'test/';\n                export type IgnoredResponseInputProperties = 'senderId' | 'version' | 'appMetadata';\n                export type PermissionResponseInput = Omit<PermissionResponse, IgnoredResponseInputProperties>;\n                export type OperationResponseInput = Omit<OperationResponse, IgnoredResponseInputProperties>;\n                export type SignPayloadResponseInput = Omit<SignPayloadResponse, IgnoredResponseInputProperties>;\n                export type BroadcastResponseInput = Omit<BroadcastResponse, IgnoredResponseInputProperties>;\n                export type AcknowledgeResponseInput = Omit<AcknowledgeResponse, IgnoredResponseInputProperties>;\n                export type ErrorResponseInput = Omit<ErrorResponse, IgnoredResponseInputProperties>;\n                export type BeaconResponseInputMessage = PermissionResponseInput | OperationResponseInput | SignPayloadResponseInput | BroadcastResponseInput | AcknowledgeResponseInput | ErrorResponseInput;\n        }\n    \n        module 'test/types/beacon/messages/BeaconResponseOutputMessage' {\n                import { PermissionResponse, OperationResponse, SignPayloadResponse, BroadcastResponse, AccountInfo } from 'test/';\n                export type IgnoredResponseOutputProperties = 'id' | 'version' | 'type';\n                export type PermissionResponseOutput = PermissionResponse & {\n                        address: string;\n                        accountInfo: AccountInfo;\n                };\n                export type OperationResponseOutput = OperationResponse;\n                export type SignPayloadResponseOutput = SignPayloadResponse;\n                export type BroadcastResponseOutput = BroadcastResponse;\n                export type BeaconResponseOutputMessage = PermissionResponseOutput | OperationResponseOutput | SignPayloadResponseOutput | BroadcastResponseOutput;\n        }\n    \n        module 'test/types/beacon/messages/BroadcastRequest' {\n                import { BeaconBaseMessage, BeaconMessageType, Network } from 'test/';\n                export interface BroadcastRequest extends BeaconBaseMessage {\n                        type: BeaconMessageType.BroadcastRequest;\n                        network: Network;\n                        signedTransaction: string;\n                }\n        }\n    \n        module 'test/types/beacon/messages/BroadcastResponse' {\n                import { BeaconBaseMessage, BeaconMessageType } from 'test/';\n                export interface BroadcastResponse extends BeaconBaseMessage {\n                        type: BeaconMessageType.BroadcastResponse;\n                        transactionHash: string;\n                }\n        }\n    \n        module 'test/types/beacon/messages/DisconnectMessage' {\n                import { BeaconBaseMessage, BeaconMessageType } from 'test/';\n                export interface DisconnectMessage extends BeaconBaseMessage {\n                        type: BeaconMessageType.Disconnect;\n                }\n        }\n    \n        module 'test/types/beacon/messages/ErrorResponse' {\n                import { BeaconBaseMessage, BeaconErrorType, BeaconMessageType } from 'test/';\n                export interface ErrorResponse extends BeaconBaseMessage {\n                        type: BeaconMessageType.Error;\n                        errorType: BeaconErrorType;\n                        errorData?: any;\n                }\n        }\n    \n        module 'test/types/beacon/messages/OperationRequest' {\n                import { BeaconBaseMessage, BeaconMessageType, Network } from 'test/';\n                import { PartialTezosOperation } from 'test/types/tezos/PartialTezosOperation';\n                export interface OperationRequest extends BeaconBaseMessage {\n                        type: BeaconMessageType.OperationRequest;\n                        network: Network;\n                        operationDetails: PartialTezosOperation[];\n                        sourceAddress: string;\n                }\n        }\n    \n        module 'test/types/beacon/messages/OperationResponse' {\n                import { BeaconBaseMessage, BeaconMessageType } from 'test/';\n                export interface OperationResponse extends BeaconBaseMessage {\n                        type: BeaconMessageType.OperationResponse;\n                        transactionHash: string;\n                }\n        }\n    \n        module 'test/types/beacon/messages/PermissionRequest' {\n                import { BeaconBaseMessage, BeaconMessageType, PermissionScope, AppMetadata, Network } from 'test/';\n                export interface PermissionRequest extends BeaconBaseMessage {\n                        type: BeaconMessageType.PermissionRequest;\n                        appMetadata: AppMetadata;\n                        network: Network;\n                        scopes: PermissionScope[];\n                }\n        }\n    \n        module 'test/types/beacon/messages/PermissionResponse' {\n                import { AppMetadata, BeaconBaseMessage, BeaconMessageType, Network, PermissionScope, Threshold } from 'test/';\n                export interface PermissionResponse extends BeaconBaseMessage {\n                        type: BeaconMessageType.PermissionResponse;\n                        appMetadata: AppMetadata;\n                        publicKey: string;\n                        network: Network;\n                        scopes: PermissionScope[];\n                        threshold?: Threshold;\n                }\n        }\n    \n        module 'test/types/beacon/messages/SignPayloadRequest' {\n                import { BeaconBaseMessage, BeaconMessageType, SigningType } from 'test/';\n                export interface SignPayloadRequest extends BeaconBaseMessage {\n                        type: BeaconMessageType.SignPayloadRequest;\n                        signingType: SigningType;\n                        payload: string;\n                        sourceAddress: string;\n                }\n        }\n    \n        module 'test/types/beacon/messages/SignPayloadResponse' {\n                import { BeaconBaseMessage, BeaconMessageType, SigningType } from 'test/';\n                export interface SignPayloadResponse extends BeaconBaseMessage {\n                        type: BeaconMessageType.SignPayloadResponse;\n                        signingType: SigningType;\n                        signature: string;\n                }\n        }\n    \n        module 'test/types/beacon/Network' {\n                import { NetworkType } from 'test/';\n                export interface Network {\n                        type: NetworkType;\n                        name?: string;\n                        rpcUrl?: string;\n                }\n        }\n    \n        module 'test/types/beacon/NetworkType' {\n                export enum NetworkType {\n                        MAINNET = \"mainnet\",\n                        DELPHINET = \"delphinet\",\n                        EDONET = \"edonet\",\n                        CUSTOM = \"custom\"\n                }\n        }\n    \n        module 'test/types/beacon/PermissionScope' {\n                export enum PermissionScope {\n                        SIGN = \"sign\",\n                        OPERATION_REQUEST = \"operation_request\",\n                        THRESHOLD = \"threshold\"\n                }\n        }\n    \n        module 'test/types/beacon/SigningType' {\n                export enum SigningType {\n                        RAW = \"raw\",\n                        OPERATION = \"operation\",\n                        MICHELINE = \"micheline\"\n                }\n        }\n    \n        module 'test/types/beacon/Threshold' {\n                export interface Threshold {\n                        amount: string;\n                        timeframe: string;\n                }\n        }\n    \n        module 'test/types/BeaconErrorType' {\n                export enum BeaconErrorType {\n                        BROADCAST_ERROR = \"BROADCAST_ERROR\",\n                        NETWORK_NOT_SUPPORTED = \"NETWORK_NOT_SUPPORTED\",\n                        NO_ADDRESS_ERROR = \"NO_ADDRESS_ERROR\",\n                        NO_PRIVATE_KEY_FOUND_ERROR = \"NO_PRIVATE_KEY_FOUND_ERROR\",\n                        NOT_GRANTED_ERROR = \"NOT_GRANTED_ERROR\",\n                        PARAMETERS_INVALID_ERROR = \"PARAMETERS_INVALID_ERROR\",\n                        TOO_MANY_OPERATIONS = \"TOO_MANY_OPERATIONS\",\n                        TRANSACTION_INVALID_ERROR = \"TRANSACTION_INVALID_ERROR\",\n                        SIGNATURE_TYPE_NOT_SUPPORTED = \"SIGNATURE_TYPE_NOT_SUPPORTED\",\n                        ABORTED_ERROR = \"ABORTED_ERROR\",\n                        UNKNOWN_ERROR = \"UNKNOWN_ERROR\"\n                }\n        }\n    \n        module 'test/types/ColorMode' {\n                export enum ColorMode {\n                        LIGHT = \"light\",\n                        DARK = \"dark\"\n                }\n        }\n    \n        module 'test/types/ConnectionContext' {\n                import { Origin } from 'test/';\n                export interface ConnectionContext {\n                        origin: Origin;\n                        id: string;\n                        extras?: {\n                                sender: chrome.runtime.MessageSender;\n                                sendResponse(response?: unknown): void;\n                        };\n                }\n        }\n    \n        module 'test/types/Extension' {\n                export interface Extension {\n                        id: string;\n                        name: string;\n                        shortName?: string;\n                        iconUrl?: string;\n                        color?: string;\n                }\n        }\n    \n        module 'test/types/ExtensionMessage' {\n                import { ExtensionMessageTarget } from 'test/';\n                export interface ExtensionMessage<T, U = unknown> {\n                        target: ExtensionMessageTarget;\n                        targetId?: string;\n                        sender?: U;\n                        payload: T;\n                }\n                export interface EncryptedExtensionMessage<U = unknown> {\n                        target: ExtensionMessageTarget;\n                        targetId?: string;\n                        sender?: U;\n                        encryptedPayload: string;\n                }\n        }\n    \n        module 'test/types/ExtensionMessageTarget' {\n                export enum ExtensionMessageTarget {\n                        BACKGROUND = \"toBackground\",\n                        PAGE = \"toPage\",\n                        EXTENSION = \"toExtension\"\n                }\n        }\n    \n        module 'test/types/Origin' {\n                export enum Origin {\n                        WEBSITE = \"website\",\n                        EXTENSION = \"extension\",\n                        P2P = \"p2p\"\n                }\n        }\n    \n        module 'test/types/P2PPairingRequest' {\n                import { PeerInfo } from 'test/types/PeerInfo';\n                export interface P2PPairingRequest extends PeerInfo {\n                        id: string;\n                        type: 'p2p-pairing-request';\n                        name: string;\n                        publicKey: string;\n                        relayServer: string;\n                        icon?: string;\n                        appUrl?: string;\n                }\n                export type ExtendedP2PPairingRequest = P2PPairingRequest & {\n                        senderId: string;\n                };\n        }\n    \n        module 'test/types/P2PPairingResponse' {\n                import { PeerInfo } from 'test/types/PeerInfo';\n                export interface P2PPairingResponse extends PeerInfo {\n                        id: string;\n                        type: 'p2p-pairing-response';\n                        name: string;\n                        publicKey: string;\n                        relayServer: string;\n                        icon?: string;\n                        appUrl?: string;\n                }\n                export type ExtendedP2PPairingResponse = P2PPairingResponse & {\n                        senderId: string;\n                };\n        }\n    \n        module 'test/types/PeerInfo' {\n                export interface PeerInfo {\n                        name: string;\n                        publicKey: string;\n                        version: string;\n                }\n                export type ExtendedPeerInfo = PeerInfo & {\n                        senderId: string;\n                };\n        }\n    \n        module 'test/types/PermissionEntity' {\n                import { Network, PermissionScope, Threshold } from 'test/';\n                export interface PermissionEntity {\n                        address: string;\n                        network: Network;\n                        scopes: PermissionScope[];\n                        threshold?: Threshold;\n                }\n        }\n    \n        module 'test/types/PermissionInfo' {\n                import { AppMetadata } from 'test/';\n                import { PermissionEntity } from 'test/types/PermissionEntity';\n                export interface PermissionInfo extends PermissionEntity {\n                        accountIdentifier: string;\n                        senderId: string;\n                        appMetadata: AppMetadata;\n                        website: string;\n                        publicKey: string;\n                        connectedAt: number;\n                }\n        }\n    \n        module 'test/types/PostMessagePairingRequest' {\n                import { PeerInfo } from 'test/types/PeerInfo';\n                export interface PostMessagePairingRequest extends PeerInfo {\n                        id: string;\n                        type: 'postmessage-pairing-request';\n                        name: string;\n                        publicKey: string;\n                        icon?: string;\n                        appUrl?: string;\n                }\n                export type ExtendedPostMessagePairingRequest = PostMessagePairingRequest & {\n                        senderId: string;\n                };\n        }\n    \n        module 'test/types/PostMessagePairingResponse' {\n                import { PeerInfo } from 'test/types/PeerInfo';\n                export interface PostMessagePairingResponse extends PeerInfo {\n                        id: string;\n                        type: 'postmessage-pairing-response';\n                        name: string;\n                        publicKey: string;\n                        icon?: string;\n                        appUrl?: string;\n                }\n                export type ExtendedPostMessagePairingResponse = PostMessagePairingResponse & {\n                        senderId: string;\n                        extensionId: string;\n                };\n        }\n    \n        module 'test/types/RequestBroadcastInput' {\n                import { Network } from 'test/';\n                export interface RequestBroadcastInput {\n                        network?: Network;\n                        signedTransaction: string;\n                }\n        }\n    \n        module 'test/types/RequestOperationInput' {\n                import { PartialTezosOperation } from 'test/types/tezos/PartialTezosOperation';\n                export interface RequestOperationInput {\n                        operationDetails: PartialTezosOperation[];\n                }\n        }\n    \n        module 'test/types/RequestPermissionInput' {\n                import { Network, PermissionScope } from 'test/';\n                export interface RequestPermissionInput {\n                        network?: Network;\n                        scopes?: PermissionScope[];\n                }\n        }\n    \n        module 'test/types/RequestSignPayloadInput' {\n                import { SigningType } from 'test/';\n                export interface RequestSignPayloadInput {\n                        signingType?: SigningType;\n                        payload: string;\n                        sourceAddress?: string;\n                }\n        }\n    \n        module 'test/types/storage/StorageKey' {\n                export enum StorageKey {\n                        TRANSPORT_P2P_PEERS_DAPP = \"beacon:communication-peers-dapp\",\n                        TRANSPORT_P2P_PEERS_WALLET = \"beacon:communication-peers-wallet\",\n                        TRANSPORT_POSTMESSAGE_PEERS_DAPP = \"beacon:postmessage-peers-dapp\",\n                        TRANSPORT_POSTMESSAGE_PEERS_WALLET = \"beacon:postmessage-peers-wallet\",\n                        ACCOUNTS = \"beacon:accounts\",\n                        ACTIVE_ACCOUNT = \"beacon:active-account\",\n                        ACTIVE_PEER = \"beacon:active-peer\",\n                        BEACON_SDK_SECRET_SEED = \"beacon:sdk-secret-seed\",\n                        APP_METADATA_LIST = \"beacon:app-metadata-list\",\n                        PERMISSION_LIST = \"beacon:permissions\",\n                        BEACON_SDK_VERSION = \"beacon:sdk_version\",\n                        MATRIX_PRESERVED_STATE = \"beacon:sdk-matrix-preserved-state\",\n                        MATRIX_PEER_ROOM_IDS = \"beacon:matrix-peer-rooms\"\n                }\n        }\n    \n        module 'test/types/storage/StorageKeyReturnDefaults' {\n                import { StorageKey, StorageKeyReturnType } from 'test/';\n                export type StorageKeyReturnDefaults = {\n                        [key in StorageKey]: StorageKeyReturnType[key];\n                };\n                export const defaultValues: StorageKeyReturnDefaults;\n        }\n    \n        module 'test/types/storage/StorageKeyReturnType' {\n                import { StorageKey, AccountInfo, AccountIdentifier, P2PPairingRequest, AppMetadata, PermissionInfo } from 'test/';\n                import { MatrixState } from 'test/matrix-client/MatrixClientStore';\n                import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n                import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n                import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n                export interface StorageKeyReturnType {\n                        [StorageKey.TRANSPORT_P2P_PEERS_DAPP]: P2PPairingRequest[];\n                        [StorageKey.TRANSPORT_P2P_PEERS_WALLET]: ExtendedP2PPairingResponse[];\n                        [StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP]: PostMessagePairingRequest[];\n                        [StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET]: ExtendedPostMessagePairingResponse[];\n                        [StorageKey.ACCOUNTS]: AccountInfo[];\n                        [StorageKey.ACTIVE_ACCOUNT]: AccountIdentifier | undefined;\n                        [StorageKey.ACTIVE_PEER]: string | undefined;\n                        [StorageKey.BEACON_SDK_SECRET_SEED]: string | undefined;\n                        [StorageKey.APP_METADATA_LIST]: AppMetadata[];\n                        [StorageKey.PERMISSION_LIST]: PermissionInfo[];\n                        [StorageKey.BEACON_SDK_VERSION]: string | undefined;\n                        [StorageKey.MATRIX_PRESERVED_STATE]: Partial<MatrixState>;\n                        [StorageKey.MATRIX_PEER_ROOM_IDS]: {\n                                [key: string]: string | undefined;\n                        };\n                }\n        }\n    \n        module 'test/types/tezos/MichelineMichelsonV1Expression' {\n                import { MichelsonPrimitives } from 'test/';\n                export type MichelineMichelsonV1Expression = {\n                        int: string;\n                } | {\n                        string: string;\n                } | {\n                        bytes: string;\n                } | MichelineMichelsonV1Expression[] | {\n                        prim: MichelsonPrimitives;\n                        args?: MichelineMichelsonV1Expression[];\n                        annots?: string[];\n                };\n        }\n    \n        module 'test/types/tezos/MichelsonPrimitives' {\n                export type MichelsonPrimitives = 'ADD' | 'IF_NONE' | 'SWAP' | 'set' | 'nat' | 'CHECK_SIGNATURE' | 'IF_LEFT' | 'LAMBDA' | 'Elt' | 'CREATE_CONTRACT' | 'NEG' | 'big_map' | 'map' | 'or' | 'BLAKE2B' | 'bytes' | 'SHA256' | 'SET_DELEGATE' | 'CONTRACT' | 'LSL' | 'SUB' | 'IMPLICIT_ACCOUNT' | 'PACK' | 'list' | 'PAIR' | 'Right' | 'contract' | 'GT' | 'LEFT' | 'STEPS_TO_QUOTA' | 'storage' | 'TRANSFER_TOKENS' | 'CDR' | 'SLICE' | 'PUSH' | 'False' | 'SHA512' | 'CHAIN_ID' | 'BALANCE' | 'signature' | 'DUG' | 'SELF' | 'EMPTY_BIG_MAP' | 'LSR' | 'OR' | 'XOR' | 'lambda' | 'COMPARE' | 'key' | 'option' | 'Unit' | 'Some' | 'UNPACK' | 'NEQ' | 'INT' | 'pair' | 'AMOUNT' | 'DIP' | 'ABS' | 'ISNAT' | 'EXEC' | 'NOW' | 'LOOP' | 'chain_id' | 'string' | 'MEM' | 'MAP' | 'None' | 'address' | 'CONCAT' | 'EMPTY_SET' | 'MUL' | 'LOOP_LEFT' | 'timestamp' | 'LT' | 'UPDATE' | 'DUP' | 'SOURCE' | 'mutez' | 'SENDER' | 'IF_CONS' | 'RIGHT' | 'CAR' | 'CONS' | 'LE' | 'NONE' | 'IF' | 'SOME' | 'GET' | 'Left' | 'CAST' | 'int' | 'SIZE' | 'key_hash' | 'unit' | 'DROP' | 'EMPTY_MAP' | 'NIL' | 'DIG' | 'APPLY' | 'bool' | 'RENAME' | 'operation' | 'True' | 'FAILWITH' | 'parameter' | 'HASH_KEY' | 'EQ' | 'NOT' | 'UNIT' | 'Pair' | 'ADDRESS' | 'EDIV' | 'CREATE_ACCOUNT' | 'GE' | 'ITER' | 'code' | 'AND';\n        }\n    \n        module 'test/types/tezos/operations/ActivateAccount' {\n                import { TezosBaseOperation, TezosOperationType } from 'test/';\n                export interface TezosActivateAccountOperation extends TezosBaseOperation {\n                        kind: TezosOperationType.ACTIVATE_ACCOUNT;\n                        pkh: string;\n                        secret: string;\n                }\n        }\n    \n        module 'test/types/tezos/operations/Ballot' {\n                import { TezosBaseOperation, TezosOperationType } from 'test/';\n                export interface TezosBallotOperation extends TezosBaseOperation {\n                        kind: TezosOperationType.BALLOT;\n                        source: string;\n                        period: string;\n                        proposal: string;\n                        ballot: 'nay' | 'yay' | 'pass';\n                }\n        }\n    \n        module 'test/types/tezos/operations/Delegation' {\n                import { TezosBaseOperation, TezosOperationType } from 'test/';\n                export interface TezosDelegationOperation extends TezosBaseOperation {\n                        kind: TezosOperationType.DELEGATION;\n                        source: string;\n                        fee: string;\n                        counter: string;\n                        gas_limit: string;\n                        storage_limit: string;\n                        delegate?: string;\n                }\n        }\n    \n        module 'test/types/tezos/operations/DoubleBakingEvidence' {\n                import { TezosBaseOperation, TezosOperationType, TezosBlockHeader } from 'test/';\n                export interface InlinedEndorsement {\n                        branch: string;\n                        operations: InlinedEndorsementContents;\n                        signature?: string;\n                }\n                export interface InlinedEndorsementContents {\n                        kind: 'endorsement';\n                        level: string;\n                }\n                export interface TezosDoubleBakingEvidenceOperation extends TezosBaseOperation {\n                        kind: TezosOperationType.DOUBLE_BAKING_EVIDENCE;\n                        bh1: TezosBlockHeader;\n                        bh2: TezosBlockHeader;\n                }\n        }\n    \n        module 'test/types/tezos/operations/DoubleEndorsementEvidence' {\n                import { TezosBaseOperation, TezosOperationType } from 'test/';\n                export interface InlinedEndorsement {\n                        branch: string;\n                        operations: InlinedEndorsementContents;\n                        signature?: string;\n                }\n                export interface InlinedEndorsementContents {\n                        kind: 'endorsement';\n                        level: string;\n                }\n                export interface TezosDoubleEndorsementEvidenceOperation extends TezosBaseOperation {\n                        kind: TezosOperationType.DOUBLE_ENDORSEMENT_EVIDENCE;\n                        op1: InlinedEndorsement;\n                        op2: InlinedEndorsement;\n                }\n        }\n    \n        module 'test/types/tezos/operations/Endorsement' {\n                import { TezosBaseOperation, TezosOperationType } from 'test/';\n                export interface TezosEndorsementOperation extends TezosBaseOperation {\n                        kind: TezosOperationType.ENDORSEMENT;\n                        level: string;\n                }\n        }\n    \n        module 'test/types/tezos/operations/Origination' {\n                import { TezosBaseOperation, TezosOperationType } from 'test/';\n                export interface TezosOriginationOperation extends TezosBaseOperation {\n                        kind: TezosOperationType.ORIGINATION;\n                        source: string;\n                        fee: string;\n                        counter: string;\n                        gas_limit: string;\n                        storage_limit: string;\n                        balance: string;\n                        delegate?: string;\n                        script: string;\n                }\n        }\n    \n        module 'test/types/tezos/operations/Proposal' {\n                import { TezosBaseOperation, TezosOperationType } from 'test/';\n                export interface TezosProposalOperation extends TezosBaseOperation {\n                        kind: TezosOperationType.PROPOSALS;\n                        period: string;\n                        proposals: string[];\n                }\n        }\n    \n        module 'test/types/tezos/operations/Reveal' {\n                import { TezosBaseOperation, TezosOperationType } from 'test/';\n                export interface TezosRevealOperation extends TezosBaseOperation {\n                        kind: TezosOperationType.REVEAL;\n                        source: string;\n                        fee: string;\n                        counter: string;\n                        gas_limit: string;\n                        storage_limit: string;\n                        public_key: string;\n                }\n        }\n    \n        module 'test/types/tezos/operations/SeedNonceRevelation' {\n                import { TezosBaseOperation, TezosOperationType } from 'test/';\n                export interface TezosSeedNonceRevelationOperation extends TezosBaseOperation {\n                        kind: TezosOperationType.SEED_NONCE_REVELATION;\n                        level: string;\n                        nonce: string;\n                }\n        }\n    \n        module 'test/types/tezos/operations/Transaction' {\n                import { TezosBaseOperation, TezosOperationType, TezosTransactionParameters } from 'test/';\n                export interface TezosTransactionOperation extends TezosBaseOperation {\n                        kind: TezosOperationType.TRANSACTION;\n                        source: string;\n                        fee: string;\n                        counter: string;\n                        gas_limit: string;\n                        storage_limit: string;\n                        amount: string;\n                        destination: string;\n                        parameters?: TezosTransactionParameters;\n                }\n        }\n    \n        module 'test/types/tezos/OperationTypes' {\n                export enum TezosOperationType {\n                        ENDORSEMENT = \"endorsement\",\n                        SEED_NONCE_REVELATION = \"seed_nonce_revelation\",\n                        DOUBLE_ENDORSEMENT_EVIDENCE = \"double_endorsement_evidence\",\n                        DOUBLE_BAKING_EVIDENCE = \"double_baking_evidence\",\n                        ACTIVATE_ACCOUNT = \"activate_account\",\n                        PROPOSALS = \"proposals\",\n                        BALLOT = \"ballot\",\n                        REVEAL = \"reveal\",\n                        TRANSACTION = \"transaction\",\n                        ORIGINATION = \"origination\",\n                        DELEGATION = \"delegation\"\n                }\n        }\n    \n        module 'test/types/tezos/PartialTezosOperation' {\n                import { TezosActivateAccountOperation } from 'test/types/tezos/operations/ActivateAccount';\n                import { TezosBallotOperation } from 'test/types/tezos/operations/Ballot';\n                import { TezosDelegationOperation } from 'test/types/tezos/operations/Delegation';\n                import { TezosDoubleBakingEvidenceOperation } from 'test/types/tezos/operations/DoubleBakingEvidence';\n                import { TezosEndorsementOperation } from 'test/types/tezos/operations/Endorsement';\n                import { TezosOriginationOperation } from 'test/types/tezos/operations/Origination';\n                import { TezosProposalOperation } from 'test/types/tezos/operations/Proposal';\n                import { TezosRevealOperation } from 'test/types/tezos/operations/Reveal';\n                import { TezosSeedNonceRevelationOperation } from 'test/types/tezos/operations/SeedNonceRevelation';\n                import { TezosTransactionOperation } from 'test/types/tezos/operations/Transaction';\n                type omittedProperties = 'source' | 'fee' | 'counter' | 'gas_limit' | 'storage_limit';\n                export type PartialTezosDelegationOperation = Omit<TezosDelegationOperation, omittedProperties>;\n                export type PartialTezosOriginationOperation = Omit<TezosOriginationOperation, omittedProperties>;\n                export type PartialTezosRevealOperation = Omit<TezosRevealOperation, omittedProperties>;\n                export type PartialTezosTransactionOperation = Omit<TezosTransactionOperation, omittedProperties>;\n                export type PartialTezosOperation = TezosActivateAccountOperation | TezosBallotOperation | PartialTezosDelegationOperation | TezosDoubleBakingEvidenceOperation | TezosEndorsementOperation | PartialTezosOriginationOperation | TezosProposalOperation | PartialTezosRevealOperation | TezosSeedNonceRevelationOperation | PartialTezosTransactionOperation;\n                export {};\n        }\n    \n        module 'test/types/tezos/TezosBaseOperation' {\n                import { TezosOperationType } from 'test/';\n                export interface TezosBaseOperation {\n                        kind: TezosOperationType;\n                }\n        }\n    \n        module 'test/types/tezos/TezosBlockHeader' {\n                export interface TezosBlockHeader {\n                        level: number;\n                        proto: number;\n                        predecessor: string;\n                        timestamp: string;\n                        validation_pass: number;\n                        operations_hash: string;\n                        fitness: string[];\n                        context: string;\n                        priority: number;\n                        proof_of_work_nonce: string;\n                        signature: string;\n                }\n        }\n    \n        module 'test/types/tezos/TezosOperation' {\n                import { TezosActivateAccountOperation, TezosBallotOperation, TezosDelegationOperation, TezosDoubleBakingEvidenceOperation, TezosEndorsementOperation, TezosOriginationOperation, TezosProposalOperation, TezosRevealOperation, TezosSeedNonceRevelationOperation, TezosTransactionOperation } from 'test/';\n                export type TezosOperation = TezosActivateAccountOperation | TezosBallotOperation | TezosDelegationOperation | TezosDoubleBakingEvidenceOperation | TezosEndorsementOperation | TezosOriginationOperation | TezosProposalOperation | TezosRevealOperation | TezosSeedNonceRevelationOperation | TezosTransactionOperation;\n        }\n    \n        module 'test/types/tezos/TezosTransactionParameters' {\n                import { MichelineMichelsonV1Expression } from 'test/types/tezos/MichelineMichelsonV1Expression';\n                export interface TezosTransactionParameters {\n                        entrypoint: 'default' | 'root' | 'do' | 'set_delegate' | 'remove_delegate' | string;\n                        value: MichelineMichelsonV1Expression;\n                }\n        }\n    \n        module 'test/types/transport/TransportStatus' {\n                export enum TransportStatus {\n                        NOT_CONNECTED = \"NOT_CONNECTED\",\n                        CONNECTING = \"CONNECTING\",\n                        CONNECTED = \"CONNECTED\"\n                }\n        }\n    \n        module 'test/types/transport/TransportType' {\n                export enum TransportType {\n                        CHROME_MESSAGE = \"chrome_message\",\n                        POST_MESSAGE = \"post_message\",\n                        LEDGER = \"ledger\",\n                        P2P = \"p2p\"\n                }\n        }\n    \n        module 'test/ui/alert/alert-templates' {\n                export const alertTemplates: {\n                        container: string;\n                        default: {\n                                html: string;\n                                css: string;\n                        };\n                        pair: {\n                                html: string;\n                                css: string;\n                        };\n                };\n        }\n    \n        module 'test/ui/alert/Alert' {\n                import { NetworkType } from 'test/';\n                export interface AlertButton {\n                                text: string;\n                                style?: 'solid' | 'outline';\n                                actionCallback?(): Promise<void>;\n                }\n                export interface AlertConfig {\n                                title: string;\n                                body?: string;\n                                timer?: number;\n                                buttons?: AlertButton[];\n                                pairingPayload?: {\n                                                p2pSyncCode: string;\n                                                postmessageSyncCode: string;\n                                                preferredNetwork: NetworkType;\n                                };\n                                closeButtonCallback?(): void;\n                }\n                /**\n                          * Close an alert by ID\n                          *\n                          * @param id ID of alert\n                          */\n                const closeAlert: (id: string) => Promise<void>;\n                /**\n                          * Close all alerts\n                          */\n                const closeAlerts: () => Promise<void>;\n                /**\n                          * Show an alert\n                          *\n                          * @param alertConfig The configuration of the alert\n                          */\n                const openAlert: (alertConfig: AlertConfig) => Promise<string>;\n                export { closeAlert, closeAlerts, openAlert };\n        }\n    \n        module 'test/ui/alert/Pairing' {\n                import { NetworkType } from 'test/';\n                export enum Platform {\n                        DESKTOP = 0,\n                        IOS = 1,\n                        ANDROID = 2\n                }\n                export enum WalletType {\n                        IOS = \"ios\",\n                        ANDROID = \"android\",\n                        EXTENSION = \"extension\",\n                        DESKTOP = \"desktop\",\n                        WEB = \"web\"\n                }\n                export interface AppBase {\n                        name: string;\n                        shortName: string;\n                        color: string;\n                        logo: string;\n                }\n                export interface ExtensionApp extends AppBase {\n                        id: string;\n                        link: string;\n                }\n                export interface WebApp extends AppBase {\n                        links: {\n                                [NetworkType.MAINNET]: string;\n                                [NetworkType.DELPHINET]?: string;\n                                [NetworkType.EDONET]?: string;\n                                [NetworkType.CUSTOM]?: string;\n                        };\n                }\n                export interface DesktopApp extends AppBase {\n                        deepLink: string;\n                }\n                export interface App extends AppBase {\n                        universalLink: string;\n                        deepLink?: string;\n                }\n                export interface PairingAlertWallet {\n                        name: string;\n                        shortName?: string;\n                        color?: string;\n                        logo?: string;\n                        enabled: boolean;\n                        clickHandler(): void;\n                }\n                export interface PairingAlertButton {\n                        title: string;\n                        text: string;\n                        clickHandler(): void;\n                }\n                export interface PairingAlertList {\n                        title: string;\n                        type: WalletType;\n                        wallets: PairingAlertWallet[];\n                }\n                export interface PairingAlertInfo {\n                        walletLists: PairingAlertList[];\n                        buttons: PairingAlertButton[];\n                        qrData: string;\n                }\n                export type StatusUpdateHandler = (walletType: WalletType, app?: PairingAlertWallet) => void;\n                export class Pairing {\n                        static getPlatfrom(): Promise<Platform>;\n                        static getPairingInfo(pairingPayload: {\n                                p2pSyncCode: string;\n                                postmessageSyncCode: string;\n                                preferredNetwork: NetworkType;\n                        }, statusUpdateHandler: StatusUpdateHandler, platform?: Platform): Promise<PairingAlertInfo>;\n                }\n        }\n    \n        module 'test/ui/alert/PairingAlert' {\n                import { NetworkType } from 'test/';\n                export const preparePairingAlert: (shadowRoot: ShadowRoot, pairingPayload: {\n                        p2pSyncCode: string;\n                        postmessageSyncCode: string;\n                        preferredNetwork: NetworkType;\n                }) => Promise<void>;\n        }\n    \n        module 'test/ui/alert/wallet-lists' {\n                import { App, DesktopApp, ExtensionApp, WebApp } from 'test/ui/alert/Pairing';\n                export const extensionList: ExtensionApp[];\n                export const desktopList: DesktopApp[];\n                export const webList: WebApp[];\n                export const iOSList: App[];\n        }\n    \n        module 'test/ui/toast/toast-templates' {\n                export const toastTemplates: {\n                        default: {\n                                html: string;\n                                css: string;\n                                poweredByBeacon: string;\n                        };\n                };\n        }\n    \n        module 'test/ui/toast/Toast' {\n                import { WalletInfo } from 'test/events';\n                export interface ToastAction {\n                                text: string;\n                                actionText?: string;\n                                actionCallback?(): Promise<void>;\n                }\n                export interface ToastConfig {\n                                body: string;\n                                timer?: number;\n                                forceNew?: boolean;\n                                state: 'loading' | 'acknowledge' | 'finished';\n                                actions?: ToastAction[];\n                                walletInfo?: WalletInfo;\n                }\n                /**\n                          * Close a toast\n                          */\n                const closeToast: () => Promise<void>;\n                /**\n                          * Create a new toast\n                          *\n                          * @param toastConfig Configuration of the toast\n                          */\n                const openToast: (toastConfig: ToastConfig) => Promise<void>;\n                export { closeToast, openToast };\n        }\n    \n        module 'test/utils/assert-never' {\n                /**\n                      * A helper function to make sure if/elses and switch/cases are exhaustive\n                      *\n                      * @param empty The data that has to be empty\n                      */\n                export function assertNever(empty: never): never;\n        }\n    \n        module 'test/utils/available-transports' {\n                /**\n                      * An object with promises to indicate whether or not that transport is available.\n                      */\n                export const availableTransports: {\n                        extension: Promise<boolean>;\n                        availableExtensions: Promise<import(\"beacon/types/Extension\").Extension[]>;\n                };\n        }\n    \n        module 'test/utils/block-explorer' {\n                import { Network, NetworkType } from 'test/';\n                export abstract class BlockExplorer {\n                                readonly rpcUrls: {\n                                                [key in NetworkType]: string;\n                                };\n                                constructor(rpcUrls: {\n                                                [key in NetworkType]: string;\n                                });\n                                protected getLinkForNetwork(network: Network): Promise<string>;\n                                /**\n                                          * Return a blockexplorer link for an address\n                                          *\n                                          * @param address The address to be opened\n                                          * @param network The network that was used\n                                          */\n                                abstract getAddressLink(address: string, network: Network): Promise<string>;\n                                /**\n                                          * Return a blockexplorer link for a transaction hash\n                                          *\n                                          * @param transactionId The hash of the transaction\n                                          * @param network The network that was used\n                                          */\n                                abstract getTransactionLink(transactionId: string, network: Network): Promise<string>;\n                }\n        }\n    \n        module 'test/utils/crypto' {\n                import * as sodium from 'libsodium-wrappers';\n                /**\n                          * Convert a value to hex\n                          *\n                          * @param value\n                          */\n                export function toHex(value: any): string;\n                /**\n                          * Get the hex hash of a value\n                          *\n                          * @param key\n                          */\n                export function getHexHash(key: string | Buffer | Uint8Array): Promise<string>;\n                /**\n                          * Get a keypair from a seed\n                          *\n                          * @param seed\n                          */\n                export function getKeypairFromSeed(seed: string): Promise<sodium.KeyPair>;\n                /**\n                          * Encrypt a message with a shared key\n                          *\n                          * @param message\n                          * @param sharedKey\n                          */\n                export function encryptCryptoboxPayload(message: string, sharedKey: Uint8Array): Promise<string>;\n                /**\n                          * Decrypt a message with a shared key\n                          *\n                          * @param payload\n                          * @param sharedKey\n                          */\n                export function decryptCryptoboxPayload(payload: Uint8Array, sharedKey: Uint8Array): Promise<string>;\n                /**\n                          * Encrypt a message with a public key\n                          *\n                          * @param payload\n                          * @param publicKey\n                          */\n                export function sealCryptobox(payload: string | Buffer, publicKey: Uint8Array): Promise<string>;\n                /**\n                          * Decrypt a message with public + private key\n                          *\n                          * @param encryptedPayload\n                          * @param publicKey\n                          * @param privateKey\n                          */\n                export function openCryptobox(encryptedPayload: string | Buffer, publicKey: Uint8Array, privateKey: Uint8Array): Promise<string>;\n                /**\n                          * Get an address from the public key\n                          *\n                          * @param publicKey\n                          */\n                export function getAddressFromPublicKey(publicKey: string): Promise<string>;\n                /**\n                          * Get the recipient string used in the matrix message\n                          *\n                          * @param recipientHash\n                          * @param relayServer\n                          */\n                export function recipientString(recipientHash: string, relayServer: string): string;\n        }\n    \n        module 'test/utils/exposed-promise' {\n                export enum ExposedPromiseStatus {\n                        PENDING = \"pending\",\n                        RESOLVED = \"resolved\",\n                        REJECTED = \"rejected\"\n                }\n                type Resolve<T> = (value?: T) => void;\n                type Reject<U> = (reason?: U) => void;\n                /**\n                      * Exposed promise allow you to create a promise and then resolve it later, from the outside\n                      */\n                export class ExposedPromise<T = unknown, U = unknown> {\n                        get promise(): Promise<T>;\n                        get resolve(): Resolve<T>;\n                        get reject(): Reject<U>;\n                        get status(): ExposedPromiseStatus;\n                        get promiseResult(): T | undefined;\n                        get promiseError(): U | undefined;\n                        constructor();\n                        static resolve<T>(value?: T): ExposedPromise<T>;\n                        static reject<T = never, U = unknown>(reason?: U): ExposedPromise<T, U>;\n                        isPending(): boolean;\n                        isResolved(): boolean;\n                        isRejected(): boolean;\n                        isSettled(): boolean;\n                }\n                export {};\n        }\n    \n        module 'test/utils/generate-uuid' {\n                /**\n                      * Generate a random GUID\n                      */\n                export function generateGUID(): Promise<string>;\n        }\n    \n        module 'test/utils/get-account-identifier' {\n                import { Network } from 'test/';\n                /**\n                      * Generate a deterministic account identifier based on an address and a network\n                      *\n                      * @param address\n                      * @param network\n                      */\n                export const getAccountIdentifier: (address: string, network: Network) => Promise<string>;\n        }\n    \n        module 'test/utils/get-sender-id' {\n                /**\n                      * Generate a deterministic sender identifier based on a public key\n                      *\n                      * @param publicKey\n                      */\n                export const getSenderId: (publicKey: string) => Promise<string>;\n        }\n    \n        module 'test/utils/get-tzip10-link' {\n                export const getTzip10Link: (url: string, payload: string) => string;\n        }\n    \n        module 'test/utils/Logger' {\n                /**\n                      * The logger that is used internally\n                      */\n                export class Logger {\n                        constructor(service: string);\n                        debug(method: string, ...args: any[]): void;\n                        log(method: string, ...args: any[]): void;\n                        warn(method: string, ...args: any[]): void;\n                        error(method: string, ...args: any[]): void;\n                }\n        }\n    \n        module 'test/utils/platform' {\n                export const testUserAgent: (win: Window, expr: RegExp) => boolean;\n                export const isMobile: (win: Window) => boolean;\n                export const isIOS: (win: Window) => boolean;\n                export const isAndroid: (win: Window) => boolean;\n                export const isDesktop: (win: Window) => boolean;\n        }\n    \n        module 'test/utils/qr' {\n                /**\n                      * Convert data to a QR code\n                      *\n                      * @param payload The data to be encoded as a QR code\n                      * @param type How the QR code will be encoded\n                      */\n                export const getQrData: (payload: string, type?: \"data\" | \"svg\" | \"ascii\" | undefined) => string;\n        }\n    \n        module 'test/utils/replace-in-template' {\n                export const replaceInTemplate: (text: string, placeholder: string, value: string) => string;\n        }\n    \n        module 'test/utils/shorten-string' {\n                export const shortenString: (text: string) => string;\n        }\n    \n        module 'test/utils/tezblock-blockexplorer' {\n                import { Network, NetworkType } from 'test/';\n                import { BlockExplorer } from 'test/utils/block-explorer';\n                export class TezblockBlockExplorer extends BlockExplorer {\n                        readonly rpcUrls: {\n                                [key in NetworkType]: string;\n                        };\n                        constructor(rpcUrls?: {\n                                [key in NetworkType]: string;\n                        });\n                        getAddressLink(address: string, network: Network): Promise<string>;\n                        getTransactionLink(transactionId: string, network: Network): Promise<string>;\n                }\n        }\n    \n        module 'test/utils/utils' {\n                /**\n                      * A helper function to improve typings of object keys\n                      *\n                      * @param obj Object\n                      */\n                export function keys<O extends object>(obj: O): (keyof O)[];\n        }\n    \n        module 'test/' {\n                import { P2PCommunicationClient } from 'test/transports/clients/P2PCommunicationClient';\n                import { AppMetadata } from 'test/types/beacon/AppMetadata';\n                import { PermissionRequest } from 'test/types/beacon/messages/PermissionRequest';\n                import { Network } from 'test/types/beacon/Network';\n                import { BeaconBaseMessage } from 'test/types/beacon/BeaconBaseMessage';\n                import { BeaconMessageType } from 'test/types/beacon/BeaconMessageType';\n                import { PermissionScope } from 'test/types/beacon/PermissionScope';\n                import { PermissionResponse } from 'test/types/beacon/messages/PermissionResponse';\n                import { OperationRequest } from 'test/types/beacon/messages/OperationRequest';\n                import { OperationResponse } from 'test/types/beacon/messages/OperationResponse';\n                import { SignPayloadRequest } from 'test/types/beacon/messages/SignPayloadRequest';\n                import { SignPayloadResponse } from 'test/types/beacon/messages/SignPayloadResponse';\n                import { BroadcastRequest } from 'test/types/beacon/messages/BroadcastRequest';\n                import { BroadcastResponse } from 'test/types/beacon/messages/BroadcastResponse';\n                import { NetworkType } from 'test/types/beacon/NetworkType';\n                import { TezosBaseOperation } from 'test/types/tezos/TezosBaseOperation';\n                import { TezosOperationType } from 'test/types/tezos/OperationTypes';\n                import { TezosActivateAccountOperation } from 'test/types/tezos/operations/ActivateAccount';\n                import { TezosBallotOperation } from 'test/types/tezos/operations/Ballot';\n                import { TezosDelegationOperation } from 'test/types/tezos/operations/Delegation';\n                import { TezosDoubleBakingEvidenceOperation } from 'test/types/tezos/operations/DoubleBakingEvidence';\n                import { TezosBlockHeader } from 'test/types/tezos/TezosBlockHeader';\n                import { TezosDoubleEndorsementEvidenceOperation } from 'test/types/tezos/operations/DoubleEndorsementEvidence';\n                import { TezosEndorsementOperation } from 'test/types/tezos/operations/Endorsement';\n                import { TezosOriginationOperation } from 'test/types/tezos/operations/Origination';\n                import { TezosProposalOperation } from 'test/types/tezos/operations/Proposal';\n                import { TezosRevealOperation } from 'test/types/tezos/operations/Reveal';\n                import { TezosSeedNonceRevelationOperation } from 'test/types/tezos/operations/SeedNonceRevelation';\n                import { TezosTransactionOperation } from 'test/types/tezos/operations/Transaction';\n                import { MichelsonPrimitives } from 'test/types/tezos/MichelsonPrimitives';\n                import { TezosTransactionParameters } from 'test/types/tezos/TezosTransactionParameters';\n                import { Origin } from 'test/types/Origin';\n                import { AccountInfo, AccountIdentifier } from 'test/types/AccountInfo';\n                import { EncryptedExtensionMessage, ExtensionMessage } from 'test/types/ExtensionMessage';\n                import { ExtensionMessageTarget } from 'test/types/ExtensionMessageTarget';\n                import { TezosOperation } from 'test/types/tezos/TezosOperation';\n                import { Client } from 'test/clients/client/Client';\n                import { WalletClient } from 'test/clients/wallet-client/WalletClient';\n                import { DAppClient } from 'test/clients/dapp-client/DAppClient';\n                import { BeaconError } from 'test/errors/BeaconError';\n                import { BeaconErrorType } from 'test/types/BeaconErrorType';\n                import { BroadcastBeaconError } from 'test/errors/BroadcastBeaconError';\n                import { NetworkNotSupportedBeaconError } from 'test/errors/NetworkNotSupportedBeaconError';\n                import { NoAddressBeaconError } from 'test/errors/NoAddressBeaconError';\n                import { NoPrivateKeyBeaconError } from 'test/errors/NoPrivateKeyBeaconError';\n                import { NotGrantedBeaconError } from 'test/errors/NotGrantedBeaconError';\n                import { ParametersInvalidBeaconError } from 'test/errors/ParametersInvalidBeaconError';\n                import { TooManyOperationsBeaconError } from 'test/errors/TooManyOperationsBeaconError';\n                import { TransactionInvalidBeaconError } from 'test/errors/TransactionInvalidBeaconError';\n                import { UnknownBeaconError } from 'test/errors/UnknownBeaconError';\n                import { ErrorResponse } from 'test/types/beacon/messages/ErrorResponse';\n                import { TransportStatus } from 'test/types/transport/TransportStatus';\n                import { TransportType } from 'test/types/transport/TransportType';\n                import { PostMessageTransport } from 'test/transports/PostMessageTransport';\n                import { Transport } from 'test/transports/Transport';\n                import { P2PTransport } from 'test/transports/P2PTransport';\n                import { Storage } from 'test/storage/Storage';\n                import { StorageKey } from 'test/types/storage/StorageKey';\n                import { StorageKeyReturnDefaults } from 'test/types/storage/StorageKeyReturnDefaults';\n                import { StorageKeyReturnType } from 'test/types/storage/StorageKeyReturnType';\n                import { ExtendedP2PPairingRequest, P2PPairingRequest } from 'test/types/P2PPairingRequest';\n                import { ChromeStorage } from 'test/storage/ChromeStorage';\n                import { LocalStorage } from 'test/storage/LocalStorage';\n                import { getStorage } from 'test/storage/getStorage';\n                import { BeaconMessage } from 'test/types/beacon/BeaconMessage';\n                import { Serializer } from 'test/Serializer';\n                import { RequestPermissionInput } from 'test/types/RequestPermissionInput';\n                import { RequestSignPayloadInput } from 'test/types/RequestSignPayloadInput';\n                import { RequestOperationInput } from 'test/types/RequestOperationInput';\n                import { RequestBroadcastInput } from 'test/types/RequestBroadcastInput';\n                import { PermissionResponseInput, SignPayloadResponseInput, OperationResponseInput, BroadcastResponseInput, BeaconResponseInputMessage, AcknowledgeResponseInput, ErrorResponseInput } from 'test/types/beacon/messages/BeaconResponseInputMessage';\n                import { PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, BeaconResponseOutputMessage } from 'test/types/beacon/messages/BeaconResponseOutputMessage';\n                import { PermissionRequestInput, SignPayloadRequestInput, OperationRequestInput, BroadcastRequestInput, BeaconRequestInputMessage } from 'test/types/beacon/messages/BeaconRequestInputMessage';\n                import { PermissionRequestOutput, SignPayloadRequestOutput, OperationRequestOutput, BroadcastRequestOutput, BeaconRequestOutputMessage } from 'test/types/beacon/messages/BeaconRequestOutputMessage';\n                import { ClientOptions } from 'test/clients/client/ClientOptions';\n                import { DAppClientOptions } from 'test/clients/dapp-client/DAppClientOptions';\n                import { WalletClientOptions } from 'test/clients/wallet-client/WalletClientOptions';\n                import { PermissionInfo } from 'test/types/PermissionInfo';\n                import { SDK_VERSION, BEACON_VERSION } from 'test/constants';\n                import { AccountManager } from 'test/managers/AccountManager';\n                import { AppMetadataManager } from 'test/managers/AppMetadataManager';\n                import { PermissionManager } from 'test/managers/PermissionManager';\n                import { BeaconEvent, BeaconEventHandler, defaultEventCallbacks } from 'test/events';\n                import { getAddressFromPublicKey } from 'test/utils/crypto';\n                import { BeaconClient } from 'test/clients/beacon-client/BeaconClient';\n                import { BeaconClientOptions } from 'test/clients/beacon-client/BeaconClientOptions';\n                import { getAccountIdentifier } from 'test/utils/get-account-identifier';\n                import { ConnectionContext } from 'test/types/ConnectionContext';\n                import { Threshold } from 'test/types/beacon/Threshold';\n                import { PartialTezosTransactionOperation, PartialTezosOperation, PartialTezosDelegationOperation, PartialTezosOriginationOperation, PartialTezosRevealOperation } from 'test/types/tezos/PartialTezosOperation';\n                import { AbortedBeaconError } from 'test/errors/AbortedBeaconError';\n                import { ExtendedPeerInfo, PeerInfo } from 'test/types/PeerInfo';\n                import { availableTransports } from 'test/utils/available-transports';\n                import { AcknowledgeResponse } from 'test/types/beacon/messages/AcknowledgeResponse';\n                import { DisconnectMessage } from 'test/types/beacon/messages/DisconnectMessage';\n                import { DappP2PTransport } from 'test/transports/DappP2PTransport';\n                import { DappPostMessageTransport } from 'test/transports/DappPostMessageTransport';\n                import { WalletP2PTransport } from 'test/transports/WalletP2PTransport';\n                import { WalletPostMessageTransport } from 'test/transports/WalletPostMessageTransport';\n                import { getSenderId } from 'test/utils/get-sender-id';\n                import { SigningType } from 'test/types/beacon/SigningType';\n                import { SignatureTypeNotSupportedBeaconError } from 'test/errors/SignatureTypeNotSupportedBeaconError';\n                import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n                import { ExtendedPostMessagePairingRequest, PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n                import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n                import { PeerManager } from 'test/managers/PeerManager';\n                import { MessageBasedClient } from 'test/transports/clients/MessageBasedClient';\n                import { BeaconRequestMessage } from 'test/types/beacon/BeaconRequestMessage';\n                import { BeaconResponseMessage } from 'test/types/beacon/BeaconResponseMessage';\n                import { Pairing } from 'test/ui/alert/Pairing';\n                import { BlockExplorer } from 'test/utils/block-explorer';\n                import { TezblockBlockExplorer } from 'test/utils/tezblock-blockexplorer';\n                import { setDebugEnabled, getDebugEnabled } from 'test/debug';\n                import { ColorMode } from 'test/types/ColorMode';\n                export { TezosBaseOperation, TezosOperationType, TezosBlockHeader, MichelsonPrimitives, TezosTransactionParameters, TezosOperation };\n                export { TezosActivateAccountOperation, TezosBallotOperation, TezosDelegationOperation, TezosDoubleBakingEvidenceOperation, TezosDoubleEndorsementEvidenceOperation, TezosEndorsementOperation, TezosOriginationOperation, TezosProposalOperation, TezosRevealOperation, TezosSeedNonceRevelationOperation, TezosTransactionOperation, PartialTezosOperation, PartialTezosTransactionOperation, PartialTezosDelegationOperation, PartialTezosOriginationOperation, PartialTezosRevealOperation };\n                export { BeaconClient, BeaconClientOptions, Client, ClientOptions, DAppClient, DAppClientOptions, WalletClient, WalletClientOptions, P2PCommunicationClient };\n                export { AccountIdentifier, AppMetadata, Network, NetworkType, BeaconMessage, PermissionRequest, PermissionResponse, OperationRequest, OperationResponse, SignPayloadRequest, SignPayloadResponse, BroadcastRequest, BroadcastResponse, AcknowledgeResponse, DisconnectMessage, BeaconBaseMessage, BeaconMessageType, PermissionScope, Origin, AccountInfo, Threshold, SigningType, ExtensionMessageTarget, ExtensionMessage, EncryptedExtensionMessage, RequestPermissionInput, RequestSignPayloadInput, RequestOperationInput, RequestBroadcastInput, PermissionInfo };\n                export { PermissionResponseInput, SignPayloadResponseInput, OperationResponseInput, BroadcastResponseInput, AcknowledgeResponseInput, ErrorResponseInput, PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, PermissionRequestInput, SignPayloadRequestInput, OperationRequestInput, BroadcastRequestInput, PermissionRequestOutput, SignPayloadRequestOutput, OperationRequestOutput, BroadcastRequestOutput, BeaconRequestInputMessage, BeaconRequestOutputMessage, BeaconResponseInputMessage, BeaconResponseOutputMessage, BeaconRequestMessage, BeaconResponseMessage };\n                export { BeaconError, BeaconErrorType, ErrorResponse, AbortedBeaconError, BroadcastBeaconError, NetworkNotSupportedBeaconError, NoAddressBeaconError, NoPrivateKeyBeaconError, NotGrantedBeaconError, ParametersInvalidBeaconError, TooManyOperationsBeaconError, TransactionInvalidBeaconError, SignatureTypeNotSupportedBeaconError, UnknownBeaconError };\n                export { TransportStatus, TransportType, Transport, PostMessageTransport, P2PTransport, WalletP2PTransport, WalletPostMessageTransport, DappP2PTransport, DappPostMessageTransport, MessageBasedClient, Pairing };\n                export { BeaconEvent, BeaconEventHandler, defaultEventCallbacks };\n                export { Storage, StorageKey, StorageKeyReturnDefaults, StorageKeyReturnType, ChromeStorage, LocalStorage, getStorage };\n                export { PeerManager, AccountManager, AppMetadataManager, PermissionManager };\n                export { SDK_VERSION, BEACON_VERSION };\n                export { getSenderId, getAccountIdentifier, getAddressFromPublicKey };\n                export { PeerInfo, ExtendedPeerInfo, PostMessagePairingRequest, ExtendedPostMessagePairingRequest, ExtendedPostMessagePairingResponse, P2PPairingRequest, ExtendedP2PPairingRequest, ExtendedP2PPairingResponse };\n                export { BlockExplorer, TezblockBlockExplorer };\n                export { ConnectionContext, Serializer, availableTransports, ColorMode };\n                export { setDebugEnabled, getDebugEnabled };\n        }\n    }\n    \n    module 'test/transports/clients/CommunicationClient' {\n        import * as sodium from 'libsodium-wrappers';\n        import { P2PPairingRequest } from 'test/';\n        import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n        import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n        import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n        export abstract class CommunicationClient {\n                protected readonly keyPair: sodium.KeyPair;\n                constructor(keyPair: sodium.KeyPair);\n                /**\n                     * Get the public key\n                     */\n                getPublicKey(): Promise<string>;\n                /**\n                     * get the public key hash\n                     */\n                getPublicKeyHash(): Promise<string>;\n                /**\n                     * Create a cryptobox shared key\n                     *\n                     * @param otherPublicKey\n                     * @param selfPrivateKey\n                     */\n                protected createCryptoBox(otherPublicKey: string, selfPrivateKey: Uint8Array): Promise<[Uint8Array, Uint8Array, Uint8Array]>;\n                /**\n                     * Create a cryptobox server\n                     *\n                     * @param otherPublicKey\n                     * @param selfPrivateKey\n                     */\n                protected createCryptoBoxServer(otherPublicKey: string, selfPrivateKey: Uint8Array): Promise<sodium.CryptoKX>;\n                /**\n                     * Create a cryptobox client\n                     *\n                     * @param otherPublicKey\n                     * @param selfPrivateKey\n                     */\n                protected createCryptoBoxClient(otherPublicKey: string, selfPrivateKey: Uint8Array): Promise<sodium.CryptoKX>;\n                /**\n                     * Encrypt a message for a specific publicKey (receiver, asymmetric)\n                     *\n                     * @param recipientPublicKey\n                     * @param message\n                     */\n                protected encryptMessageAsymmetric(recipientPublicKey: string, message: string): Promise<string>;\n                abstract unsubscribeFromEncryptedMessages(): Promise<void>;\n                abstract unsubscribeFromEncryptedMessage(senderPublicKey: string): Promise<void>;\n                abstract sendMessage(message: string, peer?: P2PPairingRequest | ExtendedP2PPairingResponse | PostMessagePairingRequest | ExtendedPostMessagePairingResponse): Promise<void>;\n        }\n    }\n    \n    module 'test/transports/clients/MessageBasedClient' {\n        import * as sodium from 'libsodium-wrappers';\n        import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n        import { PostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n        import { CommunicationClient } from 'test/transports/clients/CommunicationClient';\n        export abstract class MessageBasedClient extends CommunicationClient {\n                protected readonly name: string;\n                /**\n                     * The listeners that will be notified of new messages\n                     */\n                protected abstract readonly activeListeners: Map<string, unknown>;\n                constructor(name: string, keyPair: sodium.KeyPair);\n                /**\n                     * start the client and make sure all dependencies are ready\n                     */\n                start(): Promise<void>;\n                /**\n                     * Get the pairing request information. This will be shared with the peer during the connection setup\n                     */\n                getPairingRequestInfo(): Promise<PostMessagePairingRequest>;\n                /**\n                     * Get the pairing response information. This will be shared with the peer during the connection setup\n                     */\n                getPairingResponseInfo(request: PostMessagePairingRequest): Promise<PostMessagePairingResponse>;\n                /**\n                     * Unsubscribe from encrypted messages from a specific peer\n                     *\n                     * @param senderPublicKey\n                     */\n                unsubscribeFromEncryptedMessage(senderPublicKey: string): Promise<void>;\n                /**\n                     * Unsubscribe from all encrypted messages\n                     */\n                unsubscribeFromEncryptedMessages(): Promise<void>;\n                /**\n                     * Decrypt a message from a specific peer\n                     *\n                     * @param senderPublicKey\n                     * @param payload\n                     */\n                protected decryptMessage(senderPublicKey: string, payload: string): Promise<string>;\n                /**\n                     * Encrypt a message for a specific publicKey (receiver)\n                     *\n                     * @param recipientPublicKey\n                     * @param message\n                     */\n                protected encryptMessage(recipientPublicKey: string, message: string): Promise<string>;\n                /**\n                     * Initialize the connection\n                     */\n                abstract init(): Promise<void>;\n        }\n    }\n    \n    module 'test/transports/clients/P2PCommunicationClient' {\n        import * as sodium from 'libsodium-wrappers';\n        import { MatrixClientEvent, MatrixClientEventType, MatrixClientEventMessageContent } from 'test/matrix-client/models/MatrixClientEvent';\n        import { Storage } from 'test/storage/Storage';\n        import { P2PPairingRequest } from 'test/';\n        import { ExtendedP2PPairingResponse, P2PPairingResponse } from 'test/types/P2PPairingResponse';\n        import { CommunicationClient } from 'test/transports/clients/CommunicationClient';\n        export class P2PCommunicationClient extends CommunicationClient {\n            readonly replicationCount: number;\n            constructor(name: string, keyPair: sodium.KeyPair, replicationCount: number, storage: Storage, matrixNodes: string[], iconUrl?: string | undefined, appUrl?: string | undefined);\n            getPairingRequestInfo(): Promise<P2PPairingRequest>;\n            getPairingResponseInfo(request: P2PPairingRequest): Promise<P2PPairingResponse>;\n            getRelayServer(publicKeyHash?: string, nonce?: string): Promise<string>;\n            start(): Promise<void>;\n            listenForEncryptedMessage(senderPublicKey: string, messageCallback: (message: string) => void): Promise<void>;\n            unsubscribeFromEncryptedMessage(senderPublicKey: string): Promise<void>;\n            unsubscribeFromEncryptedMessages(): Promise<void>;\n            sendMessage(message: string, peer: P2PPairingRequest | ExtendedP2PPairingResponse): Promise<void>;\n            deleteRoomIdFromRooms(roomId: string): Promise<void>;\n            listenForChannelOpening(messageCallback: (pairingResponse: ExtendedP2PPairingResponse) => void): Promise<void>;\n            sendPairingResponse(pairingRequest: P2PPairingRequest): Promise<void>;\n            isTextMessage(content: MatrixClientEventMessageContent<any>): content is MatrixClientEventMessageContent<string>;\n            isChannelOpenMessage(content: MatrixClientEventMessageContent<string>): Promise<boolean>;\n            isSender(event: MatrixClientEvent<MatrixClientEventType.MESSAGE>, senderPublicKey: string): Promise<boolean>;\n        }\n    }\n    \n    module 'test/transports/clients/PostMessageClient' {\n        import { ConnectionContext } from 'test/';\n        import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n        import { EncryptedExtensionMessage } from 'test/types/ExtensionMessage';\n        import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n        import { MessageBasedClient } from 'test/transports/clients/MessageBasedClient';\n        export class PostMessageClient extends MessageBasedClient {\n            protected readonly activeListeners: Map<string, (message: EncryptedExtensionMessage, context: ConnectionContext) => void>;\n            init(): Promise<void>;\n            listenForEncryptedMessage(senderPublicKey: string, messageCallback: (message: string, context: ConnectionContext) => void): Promise<void>;\n            sendMessage(message: string, peer: PostMessagePairingRequest | ExtendedPostMessagePairingResponse): Promise<void>;\n            listenForChannelOpening(messageCallback: (pairingResponse: ExtendedPostMessagePairingResponse) => void): Promise<void>;\n            sendPairingRequest(id: string): Promise<void>;\n            isChannelOpenMessage(message: any): Promise<boolean>;\n        }\n    }\n    \n    module 'test/transports/DappP2PTransport' {\n        import * as sodium from 'libsodium-wrappers';\n        import { Storage, StorageKey, P2PTransport } from 'test/';\n        import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n        export class DappP2PTransport extends P2PTransport<ExtendedP2PPairingResponse, StorageKey.TRANSPORT_P2P_PEERS_DAPP> {\n            constructor(name: string, keyPair: sodium.KeyPair, storage: Storage, matrixNodes: string[], iconUrl?: string, appUrl?: string);\n            startOpenChannelListener(): Promise<void>;\n            listenForNewPeer(newPeerListener: (peer: ExtendedP2PPairingResponse) => void): Promise<void>;\n            stopListeningForNewPeers(): Promise<void>;\n        }\n    }\n    \n    module 'test/transports/DappPostMessageTransport' {\n        import * as sodium from 'libsodium-wrappers';\n        import { StorageKey, PostMessageTransport, Storage } from 'test/';\n        import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n        export class DappPostMessageTransport extends PostMessageTransport<ExtendedPostMessagePairingResponse, StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP> {\n            constructor(name: string, keyPair: sodium.KeyPair, storage: Storage);\n            startOpenChannelListener(): Promise<void>;\n            listenForNewPeer(newPeerListener: (peer: ExtendedPostMessagePairingResponse) => void): Promise<void>;\n            stopListeningForNewPeers(): Promise<void>;\n        }\n    }\n    \n    module 'test/transports/P2PTransport' {\n        import * as sodium from 'libsodium-wrappers';\n        import { Storage, StorageKey, Transport, TransportType, P2PCommunicationClient, P2PPairingRequest } from 'test/';\n        import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n        export class P2PTransport<T extends P2PPairingRequest | ExtendedP2PPairingResponse, K extends StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET> extends Transport<T, K, P2PCommunicationClient> {\n            readonly type: TransportType;\n            constructor(name: string, keyPair: sodium.KeyPair, storage: Storage, matrixNodes: string[], storageKey: K, iconUrl?: string, appUrl?: string);\n            static isAvailable(): Promise<boolean>;\n            connect(): Promise<void>;\n            startOpenChannelListener(): Promise<void>;\n            getPairingRequestInfo(): Promise<P2PPairingRequest>;\n            listen(publicKey: string): Promise<void>;\n        }\n    }\n    \n    module 'test/transports/PostMessageTransport' {\n        import * as sodium from 'libsodium-wrappers';\n        import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n        import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n        import { Extension } from 'test/types/Extension';\n        import { StorageKey } from 'test/types/storage/StorageKey';\n        import { TransportType } from 'test/types/transport/TransportType';\n        import { Storage } from 'test/storage/Storage';\n        import { PostMessageClient } from 'test/transports/clients/PostMessageClient';\n        import { Transport } from 'test/transports/Transport';\n        export class PostMessageTransport<T extends PostMessagePairingRequest | ExtendedPostMessagePairingResponse, K extends StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET> extends Transport<T, K, PostMessageClient> {\n            readonly type: TransportType;\n            constructor(name: string, keyPair: sodium.KeyPair, storage: Storage, storageKey: K);\n            static isAvailable(): Promise<boolean>;\n            static getAvailableExtensions(): Promise<Extension[]>;\n            connect(): Promise<void>;\n            startOpenChannelListener(): Promise<void>;\n            getPairingRequestInfo(): Promise<PostMessagePairingRequest>;\n            listen(publicKey: string): Promise<void>;\n        }\n    }\n    \n    module 'test/transports/Transport' {\n        import { ConnectionContext } from 'test/types/ConnectionContext';\n        import { TransportType, TransportStatus, PeerInfo, StorageKey } from 'test/';\n        import { PeerManager } from 'test/managers/PeerManager';\n        import { CommunicationClient } from 'test/transports/clients/CommunicationClient';\n        export abstract class Transport<T extends PeerInfo = PeerInfo, K extends StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET = any, S extends CommunicationClient = any> {\n                /**\n                     * The type of the transport\n                     */\n                readonly type: TransportType;\n                /**\n                     * The name of the app\n                     */\n                protected readonly name: string;\n                /**\n                     * The status of the transport\n                     */\n                protected _isConnected: TransportStatus;\n                protected readonly peerManager: PeerManager<K>;\n                /**\n                     * The client handling the encryption/decryption of messages\n                     */\n                protected client: S;\n                /**\n                     * The listener that will be invoked when a new peer is connected\n                     */\n                protected newPeerListener?: (peer: T) => void;\n                /**\n                     * Return the status of the connection\n                     */\n                get connectionStatus(): TransportStatus;\n                constructor(name: string, client: S, peerManager: PeerManager<K>);\n                /**\n                     * Returns a promise that resolves to true if the transport is available, false if it is not\n                     */\n                static isAvailable(): Promise<boolean>;\n                /**\n                     * Connect the transport\n                     */\n                connect(): Promise<void>;\n                /**\n                     * Send a message through the transport\n                     *\n                     * @param message The message to send\n                     * @param recipient The recipient of the message\n                     */\n                send(message: string, peer?: PeerInfo): Promise<void>;\n                /**\n                     * Add a listener to be called when a new message is received\n                     *\n                     * @param listener The listener that will be registered\n                     */\n                addListener(listener: (message: unknown, connectionInfo: ConnectionContext) => void): Promise<void>;\n                /**\n                     * Remove a listener\n                     *\n                     * @param listener\n                     */\n                removeListener(listener: (message: string, connectionInfo: ConnectionContext) => void): Promise<void>;\n                getPeers(): Promise<T[]>;\n                addPeer(newPeer: T): Promise<void>;\n                removePeer(peerToBeRemoved: T): Promise<void>;\n                removeAllPeers(): Promise<void>;\n                /**\n                     * Notify the listeners when a new message comes in\n                     *\n                     * @param message Message\n                     * @param connectionInfo Context info about the connection\n                     */\n                protected notifyListeners(message: unknown, connectionInfo: ConnectionContext): Promise<void>;\n                abstract listen(publicKey: string): Promise<void>;\n        }\n    }\n    \n    module 'test/transports/WalletP2PTransport' {\n        import * as sodium from 'libsodium-wrappers';\n        import { Storage, StorageKey, P2PTransport, P2PPairingRequest } from 'test/';\n        export class WalletP2PTransport extends P2PTransport<P2PPairingRequest, StorageKey.TRANSPORT_P2P_PEERS_WALLET> {\n            constructor(name: string, keyPair: sodium.KeyPair, storage: Storage, matrixNodes: string[], iconUrl?: string, appUrl?: string);\n            addPeer(newPeer: P2PPairingRequest): Promise<void>;\n        }\n    }\n    \n    module 'test/transports/WalletPostMessageTransport' {\n        import * as sodium from 'libsodium-wrappers';\n        import { StorageKey, PostMessageTransport, Storage } from 'test/';\n        import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n        export class WalletPostMessageTransport extends PostMessageTransport<PostMessagePairingRequest, StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET> {\n            constructor(name: string, keyPair: sodium.KeyPair, storage: Storage);\n        }\n    }\n    \n    module 'test/types/AccountInfo' {\n        import { Origin } from 'test/';\n        import { PermissionEntity } from 'test/types/PermissionEntity';\n        export type AccountIdentifier = string;\n        export interface AccountInfo extends PermissionEntity {\n            accountIdentifier: AccountIdentifier;\n            senderId: string;\n            origin: {\n                type: Origin;\n                id: string;\n            };\n            publicKey: string;\n            connectedAt: number;\n        }\n    }\n    \n    module 'test/types/beacon/AppMetadata' {\n        export interface AppMetadata {\n            senderId: string;\n            name: string;\n            icon?: string;\n        }\n    }\n    \n    module 'test/types/beacon/BeaconBaseMessage' {\n        import { BeaconMessageType } from 'test/';\n        export interface BeaconBaseMessage {\n            type: BeaconMessageType;\n            version: string;\n            id: string;\n            senderId: string;\n        }\n    }\n    \n    module 'test/types/beacon/BeaconMessage' {\n        import { PermissionResponse, PermissionRequest, OperationRequest, OperationResponse, SignPayloadRequest, SignPayloadResponse, BroadcastRequest, BroadcastResponse, AcknowledgeResponse, DisconnectMessage, ErrorResponse } from 'test/';\n        export type BeaconMessage = PermissionRequest | PermissionResponse | OperationRequest | OperationResponse | SignPayloadRequest | SignPayloadResponse | BroadcastRequest | BroadcastResponse | AcknowledgeResponse | DisconnectMessage | ErrorResponse;\n    }\n    \n    module 'test/types/beacon/BeaconMessageType' {\n        export enum BeaconMessageType {\n            PermissionRequest = \"permission_request\",\n            SignPayloadRequest = \"sign_payload_request\",\n            OperationRequest = \"operation_request\",\n            BroadcastRequest = \"broadcast_request\",\n            PermissionResponse = \"permission_response\",\n            SignPayloadResponse = \"sign_payload_response\",\n            OperationResponse = \"operation_response\",\n            BroadcastResponse = \"broadcast_response\",\n            Acknowledge = \"acknowledge\",\n            Disconnect = \"disconnect\",\n            Error = \"error\"\n        }\n    }\n    \n    module 'test/types/beacon/BeaconRequestMessage' {\n        import { PermissionRequest, OperationRequest, SignPayloadRequest, BroadcastRequest } from 'test/';\n        export type BeaconRequestMessage = PermissionRequest | OperationRequest | SignPayloadRequest | BroadcastRequest;\n    }\n    \n    module 'test/types/beacon/BeaconResponseMessage' {\n        import { PermissionResponse, OperationResponse, SignPayloadResponse, BroadcastResponse } from 'test/';\n        import { ErrorResponse } from 'test/types/beacon/messages/ErrorResponse';\n        export type BeaconResponseMessage = PermissionResponse | OperationResponse | SignPayloadResponse | BroadcastResponse | ErrorResponse;\n    }\n    \n    module 'test/types/beacon/messages/AcknowledgeResponse' {\n        import { BeaconBaseMessage, BeaconMessageType } from 'test/';\n        export interface AcknowledgeResponse extends BeaconBaseMessage {\n            type: BeaconMessageType.Acknowledge;\n        }\n    }\n    \n    module 'test/types/beacon/messages/BeaconRequestInputMessage' {\n        import { PermissionRequest, OperationRequest, SignPayloadRequest, BroadcastRequest } from 'test/';\n        export type IgnoredRequestInputProperties = 'id' | 'senderId' | 'version';\n        export type PermissionRequestInput = Omit<PermissionRequest, IgnoredRequestInputProperties>;\n        export type OperationRequestInput = Omit<OperationRequest, IgnoredRequestInputProperties>;\n        export type SignPayloadRequestInput = Omit<SignPayloadRequest, IgnoredRequestInputProperties>;\n        export type BroadcastRequestInput = Omit<BroadcastRequest, IgnoredRequestInputProperties>;\n        export type BeaconRequestInputMessage = PermissionRequestInput | OperationRequestInput | SignPayloadRequestInput | BroadcastRequestInput;\n    }\n    \n    module 'test/types/beacon/messages/BeaconRequestOutputMessage' {\n        import { AppMetadata, PermissionRequest, OperationRequest, SignPayloadRequest, BroadcastRequest } from 'test/';\n        export type IgnoredRequestOutputProperties = 'version';\n        export interface ExtraResponseOutputProperties {\n            appMetadata: AppMetadata;\n        }\n        export type PermissionRequestOutput = Omit<PermissionRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n        export type OperationRequestOutput = Omit<OperationRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n        export type SignPayloadRequestOutput = Omit<SignPayloadRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n        export type BroadcastRequestOutput = Omit<BroadcastRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n        export type BeaconRequestOutputMessage = PermissionRequestOutput | OperationRequestOutput | SignPayloadRequestOutput | BroadcastRequestOutput;\n    }\n    \n    module 'test/types/beacon/messages/BeaconResponseInputMessage' {\n        import { PermissionResponse, OperationResponse, SignPayloadResponse, BroadcastResponse, AcknowledgeResponse, ErrorResponse } from 'test/';\n        export type IgnoredResponseInputProperties = 'senderId' | 'version' | 'appMetadata';\n        export type PermissionResponseInput = Omit<PermissionResponse, IgnoredResponseInputProperties>;\n        export type OperationResponseInput = Omit<OperationResponse, IgnoredResponseInputProperties>;\n        export type SignPayloadResponseInput = Omit<SignPayloadResponse, IgnoredResponseInputProperties>;\n        export type BroadcastResponseInput = Omit<BroadcastResponse, IgnoredResponseInputProperties>;\n        export type AcknowledgeResponseInput = Omit<AcknowledgeResponse, IgnoredResponseInputProperties>;\n        export type ErrorResponseInput = Omit<ErrorResponse, IgnoredResponseInputProperties>;\n        export type BeaconResponseInputMessage = PermissionResponseInput | OperationResponseInput | SignPayloadResponseInput | BroadcastResponseInput | AcknowledgeResponseInput | ErrorResponseInput;\n    }\n    \n    module 'test/types/beacon/messages/BeaconResponseOutputMessage' {\n        import { PermissionResponse, OperationResponse, SignPayloadResponse, BroadcastResponse, AccountInfo } from 'test/';\n        export type IgnoredResponseOutputProperties = 'id' | 'version' | 'type';\n        export type PermissionResponseOutput = PermissionResponse & {\n            address: string;\n            accountInfo: AccountInfo;\n        };\n        export type OperationResponseOutput = OperationResponse;\n        export type SignPayloadResponseOutput = SignPayloadResponse;\n        export type BroadcastResponseOutput = BroadcastResponse;\n        export type BeaconResponseOutputMessage = PermissionResponseOutput | OperationResponseOutput | SignPayloadResponseOutput | BroadcastResponseOutput;\n    }\n    \n    module 'test/types/beacon/messages/BroadcastRequest' {\n        import { BeaconBaseMessage, BeaconMessageType, Network } from 'test/';\n        export interface BroadcastRequest extends BeaconBaseMessage {\n            type: BeaconMessageType.BroadcastRequest;\n            network: Network;\n            signedTransaction: string;\n        }\n    }\n    \n    module 'test/types/beacon/messages/BroadcastResponse' {\n        import { BeaconBaseMessage, BeaconMessageType } from 'test/';\n        export interface BroadcastResponse extends BeaconBaseMessage {\n            type: BeaconMessageType.BroadcastResponse;\n            transactionHash: string;\n        }\n    }\n    \n    module 'test/types/beacon/messages/DisconnectMessage' {\n        import { BeaconBaseMessage, BeaconMessageType } from 'test/';\n        export interface DisconnectMessage extends BeaconBaseMessage {\n            type: BeaconMessageType.Disconnect;\n        }\n    }\n    \n    module 'test/types/beacon/messages/ErrorResponse' {\n        import { BeaconBaseMessage, BeaconErrorType, BeaconMessageType } from 'test/';\n        export interface ErrorResponse extends BeaconBaseMessage {\n            type: BeaconMessageType.Error;\n            errorType: BeaconErrorType;\n            errorData?: any;\n        }\n    }\n    \n    module 'test/types/beacon/messages/OperationRequest' {\n        import { BeaconBaseMessage, BeaconMessageType, Network } from 'test/';\n        import { PartialTezosOperation } from 'test/types/tezos/PartialTezosOperation';\n        export interface OperationRequest extends BeaconBaseMessage {\n            type: BeaconMessageType.OperationRequest;\n            network: Network;\n            operationDetails: PartialTezosOperation[];\n            sourceAddress: string;\n        }\n    }\n    \n    module 'test/types/beacon/messages/OperationResponse' {\n        import { BeaconBaseMessage, BeaconMessageType } from 'test/';\n        export interface OperationResponse extends BeaconBaseMessage {\n            type: BeaconMessageType.OperationResponse;\n            transactionHash: string;\n        }\n    }\n    \n    module 'test/types/beacon/messages/PermissionRequest' {\n        import { BeaconBaseMessage, BeaconMessageType, PermissionScope, AppMetadata, Network } from 'test/';\n        export interface PermissionRequest extends BeaconBaseMessage {\n            type: BeaconMessageType.PermissionRequest;\n            appMetadata: AppMetadata;\n            network: Network;\n            scopes: PermissionScope[];\n        }\n    }\n    \n    module 'test/types/beacon/messages/PermissionResponse' {\n        import { AppMetadata, BeaconBaseMessage, BeaconMessageType, Network, PermissionScope, Threshold } from 'test/';\n        export interface PermissionResponse extends BeaconBaseMessage {\n            type: BeaconMessageType.PermissionResponse;\n            appMetadata: AppMetadata;\n            publicKey: string;\n            network: Network;\n            scopes: PermissionScope[];\n            threshold?: Threshold;\n        }\n    }\n    \n    module 'test/types/beacon/messages/SignPayloadRequest' {\n        import { BeaconBaseMessage, BeaconMessageType, SigningType } from 'test/';\n        export interface SignPayloadRequest extends BeaconBaseMessage {\n            type: BeaconMessageType.SignPayloadRequest;\n            signingType: SigningType;\n            payload: string;\n            sourceAddress: string;\n        }\n    }\n    \n    module 'test/types/beacon/messages/SignPayloadResponse' {\n        import { BeaconBaseMessage, BeaconMessageType, SigningType } from 'test/';\n        export interface SignPayloadResponse extends BeaconBaseMessage {\n            type: BeaconMessageType.SignPayloadResponse;\n            signingType: SigningType;\n            signature: string;\n        }\n    }\n    \n    module 'test/types/beacon/Network' {\n        import { NetworkType } from 'test/';\n        export interface Network {\n            type: NetworkType;\n            name?: string;\n            rpcUrl?: string;\n        }\n    }\n    \n    module 'test/types/beacon/NetworkType' {\n        export enum NetworkType {\n            MAINNET = \"mainnet\",\n            DELPHINET = \"delphinet\",\n            EDONET = \"edonet\",\n            CUSTOM = \"custom\"\n        }\n    }\n    \n    module 'test/types/beacon/PermissionScope' {\n        export enum PermissionScope {\n            SIGN = \"sign\",\n            OPERATION_REQUEST = \"operation_request\",\n            THRESHOLD = \"threshold\"\n        }\n    }\n    \n    module 'test/types/beacon/SigningType' {\n        export enum SigningType {\n            RAW = \"raw\",\n            OPERATION = \"operation\",\n            MICHELINE = \"micheline\"\n        }\n    }\n    \n    module 'test/types/beacon/Threshold' {\n        export interface Threshold {\n            amount: string;\n            timeframe: string;\n        }\n    }\n    \n    module 'test/types/BeaconErrorType' {\n        export enum BeaconErrorType {\n            BROADCAST_ERROR = \"BROADCAST_ERROR\",\n            NETWORK_NOT_SUPPORTED = \"NETWORK_NOT_SUPPORTED\",\n            NO_ADDRESS_ERROR = \"NO_ADDRESS_ERROR\",\n            NO_PRIVATE_KEY_FOUND_ERROR = \"NO_PRIVATE_KEY_FOUND_ERROR\",\n            NOT_GRANTED_ERROR = \"NOT_GRANTED_ERROR\",\n            PARAMETERS_INVALID_ERROR = \"PARAMETERS_INVALID_ERROR\",\n            TOO_MANY_OPERATIONS = \"TOO_MANY_OPERATIONS\",\n            TRANSACTION_INVALID_ERROR = \"TRANSACTION_INVALID_ERROR\",\n            SIGNATURE_TYPE_NOT_SUPPORTED = \"SIGNATURE_TYPE_NOT_SUPPORTED\",\n            ABORTED_ERROR = \"ABORTED_ERROR\",\n            UNKNOWN_ERROR = \"UNKNOWN_ERROR\"\n        }\n    }\n    \n    module 'test/types/ColorMode' {\n        export enum ColorMode {\n            LIGHT = \"light\",\n            DARK = \"dark\"\n        }\n    }\n    \n    module 'test/types/ConnectionContext' {\n        import { Origin } from 'test/';\n        export interface ConnectionContext {\n            origin: Origin;\n            id: string;\n            extras?: {\n                sender: chrome.runtime.MessageSender;\n                sendResponse(response?: unknown): void;\n            };\n        }\n    }\n    \n    module 'test/types/Extension' {\n        export interface Extension {\n            id: string;\n            name: string;\n            shortName?: string;\n            iconUrl?: string;\n            color?: string;\n        }\n    }\n    \n    module 'test/types/ExtensionMessage' {\n        import { ExtensionMessageTarget } from 'test/';\n        export interface ExtensionMessage<T, U = unknown> {\n            target: ExtensionMessageTarget;\n            targetId?: string;\n            sender?: U;\n            payload: T;\n        }\n        export interface EncryptedExtensionMessage<U = unknown> {\n            target: ExtensionMessageTarget;\n            targetId?: string;\n            sender?: U;\n            encryptedPayload: string;\n        }\n    }\n    \n    module 'test/types/ExtensionMessageTarget' {\n        export enum ExtensionMessageTarget {\n            BACKGROUND = \"toBackground\",\n            PAGE = \"toPage\",\n            EXTENSION = \"toExtension\"\n        }\n    }\n    \n    module 'test/types/Origin' {\n        export enum Origin {\n            WEBSITE = \"website\",\n            EXTENSION = \"extension\",\n            P2P = \"p2p\"\n        }\n    }\n    \n    module 'test/types/P2PPairingRequest' {\n        import { PeerInfo } from 'test/types/PeerInfo';\n        export interface P2PPairingRequest extends PeerInfo {\n            id: string;\n            type: 'p2p-pairing-request';\n            name: string;\n            publicKey: string;\n            relayServer: string;\n            icon?: string;\n            appUrl?: string;\n        }\n        export type ExtendedP2PPairingRequest = P2PPairingRequest & {\n            senderId: string;\n        };\n    }\n    \n    module 'test/types/P2PPairingResponse' {\n        import { PeerInfo } from 'test/types/PeerInfo';\n        export interface P2PPairingResponse extends PeerInfo {\n            id: string;\n            type: 'p2p-pairing-response';\n            name: string;\n            publicKey: string;\n            relayServer: string;\n            icon?: string;\n            appUrl?: string;\n        }\n        export type ExtendedP2PPairingResponse = P2PPairingResponse & {\n            senderId: string;\n        };\n    }\n    \n    module 'test/types/PeerInfo' {\n        export interface PeerInfo {\n            name: string;\n            publicKey: string;\n            version: string;\n        }\n        export type ExtendedPeerInfo = PeerInfo & {\n            senderId: string;\n        };\n    }\n    \n    module 'test/types/PermissionEntity' {\n        import { Network, PermissionScope, Threshold } from 'test/';\n        export interface PermissionEntity {\n            address: string;\n            network: Network;\n            scopes: PermissionScope[];\n            threshold?: Threshold;\n        }\n    }\n    \n    module 'test/types/PermissionInfo' {\n        import { AppMetadata } from 'test/';\n        import { PermissionEntity } from 'test/types/PermissionEntity';\n        export interface PermissionInfo extends PermissionEntity {\n            accountIdentifier: string;\n            senderId: string;\n            appMetadata: AppMetadata;\n            website: string;\n            publicKey: string;\n            connectedAt: number;\n        }\n    }\n    \n    module 'test/types/PostMessagePairingRequest' {\n        import { PeerInfo } from 'test/types/PeerInfo';\n        export interface PostMessagePairingRequest extends PeerInfo {\n            id: string;\n            type: 'postmessage-pairing-request';\n            name: string;\n            publicKey: string;\n            icon?: string;\n            appUrl?: string;\n        }\n        export type ExtendedPostMessagePairingRequest = PostMessagePairingRequest & {\n            senderId: string;\n        };\n    }\n    \n    module 'test/types/PostMessagePairingResponse' {\n        import { PeerInfo } from 'test/types/PeerInfo';\n        export interface PostMessagePairingResponse extends PeerInfo {\n            id: string;\n            type: 'postmessage-pairing-response';\n            name: string;\n            publicKey: string;\n            icon?: string;\n            appUrl?: string;\n        }\n        export type ExtendedPostMessagePairingResponse = PostMessagePairingResponse & {\n            senderId: string;\n            extensionId: string;\n        };\n    }\n    \n    module 'test/types/RequestBroadcastInput' {\n        import { Network } from 'test/';\n        export interface RequestBroadcastInput {\n            network?: Network;\n            signedTransaction: string;\n        }\n    }\n    \n    module 'test/types/RequestOperationInput' {\n        import { PartialTezosOperation } from 'test/types/tezos/PartialTezosOperation';\n        export interface RequestOperationInput {\n            operationDetails: PartialTezosOperation[];\n        }\n    }\n    \n    module 'test/types/RequestPermissionInput' {\n        import { Network, PermissionScope } from 'test/';\n        export interface RequestPermissionInput {\n            network?: Network;\n            scopes?: PermissionScope[];\n        }\n    }\n    \n    module 'test/types/RequestSignPayloadInput' {\n        import { SigningType } from 'test/';\n        export interface RequestSignPayloadInput {\n            signingType?: SigningType;\n            payload: string;\n            sourceAddress?: string;\n        }\n    }\n    \n    module 'test/types/storage/StorageKey' {\n        export enum StorageKey {\n            TRANSPORT_P2P_PEERS_DAPP = \"beacon:communication-peers-dapp\",\n            TRANSPORT_P2P_PEERS_WALLET = \"beacon:communication-peers-wallet\",\n            TRANSPORT_POSTMESSAGE_PEERS_DAPP = \"beacon:postmessage-peers-dapp\",\n            TRANSPORT_POSTMESSAGE_PEERS_WALLET = \"beacon:postmessage-peers-wallet\",\n            ACCOUNTS = \"beacon:accounts\",\n            ACTIVE_ACCOUNT = \"beacon:active-account\",\n            ACTIVE_PEER = \"beacon:active-peer\",\n            BEACON_SDK_SECRET_SEED = \"beacon:sdk-secret-seed\",\n            APP_METADATA_LIST = \"beacon:app-metadata-list\",\n            PERMISSION_LIST = \"beacon:permissions\",\n            BEACON_SDK_VERSION = \"beacon:sdk_version\",\n            MATRIX_PRESERVED_STATE = \"beacon:sdk-matrix-preserved-state\",\n            MATRIX_PEER_ROOM_IDS = \"beacon:matrix-peer-rooms\"\n        }\n    }\n    \n    module 'test/types/storage/StorageKeyReturnDefaults' {\n        import { StorageKey, StorageKeyReturnType } from 'test/';\n        export type StorageKeyReturnDefaults = {\n            [key in StorageKey]: StorageKeyReturnType[key];\n        };\n        export const defaultValues: StorageKeyReturnDefaults;\n    }\n    \n    module 'test/types/storage/StorageKeyReturnType' {\n        import { StorageKey, AccountInfo, AccountIdentifier, P2PPairingRequest, AppMetadata, PermissionInfo } from 'test/';\n        import { MatrixState } from 'test/matrix-client/MatrixClientStore';\n        import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n        import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n        import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n        export interface StorageKeyReturnType {\n            [StorageKey.TRANSPORT_P2P_PEERS_DAPP]: P2PPairingRequest[];\n            [StorageKey.TRANSPORT_P2P_PEERS_WALLET]: ExtendedP2PPairingResponse[];\n            [StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP]: PostMessagePairingRequest[];\n            [StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET]: ExtendedPostMessagePairingResponse[];\n            [StorageKey.ACCOUNTS]: AccountInfo[];\n            [StorageKey.ACTIVE_ACCOUNT]: AccountIdentifier | undefined;\n            [StorageKey.ACTIVE_PEER]: string | undefined;\n            [StorageKey.BEACON_SDK_SECRET_SEED]: string | undefined;\n            [StorageKey.APP_METADATA_LIST]: AppMetadata[];\n            [StorageKey.PERMISSION_LIST]: PermissionInfo[];\n            [StorageKey.BEACON_SDK_VERSION]: string | undefined;\n            [StorageKey.MATRIX_PRESERVED_STATE]: Partial<MatrixState>;\n            [StorageKey.MATRIX_PEER_ROOM_IDS]: {\n                [key: string]: string | undefined;\n            };\n        }\n    }\n    \n    module 'test/types/tezos/MichelineMichelsonV1Expression' {\n        import { MichelsonPrimitives } from 'test/';\n        export type MichelineMichelsonV1Expression = {\n            int: string;\n        } | {\n            string: string;\n        } | {\n            bytes: string;\n        } | MichelineMichelsonV1Expression[] | {\n            prim: MichelsonPrimitives;\n            args?: MichelineMichelsonV1Expression[];\n            annots?: string[];\n        };\n    }\n    \n    module 'test/types/tezos/MichelsonPrimitives' {\n        export type MichelsonPrimitives = 'ADD' | 'IF_NONE' | 'SWAP' | 'set' | 'nat' | 'CHECK_SIGNATURE' | 'IF_LEFT' | 'LAMBDA' | 'Elt' | 'CREATE_CONTRACT' | 'NEG' | 'big_map' | 'map' | 'or' | 'BLAKE2B' | 'bytes' | 'SHA256' | 'SET_DELEGATE' | 'CONTRACT' | 'LSL' | 'SUB' | 'IMPLICIT_ACCOUNT' | 'PACK' | 'list' | 'PAIR' | 'Right' | 'contract' | 'GT' | 'LEFT' | 'STEPS_TO_QUOTA' | 'storage' | 'TRANSFER_TOKENS' | 'CDR' | 'SLICE' | 'PUSH' | 'False' | 'SHA512' | 'CHAIN_ID' | 'BALANCE' | 'signature' | 'DUG' | 'SELF' | 'EMPTY_BIG_MAP' | 'LSR' | 'OR' | 'XOR' | 'lambda' | 'COMPARE' | 'key' | 'option' | 'Unit' | 'Some' | 'UNPACK' | 'NEQ' | 'INT' | 'pair' | 'AMOUNT' | 'DIP' | 'ABS' | 'ISNAT' | 'EXEC' | 'NOW' | 'LOOP' | 'chain_id' | 'string' | 'MEM' | 'MAP' | 'None' | 'address' | 'CONCAT' | 'EMPTY_SET' | 'MUL' | 'LOOP_LEFT' | 'timestamp' | 'LT' | 'UPDATE' | 'DUP' | 'SOURCE' | 'mutez' | 'SENDER' | 'IF_CONS' | 'RIGHT' | 'CAR' | 'CONS' | 'LE' | 'NONE' | 'IF' | 'SOME' | 'GET' | 'Left' | 'CAST' | 'int' | 'SIZE' | 'key_hash' | 'unit' | 'DROP' | 'EMPTY_MAP' | 'NIL' | 'DIG' | 'APPLY' | 'bool' | 'RENAME' | 'operation' | 'True' | 'FAILWITH' | 'parameter' | 'HASH_KEY' | 'EQ' | 'NOT' | 'UNIT' | 'Pair' | 'ADDRESS' | 'EDIV' | 'CREATE_ACCOUNT' | 'GE' | 'ITER' | 'code' | 'AND';\n    }\n    \n    module 'test/types/tezos/operations/ActivateAccount' {\n        import { TezosBaseOperation, TezosOperationType } from 'test/';\n        export interface TezosActivateAccountOperation extends TezosBaseOperation {\n            kind: TezosOperationType.ACTIVATE_ACCOUNT;\n            pkh: string;\n            secret: string;\n        }\n    }\n    \n    module 'test/types/tezos/operations/Ballot' {\n        import { TezosBaseOperation, TezosOperationType } from 'test/';\n        export interface TezosBallotOperation extends TezosBaseOperation {\n            kind: TezosOperationType.BALLOT;\n            source: string;\n            period: string;\n            proposal: string;\n            ballot: 'nay' | 'yay' | 'pass';\n        }\n    }\n    \n    module 'test/types/tezos/operations/Delegation' {\n        import { TezosBaseOperation, TezosOperationType } from 'test/';\n        export interface TezosDelegationOperation extends TezosBaseOperation {\n            kind: TezosOperationType.DELEGATION;\n            source: string;\n            fee: string;\n            counter: string;\n            gas_limit: string;\n            storage_limit: string;\n            delegate?: string;\n        }\n    }\n    \n    module 'test/types/tezos/operations/DoubleBakingEvidence' {\n        import { TezosBaseOperation, TezosOperationType, TezosBlockHeader } from 'test/';\n        export interface InlinedEndorsement {\n            branch: string;\n            operations: InlinedEndorsementContents;\n            signature?: string;\n        }\n        export interface InlinedEndorsementContents {\n            kind: 'endorsement';\n            level: string;\n        }\n        export interface TezosDoubleBakingEvidenceOperation extends TezosBaseOperation {\n            kind: TezosOperationType.DOUBLE_BAKING_EVIDENCE;\n            bh1: TezosBlockHeader;\n            bh2: TezosBlockHeader;\n        }\n    }\n    \n    module 'test/types/tezos/operations/DoubleEndorsementEvidence' {\n        import { TezosBaseOperation, TezosOperationType } from 'test/';\n        export interface InlinedEndorsement {\n            branch: string;\n            operations: InlinedEndorsementContents;\n            signature?: string;\n        }\n        export interface InlinedEndorsementContents {\n            kind: 'endorsement';\n            level: string;\n        }\n        export interface TezosDoubleEndorsementEvidenceOperation extends TezosBaseOperation {\n            kind: TezosOperationType.DOUBLE_ENDORSEMENT_EVIDENCE;\n            op1: InlinedEndorsement;\n            op2: InlinedEndorsement;\n        }\n    }\n    \n    module 'test/types/tezos/operations/Endorsement' {\n        import { TezosBaseOperation, TezosOperationType } from 'test/';\n        export interface TezosEndorsementOperation extends TezosBaseOperation {\n            kind: TezosOperationType.ENDORSEMENT;\n            level: string;\n        }\n    }\n    \n    module 'test/types/tezos/operations/Origination' {\n        import { TezosBaseOperation, TezosOperationType } from 'test/';\n        export interface TezosOriginationOperation extends TezosBaseOperation {\n            kind: TezosOperationType.ORIGINATION;\n            source: string;\n            fee: string;\n            counter: string;\n            gas_limit: string;\n            storage_limit: string;\n            balance: string;\n            delegate?: string;\n            script: string;\n        }\n    }\n    \n    module 'test/types/tezos/operations/Proposal' {\n        import { TezosBaseOperation, TezosOperationType } from 'test/';\n        export interface TezosProposalOperation extends TezosBaseOperation {\n            kind: TezosOperationType.PROPOSALS;\n            period: string;\n            proposals: string[];\n        }\n    }\n    \n    module 'test/types/tezos/operations/Reveal' {\n        import { TezosBaseOperation, TezosOperationType } from 'test/';\n        export interface TezosRevealOperation extends TezosBaseOperation {\n            kind: TezosOperationType.REVEAL;\n            source: string;\n            fee: string;\n            counter: string;\n            gas_limit: string;\n            storage_limit: string;\n            public_key: string;\n        }\n    }\n    \n    module 'test/types/tezos/operations/SeedNonceRevelation' {\n        import { TezosBaseOperation, TezosOperationType } from 'test/';\n        export interface TezosSeedNonceRevelationOperation extends TezosBaseOperation {\n            kind: TezosOperationType.SEED_NONCE_REVELATION;\n            level: string;\n            nonce: string;\n        }\n    }\n    \n    module 'test/types/tezos/operations/Transaction' {\n        import { TezosBaseOperation, TezosOperationType, TezosTransactionParameters } from 'test/';\n        export interface TezosTransactionOperation extends TezosBaseOperation {\n            kind: TezosOperationType.TRANSACTION;\n            source: string;\n            fee: string;\n            counter: string;\n            gas_limit: string;\n            storage_limit: string;\n            amount: string;\n            destination: string;\n            parameters?: TezosTransactionParameters;\n        }\n    }\n    \n    module 'test/types/tezos/OperationTypes' {\n        export enum TezosOperationType {\n            ENDORSEMENT = \"endorsement\",\n            SEED_NONCE_REVELATION = \"seed_nonce_revelation\",\n            DOUBLE_ENDORSEMENT_EVIDENCE = \"double_endorsement_evidence\",\n            DOUBLE_BAKING_EVIDENCE = \"double_baking_evidence\",\n            ACTIVATE_ACCOUNT = \"activate_account\",\n            PROPOSALS = \"proposals\",\n            BALLOT = \"ballot\",\n            REVEAL = \"reveal\",\n            TRANSACTION = \"transaction\",\n            ORIGINATION = \"origination\",\n            DELEGATION = \"delegation\"\n        }\n    }\n    \n    module 'test/types/tezos/PartialTezosOperation' {\n        import { TezosActivateAccountOperation } from 'test/types/tezos/operations/ActivateAccount';\n        import { TezosBallotOperation } from 'test/types/tezos/operations/Ballot';\n        import { TezosDelegationOperation } from 'test/types/tezos/operations/Delegation';\n        import { TezosDoubleBakingEvidenceOperation } from 'test/types/tezos/operations/DoubleBakingEvidence';\n        import { TezosEndorsementOperation } from 'test/types/tezos/operations/Endorsement';\n        import { TezosOriginationOperation } from 'test/types/tezos/operations/Origination';\n        import { TezosProposalOperation } from 'test/types/tezos/operations/Proposal';\n        import { TezosRevealOperation } from 'test/types/tezos/operations/Reveal';\n        import { TezosSeedNonceRevelationOperation } from 'test/types/tezos/operations/SeedNonceRevelation';\n        import { TezosTransactionOperation } from 'test/types/tezos/operations/Transaction';\n        type omittedProperties = 'source' | 'fee' | 'counter' | 'gas_limit' | 'storage_limit';\n        export type PartialTezosDelegationOperation = Omit<TezosDelegationOperation, omittedProperties>;\n        export type PartialTezosOriginationOperation = Omit<TezosOriginationOperation, omittedProperties>;\n        export type PartialTezosRevealOperation = Omit<TezosRevealOperation, omittedProperties>;\n        export type PartialTezosTransactionOperation = Omit<TezosTransactionOperation, omittedProperties>;\n        export type PartialTezosOperation = TezosActivateAccountOperation | TezosBallotOperation | PartialTezosDelegationOperation | TezosDoubleBakingEvidenceOperation | TezosEndorsementOperation | PartialTezosOriginationOperation | TezosProposalOperation | PartialTezosRevealOperation | TezosSeedNonceRevelationOperation | PartialTezosTransactionOperation;\n        export {};\n    }\n    \n    module 'test/types/tezos/TezosBaseOperation' {\n        import { TezosOperationType } from 'test/';\n        export interface TezosBaseOperation {\n            kind: TezosOperationType;\n        }\n    }\n    \n    module 'test/types/tezos/TezosBlockHeader' {\n        export interface TezosBlockHeader {\n            level: number;\n            proto: number;\n            predecessor: string;\n            timestamp: string;\n            validation_pass: number;\n            operations_hash: string;\n            fitness: string[];\n            context: string;\n            priority: number;\n            proof_of_work_nonce: string;\n            signature: string;\n        }\n    }\n    \n    module 'test/types/tezos/TezosOperation' {\n        import { TezosActivateAccountOperation, TezosBallotOperation, TezosDelegationOperation, TezosDoubleBakingEvidenceOperation, TezosEndorsementOperation, TezosOriginationOperation, TezosProposalOperation, TezosRevealOperation, TezosSeedNonceRevelationOperation, TezosTransactionOperation } from 'test/';\n        export type TezosOperation = TezosActivateAccountOperation | TezosBallotOperation | TezosDelegationOperation | TezosDoubleBakingEvidenceOperation | TezosEndorsementOperation | TezosOriginationOperation | TezosProposalOperation | TezosRevealOperation | TezosSeedNonceRevelationOperation | TezosTransactionOperation;\n    }\n    \n    module 'test/types/tezos/TezosTransactionParameters' {\n        import { MichelineMichelsonV1Expression } from 'test/types/tezos/MichelineMichelsonV1Expression';\n        export interface TezosTransactionParameters {\n            entrypoint: 'default' | 'root' | 'do' | 'set_delegate' | 'remove_delegate' | string;\n            value: MichelineMichelsonV1Expression;\n        }\n    }\n    \n    module 'test/types/transport/TransportStatus' {\n        export enum TransportStatus {\n            NOT_CONNECTED = \"NOT_CONNECTED\",\n            CONNECTING = \"CONNECTING\",\n            CONNECTED = \"CONNECTED\"\n        }\n    }\n    \n    module 'test/types/transport/TransportType' {\n        export enum TransportType {\n            CHROME_MESSAGE = \"chrome_message\",\n            POST_MESSAGE = \"post_message\",\n            LEDGER = \"ledger\",\n            P2P = \"p2p\"\n        }\n    }\n    \n    module 'test/ui/alert/alert-templates' {\n        export const alertTemplates: {\n            container: string;\n            default: {\n                html: string;\n                css: string;\n            };\n            pair: {\n                html: string;\n                css: string;\n            };\n        };\n    }\n    \n    module 'test/ui/alert/Alert' {\n        import { NetworkType } from 'test/';\n        export interface AlertButton {\n                text: string;\n                style?: 'solid' | 'outline';\n                actionCallback?(): Promise<void>;\n        }\n        export interface AlertConfig {\n                title: string;\n                body?: string;\n                timer?: number;\n                buttons?: AlertButton[];\n                pairingPayload?: {\n                        p2pSyncCode: string;\n                        postmessageSyncCode: string;\n                        preferredNetwork: NetworkType;\n                };\n                closeButtonCallback?(): void;\n        }\n        /**\n             * Close an alert by ID\n             *\n             * @param id ID of alert\n             */\n        const closeAlert: (id: string) => Promise<void>;\n        /**\n             * Close all alerts\n             */\n        const closeAlerts: () => Promise<void>;\n        /**\n             * Show an alert\n             *\n             * @param alertConfig The configuration of the alert\n             */\n        const openAlert: (alertConfig: AlertConfig) => Promise<string>;\n        export { closeAlert, closeAlerts, openAlert };\n    }\n    \n    module 'test/ui/alert/Pairing' {\n        import { NetworkType } from 'test/';\n        export enum Platform {\n            DESKTOP = 0,\n            IOS = 1,\n            ANDROID = 2\n        }\n        export enum WalletType {\n            IOS = \"ios\",\n            ANDROID = \"android\",\n            EXTENSION = \"extension\",\n            DESKTOP = \"desktop\",\n            WEB = \"web\"\n        }\n        export interface AppBase {\n            name: string;\n            shortName: string;\n            color: string;\n            logo: string;\n        }\n        export interface ExtensionApp extends AppBase {\n            id: string;\n            link: string;\n        }\n        export interface WebApp extends AppBase {\n            links: {\n                [NetworkType.MAINNET]: string;\n                [NetworkType.DELPHINET]?: string;\n                [NetworkType.EDONET]?: string;\n                [NetworkType.CUSTOM]?: string;\n            };\n        }\n        export interface DesktopApp extends AppBase {\n            deepLink: string;\n        }\n        export interface App extends AppBase {\n            universalLink: string;\n            deepLink?: string;\n        }\n        export interface PairingAlertWallet {\n            name: string;\n            shortName?: string;\n            color?: string;\n            logo?: string;\n            enabled: boolean;\n            clickHandler(): void;\n        }\n        export interface PairingAlertButton {\n            title: string;\n            text: string;\n            clickHandler(): void;\n        }\n        export interface PairingAlertList {\n            title: string;\n            type: WalletType;\n            wallets: PairingAlertWallet[];\n        }\n        export interface PairingAlertInfo {\n            walletLists: PairingAlertList[];\n            buttons: PairingAlertButton[];\n            qrData: string;\n        }\n        export type StatusUpdateHandler = (walletType: WalletType, app?: PairingAlertWallet) => void;\n        export class Pairing {\n            static getPlatfrom(): Promise<Platform>;\n            static getPairingInfo(pairingPayload: {\n                p2pSyncCode: string;\n                postmessageSyncCode: string;\n                preferredNetwork: NetworkType;\n            }, statusUpdateHandler: StatusUpdateHandler, platform?: Platform): Promise<PairingAlertInfo>;\n        }\n    }\n    \n    module 'test/ui/alert/PairingAlert' {\n        import { NetworkType } from 'test/';\n        export const preparePairingAlert: (shadowRoot: ShadowRoot, pairingPayload: {\n            p2pSyncCode: string;\n            postmessageSyncCode: string;\n            preferredNetwork: NetworkType;\n        }) => Promise<void>;\n    }\n    \n    module 'test/ui/alert/wallet-lists' {\n        import { App, DesktopApp, ExtensionApp, WebApp } from 'test/ui/alert/Pairing';\n        export const extensionList: ExtensionApp[];\n        export const desktopList: DesktopApp[];\n        export const webList: WebApp[];\n        export const iOSList: App[];\n    }\n    \n    module 'test/ui/toast/toast-templates' {\n        export const toastTemplates: {\n            default: {\n                html: string;\n                css: string;\n                poweredByBeacon: string;\n            };\n        };\n    }\n    \n    module 'test/ui/toast/Toast' {\n        import { WalletInfo } from 'test/events';\n        export interface ToastAction {\n                text: string;\n                actionText?: string;\n                actionCallback?(): Promise<void>;\n        }\n        export interface ToastConfig {\n                body: string;\n                timer?: number;\n                forceNew?: boolean;\n                state: 'loading' | 'acknowledge' | 'finished';\n                actions?: ToastAction[];\n                walletInfo?: WalletInfo;\n        }\n        /**\n             * Close a toast\n             */\n        const closeToast: () => Promise<void>;\n        /**\n             * Create a new toast\n             *\n             * @param toastConfig Configuration of the toast\n             */\n        const openToast: (toastConfig: ToastConfig) => Promise<void>;\n        export { closeToast, openToast };\n    }\n    \n    module 'test/utils/assert-never' {\n        /**\n           * A helper function to make sure if/elses and switch/cases are exhaustive\n           *\n           * @param empty The data that has to be empty\n           */\n        export function assertNever(empty: never): never;\n    }\n    \n    module 'test/utils/available-transports' {\n        /**\n           * An object with promises to indicate whether or not that transport is available.\n           */\n        export const availableTransports: {\n            extension: Promise<boolean>;\n            availableExtensions: Promise<import(\"beacon/types/Extension\").Extension[]>;\n        };\n    }\n    \n    module 'test/utils/block-explorer' {\n        import { Network, NetworkType } from 'test/';\n        export abstract class BlockExplorer {\n                readonly rpcUrls: {\n                        [key in NetworkType]: string;\n                };\n                constructor(rpcUrls: {\n                        [key in NetworkType]: string;\n                });\n                protected getLinkForNetwork(network: Network): Promise<string>;\n                /**\n                     * Return a blockexplorer link for an address\n                     *\n                     * @param address The address to be opened\n                     * @param network The network that was used\n                     */\n                abstract getAddressLink(address: string, network: Network): Promise<string>;\n                /**\n                     * Return a blockexplorer link for a transaction hash\n                     *\n                     * @param transactionId The hash of the transaction\n                     * @param network The network that was used\n                     */\n                abstract getTransactionLink(transactionId: string, network: Network): Promise<string>;\n        }\n    }\n    \n    module 'test/utils/crypto' {\n        import * as sodium from 'libsodium-wrappers';\n        /**\n             * Convert a value to hex\n             *\n             * @param value\n             */\n        export function toHex(value: any): string;\n        /**\n             * Get the hex hash of a value\n             *\n             * @param key\n             */\n        export function getHexHash(key: string | Buffer | Uint8Array): Promise<string>;\n        /**\n             * Get a keypair from a seed\n             *\n             * @param seed\n             */\n        export function getKeypairFromSeed(seed: string): Promise<sodium.KeyPair>;\n        /**\n             * Encrypt a message with a shared key\n             *\n             * @param message\n             * @param sharedKey\n             */\n        export function encryptCryptoboxPayload(message: string, sharedKey: Uint8Array): Promise<string>;\n        /**\n             * Decrypt a message with a shared key\n             *\n             * @param payload\n             * @param sharedKey\n             */\n        export function decryptCryptoboxPayload(payload: Uint8Array, sharedKey: Uint8Array): Promise<string>;\n        /**\n             * Encrypt a message with a public key\n             *\n             * @param payload\n             * @param publicKey\n             */\n        export function sealCryptobox(payload: string | Buffer, publicKey: Uint8Array): Promise<string>;\n        /**\n             * Decrypt a message with public + private key\n             *\n             * @param encryptedPayload\n             * @param publicKey\n             * @param privateKey\n             */\n        export function openCryptobox(encryptedPayload: string | Buffer, publicKey: Uint8Array, privateKey: Uint8Array): Promise<string>;\n        /**\n             * Get an address from the public key\n             *\n             * @param publicKey\n             */\n        export function getAddressFromPublicKey(publicKey: string): Promise<string>;\n        /**\n             * Get the recipient string used in the matrix message\n             *\n             * @param recipientHash\n             * @param relayServer\n             */\n        export function recipientString(recipientHash: string, relayServer: string): string;\n    }\n    \n    module 'test/utils/exposed-promise' {\n        export enum ExposedPromiseStatus {\n            PENDING = \"pending\",\n            RESOLVED = \"resolved\",\n            REJECTED = \"rejected\"\n        }\n        type Resolve<T> = (value?: T) => void;\n        type Reject<U> = (reason?: U) => void;\n        /**\n           * Exposed promise allow you to create a promise and then resolve it later, from the outside\n           */\n        export class ExposedPromise<T = unknown, U = unknown> {\n            get promise(): Promise<T>;\n            get resolve(): Resolve<T>;\n            get reject(): Reject<U>;\n            get status(): ExposedPromiseStatus;\n            get promiseResult(): T | undefined;\n            get promiseError(): U | undefined;\n            constructor();\n            static resolve<T>(value?: T): ExposedPromise<T>;\n            static reject<T = never, U = unknown>(reason?: U): ExposedPromise<T, U>;\n            isPending(): boolean;\n            isResolved(): boolean;\n            isRejected(): boolean;\n            isSettled(): boolean;\n        }\n        export {};\n    }\n    \n    module 'test/utils/generate-uuid' {\n        /**\n           * Generate a random GUID\n           */\n        export function generateGUID(): Promise<string>;\n    }\n    \n    module 'test/utils/get-account-identifier' {\n        import { Network } from 'test/';\n        /**\n           * Generate a deterministic account identifier based on an address and a network\n           *\n           * @param address\n           * @param network\n           */\n        export const getAccountIdentifier: (address: string, network: Network) => Promise<string>;\n    }\n    \n    module 'test/utils/get-sender-id' {\n        /**\n           * Generate a deterministic sender identifier based on a public key\n           *\n           * @param publicKey\n           */\n        export const getSenderId: (publicKey: string) => Promise<string>;\n    }\n    \n    module 'test/utils/get-tzip10-link' {\n        export const getTzip10Link: (url: string, payload: string) => string;\n    }\n    \n    module 'test/utils/Logger' {\n        /**\n           * The logger that is used internally\n           */\n        export class Logger {\n            constructor(service: string);\n            debug(method: string, ...args: any[]): void;\n            log(method: string, ...args: any[]): void;\n            warn(method: string, ...args: any[]): void;\n            error(method: string, ...args: any[]): void;\n        }\n    }\n    \n    module 'test/utils/platform' {\n        export const testUserAgent: (win: Window, expr: RegExp) => boolean;\n        export const isMobile: (win: Window) => boolean;\n        export const isIOS: (win: Window) => boolean;\n        export const isAndroid: (win: Window) => boolean;\n        export const isDesktop: (win: Window) => boolean;\n    }\n    \n    module 'test/utils/qr' {\n        /**\n           * Convert data to a QR code\n           *\n           * @param payload The data to be encoded as a QR code\n           * @param type How the QR code will be encoded\n           */\n        export const getQrData: (payload: string, type?: \"data\" | \"svg\" | \"ascii\" | undefined) => string;\n    }\n    \n    module 'test/utils/replace-in-template' {\n        export const replaceInTemplate: (text: string, placeholder: string, value: string) => string;\n    }\n    \n    module 'test/utils/shorten-string' {\n        export const shortenString: (text: string) => string;\n    }\n    \n    module 'test/utils/tezblock-blockexplorer' {\n        import { Network, NetworkType } from 'test/';\n        import { BlockExplorer } from 'test/utils/block-explorer';\n        export class TezblockBlockExplorer extends BlockExplorer {\n            readonly rpcUrls: {\n                [key in NetworkType]: string;\n            };\n            constructor(rpcUrls?: {\n                [key in NetworkType]: string;\n            });\n            getAddressLink(address: string, network: Network): Promise<string>;\n            getTransactionLink(transactionId: string, network: Network): Promise<string>;\n        }\n    }\n    \n    module 'test/utils/utils' {\n        /**\n           * A helper function to improve typings of object keys\n           *\n           * @param obj Object\n           */\n        export function keys<O extends object>(obj: O): (keyof O)[];\n    }\n    \n    module 'test/' {\n        import { P2PCommunicationClient } from 'test/transports/clients/P2PCommunicationClient';\n        import { AppMetadata } from 'test/types/beacon/AppMetadata';\n        import { PermissionRequest } from 'test/types/beacon/messages/PermissionRequest';\n        import { Network } from 'test/types/beacon/Network';\n        import { BeaconBaseMessage } from 'test/types/beacon/BeaconBaseMessage';\n        import { BeaconMessageType } from 'test/types/beacon/BeaconMessageType';\n        import { PermissionScope } from 'test/types/beacon/PermissionScope';\n        import { PermissionResponse } from 'test/types/beacon/messages/PermissionResponse';\n        import { OperationRequest } from 'test/types/beacon/messages/OperationRequest';\n        import { OperationResponse } from 'test/types/beacon/messages/OperationResponse';\n        import { SignPayloadRequest } from 'test/types/beacon/messages/SignPayloadRequest';\n        import { SignPayloadResponse } from 'test/types/beacon/messages/SignPayloadResponse';\n        import { BroadcastRequest } from 'test/types/beacon/messages/BroadcastRequest';\n        import { BroadcastResponse } from 'test/types/beacon/messages/BroadcastResponse';\n        import { NetworkType } from 'test/types/beacon/NetworkType';\n        import { TezosBaseOperation } from 'test/types/tezos/TezosBaseOperation';\n        import { TezosOperationType } from 'test/types/tezos/OperationTypes';\n        import { TezosActivateAccountOperation } from 'test/types/tezos/operations/ActivateAccount';\n        import { TezosBallotOperation } from 'test/types/tezos/operations/Ballot';\n        import { TezosDelegationOperation } from 'test/types/tezos/operations/Delegation';\n        import { TezosDoubleBakingEvidenceOperation } from 'test/types/tezos/operations/DoubleBakingEvidence';\n        import { TezosBlockHeader } from 'test/types/tezos/TezosBlockHeader';\n        import { TezosDoubleEndorsementEvidenceOperation } from 'test/types/tezos/operations/DoubleEndorsementEvidence';\n        import { TezosEndorsementOperation } from 'test/types/tezos/operations/Endorsement';\n        import { TezosOriginationOperation } from 'test/types/tezos/operations/Origination';\n        import { TezosProposalOperation } from 'test/types/tezos/operations/Proposal';\n        import { TezosRevealOperation } from 'test/types/tezos/operations/Reveal';\n        import { TezosSeedNonceRevelationOperation } from 'test/types/tezos/operations/SeedNonceRevelation';\n        import { TezosTransactionOperation } from 'test/types/tezos/operations/Transaction';\n        import { MichelsonPrimitives } from 'test/types/tezos/MichelsonPrimitives';\n        import { TezosTransactionParameters } from 'test/types/tezos/TezosTransactionParameters';\n        import { Origin } from 'test/types/Origin';\n        import { AccountInfo, AccountIdentifier } from 'test/types/AccountInfo';\n        import { EncryptedExtensionMessage, ExtensionMessage } from 'test/types/ExtensionMessage';\n        import { ExtensionMessageTarget } from 'test/types/ExtensionMessageTarget';\n        import { TezosOperation } from 'test/types/tezos/TezosOperation';\n        import { Client } from 'test/clients/client/Client';\n        import { WalletClient } from 'test/clients/wallet-client/WalletClient';\n        import { DAppClient } from 'test/clients/dapp-client/DAppClient';\n        import { BeaconError } from 'test/errors/BeaconError';\n        import { BeaconErrorType } from 'test/types/BeaconErrorType';\n        import { BroadcastBeaconError } from 'test/errors/BroadcastBeaconError';\n        import { NetworkNotSupportedBeaconError } from 'test/errors/NetworkNotSupportedBeaconError';\n        import { NoAddressBeaconError } from 'test/errors/NoAddressBeaconError';\n        import { NoPrivateKeyBeaconError } from 'test/errors/NoPrivateKeyBeaconError';\n        import { NotGrantedBeaconError } from 'test/errors/NotGrantedBeaconError';\n        import { ParametersInvalidBeaconError } from 'test/errors/ParametersInvalidBeaconError';\n        import { TooManyOperationsBeaconError } from 'test/errors/TooManyOperationsBeaconError';\n        import { TransactionInvalidBeaconError } from 'test/errors/TransactionInvalidBeaconError';\n        import { UnknownBeaconError } from 'test/errors/UnknownBeaconError';\n        import { ErrorResponse } from 'test/types/beacon/messages/ErrorResponse';\n        import { TransportStatus } from 'test/types/transport/TransportStatus';\n        import { TransportType } from 'test/types/transport/TransportType';\n        import { PostMessageTransport } from 'test/transports/PostMessageTransport';\n        import { Transport } from 'test/transports/Transport';\n        import { P2PTransport } from 'test/transports/P2PTransport';\n        import { Storage } from 'test/storage/Storage';\n        import { StorageKey } from 'test/types/storage/StorageKey';\n        import { StorageKeyReturnDefaults } from 'test/types/storage/StorageKeyReturnDefaults';\n        import { StorageKeyReturnType } from 'test/types/storage/StorageKeyReturnType';\n        import { ExtendedP2PPairingRequest, P2PPairingRequest } from 'test/types/P2PPairingRequest';\n        import { ChromeStorage } from 'test/storage/ChromeStorage';\n        import { LocalStorage } from 'test/storage/LocalStorage';\n        import { getStorage } from 'test/storage/getStorage';\n        import { BeaconMessage } from 'test/types/beacon/BeaconMessage';\n        import { Serializer } from 'test/Serializer';\n        import { RequestPermissionInput } from 'test/types/RequestPermissionInput';\n        import { RequestSignPayloadInput } from 'test/types/RequestSignPayloadInput';\n        import { RequestOperationInput } from 'test/types/RequestOperationInput';\n        import { RequestBroadcastInput } from 'test/types/RequestBroadcastInput';\n        import { PermissionResponseInput, SignPayloadResponseInput, OperationResponseInput, BroadcastResponseInput, BeaconResponseInputMessage, AcknowledgeResponseInput, ErrorResponseInput } from 'test/types/beacon/messages/BeaconResponseInputMessage';\n        import { PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, BeaconResponseOutputMessage } from 'test/types/beacon/messages/BeaconResponseOutputMessage';\n        import { PermissionRequestInput, SignPayloadRequestInput, OperationRequestInput, BroadcastRequestInput, BeaconRequestInputMessage } from 'test/types/beacon/messages/BeaconRequestInputMessage';\n        import { PermissionRequestOutput, SignPayloadRequestOutput, OperationRequestOutput, BroadcastRequestOutput, BeaconRequestOutputMessage } from 'test/types/beacon/messages/BeaconRequestOutputMessage';\n        import { ClientOptions } from 'test/clients/client/ClientOptions';\n        import { DAppClientOptions } from 'test/clients/dapp-client/DAppClientOptions';\n        import { WalletClientOptions } from 'test/clients/wallet-client/WalletClientOptions';\n        import { PermissionInfo } from 'test/types/PermissionInfo';\n        import { SDK_VERSION, BEACON_VERSION } from 'test/constants';\n        import { AccountManager } from 'test/managers/AccountManager';\n        import { AppMetadataManager } from 'test/managers/AppMetadataManager';\n        import { PermissionManager } from 'test/managers/PermissionManager';\n        import { BeaconEvent, BeaconEventHandler, defaultEventCallbacks } from 'test/events';\n        import { getAddressFromPublicKey } from 'test/utils/crypto';\n        import { BeaconClient } from 'test/clients/beacon-client/BeaconClient';\n        import { BeaconClientOptions } from 'test/clients/beacon-client/BeaconClientOptions';\n        import { getAccountIdentifier } from 'test/utils/get-account-identifier';\n        import { ConnectionContext } from 'test/types/ConnectionContext';\n        import { Threshold } from 'test/types/beacon/Threshold';\n        import { PartialTezosTransactionOperation, PartialTezosOperation, PartialTezosDelegationOperation, PartialTezosOriginationOperation, PartialTezosRevealOperation } from 'test/types/tezos/PartialTezosOperation';\n        import { AbortedBeaconError } from 'test/errors/AbortedBeaconError';\n        import { ExtendedPeerInfo, PeerInfo } from 'test/types/PeerInfo';\n        import { availableTransports } from 'test/utils/available-transports';\n        import { AcknowledgeResponse } from 'test/types/beacon/messages/AcknowledgeResponse';\n        import { DisconnectMessage } from 'test/types/beacon/messages/DisconnectMessage';\n        import { DappP2PTransport } from 'test/transports/DappP2PTransport';\n        import { DappPostMessageTransport } from 'test/transports/DappPostMessageTransport';\n        import { WalletP2PTransport } from 'test/transports/WalletP2PTransport';\n        import { WalletPostMessageTransport } from 'test/transports/WalletPostMessageTransport';\n        import { getSenderId } from 'test/utils/get-sender-id';\n        import { SigningType } from 'test/types/beacon/SigningType';\n        import { SignatureTypeNotSupportedBeaconError } from 'test/errors/SignatureTypeNotSupportedBeaconError';\n        import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n        import { ExtendedPostMessagePairingRequest, PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n        import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n        import { PeerManager } from 'test/managers/PeerManager';\n        import { MessageBasedClient } from 'test/transports/clients/MessageBasedClient';\n        import { BeaconRequestMessage } from 'test/types/beacon/BeaconRequestMessage';\n        import { BeaconResponseMessage } from 'test/types/beacon/BeaconResponseMessage';\n        import { Pairing } from 'test/ui/alert/Pairing';\n        import { BlockExplorer } from 'test/utils/block-explorer';\n        import { TezblockBlockExplorer } from 'test/utils/tezblock-blockexplorer';\n        import { setDebugEnabled, getDebugEnabled } from 'test/debug';\n        import { ColorMode } from 'test/types/ColorMode';\n        export { TezosBaseOperation, TezosOperationType, TezosBlockHeader, MichelsonPrimitives, TezosTransactionParameters, TezosOperation };\n        export { TezosActivateAccountOperation, TezosBallotOperation, TezosDelegationOperation, TezosDoubleBakingEvidenceOperation, TezosDoubleEndorsementEvidenceOperation, TezosEndorsementOperation, TezosOriginationOperation, TezosProposalOperation, TezosRevealOperation, TezosSeedNonceRevelationOperation, TezosTransactionOperation, PartialTezosOperation, PartialTezosTransactionOperation, PartialTezosDelegationOperation, PartialTezosOriginationOperation, PartialTezosRevealOperation };\n        export { BeaconClient, BeaconClientOptions, Client, ClientOptions, DAppClient, DAppClientOptions, WalletClient, WalletClientOptions, P2PCommunicationClient };\n        export { AccountIdentifier, AppMetadata, Network, NetworkType, BeaconMessage, PermissionRequest, PermissionResponse, OperationRequest, OperationResponse, SignPayloadRequest, SignPayloadResponse, BroadcastRequest, BroadcastResponse, AcknowledgeResponse, DisconnectMessage, BeaconBaseMessage, BeaconMessageType, PermissionScope, Origin, AccountInfo, Threshold, SigningType, ExtensionMessageTarget, ExtensionMessage, EncryptedExtensionMessage, RequestPermissionInput, RequestSignPayloadInput, RequestOperationInput, RequestBroadcastInput, PermissionInfo };\n        export { PermissionResponseInput, SignPayloadResponseInput, OperationResponseInput, BroadcastResponseInput, AcknowledgeResponseInput, ErrorResponseInput, PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, PermissionRequestInput, SignPayloadRequestInput, OperationRequestInput, BroadcastRequestInput, PermissionRequestOutput, SignPayloadRequestOutput, OperationRequestOutput, BroadcastRequestOutput, BeaconRequestInputMessage, BeaconRequestOutputMessage, BeaconResponseInputMessage, BeaconResponseOutputMessage, BeaconRequestMessage, BeaconResponseMessage };\n        export { BeaconError, BeaconErrorType, ErrorResponse, AbortedBeaconError, BroadcastBeaconError, NetworkNotSupportedBeaconError, NoAddressBeaconError, NoPrivateKeyBeaconError, NotGrantedBeaconError, ParametersInvalidBeaconError, TooManyOperationsBeaconError, TransactionInvalidBeaconError, SignatureTypeNotSupportedBeaconError, UnknownBeaconError };\n        export { TransportStatus, TransportType, Transport, PostMessageTransport, P2PTransport, WalletP2PTransport, WalletPostMessageTransport, DappP2PTransport, DappPostMessageTransport, MessageBasedClient, Pairing };\n        export { BeaconEvent, BeaconEventHandler, defaultEventCallbacks };\n        export { Storage, StorageKey, StorageKeyReturnDefaults, StorageKeyReturnType, ChromeStorage, LocalStorage, getStorage };\n        export { PeerManager, AccountManager, AppMetadataManager, PermissionManager };\n        export { SDK_VERSION, BEACON_VERSION };\n        export { getSenderId, getAccountIdentifier, getAddressFromPublicKey };\n        export { PeerInfo, ExtendedPeerInfo, PostMessagePairingRequest, ExtendedPostMessagePairingRequest, ExtendedPostMessagePairingResponse, P2PPairingRequest, ExtendedP2PPairingRequest, ExtendedP2PPairingResponse };\n        export { BlockExplorer, TezblockBlockExplorer };\n        export { ConnectionContext, Serializer, availableTransports, ColorMode };\n        export { setDebugEnabled, getDebugEnabled };\n    }\n}\n\ndeclare module 'beacon/Serializer' {\n    /**\n      * The Serializer is used to serialize / deserialize JSON objects and encode them with bs58check\n      */\n    export class Serializer {\n        /**\n          * Serialize and bs58check encode an object\n          *\n          * @param message JSON object to serialize\n          */\n        serialize(message: unknown): Promise<string>;\n        /**\n          * Deserialize a bs58check encoded string\n          *\n          * @param encoded String to be deserialized\n          */\n        deserialize(encoded: string): Promise<unknown>;\n    }\n}\n\ndeclare module 'beacon/storage/ChromeStorage' {\n    import { Storage, StorageKey, StorageKeyReturnType } from 'beacon/';\n    export class ChromeStorage implements Storage {\n        static isSupported(): Promise<boolean>;\n        get<K extends StorageKey>(key: K): Promise<StorageKeyReturnType[K]>;\n        set<K extends StorageKey>(key: K, value: StorageKeyReturnType[K]): Promise<void>;\n        delete<K extends StorageKey>(key: K): Promise<void>;\n    }\n}\n\ndeclare module 'beacon/storage/getStorage' {\n    import { Storage } from 'beacon/';\n    /**\n      * Get a supported storage on this platform\n      */\n    export const getStorage: () => Promise<Storage>;\n}\n\ndeclare module 'beacon/storage/LocalStorage' {\n    import { Storage, StorageKey, StorageKeyReturnType } from 'beacon/';\n    export class LocalStorage implements Storage {\n        constructor(prefix?: string | undefined);\n        static isSupported(): Promise<boolean>;\n        get<K extends StorageKey>(key: K): Promise<StorageKeyReturnType[K]>;\n        set<K extends StorageKey>(key: K, value: StorageKeyReturnType[K]): Promise<void>;\n        delete<K extends StorageKey>(key: K): Promise<void>;\n    }\n}\n\ndeclare module 'beacon/storage/Storage' {\n    import { StorageKey } from 'beacon/types/storage/StorageKey';\n    import { StorageKeyReturnType } from 'beacon/types/storage/StorageKeyReturnType';\n    /**\n      * The storage used in the SDK\n      */\n    export abstract class Storage {\n        /**\n          * Returns a promise that resolves to true if the storage option is available on this platform.\n          */\n        static isSupported(): Promise<boolean>;\n        /**\n          * Gets a value from storage and returns it\n          *\n          * @param key The storage key\n          */\n        abstract get<K extends StorageKey>(key: K): Promise<StorageKeyReturnType[K]>;\n        /**\n          * Sets a value in the storage and persist it\n          *\n          * @param key The storage key\n          * @param value The value to be persisted\n          */\n        abstract set<K extends StorageKey>(key: K, value: StorageKeyReturnType[K]): Promise<void>;\n        /**\n          * Delete a key from storage\n          *\n          * @param key The storage key\n          */\n        abstract delete<K extends StorageKey>(key: K): Promise<void>;\n    }\n}\n\ndeclare module 'beacon/test' {\n    \n    export * from 'test/beacon-message-events';\n    export * from 'test/clients/beacon-client/BeaconClient';\n    export * from 'test/clients/beacon-client/BeaconClientOptions';\n    export * from 'test/clients/client/Client';\n    export * from 'test/clients/client/ClientOptions';\n    export * from 'test/clients/dapp-client/DAppClient';\n    export * from 'test/clients/dapp-client/DAppClientOptions';\n    export * from 'test/clients/wallet-client/WalletClient';\n    export * from 'test/clients/wallet-client/WalletClientOptions';\n    export * from 'test/colorMode';\n    export * from 'test/constants';\n    export * from 'test/debug';\n    export * from 'test/errors/AbortedBeaconError';\n    export * from 'test/errors/BeaconError';\n    export * from 'test/errors/BroadcastBeaconError';\n    export * from 'test/errors/NetworkNotSupportedBeaconError';\n    export * from 'test/errors/NoAddressBeaconError';\n    export * from 'test/errors/NoPrivateKeyBeaconError';\n    export * from 'test/errors/NotGrantedBeaconError';\n    export * from 'test/errors/ParametersInvalidBeaconError';\n    export * from 'test/errors/SignatureTypeNotSupportedBeaconError';\n    export * from 'test/errors/TooManyOperationsBeaconError';\n    export * from 'test/errors/TransactionInvalidBeaconError';\n    export * from 'test/errors/UnknownBeaconError';\n    export * from 'test/events';\n    export * from 'test/examples/broadcast-request';\n    export * from 'test/examples/custom-block-explorer';\n    export * from 'test/examples/disable-all-ui';\n    export * from 'test/examples/operation-request';\n    export * from 'test/examples/override-default-events';\n    export * from 'test/examples/permission-request';\n    export * from 'test/examples/sign-payload-request';\n    export * from 'test/examples/using-custom-network';\n    export * from 'test/examples/wallet-example';\n    export * from 'test/index';\n    export * from 'test/interceptors/IncomingRequestInterceptor';\n    export * from 'test/interceptors/OutgoingResponseInterceptor';\n    export * from 'test/managers/AccountManager';\n    export * from 'test/managers/AppMetadataManager';\n    export * from 'test/managers/PeerManager';\n    export * from 'test/managers/PermissionManager';\n    export * from 'test/managers/PermissionValidator';\n    export * from 'test/managers/StorageManager';\n    export * from 'test/matrix-client/MatrixClient';\n    export * from 'test/matrix-client/MatrixClientEventEmitter';\n    export * from 'test/matrix-client/MatrixClientStore';\n    export * from 'test/matrix-client/MatrixHttpClient';\n    export * from 'test/matrix-client/models/api/MatrixEventSend';\n    export * from 'test/matrix-client/models/api/MatrixLogin';\n    export * from 'test/matrix-client/models/api/MatrixRequest';\n    export * from 'test/matrix-client/models/api/MatrixRoomCreate';\n    export * from 'test/matrix-client/models/api/MatrixRoomInvite';\n    export * from 'test/matrix-client/models/api/MatrixRoomJoin';\n    export * from 'test/matrix-client/models/api/MatrixSync';\n    export * from 'test/matrix-client/models/MatrixClientEvent';\n    export * from 'test/matrix-client/models/MatrixMessage';\n    export * from 'test/matrix-client/models/MatrixRoom';\n    export * from 'test/matrix-client/models/MatrixStateEvent';\n    export * from 'test/matrix-client/services/MatrixEventService';\n    export * from 'test/matrix-client/services/MatrixRoomService';\n    export * from 'test/matrix-client/services/MatrixUserService';\n    export * from 'test/matrix-client/utils/events';\n    export * from 'test/migrations/migrate-0.7.0';\n    export * from 'test/migrations/migrations';\n    export * from 'test/MockWindow';\n    export * from 'test/Serializer';\n    export * from 'test/storage/ChromeStorage';\n    export * from 'test/storage/getStorage';\n    export * from 'test/storage/LocalStorage';\n    export * from 'test/storage/Storage';\n    export * from 'test/test';\n    export * from 'test/transports/clients/CommunicationClient';\n    export * from 'test/transports/clients/MessageBasedClient';\n    export * from 'test/transports/clients/P2PCommunicationClient';\n    export * from 'test/transports/clients/PostMessageClient';\n    export * from 'test/transports/DappP2PTransport';\n    export * from 'test/transports/DappPostMessageTransport';\n    export * from 'test/transports/P2PTransport';\n    export * from 'test/transports/PostMessageTransport';\n    export * from 'test/transports/Transport';\n    export * from 'test/transports/WalletP2PTransport';\n    export * from 'test/transports/WalletPostMessageTransport';\n    export * from 'test/types/AccountInfo';\n    export * from 'test/types/beacon/AppMetadata';\n    export * from 'test/types/beacon/BeaconBaseMessage';\n    export * from 'test/types/beacon/BeaconMessage';\n    export * from 'test/types/beacon/BeaconMessageType';\n    export * from 'test/types/beacon/BeaconRequestMessage';\n    export * from 'test/types/beacon/BeaconResponseMessage';\n    export * from 'test/types/beacon/messages/AcknowledgeResponse';\n    export * from 'test/types/beacon/messages/BeaconRequestInputMessage';\n    export * from 'test/types/beacon/messages/BeaconRequestOutputMessage';\n    export * from 'test/types/beacon/messages/BeaconResponseInputMessage';\n    export * from 'test/types/beacon/messages/BeaconResponseOutputMessage';\n    export * from 'test/types/beacon/messages/BroadcastRequest';\n    export * from 'test/types/beacon/messages/BroadcastResponse';\n    export * from 'test/types/beacon/messages/DisconnectMessage';\n    export * from 'test/types/beacon/messages/ErrorResponse';\n    export * from 'test/types/beacon/messages/OperationRequest';\n    export * from 'test/types/beacon/messages/OperationResponse';\n    export * from 'test/types/beacon/messages/PermissionRequest';\n    export * from 'test/types/beacon/messages/PermissionResponse';\n    export * from 'test/types/beacon/messages/SignPayloadRequest';\n    export * from 'test/types/beacon/messages/SignPayloadResponse';\n    export * from 'test/types/beacon/Network';\n    export * from 'test/types/beacon/NetworkType';\n    export * from 'test/types/beacon/PermissionScope';\n    export * from 'test/types/beacon/SigningType';\n    export * from 'test/types/beacon/Threshold';\n    export * from 'test/types/BeaconErrorType';\n    export * from 'test/types/ColorMode';\n    export * from 'test/types/ConnectionContext';\n    export * from 'test/types/Extension';\n    export * from 'test/types/ExtensionMessage';\n    export * from 'test/types/ExtensionMessageTarget';\n    export * from 'test/types/Origin';\n    export * from 'test/types/P2PPairingRequest';\n    export * from 'test/types/P2PPairingResponse';\n    export * from 'test/types/PeerInfo';\n    export * from 'test/types/PermissionEntity';\n    export * from 'test/types/PermissionInfo';\n    export * from 'test/types/PostMessagePairingRequest';\n    export * from 'test/types/PostMessagePairingResponse';\n    export * from 'test/types/RequestBroadcastInput';\n    export * from 'test/types/RequestOperationInput';\n    export * from 'test/types/RequestPermissionInput';\n    export * from 'test/types/RequestSignPayloadInput';\n    export * from 'test/types/storage/StorageKey';\n    export * from 'test/types/storage/StorageKeyReturnDefaults';\n    export * from 'test/types/storage/StorageKeyReturnType';\n    export * from 'test/types/tezos/MichelineMichelsonV1Expression';\n    export * from 'test/types/tezos/MichelsonPrimitives';\n    export * from 'test/types/tezos/operations/ActivateAccount';\n    export * from 'test/types/tezos/operations/Ballot';\n    export * from 'test/types/tezos/operations/Delegation';\n    export * from 'test/types/tezos/operations/DoubleBakingEvidence';\n    export * from 'test/types/tezos/operations/DoubleEndorsementEvidence';\n    export * from 'test/types/tezos/operations/Endorsement';\n    export * from 'test/types/tezos/operations/Origination';\n    export * from 'test/types/tezos/operations/Proposal';\n    export * from 'test/types/tezos/operations/Reveal';\n    export * from 'test/types/tezos/operations/SeedNonceRevelation';\n    export * from 'test/types/tezos/operations/Transaction';\n    export * from 'test/types/tezos/OperationTypes';\n    export * from 'test/types/tezos/PartialTezosOperation';\n    export * from 'test/types/tezos/TezosBaseOperation';\n    export * from 'test/types/tezos/TezosBlockHeader';\n    export * from 'test/types/tezos/TezosOperation';\n    export * from 'test/types/tezos/TezosTransactionParameters';\n    export * from 'test/types/transport/TransportStatus';\n    export * from 'test/types/transport/TransportType';\n    export * from 'test/ui/alert/alert-templates';\n    export * from 'test/ui/alert/Alert';\n    export * from 'test/ui/alert/Pairing';\n    export * from 'test/ui/alert/PairingAlert';\n    export * from 'test/ui/alert/wallet-lists';\n    export * from 'test/ui/toast/toast-templates';\n    export * from 'test/ui/toast/Toast';\n    export * from 'test/utils/assert-never';\n    export * from 'test/utils/available-transports';\n    export * from 'test/utils/block-explorer';\n    export * from 'test/utils/crypto';\n    export * from 'test/utils/exposed-promise';\n    export * from 'test/utils/generate-uuid';\n    export * from 'test/utils/get-account-identifier';\n    export * from 'test/utils/get-sender-id';\n    export * from 'test/utils/get-tzip10-link';\n    export * from 'test/utils/Logger';\n    export * from 'test/utils/platform';\n    export * from 'test/utils/qr';\n    export * from 'test/utils/replace-in-template';\n    export * from 'test/utils/shorten-string';\n    export * from 'test/utils/tezblock-blockexplorer';\n    export * from 'test/utils/utils';\n    \n    module 'test/beacon-message-events' {\n        import { BeaconEvent } from 'test/events';\n        import { BeaconMessageType } from 'test/';\n        export const messageEvents: {\n            [key in BeaconMessageType]: {\n                sent: BeaconEvent;\n                success: BeaconEvent;\n                error: BeaconEvent;\n            };\n        };\n    }\n    \n    module 'test/clients/beacon-client/BeaconClient' {\n        import * as sodium from 'libsodium-wrappers';\n        import { ExposedPromise } from 'test/utils/exposed-promise';\n        import { Storage } from 'test/';\n        import { BeaconEventHandler } from 'test/events';\n        import { BeaconClientOptions } from 'test/clients/beacon-client/BeaconClientOptions';\n        /**\n             * The beacon client is an abstract client that handles everything that is shared between all other clients.\n             * Specifically, it handles managing the beaconId and and the local keypair.\n             */\n        export abstract class BeaconClient {\n                /**\n                     * The name of the client\n                     */\n                readonly name: string;\n                /**\n                     * The URL of the dApp Icon. This can be used to display the icon of the dApp on in the wallet\n                     */\n                readonly iconUrl?: string;\n                /**\n                     * The URL of the dApp.\n                     */\n                readonly appUrl?: string;\n                /** The beaconId is a public key that is used to identify one specific application (dapp or wallet).\n                     * This is used inside a message to specify the sender, for example.\n                     */\n                protected _beaconId: ExposedPromise<string>;\n                get beaconId(): Promise<string>;\n                protected storage: Storage;\n                protected readonly events: BeaconEventHandler;\n                /**\n                     * The local keypair that is used for the communication encryption\n                     */\n                protected _keyPair: ExposedPromise<sodium.KeyPair>;\n                protected get keyPair(): Promise<sodium.KeyPair>;\n                constructor(config: BeaconClientOptions);\n                /**\n                     * This resets the SDK. After using this method, this instance is no longer usable. You will have to instanciate a new client.\n                     */\n                destroy(): Promise<void>;\n        }\n    }\n    \n    module 'test/clients/beacon-client/BeaconClientOptions' {\n        import { Storage } from 'test/';\n        export interface BeaconClientOptions {\n                /**\n                     * Name of the application\n                     */\n                name: string;\n                /**\n                     * A URL to the icon of the application\n                     */\n                iconUrl?: string;\n                /**\n                     * A URL to the website of the application\n                     */\n                appUrl?: string;\n                /**\n                     * The storage that will be used by the SDK\n                     */\n                storage: Storage;\n        }\n    }\n    \n    module 'test/clients/client/Client' {\n        import { ExposedPromise } from 'test/utils/exposed-promise';\n        import { ConnectionContext } from 'test/types/ConnectionContext';\n        import { TransportType, TransportStatus, AccountInfo, PeerInfo, Transport, AppMetadata } from 'test/';\n        import { BeaconEventHandler } from 'test/events';\n        import { BeaconClient } from 'test/clients/beacon-client/BeaconClient';\n        import { AccountManager } from 'test/managers/AccountManager';\n        import { BeaconRequestMessage } from 'test/types/beacon/BeaconRequestMessage';\n        import { ClientOptions } from 'test/clients/client/ClientOptions';\n        /**\n             * This abstract class handles the a big part of the logic that is shared between the dapp and wallet client.\n             * For example, it selects and manages the transport and accounts.\n             */\n        export abstract class Client extends BeaconClient {\n                protected readonly accountManager: AccountManager;\n                protected handleResponse: (_event: BeaconRequestMessage, connectionInfo: ConnectionContext) => void;\n                /**\n                     * How many requests can be sent after another\n                     */\n                protected readonly rateLimit: number;\n                /**\n                     * The time window in seconds in which the \"rateLimit\" is checked\n                     */\n                protected readonly rateLimitWindowInSeconds: number;\n                /**\n                     * Stores the times when requests have been made to determine if the rate limit has been reached\n                     */\n                protected requestCounter: number[];\n                protected readonly events: BeaconEventHandler;\n                protected readonly matrixNodes: string[];\n                protected _transport: ExposedPromise<Transport<any>>;\n                protected get transport(): Promise<Transport<any>>;\n                /**\n                     * Returns the connection status of the Client\n                     */\n                get connectionStatus(): TransportStatus;\n                /**\n                     * Returns whether or not the transaport is ready\n                     */\n                get ready(): Promise<void>;\n                constructor(config: ClientOptions);\n                /**\n                     * Return all locally known accounts\n                     */\n                getAccounts(): Promise<AccountInfo[]>;\n                /**\n                     * Return the account by ID\n                     * @param accountIdentifier The ID of an account\n                     */\n                getAccount(accountIdentifier: string): Promise<AccountInfo | undefined>;\n                /**\n                     * Remove the account by ID\n                     * @param accountIdentifier The ID of an account\n                     */\n                removeAccount(accountIdentifier: string): Promise<void>;\n                /**\n                     * Remove all locally stored accounts\n                     */\n                removeAllAccounts(): Promise<void>;\n                /**\n                     * Add a new request (current timestamp) to the pending requests, remove old ones and check if we are above the limit\n                     */\n                addRequestAndCheckIfRateLimited(): Promise<boolean>;\n                /**\n                     * This method initializes the client. It will check if the connection should be established to a\n                     * browser extension or if the P2P transport should be used.\n                     *\n                     * @param transport A transport that can be provided by the user\n                     */\n                init(transport: Transport<any>): Promise<TransportType>;\n                /**\n                     * Returns the metadata of this DApp\n                     */\n                getOwnAppMetadata(): Promise<AppMetadata>;\n                /**\n                     * Return all known peers\n                     */\n                getPeers(): Promise<PeerInfo[]>;\n                /**\n                     * Add a new peer to the known peers\n                     * @param peer The new peer to add\n                     */\n                addPeer(peer: PeerInfo): Promise<void>;\n                /**\n                     * A \"setter\" for when the transport needs to be changed.\n                     */\n                protected setTransport(transport?: Transport<any>): Promise<void>;\n                protected addListener(transport: Transport<any>): Promise<void>;\n                protected sendDisconnectToPeer(peer: PeerInfo, transport?: Transport<any>): Promise<void>;\n        }\n    }\n    \n    module 'test/clients/client/ClientOptions' {\n        import { Storage } from 'test/';\n        import { BeaconEvent, BeaconEventHandlerFunction, BeaconEventType } from 'test/events';\n        export interface ClientOptions {\n                /**\n                     * Name of the application\n                     */\n                name: string;\n                /**\n                     * A URL to the icon of the application\n                     */\n                iconUrl?: string;\n                /**\n                     * A URL to the website of the application\n                     */\n                appUrl?: string;\n                /**\n                     * The storage that will be used by the SDK\n                     */\n                storage: Storage;\n                /**\n                     * An object that will be used to overwrite default event handler behaviour.\n                     *\n                     * If you plan to overwrite all default events, use \"disableDefaultEvents\" instead.\n                     *\n                     * This will overwrite the default event handler, so this can lead to unexpected behavior in some cases.\n                     * We recommend that you overwrite all handlers if you want to use your own UI.\n                     *\n                     * If you simply want to be notified of events happening, but do not want to overwrite the default behavior,\n                     * please use `subscribeToEvent()` on the DAppClient instead.\n                     */\n                eventHandlers?: {\n                        [key in BeaconEvent]?: {\n                                handler: BeaconEventHandlerFunction<BeaconEventType[key]>;\n                        };\n                };\n                /**\n                     * Disable all default Events and UI elements. If passed together with \"eventHandlers\",\n                     * the default eventHandlers will be removed, and the ones passed by the user will be added.\n                     */\n                disableDefaultEvents?: boolean;\n                /**\n                     * A list of matrix nodes to connect to. If a non-empty array is passed, the default options will be overwritten.\n                     * One node will be randomly selected based on the local keypair and the other nodes will be used as a fallback in case the primary node goes down.\n                     *\n                     * Only provide the hostname, no https:// prefix. Eg. ['matrix.example.com']\n                     */\n                matrixNodes?: string[];\n        }\n    }\n    \n    module 'test/clients/dapp-client/DAppClient' {\n        import { BeaconEvent, BeaconEventHandlerFunction, BeaconEventType } from 'test/events';\n        import { AccountInfo, Client, TransportType, BeaconMessageType, NetworkType, RequestPermissionInput, RequestSignPayloadInput, RequestOperationInput, RequestBroadcastInput, PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, Transport, DappP2PTransport, DappPostMessageTransport, AppMetadata } from 'test/';\n        import { BlockExplorer } from 'test/utils/block-explorer';\n        import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n        import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n        import { ExtendedPeerInfo } from 'test/types/PeerInfo';\n        import { ColorMode } from 'test/types/ColorMode';\n        import { DAppClientOptions } from 'test/clients/dapp-client/DAppClientOptions';\n        /**\n             * The DAppClient has to be used in decentralized applications. It handles all the logic related to connecting to beacon-compatible\n             * wallets and sending requests.\n             */\n        export class DAppClient extends Client {\n                /**\n                     * The block explorer used by the SDK\n                     */\n                readonly blockExplorer: BlockExplorer;\n                preferredNetwork: NetworkType;\n                protected postMessageTransport: DappPostMessageTransport | undefined;\n                protected p2pTransport: DappP2PTransport | undefined;\n                constructor(config: DAppClientOptions);\n                initInternalTransports(): Promise<void>;\n                init(transport?: Transport<any>): Promise<TransportType>;\n                /**\n                     * Returns the active account\n                     */\n                getActiveAccount(): Promise<AccountInfo | undefined>;\n                /**\n                     * Sets the active account\n                     *\n                     * @param account The account that will be set as the active account\n                     */\n                setActiveAccount(account?: AccountInfo): Promise<void>;\n                /**\n                     * Clear the active account\n                     */\n                clearActiveAccount(): Promise<void>;\n                setColorMode(colorMode: ColorMode): Promise<void>;\n                getColorMode(): Promise<ColorMode>;\n                /**\n                     * @deprecated\n                     *\n                     * Use getOwnAppMetadata instead\n                     */\n                getAppMetadata(): Promise<AppMetadata>;\n                /**\n                     * Will remove the account from the local storage and set a new active account if necessary.\n                     *\n                     * @param accountIdentifier ID of the account\n                     */\n                removeAccount(accountIdentifier: string): Promise<void>;\n                /**\n                     * Remove all accounts and set active account to undefined\n                     */\n                removeAllAccounts(): Promise<void>;\n                /**\n                     * Removes a peer and all the accounts that have been connected through that peer\n                     *\n                     * @param peer Peer to be removed\n                     */\n                removePeer(peer: ExtendedPeerInfo, sendDisconnectToPeer?: boolean): Promise<void>;\n                /**\n                     * Remove all peers and all accounts that have been connected through those peers\n                     */\n                removeAllPeers(sendDisconnectToPeers?: boolean): Promise<void>;\n                /**\n                     * Allows the user to subscribe to specific events that are fired in the SDK\n                     *\n                     * @param internalEvent The event to subscribe to\n                     * @param eventCallback The callback that will be called when the event occurs\n                     */\n                subscribeToEvent<K extends BeaconEvent>(internalEvent: K, eventCallback: BeaconEventHandlerFunction<BeaconEventType[K]>): Promise<void>;\n                /**\n                     * Check if we have permissions to send the specific message type to the active account.\n                     * If no active account is set, only permission requests are allowed.\n                     *\n                     * @param type The type of the message\n                     */\n                checkPermissions(type: BeaconMessageType): Promise<boolean>;\n                /**\n                     * Send a permission request to the DApp. This should be done as the first step. The wallet will respond\n                     * with an publicKey and permissions that were given. The account returned will be set as the \"activeAccount\"\n                     * and will be used for the following requests.\n                     *\n                     * @param input The message details we need to prepare the PermissionRequest message.\n                     */\n                requestPermissions(input?: RequestPermissionInput): Promise<PermissionResponseOutput>;\n                /**\n                     * This method will send a \"SignPayloadRequest\" to the wallet. This method is meant to be used to sign\n                     * arbitrary data (eg. a string). It will return the signature in the format of \"edsig...\"\n                     *\n                     * @param input The message details we need to prepare the SignPayloadRequest message.\n                     */\n                requestSignPayload(input: RequestSignPayloadInput): Promise<SignPayloadResponseOutput>;\n                /**\n                     * This method sends an OperationRequest to the wallet. This method should be used for all kinds of operations,\n                     * eg. transaction or delegation. Not all properties have to be provided. Data like \"counter\" and fees will be\n                     * fetched and calculated by the wallet (but they can still be provided if required).\n                     *\n                     * @param input The message details we need to prepare the OperationRequest message.\n                     */\n                requestOperation(input: RequestOperationInput): Promise<OperationResponseOutput>;\n                /**\n                     * Sends a \"BroadcastRequest\" to the wallet. This method can be used to inject an already signed transaction\n                     * to the network.\n                     *\n                     * @param input The message details we need to prepare the BroadcastRequest message.\n                     */\n                requestBroadcast(input: RequestBroadcastInput): Promise<BroadcastResponseOutput>;\n                protected setActivePeer(peer?: ExtendedPostMessagePairingResponse | ExtendedP2PPairingResponse): Promise<void>;\n                /**\n                     * A \"setter\" for when the transport needs to be changed.\n                     */\n                protected setTransport(transport?: Transport<any>): Promise<void>;\n        }\n    }\n    \n    module 'test/clients/dapp-client/DAppClientOptions' {\n        import { NetworkType, Storage } from 'test/';\n        import { BeaconEvent, BeaconEventType, BeaconEventHandlerFunction } from 'test/events';\n        import { ColorMode } from 'test/types/ColorMode';\n        import { BlockExplorer } from 'test/utils/block-explorer';\n        export interface DAppClientOptions {\n                /**\n                     * Name of the application\n                     */\n                name: string;\n                /**\n                     * A URL to the icon of the application\n                     */\n                iconUrl?: string;\n                /**\n                     * A URL to the website of the application\n                     */\n                appUrl?: string;\n                /**\n                     * The storage that will be used by the SDK\n                     */\n                storage?: Storage;\n                /**\n                     * An object that will be used to overwrite default event handler behaviour.\n                     *\n                     * If you plan to overwrite all default events, use \"disableDefaultEvents\" instead.\n                     *\n                     * This will overwrite the default event handler, so this can lead to unexpected behavior in some cases.\n                     * We recommend that you overwrite all handlers if you want to use your own UI.\n                     *\n                     * If you simply want to be notified of events happening, but do not want to overwrite the default behavior,\n                     * please use `subscribeToEvent()` on the DAppClient instead.\n                     */\n                eventHandlers?: {\n                        [key in BeaconEvent]?: {\n                                handler: BeaconEventHandlerFunction<BeaconEventType[key]>;\n                        };\n                };\n                /**\n                     * Disable all default Events and UI elements. If passed together with \"eventHandlers\",\n                     * the default eventHandlers will be removed, and the ones passed by the user will be added.\n                     */\n                disableDefaultEvents?: boolean;\n                /**\n                     * A list of matrix nodes to connect to. If a non-empty array is passed, the default options will be overwritten.\n                     * One node will be randomly selected based on the local keypair and the other nodes will be used as a fallback in case the primary node goes down.\n                     *\n                     * Only provide the hostname, no https:// prefix. Eg. ['matrix.example.com']\n                     */\n                matrixNodes?: string[];\n                /**\n                     * The block explorer used by the SDK\n                     */\n                blockExplorer?: BlockExplorer;\n                /**\n                     * Indicates on which network the DApp is planning to run. This is currently used to adjust the URLs of web-wallets in the pairing alert if they use different URLs for testnets.\n                     * You will still have to define the network you intend to use during the permission request.\n                     */\n                preferredNetwork?: NetworkType;\n                /**\n                     * Set the color mode for the UI elements (alerts and toasts)\n                     */\n                colorMode?: ColorMode;\n        }\n    }\n    \n    module 'test/clients/wallet-client/WalletClient' {\n        import { Client, WalletClientOptions, TransportType, BeaconRequestOutputMessage, BeaconResponseInputMessage, AppMetadata, PermissionInfo } from 'test/';\n        import { ConnectionContext } from 'test/types/ConnectionContext';\n        import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n        import { ExposedPromise } from 'test/utils/exposed-promise';\n        import { PeerInfo } from 'test/types/PeerInfo';\n        /**\n             * The WalletClient has to be used in the wallet. It handles all the logic related to connecting to beacon-compatible\n             * dapps and handling/responding to requests.\n             */\n        export class WalletClient extends Client {\n                /**\n                     * Returns whether or not the transport is connected\n                     */\n                protected readonly _isConnected: ExposedPromise<boolean>;\n                get isConnected(): Promise<boolean>;\n                constructor(config: WalletClientOptions);\n                init(): Promise<TransportType>;\n                /**\n                     * This method initiates a connection to the P2P network and registers a callback that will be called\n                     * whenever a message is received.\n                     *\n                     * @param newMessageCallback The callback that will be invoked for every message the transport receives.\n                     */\n                connect(newMessageCallback: (message: BeaconRequestOutputMessage, connectionContext: ConnectionContext) => void): Promise<void>;\n                /**\n                     * The method will attempt to initiate a connection using the active transport.\n                     */\n                _connect(): Promise<void>;\n                /**\n                     * This method sends a response for a specific request back to the DApp\n                     *\n                     * @param message The BeaconResponseMessage that will be sent back to the DApp\n                     */\n                respond(message: BeaconResponseInputMessage): Promise<void>;\n                getAppMetadataList(): Promise<AppMetadata[]>;\n                getAppMetadata(senderId: string): Promise<AppMetadata | undefined>;\n                removeAppMetadata(senderId: string): Promise<void>;\n                removeAllAppMetadata(): Promise<void>;\n                getPermissions(): Promise<PermissionInfo[]>;\n                getPermission(accountIdentifier: string): Promise<PermissionInfo | undefined>;\n                removePermission(accountIdentifier: string): Promise<void>;\n                removeAllPermissions(): Promise<void>;\n                /**\n                     * Add a new peer to the known peers\n                     * @param peer The new peer to add\n                     */\n                addPeer(peer: PeerInfo): Promise<void>;\n                removePeer(peer: ExtendedP2PPairingResponse, sendDisconnectToPeer?: boolean): Promise<void>;\n                removeAllPeers(sendDisconnectToPeers?: boolean): Promise<void>;\n        }\n    }\n    \n    module 'test/clients/wallet-client/WalletClientOptions' {\n        import { Storage } from 'test/';\n        export interface WalletClientOptions {\n                /**\n                     * Name of the application\n                     */\n                name: string;\n                /**\n                     * A URL to the icon of the application\n                     */\n                iconUrl?: string;\n                /**\n                     * A URL to the website of the application\n                     */\n                appUrl?: string;\n                /**\n                     * The storage that will be used by the SDK\n                     */\n                storage?: Storage;\n                /**\n                     * A list of matrix nodes to connect to. If a non-empty array is passed, the default options will be overwritten.\n                     * One node will be randomly selected based on the local keypair and the other nodes will be used as a fallback in case the primary node goes down.\n                     *\n                     * Only provide the hostname, no https:// prefix. Eg. ['matrix.example.com']\n                     */\n                matrixNodes?: string[];\n        }\n    }\n    \n    module 'test/colorMode' {\n        import { ColorMode } from 'test/types/ColorMode';\n        export const setColorMode: (mode: ColorMode) => void;\n        export const getColorMode: () => ColorMode;\n    }\n    \n    module 'test/constants' {\n        export const SDK_VERSION: string;\n        export const BEACON_VERSION: string;\n    }\n    \n    module 'test/debug' {\n        export const setDebugEnabled: (enabled: boolean) => void;\n        export const getDebugEnabled: () => boolean;\n    }\n    \n    module 'test/errors/AbortedBeaconError' {\n        import { BeaconError } from 'test/';\n        export class AbortedBeaconError extends BeaconError {\n            name: string;\n            title: string;\n            constructor();\n        }\n    }\n    \n    module 'test/errors/BeaconError' {\n        import { BeaconErrorType } from 'test/';\n        export abstract class BeaconError implements Error {\n            name: string;\n            message: string;\n            title: string;\n            description: string;\n            get fullDescription(): string;\n            constructor(errorType: BeaconErrorType, message: string);\n            static getError(errorType: BeaconErrorType, errorData: any): BeaconError;\n        }\n    }\n    \n    module 'test/errors/BroadcastBeaconError' {\n        import { BeaconError } from 'test/';\n        export class BroadcastBeaconError extends BeaconError {\n            name: string;\n            title: string;\n            constructor();\n        }\n    }\n    \n    module 'test/errors/NetworkNotSupportedBeaconError' {\n        import { BeaconError } from 'test/';\n        export class NetworkNotSupportedBeaconError extends BeaconError {\n            name: string;\n            title: string;\n            constructor();\n        }\n    }\n    \n    module 'test/errors/NoAddressBeaconError' {\n        import { BeaconError } from 'test/';\n        export class NoAddressBeaconError extends BeaconError {\n            name: string;\n            title: string;\n            constructor();\n        }\n    }\n    \n    module 'test/errors/NoPrivateKeyBeaconError' {\n        import { BeaconError } from 'test/';\n        export class NoPrivateKeyBeaconError extends BeaconError {\n            name: string;\n            title: string;\n            constructor();\n        }\n    }\n    \n    module 'test/errors/NotGrantedBeaconError' {\n        import { BeaconError } from 'test/';\n        export class NotGrantedBeaconError extends BeaconError {\n            name: string;\n            title: string;\n            constructor();\n        }\n    }\n    \n    module 'test/errors/ParametersInvalidBeaconError' {\n        import { BeaconError } from 'test/';\n        export class ParametersInvalidBeaconError extends BeaconError {\n            name: string;\n            title: string;\n            constructor();\n        }\n    }\n    \n    module 'test/errors/SignatureTypeNotSupportedBeaconError' {\n        import { BeaconError } from 'test/';\n        export class SignatureTypeNotSupportedBeaconError extends BeaconError {\n            name: string;\n            title: string;\n            constructor();\n        }\n    }\n    \n    module 'test/errors/TooManyOperationsBeaconError' {\n        import { BeaconError } from 'test/';\n        export class TooManyOperationsBeaconError extends BeaconError {\n            name: string;\n            title: string;\n            constructor();\n        }\n    }\n    \n    module 'test/errors/TransactionInvalidBeaconError' {\n        import { BeaconError } from 'test/';\n        export class TransactionInvalidBeaconError extends BeaconError {\n            readonly data: any;\n            name: string;\n            title: string;\n            get fullDescription(): string;\n            constructor(data: any);\n        }\n    }\n    \n    module 'test/errors/UnknownBeaconError' {\n        import { BeaconError } from 'test/';\n        export class UnknownBeaconError extends BeaconError {\n            name: string;\n            title: string;\n            constructor();\n        }\n    }\n    \n    module 'test/events' {\n        import { AlertButton } from 'test/ui/alert/Alert';\n        import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n        import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n        import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n        import { BlockExplorer } from 'test/utils/block-explorer';\n        import { P2PPairingRequest, AccountInfo, ErrorResponse, PermissionResponseOutput, OperationResponseOutput, BroadcastResponseOutput, SignPayloadResponseOutput, Network, ConnectionContext, Transport, NetworkType, AcknowledgeResponse } from 'test/';\n        /**\n             * The different events that can be emitted by the beacon-sdk\n             */\n        export enum BeaconEvent {\n                PERMISSION_REQUEST_SENT = \"PERMISSION_REQUEST_SENT\",\n                PERMISSION_REQUEST_SUCCESS = \"PERMISSION_REQUEST_SUCCESS\",\n                PERMISSION_REQUEST_ERROR = \"PERMISSION_REQUEST_ERROR\",\n                OPERATION_REQUEST_SENT = \"OPERATION_REQUEST_SENT\",\n                OPERATION_REQUEST_SUCCESS = \"OPERATION_REQUEST_SUCCESS\",\n                OPERATION_REQUEST_ERROR = \"OPERATION_REQUEST_ERROR\",\n                SIGN_REQUEST_SENT = \"SIGN_REQUEST_SENT\",\n                SIGN_REQUEST_SUCCESS = \"SIGN_REQUEST_SUCCESS\",\n                SIGN_REQUEST_ERROR = \"SIGN_REQUEST_ERROR\",\n                BROADCAST_REQUEST_SENT = \"BROADCAST_REQUEST_SENT\",\n                BROADCAST_REQUEST_SUCCESS = \"BROADCAST_REQUEST_SUCCESS\",\n                BROADCAST_REQUEST_ERROR = \"BROADCAST_REQUEST_ERROR\",\n                ACKNOWLEDGE_RECEIVED = \"ACKNOWLEDGE_RECEIVED\",\n                LOCAL_RATE_LIMIT_REACHED = \"LOCAL_RATE_LIMIT_REACHED\",\n                NO_PERMISSIONS = \"NO_PERMISSIONS\",\n                ACTIVE_ACCOUNT_SET = \"ACTIVE_ACCOUNT_SET\",\n                ACTIVE_TRANSPORT_SET = \"ACTIVE_TRANSPORT_SET\",\n                PAIR_INIT = \"PAIR_INIT\",\n                PAIR_SUCCESS = \"PAIR_SUCCESS\",\n                CHANNEL_CLOSED = \"CHANNEL_CLOSED\",\n                INTERNAL_ERROR = \"INTERNAL_ERROR\",\n                UNKNOWN = \"UNKNOWN\"\n        }\n        export interface WalletInfo {\n                name: string;\n                icon?: string;\n        }\n        export interface ExtraInfo {\n                resetCallback?(): Promise<void>;\n        }\n        interface RequestSentInfo {\n                extraInfo: ExtraInfo;\n                walletInfo: WalletInfo;\n        }\n        /**\n             * The type of the payload of the different BeaconEvents\n             */\n        export interface BeaconEventType {\n                [BeaconEvent.PERMISSION_REQUEST_SENT]: RequestSentInfo;\n                [BeaconEvent.PERMISSION_REQUEST_SUCCESS]: {\n                        account: AccountInfo;\n                        output: PermissionResponseOutput;\n                        blockExplorer: BlockExplorer;\n                        connectionContext: ConnectionContext;\n                        walletInfo: WalletInfo;\n                };\n                [BeaconEvent.PERMISSION_REQUEST_ERROR]: {\n                        errorResponse: ErrorResponse;\n                        walletInfo: WalletInfo;\n                };\n                [BeaconEvent.OPERATION_REQUEST_SENT]: RequestSentInfo;\n                [BeaconEvent.OPERATION_REQUEST_SUCCESS]: {\n                        account: AccountInfo;\n                        output: OperationResponseOutput;\n                        blockExplorer: BlockExplorer;\n                        connectionContext: ConnectionContext;\n                        walletInfo: WalletInfo;\n                };\n                [BeaconEvent.OPERATION_REQUEST_ERROR]: {\n                        errorResponse: ErrorResponse;\n                        walletInfo: WalletInfo;\n                };\n                [BeaconEvent.SIGN_REQUEST_SENT]: RequestSentInfo;\n                [BeaconEvent.SIGN_REQUEST_SUCCESS]: {\n                        output: SignPayloadResponseOutput;\n                        connectionContext: ConnectionContext;\n                        walletInfo: WalletInfo;\n                };\n                [BeaconEvent.SIGN_REQUEST_ERROR]: {\n                        errorResponse: ErrorResponse;\n                        walletInfo: WalletInfo;\n                };\n                [BeaconEvent.BROADCAST_REQUEST_SENT]: RequestSentInfo;\n                [BeaconEvent.BROADCAST_REQUEST_SUCCESS]: {\n                        network: Network;\n                        output: BroadcastResponseOutput;\n                        blockExplorer: BlockExplorer;\n                        connectionContext: ConnectionContext;\n                        walletInfo: WalletInfo;\n                };\n                [BeaconEvent.BROADCAST_REQUEST_ERROR]: {\n                        errorResponse: ErrorResponse;\n                        walletInfo: WalletInfo;\n                };\n                [BeaconEvent.ACKNOWLEDGE_RECEIVED]: {\n                        message: AcknowledgeResponse;\n                        extraInfo: ExtraInfo;\n                        walletInfo: WalletInfo;\n                };\n                [BeaconEvent.LOCAL_RATE_LIMIT_REACHED]: undefined;\n                [BeaconEvent.NO_PERMISSIONS]: undefined;\n                [BeaconEvent.ACTIVE_ACCOUNT_SET]: AccountInfo;\n                [BeaconEvent.ACTIVE_TRANSPORT_SET]: Transport;\n                [BeaconEvent.PAIR_INIT]: {\n                        p2pPeerInfo: P2PPairingRequest;\n                        postmessagePeerInfo: PostMessagePairingRequest;\n                        preferredNetwork: NetworkType;\n                        abortedHandler?(): void;\n                };\n                [BeaconEvent.PAIR_SUCCESS]: ExtendedPostMessagePairingResponse | ExtendedP2PPairingResponse;\n                [BeaconEvent.CHANNEL_CLOSED]: string;\n                [BeaconEvent.INTERNAL_ERROR]: string;\n                [BeaconEvent.UNKNOWN]: undefined;\n        }\n        export type BeaconEventHandlerFunction<T = unknown> = (data: T, eventCallback?: AlertButton[]) => void | Promise<void>;\n        /**\n             * The default event handlers\n             */\n        export const defaultEventCallbacks: {\n                [key in BeaconEvent]: BeaconEventHandlerFunction<BeaconEventType[key]>;\n        };\n        /**\n             * Handles beacon events\n             */\n        export class BeaconEventHandler {\n                constructor(eventsToOverride?: {\n                        [key in BeaconEvent]?: {\n                                handler: BeaconEventHandlerFunction<BeaconEventType[key]>;\n                        };\n                }, overrideAll?: boolean);\n                /**\n                     * A method to subscribe to a specific beacon event and register a callback\n                     *\n                     * @param event The event being emitted\n                     * @param eventCallback The callback that will be invoked\n                     */\n                on<K extends BeaconEvent>(event: K, eventCallback: BeaconEventHandlerFunction<BeaconEventType[K]>): Promise<void>;\n                /**\n                     * Emit a beacon event\n                     *\n                     * @param event The event being emitted\n                     * @param data The data to be emit\n                     */\n                emit<K extends BeaconEvent>(event: K, data?: BeaconEventType[K], eventCallback?: AlertButton[]): Promise<void>;\n        }\n        export {};\n    }\n    \n    module 'test/examples/broadcast-request' {\n        export {};\n    }\n    \n    module 'test/examples/custom-block-explorer' {\n        export {};\n    }\n    \n    module 'test/examples/disable-all-ui' {\n        export {};\n    }\n    \n    module 'test/examples/operation-request' {\n        export {};\n    }\n    \n    module 'test/examples/override-default-events' {\n        export {};\n    }\n    \n    module 'test/examples/permission-request' {\n        export {};\n    }\n    \n    module 'test/examples/sign-payload-request' {\n        export {};\n    }\n    \n    module 'test/examples/using-custom-network' {\n        export {};\n    }\n    \n    module 'test/examples/wallet-example' {\n        export {};\n    }\n    \n    module 'test/index' {\n        import { P2PCommunicationClient } from 'test/transports/clients/P2PCommunicationClient';\n        import { AppMetadata } from 'test/types/beacon/AppMetadata';\n        import { PermissionRequest } from 'test/types/beacon/messages/PermissionRequest';\n        import { Network } from 'test/types/beacon/Network';\n        import { BeaconBaseMessage } from 'test/types/beacon/BeaconBaseMessage';\n        import { BeaconMessageType } from 'test/types/beacon/BeaconMessageType';\n        import { PermissionScope } from 'test/types/beacon/PermissionScope';\n        import { PermissionResponse } from 'test/types/beacon/messages/PermissionResponse';\n        import { OperationRequest } from 'test/types/beacon/messages/OperationRequest';\n        import { OperationResponse } from 'test/types/beacon/messages/OperationResponse';\n        import { SignPayloadRequest } from 'test/types/beacon/messages/SignPayloadRequest';\n        import { SignPayloadResponse } from 'test/types/beacon/messages/SignPayloadResponse';\n        import { BroadcastRequest } from 'test/types/beacon/messages/BroadcastRequest';\n        import { BroadcastResponse } from 'test/types/beacon/messages/BroadcastResponse';\n        import { NetworkType } from 'test/types/beacon/NetworkType';\n        import { TezosBaseOperation } from 'test/types/tezos/TezosBaseOperation';\n        import { TezosOperationType } from 'test/types/tezos/OperationTypes';\n        import { TezosActivateAccountOperation } from 'test/types/tezos/operations/ActivateAccount';\n        import { TezosBallotOperation } from 'test/types/tezos/operations/Ballot';\n        import { TezosDelegationOperation } from 'test/types/tezos/operations/Delegation';\n        import { TezosDoubleBakingEvidenceOperation } from 'test/types/tezos/operations/DoubleBakingEvidence';\n        import { TezosBlockHeader } from 'test/types/tezos/TezosBlockHeader';\n        import { TezosDoubleEndorsementEvidenceOperation } from 'test/types/tezos/operations/DoubleEndorsementEvidence';\n        import { TezosEndorsementOperation } from 'test/types/tezos/operations/Endorsement';\n        import { TezosOriginationOperation } from 'test/types/tezos/operations/Origination';\n        import { TezosProposalOperation } from 'test/types/tezos/operations/Proposal';\n        import { TezosRevealOperation } from 'test/types/tezos/operations/Reveal';\n        import { TezosSeedNonceRevelationOperation } from 'test/types/tezos/operations/SeedNonceRevelation';\n        import { TezosTransactionOperation } from 'test/types/tezos/operations/Transaction';\n        import { MichelsonPrimitives } from 'test/types/tezos/MichelsonPrimitives';\n        import { TezosTransactionParameters } from 'test/types/tezos/TezosTransactionParameters';\n        import { Origin } from 'test/types/Origin';\n        import { AccountInfo, AccountIdentifier } from 'test/types/AccountInfo';\n        import { EncryptedExtensionMessage, ExtensionMessage } from 'test/types/ExtensionMessage';\n        import { ExtensionMessageTarget } from 'test/types/ExtensionMessageTarget';\n        import { TezosOperation } from 'test/types/tezos/TezosOperation';\n        import { Client } from 'test/clients/client/Client';\n        import { WalletClient } from 'test/clients/wallet-client/WalletClient';\n        import { DAppClient } from 'test/clients/dapp-client/DAppClient';\n        import { BeaconError } from 'test/errors/BeaconError';\n        import { BeaconErrorType } from 'test/types/BeaconErrorType';\n        import { BroadcastBeaconError } from 'test/errors/BroadcastBeaconError';\n        import { NetworkNotSupportedBeaconError } from 'test/errors/NetworkNotSupportedBeaconError';\n        import { NoAddressBeaconError } from 'test/errors/NoAddressBeaconError';\n        import { NoPrivateKeyBeaconError } from 'test/errors/NoPrivateKeyBeaconError';\n        import { NotGrantedBeaconError } from 'test/errors/NotGrantedBeaconError';\n        import { ParametersInvalidBeaconError } from 'test/errors/ParametersInvalidBeaconError';\n        import { TooManyOperationsBeaconError } from 'test/errors/TooManyOperationsBeaconError';\n        import { TransactionInvalidBeaconError } from 'test/errors/TransactionInvalidBeaconError';\n        import { UnknownBeaconError } from 'test/errors/UnknownBeaconError';\n        import { ErrorResponse } from 'test/types/beacon/messages/ErrorResponse';\n        import { TransportStatus } from 'test/types/transport/TransportStatus';\n        import { TransportType } from 'test/types/transport/TransportType';\n        import { PostMessageTransport } from 'test/transports/PostMessageTransport';\n        import { Transport } from 'test/transports/Transport';\n        import { P2PTransport } from 'test/transports/P2PTransport';\n        import { Storage } from 'test/storage/Storage';\n        import { StorageKey } from 'test/types/storage/StorageKey';\n        import { StorageKeyReturnDefaults } from 'test/types/storage/StorageKeyReturnDefaults';\n        import { StorageKeyReturnType } from 'test/types/storage/StorageKeyReturnType';\n        import { ExtendedP2PPairingRequest, P2PPairingRequest } from 'test/types/P2PPairingRequest';\n        import { ChromeStorage } from 'test/storage/ChromeStorage';\n        import { LocalStorage } from 'test/storage/LocalStorage';\n        import { getStorage } from 'test/storage/getStorage';\n        import { BeaconMessage } from 'test/types/beacon/BeaconMessage';\n        import { Serializer } from 'test/Serializer';\n        import { RequestPermissionInput } from 'test/types/RequestPermissionInput';\n        import { RequestSignPayloadInput } from 'test/types/RequestSignPayloadInput';\n        import { RequestOperationInput } from 'test/types/RequestOperationInput';\n        import { RequestBroadcastInput } from 'test/types/RequestBroadcastInput';\n        import { PermissionResponseInput, SignPayloadResponseInput, OperationResponseInput, BroadcastResponseInput, BeaconResponseInputMessage, AcknowledgeResponseInput, ErrorResponseInput } from 'test/types/beacon/messages/BeaconResponseInputMessage';\n        import { PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, BeaconResponseOutputMessage } from 'test/types/beacon/messages/BeaconResponseOutputMessage';\n        import { PermissionRequestInput, SignPayloadRequestInput, OperationRequestInput, BroadcastRequestInput, BeaconRequestInputMessage } from 'test/types/beacon/messages/BeaconRequestInputMessage';\n        import { PermissionRequestOutput, SignPayloadRequestOutput, OperationRequestOutput, BroadcastRequestOutput, BeaconRequestOutputMessage } from 'test/types/beacon/messages/BeaconRequestOutputMessage';\n        import { ClientOptions } from 'test/clients/client/ClientOptions';\n        import { DAppClientOptions } from 'test/clients/dapp-client/DAppClientOptions';\n        import { WalletClientOptions } from 'test/clients/wallet-client/WalletClientOptions';\n        import { PermissionInfo } from 'test/types/PermissionInfo';\n        import { SDK_VERSION, BEACON_VERSION } from 'test/constants';\n        import { AccountManager } from 'test/managers/AccountManager';\n        import { AppMetadataManager } from 'test/managers/AppMetadataManager';\n        import { PermissionManager } from 'test/managers/PermissionManager';\n        import { BeaconEvent, BeaconEventHandler, defaultEventCallbacks } from 'test/events';\n        import { getAddressFromPublicKey } from 'test/utils/crypto';\n        import { BeaconClient } from 'test/clients/beacon-client/BeaconClient';\n        import { BeaconClientOptions } from 'test/clients/beacon-client/BeaconClientOptions';\n        import { getAccountIdentifier } from 'test/utils/get-account-identifier';\n        import { ConnectionContext } from 'test/types/ConnectionContext';\n        import { Threshold } from 'test/types/beacon/Threshold';\n        import { PartialTezosTransactionOperation, PartialTezosOperation, PartialTezosDelegationOperation, PartialTezosOriginationOperation, PartialTezosRevealOperation } from 'test/types/tezos/PartialTezosOperation';\n        import { AbortedBeaconError } from 'test/errors/AbortedBeaconError';\n        import { ExtendedPeerInfo, PeerInfo } from 'test/types/PeerInfo';\n        import { availableTransports } from 'test/utils/available-transports';\n        import { AcknowledgeResponse } from 'test/types/beacon/messages/AcknowledgeResponse';\n        import { DisconnectMessage } from 'test/types/beacon/messages/DisconnectMessage';\n        import { DappP2PTransport } from 'test/transports/DappP2PTransport';\n        import { DappPostMessageTransport } from 'test/transports/DappPostMessageTransport';\n        import { WalletP2PTransport } from 'test/transports/WalletP2PTransport';\n        import { WalletPostMessageTransport } from 'test/transports/WalletPostMessageTransport';\n        import { getSenderId } from 'test/utils/get-sender-id';\n        import { SigningType } from 'test/types/beacon/SigningType';\n        import { SignatureTypeNotSupportedBeaconError } from 'test/errors/SignatureTypeNotSupportedBeaconError';\n        import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n        import { ExtendedPostMessagePairingRequest, PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n        import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n        import { PeerManager } from 'test/managers/PeerManager';\n        import { MessageBasedClient } from 'test/transports/clients/MessageBasedClient';\n        import { BeaconRequestMessage } from 'test/types/beacon/BeaconRequestMessage';\n        import { BeaconResponseMessage } from 'test/types/beacon/BeaconResponseMessage';\n        import { Pairing } from 'test/ui/alert/Pairing';\n        import { BlockExplorer } from 'test/utils/block-explorer';\n        import { TezblockBlockExplorer } from 'test/utils/tezblock-blockexplorer';\n        import { setDebugEnabled, getDebugEnabled } from 'test/debug';\n        import { ColorMode } from 'test/types/ColorMode';\n        export { TezosBaseOperation, TezosOperationType, TezosBlockHeader, MichelsonPrimitives, TezosTransactionParameters, TezosOperation };\n        export { TezosActivateAccountOperation, TezosBallotOperation, TezosDelegationOperation, TezosDoubleBakingEvidenceOperation, TezosDoubleEndorsementEvidenceOperation, TezosEndorsementOperation, TezosOriginationOperation, TezosProposalOperation, TezosRevealOperation, TezosSeedNonceRevelationOperation, TezosTransactionOperation, PartialTezosOperation, PartialTezosTransactionOperation, PartialTezosDelegationOperation, PartialTezosOriginationOperation, PartialTezosRevealOperation };\n        export { BeaconClient, BeaconClientOptions, Client, ClientOptions, DAppClient, DAppClientOptions, WalletClient, WalletClientOptions, P2PCommunicationClient };\n        export { AccountIdentifier, AppMetadata, Network, NetworkType, BeaconMessage, PermissionRequest, PermissionResponse, OperationRequest, OperationResponse, SignPayloadRequest, SignPayloadResponse, BroadcastRequest, BroadcastResponse, AcknowledgeResponse, DisconnectMessage, BeaconBaseMessage, BeaconMessageType, PermissionScope, Origin, AccountInfo, Threshold, SigningType, ExtensionMessageTarget, ExtensionMessage, EncryptedExtensionMessage, RequestPermissionInput, RequestSignPayloadInput, RequestOperationInput, RequestBroadcastInput, PermissionInfo };\n        export { PermissionResponseInput, SignPayloadResponseInput, OperationResponseInput, BroadcastResponseInput, AcknowledgeResponseInput, ErrorResponseInput, PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, PermissionRequestInput, SignPayloadRequestInput, OperationRequestInput, BroadcastRequestInput, PermissionRequestOutput, SignPayloadRequestOutput, OperationRequestOutput, BroadcastRequestOutput, BeaconRequestInputMessage, BeaconRequestOutputMessage, BeaconResponseInputMessage, BeaconResponseOutputMessage, BeaconRequestMessage, BeaconResponseMessage };\n        export { BeaconError, BeaconErrorType, ErrorResponse, AbortedBeaconError, BroadcastBeaconError, NetworkNotSupportedBeaconError, NoAddressBeaconError, NoPrivateKeyBeaconError, NotGrantedBeaconError, ParametersInvalidBeaconError, TooManyOperationsBeaconError, TransactionInvalidBeaconError, SignatureTypeNotSupportedBeaconError, UnknownBeaconError };\n        export { TransportStatus, TransportType, Transport, PostMessageTransport, P2PTransport, WalletP2PTransport, WalletPostMessageTransport, DappP2PTransport, DappPostMessageTransport, MessageBasedClient, Pairing };\n        export { BeaconEvent, BeaconEventHandler, defaultEventCallbacks };\n        export { Storage, StorageKey, StorageKeyReturnDefaults, StorageKeyReturnType, ChromeStorage, LocalStorage, getStorage };\n        export { PeerManager, AccountManager, AppMetadataManager, PermissionManager };\n        export { SDK_VERSION, BEACON_VERSION };\n        export { getSenderId, getAccountIdentifier, getAddressFromPublicKey };\n        export { PeerInfo, ExtendedPeerInfo, PostMessagePairingRequest, ExtendedPostMessagePairingRequest, ExtendedPostMessagePairingResponse, P2PPairingRequest, ExtendedP2PPairingRequest, ExtendedP2PPairingResponse };\n        export { BlockExplorer, TezblockBlockExplorer };\n        export { ConnectionContext, Serializer, availableTransports, ColorMode };\n        export { setDebugEnabled, getDebugEnabled };\n    }\n    \n    module 'test/interceptors/IncomingRequestInterceptor' {\n        import { BeaconRequestOutputMessage } from 'test/';\n        import { ConnectionContext } from 'test/types/ConnectionContext';\n        import { AppMetadataManager } from 'test/managers/AppMetadataManager';\n        import { BeaconRequestMessage } from 'test/types/beacon/BeaconRequestMessage';\n        interface IncomingRequestInterceptorOptions {\n                message: BeaconRequestMessage;\n                connectionInfo: ConnectionContext;\n                appMetadataManager: AppMetadataManager;\n                interceptorCallback(message: BeaconRequestOutputMessage, connectionInfo: ConnectionContext): void;\n        }\n        /**\n             * The IncomingRequestInterceptor is used in the WalletClient to intercept an incoming request and enrich it with data, like app metadata.\n             */\n        export class IncomingRequestInterceptor {\n                /**\n                     * The method that is called during the interception\n                     *\n                     * @param config\n                     */\n                static intercept(config: IncomingRequestInterceptorOptions): Promise<void>;\n        }\n        export {};\n    }\n    \n    module 'test/interceptors/OutgoingResponseInterceptor' {\n        import { BeaconMessage, BeaconResponseInputMessage, AppMetadata } from 'test/';\n        import { PermissionManager } from 'test/managers/PermissionManager';\n        import { AppMetadataManager } from 'test/managers/AppMetadataManager';\n        import { BeaconRequestMessage } from 'test/types/beacon/BeaconRequestMessage';\n        interface OutgoingResponseInterceptorOptions {\n            senderId: string;\n            request: BeaconRequestMessage;\n            message: BeaconResponseInputMessage;\n            ownAppMetadata: AppMetadata;\n            permissionManager: PermissionManager;\n            appMetadataManager: AppMetadataManager;\n            interceptorCallback(message: BeaconMessage): void;\n        }\n        /**\n           * The OutgoingResponseInterceptor is used in the WalletClient to intercept an outgoing response and enrich it with data.\n           */\n        export class OutgoingResponseInterceptor {\n            static intercept(config: OutgoingResponseInterceptorOptions): Promise<void>;\n        }\n        export {};\n    }\n    \n    module 'test/managers/AccountManager' {\n        import { Storage, AccountInfo, BeaconMessage } from 'test/';\n        /**\n           * The AccountManager provides CRUD functionality for account entities and persists them to the provided storage.\n           */\n        export class AccountManager {\n            constructor(storage: Storage);\n            getAccounts(): Promise<AccountInfo[]>;\n            getAccount(accountIdentifier: string): Promise<AccountInfo | undefined>;\n            addAccount(accountInfo: AccountInfo): Promise<void>;\n            removeAccount(accountIdentifier: string): Promise<void>;\n            removeAccounts(accountIdentifiers: string[]): Promise<void>;\n            removeAllAccounts(): Promise<void>;\n            hasPermission(message: BeaconMessage): Promise<boolean>;\n        }\n    }\n    \n    module 'test/managers/AppMetadataManager' {\n        import { Storage, AppMetadata } from 'test/';\n        /**\n           * The AppMetadataManager provides CRUD functionality for app-metadata entities and persists them to the provided storage.\n           */\n        export class AppMetadataManager {\n            constructor(storage: Storage);\n            getAppMetadataList(): Promise<AppMetadata[]>;\n            getAppMetadata(senderId: string): Promise<AppMetadata | undefined>;\n            addAppMetadata(appMetadata: AppMetadata): Promise<void>;\n            removeAppMetadata(senderId: string): Promise<void>;\n            removeAppMetadatas(senderIds: string[]): Promise<void>;\n            removeAllAppMetadata(): Promise<void>;\n        }\n    }\n    \n    module 'test/managers/PeerManager' {\n        import { Storage, StorageKey, StorageKeyReturnType } from 'test/';\n        import { ArrayElem } from 'test/managers/StorageManager';\n        /**\n           * The PeerManager provides CRUD functionality for peer entities and persists them to the provided storage.\n           */\n        export class PeerManager<T extends StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET> {\n            constructor(storage: Storage, key: T);\n            hasPeer(publicKey: string): Promise<boolean>;\n            getPeers(): Promise<StorageKeyReturnType[T]>;\n            getPeer(publicKey: string): Promise<ArrayElem<StorageKeyReturnType[T]> | undefined>;\n            addPeer(peerInfo: ArrayElem<StorageKeyReturnType[T]>): Promise<void>;\n            removePeer(publicKey: string): Promise<void>;\n            removePeers(publicKeys: string[]): Promise<void>;\n            removeAllPeers(): Promise<void>;\n        }\n    }\n    \n    module 'test/managers/PermissionManager' {\n        import { BeaconMessage, Storage } from 'test/';\n        import { PermissionInfo } from 'test/types/PermissionInfo';\n        /**\n           * The PermissionManager provides CRUD functionality for permission entities and persists them to the provided storage.\n           */\n        export class PermissionManager {\n            constructor(storage: Storage);\n            getPermissions(): Promise<PermissionInfo[]>;\n            getPermission(accountIdentifier: string): Promise<PermissionInfo | undefined>;\n            addPermission(permissionInfo: PermissionInfo): Promise<void>;\n            removePermission(accountIdentifier: string): Promise<void>;\n            removePermissions(accountIdentifiers: string[]): Promise<void>;\n            removeAllPermissions(): Promise<void>;\n            hasPermission(message: BeaconMessage): Promise<boolean>;\n        }\n    }\n    \n    module 'test/managers/PermissionValidator' {\n        import { BeaconMessage } from 'test/';\n        import { PermissionEntity } from 'test/types/PermissionEntity';\n        /**\n             * The PermissionValidator is used to check if permissions for a certain message type have been given\n             */\n        export class PermissionValidator {\n                /**\n                     * Check if permissions were given for a certain message type.\n                     *\n                     * PermissionRequest and BroadcastRequest will always return true.\n                     *\n                     * @param message Beacon Message\n                     */\n                static hasPermission(message: BeaconMessage, getOne: (id: string) => Promise<PermissionEntity | undefined>, getAll: () => Promise<PermissionEntity[]>): Promise<boolean>;\n        }\n    }\n    \n    module 'test/managers/StorageManager' {\n        import { StorageKey, Storage, StorageKeyReturnType } from 'test/';\n        /** Type workaround for https://github.com/Microsoft/TypeScript/issues/7294#issuecomment-465794460 */\n        export type ArrayElem<A> = A extends (infer Elem)[] ? Elem : never;\n        /**\n             * The StorageManager provides CRUD functionality for specific entities and persists them to the provided storage.\n             */\n        export class StorageManager<T extends StorageKey.ACCOUNTS | StorageKey.APP_METADATA_LIST | StorageKey.PERMISSION_LIST | StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET> {\n                constructor(storage: Storage, storageKey: T);\n                getAll(): Promise<StorageKeyReturnType[T]>;\n                getOne(predicate: (element: ArrayElem<StorageKeyReturnType[T]>) => boolean): Promise<ArrayElem<StorageKeyReturnType[T]> | undefined>;\n                addOne(element: ArrayElem<StorageKeyReturnType[T]>, predicate: (element: ArrayElem<StorageKeyReturnType[T]>) => boolean, overwrite?: boolean): Promise<void>;\n                remove(predicate: (element: ArrayElem<StorageKeyReturnType[T]>) => boolean): Promise<void>;\n                removeAll(): Promise<void>;\n        }\n    }\n    \n    module 'test/matrix-client/MatrixClient' {\n        import { Storage } from 'test/storage/Storage';\n        import { MatrixClientStore } from 'test/matrix-client/MatrixClientStore';\n        import { MatrixRoom } from 'test/matrix-client/models/MatrixRoom';\n        import { MatrixRoomService } from 'test/matrix-client/services/MatrixRoomService';\n        import { MatrixUserService } from 'test/matrix-client/services/MatrixUserService';\n        import { MatrixEventService } from 'test/matrix-client/services/MatrixEventService';\n        import { MatrixClientEventEmitter } from 'test/matrix-client/MatrixClientEventEmitter';\n        import { MatrixClientEventType, MatrixClientEvent } from 'test/matrix-client/models/MatrixClientEvent';\n        interface MatrixClientOptions {\n                baseUrl: string;\n                storage: Storage;\n        }\n        interface MatrixLoginConfig {\n                id: string;\n                password: string;\n                deviceId: string;\n        }\n        /**\n             * The matrix client used to connect to the matrix network\n             */\n        export class MatrixClient {\n                /**\n                     * Create a matrix client based on the options provided\n                     *\n                     * @param config\n                     */\n                static create(config: MatrixClientOptions): MatrixClient;\n                /**\n                     * Return all the rooms we are currently part of\n                     */\n                get joinedRooms(): MatrixRoom[];\n                /**\n                     * Return all the rooms to which we have received invitations\n                     */\n                get invitedRooms(): MatrixRoom[];\n                /**\n                     * Return all the rooms that we left\n                     */\n                get leftRooms(): MatrixRoom[];\n                constructor(store: MatrixClientStore, eventEmitter: MatrixClientEventEmitter, userService: MatrixUserService, roomService: MatrixRoomService, eventService: MatrixEventService);\n                /**\n                     * Initiate the connection to the matrix node and log in\n                     *\n                     * @param user\n                     */\n                start(user: MatrixLoginConfig): Promise<void>;\n                /**\n                     * Subscribe to new matrix events\n                     *\n                     * @param event\n                     * @param listener\n                     */\n                subscribe<T extends MatrixClientEventType>(event: T, listener: (event: MatrixClientEvent<T>) => void): void;\n                /**\n                     * Unsubscribe from matrix events\n                     *\n                     * @param event\n                     * @param listener\n                     */\n                unsubscribe(event: MatrixClientEventType, listener?: (event: MatrixClientEvent<any>) => void): void;\n                getRoomById(id: string): MatrixRoom;\n                /**\n                     * Create a private room with the supplied members\n                     *\n                     * @param members Members that will be in the room\n                     */\n                createTrustedPrivateRoom(...members: string[]): Promise<string>;\n                /**\n                     * Invite user to rooms\n                     *\n                     * @param user The user to be invited\n                     * @param roomsOrIds The rooms the user will be invited to\n                     */\n                inviteToRooms(user: string, ...roomsOrIds: string[] | MatrixRoom[]): Promise<void>;\n                /**\n                     * Join rooms\n                     *\n                     * @param roomsOrIds\n                     */\n                joinRooms(...roomsOrIds: string[] | MatrixRoom[]): Promise<void>;\n                /**\n                     * Send a text message\n                     *\n                     * @param roomOrId\n                     * @param message\n                     */\n                sendTextMessage(roomId: string, message: string): Promise<void>;\n        }\n        export {};\n    }\n    \n    module 'test/matrix-client/MatrixClientEventEmitter' {\n        import { EventEmitter } from 'events';\n        import { MatrixStateStore, MatrixStateUpdate } from 'test/matrix-client/MatrixClientStore';\n        export class MatrixClientEventEmitter extends EventEmitter {\n                /**\n                     * This method is called every time the state is changed\n                     *\n                     * @param _oldState\n                     * @param _newState\n                     * @param stateChange\n                     */\n                onStateChanged(_oldState: MatrixStateStore, _newState: MatrixStateStore, stateChange: Partial<MatrixStateUpdate>): void;\n        }\n    }\n    \n    module 'test/matrix-client/MatrixClientStore' {\n        import { MatrixRoom } from 'test/matrix-client/models/MatrixRoom';\n        import { Storage } from 'test/storage/Storage';\n        type OnStateChangedListener = (oldState: MatrixStateStore, newState: MatrixStateStore, stateChange: Partial<MatrixStateUpdate>) => void;\n        export interface MatrixState {\n                isRunning: boolean;\n                userId: string | undefined;\n                deviceId: string | undefined;\n                txnNo: number;\n                accessToken: string | undefined;\n                syncToken: string | undefined;\n                pollingTimeout: number | undefined;\n                pollingRetries: number;\n                rooms: MatrixRoom[] | Record<string, MatrixRoom>;\n        }\n        export interface MatrixStateStore extends MatrixState {\n                rooms: Record<string, MatrixRoom>;\n        }\n        export interface MatrixStateUpdate extends MatrixState {\n                rooms: MatrixRoom[];\n        }\n        /**\n             * The class managing the local state of matrix\n             */\n        export class MatrixClientStore {\n                constructor(storage: Storage);\n                /**\n                     * Get an item from the state\n                     *\n                     * @param key\n                     */\n                get<T extends keyof MatrixStateStore>(key: T): MatrixStateStore[T];\n                /**\n                     * Get the room from an ID or room instance\n                     *\n                     * @param roomOrId\n                     */\n                getRoom(roomOrId: string | MatrixRoom): MatrixRoom;\n                /**\n                     * Update the state with a partial state\n                     *\n                     * @param stateUpdate\n                     */\n                update(stateUpdate: Partial<MatrixStateUpdate>): Promise<void>;\n                /**\n                     * Register listeners that are called once the state has changed\n                     *\n                     * @param listener\n                     * @param subscribed\n                     */\n                onStateChanged(listener: OnStateChangedListener, ...subscribed: (keyof MatrixState)[]): void;\n        }\n        export {};\n    }\n    \n    module 'test/matrix-client/MatrixHttpClient' {\n        import { MatrixRequest, MatrixRequestParams } from 'test/matrix-client/models/api/MatrixRequest';\n        interface HttpOptions {\n                accessToken?: string;\n        }\n        /**\n             * Handling the HTTP connection to the matrix synapse node\n             */\n        export class MatrixHttpClient {\n                constructor(baseUrl: string);\n                /**\n                     * Get data from the synapse node\n                     *\n                     * @param endpoint\n                     * @param options\n                     */\n                get<T>(endpoint: string, params?: MatrixRequestParams<T>, options?: HttpOptions): Promise<T>;\n                /**\n                     * Post data to the synapse node\n                     *\n                     * @param endpoint\n                     * @param body\n                     * @param options\n                     * @param params\n                     */\n                post<T>(endpoint: string, body: MatrixRequest<T>, options?: HttpOptions, params?: MatrixRequestParams<T>): Promise<T>;\n                /**\n                     * Put data to the synapse node\n                     *\n                     * @param endpoint\n                     * @param body\n                     * @param options\n                     * @param params\n                     */\n                put<T>(endpoint: string, body: MatrixRequest<T>, options?: HttpOptions, params?: MatrixRequestParams<T>): Promise<T>;\n        }\n        export {};\n    }\n    \n    module 'test/matrix-client/models/api/MatrixEventSend' {\n        export interface MatrixEventSendRequest {\n            content: any;\n        }\n        export interface MatrixEventSendResponse {\n            type?: 'event_send';\n            event_id: string;\n        }\n    }\n    \n    module 'test/matrix-client/models/api/MatrixLogin' {\n        export interface MatrixLoginRequest {\n            type: 'm.login.password';\n            identifier: {\n                type: 'm.id.user';\n                user: string;\n            };\n            password: string;\n            device_id?: string;\n        }\n        export interface MatrixLoginResponse {\n            type?: 'login';\n            user_id: string;\n            device_id: string;\n            access_token: string;\n        }\n    }\n    \n    module 'test/matrix-client/models/api/MatrixRequest' {\n        import { MatrixLoginRequest, MatrixLoginResponse } from 'test/matrix-client/models/api/MatrixLogin';\n        import { MatrixRoomCreateRequest, MatrixRoomCreateResponse } from 'test/matrix-client/models/api/MatrixRoomCreate';\n        import { MatrixRoomInviteRequest, MatrixRoomInviteResponse } from 'test/matrix-client/models/api/MatrixRoomInvite';\n        import { MatrixRoomJoinRequest, MatrixRoomJoinResponse } from 'test/matrix-client/models/api/MatrixRoomJoin';\n        import { MatrixEventSendRequest, MatrixEventSendResponse } from 'test/matrix-client/models/api/MatrixEventSend';\n        import { MatrixSyncResponse, MatrixSyncRequestParams } from 'test/matrix-client/models/api/MatrixSync';\n        export type MatrixRequest<T> = T extends MatrixLoginResponse ? MatrixLoginRequest : T extends MatrixRoomCreateResponse ? MatrixRoomCreateRequest : T extends MatrixRoomInviteResponse ? MatrixRoomInviteRequest : T extends MatrixRoomJoinResponse ? MatrixRoomJoinRequest : T extends MatrixEventSendResponse ? MatrixEventSendRequest : never;\n        export type MatrixRequestParams<T> = T extends MatrixSyncResponse ? MatrixSyncRequestParams : never;\n    }\n    \n    module 'test/matrix-client/models/api/MatrixRoomCreate' {\n        export interface MatrixRoomCreateRequest {\n            visibility?: 'public' | 'private';\n            room_alias_name?: string;\n            name?: string;\n            topic?: string;\n            invite?: string[];\n            preset?: 'private_chat' | 'public_chat' | 'trusted_private_chat';\n            is_direct?: boolean;\n        }\n        export interface MatrixRoomCreateResponse {\n            type?: 'room_create';\n            room_id: string;\n        }\n    }\n    \n    module 'test/matrix-client/models/api/MatrixRoomInvite' {\n        export interface MatrixRoomInviteRequest {\n            user_id: string;\n        }\n        export interface MatrixRoomInviteResponse {\n            type?: 'room_invite';\n        }\n    }\n    \n    module 'test/matrix-client/models/api/MatrixRoomJoin' {\n        export interface MatrixRoomJoinRequest {\n        }\n        export interface MatrixRoomJoinResponse {\n            type?: 'room_join';\n            room_id: string;\n        }\n    }\n    \n    module 'test/matrix-client/models/api/MatrixSync' {\n        import { MatrixStateEvent } from 'test/matrix-client/models/MatrixStateEvent';\n        export interface MatrixSyncJoinedRoom {\n            state: {\n                events: MatrixStateEvent[];\n            };\n            timeline: {\n                events: MatrixStateEvent[];\n            };\n        }\n        export interface MatrixSyncInvitedRoom {\n            invite_state: {\n                events: MatrixStateEvent[];\n            };\n        }\n        export interface MatrixSyncLeftRoom {\n            state: {\n                events: MatrixStateEvent[];\n            };\n            timeline: {\n                events: MatrixStateEvent[];\n            };\n        }\n        export interface MatrixSyncRooms {\n            join: {\n                [key: string]: MatrixSyncJoinedRoom;\n            };\n            invite: {\n                [key: string]: MatrixSyncInvitedRoom;\n            };\n            leave: {\n                [key: string]: MatrixSyncLeftRoom;\n            };\n        }\n        export interface MatrixSyncRequestParams {\n            timeout?: number;\n            since?: string;\n        }\n        export interface MatrixSyncResponse {\n            type?: 'sync';\n            next_batch: string;\n            rooms: MatrixSyncRooms;\n        }\n    }\n    \n    module 'test/matrix-client/models/MatrixClientEvent' {\n        import { MatrixMessage } from 'test/matrix-client/models/MatrixMessage';\n        export enum MatrixClientEventType {\n            INVITE = \"invite\",\n            MESSAGE = \"message\"\n        }\n        export type MatrixClientEventContent<T> = T extends MatrixClientEventType.INVITE ? MatrixClientEventInviteContent : T extends MatrixClientEventType.MESSAGE ? MatrixClientEventMessageContent<any> : never;\n        export interface MatrixClientEventInviteContent {\n            roomId: string;\n        }\n        export interface MatrixClientEventMessageContent<T> {\n            roomId: string;\n            message: MatrixMessage<T>;\n        }\n        export interface MatrixClientEvent<T extends MatrixClientEventType> {\n            type: T;\n            content: MatrixClientEventContent<T>;\n        }\n    }\n    \n    module 'test/matrix-client/models/MatrixMessage' {\n        import { MatrixStateEvent } from 'test/matrix-client/models/MatrixStateEvent';\n        export enum MatrixMessageType {\n            TEXT = \"m.text\"\n        }\n        export class MatrixMessage<T> {\n            readonly type: MatrixMessageType;\n            readonly sender: string;\n            readonly content: T;\n            /**\n               * Construct a message from a message event\n               *\n               * @param event\n               */\n            static from(event: MatrixStateEvent): MatrixMessage<any> | undefined;\n        }\n    }\n    \n    module 'test/matrix-client/models/MatrixRoom' {\n        import { MatrixSyncRooms } from 'test/matrix-client/models/api/MatrixSync';\n        import { MatrixMessage } from 'test/matrix-client/models/MatrixMessage';\n        export enum MatrixRoomStatus {\n                UNKNOWN = 0,\n                JOINED = 1,\n                INVITED = 2,\n                LEFT = 3\n        }\n        export class MatrixRoom {\n                readonly id: string;\n                readonly status: MatrixRoomStatus;\n                readonly members: string[];\n                messages: MatrixMessage<any>[];\n                /**\n                     * Reconstruct rooms from a sync response\n                     *\n                     * @param roomSync\n                     */\n                static fromSync(roomSync: MatrixSyncRooms): MatrixRoom[];\n                /**\n                     * Reconstruct a room from an ID or object\n                     *\n                     * @param roomOrId\n                     * @param status\n                     */\n                static from(roomOrId: string | MatrixRoom, status?: MatrixRoomStatus): MatrixRoom;\n                /**\n                     * Merge new and old state and remove duplicates\n                     *\n                     * @param newState\n                     * @param previousState\n                     */\n                static merge(newState: MatrixRoom, previousState?: MatrixRoom): MatrixRoom;\n        }\n    }\n    \n    module 'test/matrix-client/models/MatrixStateEvent' {\n        import { MatrixMessageType } from 'test/matrix-client/models/MatrixMessage';\n        export interface MatrixStateEventMessageText extends MatrixStateEventMessage {\n            type: 'm.room.message';\n            content: {\n                msgtype: MatrixMessageType.TEXT;\n                body: string;\n            };\n        }\n        export interface MatrixStateEventMessageContent {\n            msgtype: string;\n            body: any;\n            [key: string]: any;\n        }\n        export interface MatrixStateEventMessage extends MatrixStateEvent {\n            type: 'm.room.message';\n            content: MatrixStateEventMessageContent;\n        }\n        export interface MatrixStateEvent {\n            type: string;\n            sender: string;\n            content: unknown;\n            event_id?: string;\n        }\n    }\n    \n    module 'test/matrix-client/services/MatrixEventService' {\n        import { MatrixHttpClient } from 'test/matrix-client/MatrixHttpClient';\n        import { MatrixEventSendResponse } from 'test/matrix-client/models/api/MatrixEventSend';\n        import { MatrixSyncResponse } from 'test/matrix-client/models/api/MatrixSync';\n        import { MatrixStateEventMessageContent } from 'test/matrix-client/models/MatrixStateEvent';\n        interface MatrixScheduledEvent<T> {\n                accessToken: string;\n                roomId: string;\n                type: MatrixEventType;\n                content: any;\n                txnId: string;\n                onSuccess(response: T): void;\n                onError(error: unknown): void;\n        }\n        type MatrixEventType = 'm.room.message';\n        export interface MatrixSyncOptions {\n                syncToken?: string;\n                pollingTimeout?: number;\n        }\n        /**\n             * A service to help with matrix event management\n             */\n        export class MatrixEventService {\n                constructor(httpClient: MatrixHttpClient);\n                /**\n                     * Get the latest state from the matrix node\n                     *\n                     * @param accessToken\n                     * @param options\n                     */\n                sync(accessToken: string, options?: MatrixSyncOptions): Promise<MatrixSyncResponse>;\n                /**\n                     * Send a message to a room\n                     *\n                     * @param accessToken\n                     * @param room\n                     * @param content\n                     * @param txnId\n                     */\n                sendMessage(accessToken: string, roomId: string, content: MatrixStateEventMessageContent, txnId: string): Promise<MatrixEventSendResponse>;\n                /**\n                     * Schedules an event to be sent to the node\n                     *\n                     * @param event\n                     */\n                scheduleEvent(event: MatrixScheduledEvent<any>): void;\n                /**\n                     * Send an event to the matrix node\n                     *\n                     * @param scheduledEvent\n                     */\n                sendEvent(scheduledEvent: MatrixScheduledEvent<any>): Promise<void>;\n        }\n        export {};\n    }\n    \n    module 'test/matrix-client/services/MatrixRoomService' {\n        import { MatrixHttpClient } from 'test/matrix-client/MatrixHttpClient';\n        import { MatrixRoom } from 'test/matrix-client/models/MatrixRoom';\n        import { MatrixRoomCreateRequest, MatrixRoomCreateResponse } from 'test/matrix-client/models/api/MatrixRoomCreate';\n        import { MatrixRoomInviteResponse } from 'test/matrix-client/models/api/MatrixRoomInvite';\n        import { MatrixRoomJoinResponse } from 'test/matrix-client/models/api/MatrixRoomJoin';\n        /**\n             * A service to help with matrix room management\n             */\n        export class MatrixRoomService {\n                constructor(httpClient: MatrixHttpClient);\n                /**\n                     * Create a room\n                     *\n                     * @param accessToken\n                     * @param config\n                     */\n                createRoom(accessToken: string, config?: MatrixRoomCreateRequest): Promise<MatrixRoomCreateResponse>;\n                /**\n                     * Invite a user to a room\n                     *\n                     * @param accessToken\n                     * @param user\n                     * @param room\n                     */\n                inviteToRoom(accessToken: string, user: string, room: MatrixRoom): Promise<MatrixRoomInviteResponse>;\n                /**\n                     * Join a specific room\n                     *\n                     * @param accessToken\n                     * @param room\n                     */\n                joinRoom(accessToken: string, room: MatrixRoom): Promise<MatrixRoomJoinResponse>;\n                /**\n                     * Get all joined rooms\n                     *\n                     * @param accessToken\n                     */\n                getJoinedRooms(accessToken: string): Promise<MatrixRoomJoinResponse>;\n        }\n    }\n    \n    module 'test/matrix-client/services/MatrixUserService' {\n        import { MatrixHttpClient } from 'test/matrix-client/MatrixHttpClient';\n        import { MatrixLoginResponse } from 'test/matrix-client/models/api/MatrixLogin';\n        export class MatrixUserService {\n            constructor(httpClient: MatrixHttpClient);\n            /**\n               * Log in to the matrix node with username and password\n               *\n               * @param user\n               * @param password\n               * @param deviceId\n               */\n            login(user: string, password: string, deviceId: string): Promise<MatrixLoginResponse>;\n        }\n    }\n    \n    module 'test/matrix-client/utils/events' {\n        import { MatrixStateEvent, MatrixStateEventMessageText } from 'test/matrix-client/models/MatrixStateEvent';\n        /**\n             * Check if an event is a create event\n             *\n             * @param event MatrixStateEvent\n             */\n        export const isCreateEvent: (event: MatrixStateEvent) => boolean;\n        /**\n             * Check if an event is a join event\n             *\n             * @param event MatrixStateEvent\n             */\n        export const isJoinEvent: (event: MatrixStateEvent) => boolean;\n        /**\n             * Check if an event is a message event\n             *\n             * @param event MatrixStateEvent\n             */\n        export const isMessageEvent: (event: MatrixStateEvent) => boolean;\n        /**\n             * Check if an event is a text message event\n             *\n             * @param event MatrixStateEvent\n             */\n        export const isTextMessageEvent: (event: MatrixStateEvent) => event is MatrixStateEventMessageText;\n    }\n    \n    module 'test/migrations/migrate-0.7.0' {\n        import { PermissionScope, AccountIdentifier, Origin, Network } from 'test/';\n        export interface AccountInfoOld {\n            accountIdentifier: AccountIdentifier;\n            beaconId: string;\n            origin: {\n                type: Origin;\n                id: string;\n            };\n            address: string;\n            pubkey: string;\n            network: Network;\n            scopes: PermissionScope[];\n            connectedAt: Date;\n        }\n        export interface P2PPairingRequestOld {\n            name: string;\n            pubKey: string;\n            relayServer: string;\n        }\n        export const migrate_0_7_0: (storage: Storage) => Promise<void>;\n    }\n    \n    module 'test/migrations/migrations' {\n        import { Storage } from 'test/';\n        export const migrate: (storage: Storage) => Promise<void>;\n    }\n    \n    module 'test/MockWindow' {\n        type Callback = (message: unknown) => void;\n        /**\n           * A mock for postmessage if run in node.js environment\n           */\n        let windowRef: {\n            postMessage: (message: string | Record<string, unknown>, _target?: string | undefined) => void;\n            addEventListener: (_name: string, eventCallback: Callback) => void;\n            removeEventListener: (_name: string, eventCallback: Callback) => void;\n            location: {\n                origin: string;\n            };\n        };\n        const clearMockWindowState: () => void;\n        export { windowRef, clearMockWindowState };\n    }\n    \n    module 'test/Serializer' {\n        /**\n             * The Serializer is used to serialize / deserialize JSON objects and encode them with bs58check\n             */\n        export class Serializer {\n                /**\n                     * Serialize and bs58check encode an object\n                     *\n                     * @param message JSON object to serialize\n                     */\n                serialize(message: unknown): Promise<string>;\n                /**\n                     * Deserialize a bs58check encoded string\n                     *\n                     * @param encoded String to be deserialized\n                     */\n                deserialize(encoded: string): Promise<unknown>;\n        }\n    }\n    \n    module 'test/storage/ChromeStorage' {\n        import { Storage, StorageKey, StorageKeyReturnType } from 'test/';\n        export class ChromeStorage implements Storage {\n            static isSupported(): Promise<boolean>;\n            get<K extends StorageKey>(key: K): Promise<StorageKeyReturnType[K]>;\n            set<K extends StorageKey>(key: K, value: StorageKeyReturnType[K]): Promise<void>;\n            delete<K extends StorageKey>(key: K): Promise<void>;\n        }\n    }\n    \n    module 'test/storage/getStorage' {\n        import { Storage } from 'test/';\n        /**\n           * Get a supported storage on this platform\n           */\n        export const getStorage: () => Promise<Storage>;\n    }\n    \n    module 'test/storage/LocalStorage' {\n        import { Storage, StorageKey, StorageKeyReturnType } from 'test/';\n        export class LocalStorage implements Storage {\n            constructor(prefix?: string | undefined);\n            static isSupported(): Promise<boolean>;\n            get<K extends StorageKey>(key: K): Promise<StorageKeyReturnType[K]>;\n            set<K extends StorageKey>(key: K, value: StorageKeyReturnType[K]): Promise<void>;\n            delete<K extends StorageKey>(key: K): Promise<void>;\n        }\n    }\n    \n    module 'test/storage/Storage' {\n        import { StorageKey } from 'test/types/storage/StorageKey';\n        import { StorageKeyReturnType } from 'test/types/storage/StorageKeyReturnType';\n        /**\n             * The storage used in the SDK\n             */\n        export abstract class Storage {\n                /**\n                     * Returns a promise that resolves to true if the storage option is available on this platform.\n                     */\n                static isSupported(): Promise<boolean>;\n                /**\n                     * Gets a value from storage and returns it\n                     *\n                     * @param key The storage key\n                     */\n                abstract get<K extends StorageKey>(key: K): Promise<StorageKeyReturnType[K]>;\n                /**\n                     * Sets a value in the storage and persist it\n                     *\n                     * @param key The storage key\n                     * @param value The value to be persisted\n                     */\n                abstract set<K extends StorageKey>(key: K, value: StorageKeyReturnType[K]): Promise<void>;\n                /**\n                     * Delete a key from storage\n                     *\n                     * @param key The storage key\n                     */\n                abstract delete<K extends StorageKey>(key: K): Promise<void>;\n        }\n    }\n    \n    module 'test/test' {\n    \n        export * from 'test/beacon-message-events';\n        export * from 'test/clients/beacon-client/BeaconClient';\n        export * from 'test/clients/beacon-client/BeaconClientOptions';\n        export * from 'test/clients/client/Client';\n        export * from 'test/clients/client/ClientOptions';\n        export * from 'test/clients/dapp-client/DAppClient';\n        export * from 'test/clients/dapp-client/DAppClientOptions';\n        export * from 'test/clients/wallet-client/WalletClient';\n        export * from 'test/clients/wallet-client/WalletClientOptions';\n        export * from 'test/colorMode';\n        export * from 'test/constants';\n        export * from 'test/debug';\n        export * from 'test/errors/AbortedBeaconError';\n        export * from 'test/errors/BeaconError';\n        export * from 'test/errors/BroadcastBeaconError';\n        export * from 'test/errors/NetworkNotSupportedBeaconError';\n        export * from 'test/errors/NoAddressBeaconError';\n        export * from 'test/errors/NoPrivateKeyBeaconError';\n        export * from 'test/errors/NotGrantedBeaconError';\n        export * from 'test/errors/ParametersInvalidBeaconError';\n        export * from 'test/errors/SignatureTypeNotSupportedBeaconError';\n        export * from 'test/errors/TooManyOperationsBeaconError';\n        export * from 'test/errors/TransactionInvalidBeaconError';\n        export * from 'test/errors/UnknownBeaconError';\n        export * from 'test/events';\n        export * from 'test/examples/broadcast-request';\n        export * from 'test/examples/custom-block-explorer';\n        export * from 'test/examples/disable-all-ui';\n        export * from 'test/examples/operation-request';\n        export * from 'test/examples/override-default-events';\n        export * from 'test/examples/permission-request';\n        export * from 'test/examples/sign-payload-request';\n        export * from 'test/examples/using-custom-network';\n        export * from 'test/examples/wallet-example';\n        export * from 'test/index';\n        export * from 'test/interceptors/IncomingRequestInterceptor';\n        export * from 'test/interceptors/OutgoingResponseInterceptor';\n        export * from 'test/managers/AccountManager';\n        export * from 'test/managers/AppMetadataManager';\n        export * from 'test/managers/PeerManager';\n        export * from 'test/managers/PermissionManager';\n        export * from 'test/managers/PermissionValidator';\n        export * from 'test/managers/StorageManager';\n        export * from 'test/matrix-client/MatrixClient';\n        export * from 'test/matrix-client/MatrixClientEventEmitter';\n        export * from 'test/matrix-client/MatrixClientStore';\n        export * from 'test/matrix-client/MatrixHttpClient';\n        export * from 'test/matrix-client/models/api/MatrixEventSend';\n        export * from 'test/matrix-client/models/api/MatrixLogin';\n        export * from 'test/matrix-client/models/api/MatrixRequest';\n        export * from 'test/matrix-client/models/api/MatrixRoomCreate';\n        export * from 'test/matrix-client/models/api/MatrixRoomInvite';\n        export * from 'test/matrix-client/models/api/MatrixRoomJoin';\n        export * from 'test/matrix-client/models/api/MatrixSync';\n        export * from 'test/matrix-client/models/MatrixClientEvent';\n        export * from 'test/matrix-client/models/MatrixMessage';\n        export * from 'test/matrix-client/models/MatrixRoom';\n        export * from 'test/matrix-client/models/MatrixStateEvent';\n        export * from 'test/matrix-client/services/MatrixEventService';\n        export * from 'test/matrix-client/services/MatrixRoomService';\n        export * from 'test/matrix-client/services/MatrixUserService';\n        export * from 'test/matrix-client/utils/events';\n        export * from 'test/migrations/migrate-0.7.0';\n        export * from 'test/migrations/migrations';\n        export * from 'test/MockWindow';\n        export * from 'test/Serializer';\n        export * from 'test/storage/ChromeStorage';\n        export * from 'test/storage/getStorage';\n        export * from 'test/storage/LocalStorage';\n        export * from 'test/storage/Storage';\n        export * from 'test/transports/clients/CommunicationClient';\n        export * from 'test/transports/clients/MessageBasedClient';\n        export * from 'test/transports/clients/P2PCommunicationClient';\n        export * from 'test/transports/clients/PostMessageClient';\n        export * from 'test/transports/DappP2PTransport';\n        export * from 'test/transports/DappPostMessageTransport';\n        export * from 'test/transports/P2PTransport';\n        export * from 'test/transports/PostMessageTransport';\n        export * from 'test/transports/Transport';\n        export * from 'test/transports/WalletP2PTransport';\n        export * from 'test/transports/WalletPostMessageTransport';\n        export * from 'test/types/AccountInfo';\n        export * from 'test/types/beacon/AppMetadata';\n        export * from 'test/types/beacon/BeaconBaseMessage';\n        export * from 'test/types/beacon/BeaconMessage';\n        export * from 'test/types/beacon/BeaconMessageType';\n        export * from 'test/types/beacon/BeaconRequestMessage';\n        export * from 'test/types/beacon/BeaconResponseMessage';\n        export * from 'test/types/beacon/messages/AcknowledgeResponse';\n        export * from 'test/types/beacon/messages/BeaconRequestInputMessage';\n        export * from 'test/types/beacon/messages/BeaconRequestOutputMessage';\n        export * from 'test/types/beacon/messages/BeaconResponseInputMessage';\n        export * from 'test/types/beacon/messages/BeaconResponseOutputMessage';\n        export * from 'test/types/beacon/messages/BroadcastRequest';\n        export * from 'test/types/beacon/messages/BroadcastResponse';\n        export * from 'test/types/beacon/messages/DisconnectMessage';\n        export * from 'test/types/beacon/messages/ErrorResponse';\n        export * from 'test/types/beacon/messages/OperationRequest';\n        export * from 'test/types/beacon/messages/OperationResponse';\n        export * from 'test/types/beacon/messages/PermissionRequest';\n        export * from 'test/types/beacon/messages/PermissionResponse';\n        export * from 'test/types/beacon/messages/SignPayloadRequest';\n        export * from 'test/types/beacon/messages/SignPayloadResponse';\n        export * from 'test/types/beacon/Network';\n        export * from 'test/types/beacon/NetworkType';\n        export * from 'test/types/beacon/PermissionScope';\n        export * from 'test/types/beacon/SigningType';\n        export * from 'test/types/beacon/Threshold';\n        export * from 'test/types/BeaconErrorType';\n        export * from 'test/types/ColorMode';\n        export * from 'test/types/ConnectionContext';\n        export * from 'test/types/Extension';\n        export * from 'test/types/ExtensionMessage';\n        export * from 'test/types/ExtensionMessageTarget';\n        export * from 'test/types/Origin';\n        export * from 'test/types/P2PPairingRequest';\n        export * from 'test/types/P2PPairingResponse';\n        export * from 'test/types/PeerInfo';\n        export * from 'test/types/PermissionEntity';\n        export * from 'test/types/PermissionInfo';\n        export * from 'test/types/PostMessagePairingRequest';\n        export * from 'test/types/PostMessagePairingResponse';\n        export * from 'test/types/RequestBroadcastInput';\n        export * from 'test/types/RequestOperationInput';\n        export * from 'test/types/RequestPermissionInput';\n        export * from 'test/types/RequestSignPayloadInput';\n        export * from 'test/types/storage/StorageKey';\n        export * from 'test/types/storage/StorageKeyReturnDefaults';\n        export * from 'test/types/storage/StorageKeyReturnType';\n        export * from 'test/types/tezos/MichelineMichelsonV1Expression';\n        export * from 'test/types/tezos/MichelsonPrimitives';\n        export * from 'test/types/tezos/operations/ActivateAccount';\n        export * from 'test/types/tezos/operations/Ballot';\n        export * from 'test/types/tezos/operations/Delegation';\n        export * from 'test/types/tezos/operations/DoubleBakingEvidence';\n        export * from 'test/types/tezos/operations/DoubleEndorsementEvidence';\n        export * from 'test/types/tezos/operations/Endorsement';\n        export * from 'test/types/tezos/operations/Origination';\n        export * from 'test/types/tezos/operations/Proposal';\n        export * from 'test/types/tezos/operations/Reveal';\n        export * from 'test/types/tezos/operations/SeedNonceRevelation';\n        export * from 'test/types/tezos/operations/Transaction';\n        export * from 'test/types/tezos/OperationTypes';\n        export * from 'test/types/tezos/PartialTezosOperation';\n        export * from 'test/types/tezos/TezosBaseOperation';\n        export * from 'test/types/tezos/TezosBlockHeader';\n        export * from 'test/types/tezos/TezosOperation';\n        export * from 'test/types/tezos/TezosTransactionParameters';\n        export * from 'test/types/transport/TransportStatus';\n        export * from 'test/types/transport/TransportType';\n        export * from 'test/ui/alert/alert-templates';\n        export * from 'test/ui/alert/Alert';\n        export * from 'test/ui/alert/Pairing';\n        export * from 'test/ui/alert/PairingAlert';\n        export * from 'test/ui/alert/wallet-lists';\n        export * from 'test/ui/toast/toast-templates';\n        export * from 'test/ui/toast/Toast';\n        export * from 'test/utils/assert-never';\n        export * from 'test/utils/available-transports';\n        export * from 'test/utils/block-explorer';\n        export * from 'test/utils/crypto';\n        export * from 'test/utils/exposed-promise';\n        export * from 'test/utils/generate-uuid';\n        export * from 'test/utils/get-account-identifier';\n        export * from 'test/utils/get-sender-id';\n        export * from 'test/utils/get-tzip10-link';\n        export * from 'test/utils/Logger';\n        export * from 'test/utils/platform';\n        export * from 'test/utils/qr';\n        export * from 'test/utils/replace-in-template';\n        export * from 'test/utils/shorten-string';\n        export * from 'test/utils/tezblock-blockexplorer';\n        export * from 'test/utils/utils';\n    \n        module 'test/beacon-message-events' {\n                import { BeaconEvent } from 'test/events';\n                import { BeaconMessageType } from 'test/';\n                export const messageEvents: {\n                        [key in BeaconMessageType]: {\n                                sent: BeaconEvent;\n                                success: BeaconEvent;\n                                error: BeaconEvent;\n                        };\n                };\n        }\n    \n        module 'test/clients/beacon-client/BeaconClient' {\n                import * as sodium from 'libsodium-wrappers';\n                import { ExposedPromise } from 'test/utils/exposed-promise';\n                import { Storage } from 'test/';\n                import { BeaconEventHandler } from 'test/events';\n                import { BeaconClientOptions } from 'test/clients/beacon-client/BeaconClientOptions';\n                /**\n                          * The beacon client is an abstract client that handles everything that is shared between all other clients.\n                          * Specifically, it handles managing the beaconId and and the local keypair.\n                          */\n                export abstract class BeaconClient {\n                                /**\n                                          * The name of the client\n                                          */\n                                readonly name: string;\n                                /**\n                                          * The URL of the dApp Icon. This can be used to display the icon of the dApp on in the wallet\n                                          */\n                                readonly iconUrl?: string;\n                                /**\n                                          * The URL of the dApp.\n                                          */\n                                readonly appUrl?: string;\n                                /** The beaconId is a public key that is used to identify one specific application (dapp or wallet).\n                                          * This is used inside a message to specify the sender, for example.\n                                          */\n                                protected _beaconId: ExposedPromise<string>;\n                                get beaconId(): Promise<string>;\n                                protected storage: Storage;\n                                protected readonly events: BeaconEventHandler;\n                                /**\n                                          * The local keypair that is used for the communication encryption\n                                          */\n                                protected _keyPair: ExposedPromise<sodium.KeyPair>;\n                                protected get keyPair(): Promise<sodium.KeyPair>;\n                                constructor(config: BeaconClientOptions);\n                                /**\n                                          * This resets the SDK. After using this method, this instance is no longer usable. You will have to instanciate a new client.\n                                          */\n                                destroy(): Promise<void>;\n                }\n        }\n    \n        module 'test/clients/beacon-client/BeaconClientOptions' {\n                import { Storage } from 'test/';\n                export interface BeaconClientOptions {\n                                /**\n                                          * Name of the application\n                                          */\n                                name: string;\n                                /**\n                                          * A URL to the icon of the application\n                                          */\n                                iconUrl?: string;\n                                /**\n                                          * A URL to the website of the application\n                                          */\n                                appUrl?: string;\n                                /**\n                                          * The storage that will be used by the SDK\n                                          */\n                                storage: Storage;\n                }\n        }\n    \n        module 'test/clients/client/Client' {\n                import { ExposedPromise } from 'test/utils/exposed-promise';\n                import { ConnectionContext } from 'test/types/ConnectionContext';\n                import { TransportType, TransportStatus, AccountInfo, PeerInfo, Transport, AppMetadata } from 'test/';\n                import { BeaconEventHandler } from 'test/events';\n                import { BeaconClient } from 'test/clients/beacon-client/BeaconClient';\n                import { AccountManager } from 'test/managers/AccountManager';\n                import { BeaconRequestMessage } from 'test/types/beacon/BeaconRequestMessage';\n                import { ClientOptions } from 'test/clients/client/ClientOptions';\n                /**\n                          * This abstract class handles the a big part of the logic that is shared between the dapp and wallet client.\n                          * For example, it selects and manages the transport and accounts.\n                          */\n                export abstract class Client extends BeaconClient {\n                                protected readonly accountManager: AccountManager;\n                                protected handleResponse: (_event: BeaconRequestMessage, connectionInfo: ConnectionContext) => void;\n                                /**\n                                          * How many requests can be sent after another\n                                          */\n                                protected readonly rateLimit: number;\n                                /**\n                                          * The time window in seconds in which the \"rateLimit\" is checked\n                                          */\n                                protected readonly rateLimitWindowInSeconds: number;\n                                /**\n                                          * Stores the times when requests have been made to determine if the rate limit has been reached\n                                          */\n                                protected requestCounter: number[];\n                                protected readonly events: BeaconEventHandler;\n                                protected readonly matrixNodes: string[];\n                                protected _transport: ExposedPromise<Transport<any>>;\n                                protected get transport(): Promise<Transport<any>>;\n                                /**\n                                          * Returns the connection status of the Client\n                                          */\n                                get connectionStatus(): TransportStatus;\n                                /**\n                                          * Returns whether or not the transaport is ready\n                                          */\n                                get ready(): Promise<void>;\n                                constructor(config: ClientOptions);\n                                /**\n                                          * Return all locally known accounts\n                                          */\n                                getAccounts(): Promise<AccountInfo[]>;\n                                /**\n                                          * Return the account by ID\n                                          * @param accountIdentifier The ID of an account\n                                          */\n                                getAccount(accountIdentifier: string): Promise<AccountInfo | undefined>;\n                                /**\n                                          * Remove the account by ID\n                                          * @param accountIdentifier The ID of an account\n                                          */\n                                removeAccount(accountIdentifier: string): Promise<void>;\n                                /**\n                                          * Remove all locally stored accounts\n                                          */\n                                removeAllAccounts(): Promise<void>;\n                                /**\n                                          * Add a new request (current timestamp) to the pending requests, remove old ones and check if we are above the limit\n                                          */\n                                addRequestAndCheckIfRateLimited(): Promise<boolean>;\n                                /**\n                                          * This method initializes the client. It will check if the connection should be established to a\n                                          * browser extension or if the P2P transport should be used.\n                                          *\n                                          * @param transport A transport that can be provided by the user\n                                          */\n                                init(transport: Transport<any>): Promise<TransportType>;\n                                /**\n                                          * Returns the metadata of this DApp\n                                          */\n                                getOwnAppMetadata(): Promise<AppMetadata>;\n                                /**\n                                          * Return all known peers\n                                          */\n                                getPeers(): Promise<PeerInfo[]>;\n                                /**\n                                          * Add a new peer to the known peers\n                                          * @param peer The new peer to add\n                                          */\n                                addPeer(peer: PeerInfo): Promise<void>;\n                                /**\n                                          * A \"setter\" for when the transport needs to be changed.\n                                          */\n                                protected setTransport(transport?: Transport<any>): Promise<void>;\n                                protected addListener(transport: Transport<any>): Promise<void>;\n                                protected sendDisconnectToPeer(peer: PeerInfo, transport?: Transport<any>): Promise<void>;\n                }\n        }\n    \n        module 'test/clients/client/ClientOptions' {\n                import { Storage } from 'test/';\n                import { BeaconEvent, BeaconEventHandlerFunction, BeaconEventType } from 'test/events';\n                export interface ClientOptions {\n                                /**\n                                          * Name of the application\n                                          */\n                                name: string;\n                                /**\n                                          * A URL to the icon of the application\n                                          */\n                                iconUrl?: string;\n                                /**\n                                          * A URL to the website of the application\n                                          */\n                                appUrl?: string;\n                                /**\n                                          * The storage that will be used by the SDK\n                                          */\n                                storage: Storage;\n                                /**\n                                          * An object that will be used to overwrite default event handler behaviour.\n                                          *\n                                          * If you plan to overwrite all default events, use \"disableDefaultEvents\" instead.\n                                          *\n                                          * This will overwrite the default event handler, so this can lead to unexpected behavior in some cases.\n                                          * We recommend that you overwrite all handlers if you want to use your own UI.\n                                          *\n                                          * If you simply want to be notified of events happening, but do not want to overwrite the default behavior,\n                                          * please use `subscribeToEvent()` on the DAppClient instead.\n                                          */\n                                eventHandlers?: {\n                                                [key in BeaconEvent]?: {\n                                                                handler: BeaconEventHandlerFunction<BeaconEventType[key]>;\n                                                };\n                                };\n                                /**\n                                          * Disable all default Events and UI elements. If passed together with \"eventHandlers\",\n                                          * the default eventHandlers will be removed, and the ones passed by the user will be added.\n                                          */\n                                disableDefaultEvents?: boolean;\n                                /**\n                                          * A list of matrix nodes to connect to. If a non-empty array is passed, the default options will be overwritten.\n                                          * One node will be randomly selected based on the local keypair and the other nodes will be used as a fallback in case the primary node goes down.\n                                          *\n                                          * Only provide the hostname, no https:// prefix. Eg. ['matrix.example.com']\n                                          */\n                                matrixNodes?: string[];\n                }\n        }\n    \n        module 'test/clients/dapp-client/DAppClient' {\n                import { BeaconEvent, BeaconEventHandlerFunction, BeaconEventType } from 'test/events';\n                import { AccountInfo, Client, TransportType, BeaconMessageType, NetworkType, RequestPermissionInput, RequestSignPayloadInput, RequestOperationInput, RequestBroadcastInput, PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, Transport, DappP2PTransport, DappPostMessageTransport, AppMetadata } from 'test/';\n                import { BlockExplorer } from 'test/utils/block-explorer';\n                import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n                import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n                import { ExtendedPeerInfo } from 'test/types/PeerInfo';\n                import { ColorMode } from 'test/types/ColorMode';\n                import { DAppClientOptions } from 'test/clients/dapp-client/DAppClientOptions';\n                /**\n                          * The DAppClient has to be used in decentralized applications. It handles all the logic related to connecting to beacon-compatible\n                          * wallets and sending requests.\n                          */\n                export class DAppClient extends Client {\n                                /**\n                                          * The block explorer used by the SDK\n                                          */\n                                readonly blockExplorer: BlockExplorer;\n                                preferredNetwork: NetworkType;\n                                protected postMessageTransport: DappPostMessageTransport | undefined;\n                                protected p2pTransport: DappP2PTransport | undefined;\n                                constructor(config: DAppClientOptions);\n                                initInternalTransports(): Promise<void>;\n                                init(transport?: Transport<any>): Promise<TransportType>;\n                                /**\n                                          * Returns the active account\n                                          */\n                                getActiveAccount(): Promise<AccountInfo | undefined>;\n                                /**\n                                          * Sets the active account\n                                          *\n                                          * @param account The account that will be set as the active account\n                                          */\n                                setActiveAccount(account?: AccountInfo): Promise<void>;\n                                /**\n                                          * Clear the active account\n                                          */\n                                clearActiveAccount(): Promise<void>;\n                                setColorMode(colorMode: ColorMode): Promise<void>;\n                                getColorMode(): Promise<ColorMode>;\n                                /**\n                                          * @deprecated\n                                          *\n                                          * Use getOwnAppMetadata instead\n                                          */\n                                getAppMetadata(): Promise<AppMetadata>;\n                                /**\n                                          * Will remove the account from the local storage and set a new active account if necessary.\n                                          *\n                                          * @param accountIdentifier ID of the account\n                                          */\n                                removeAccount(accountIdentifier: string): Promise<void>;\n                                /**\n                                          * Remove all accounts and set active account to undefined\n                                          */\n                                removeAllAccounts(): Promise<void>;\n                                /**\n                                          * Removes a peer and all the accounts that have been connected through that peer\n                                          *\n                                          * @param peer Peer to be removed\n                                          */\n                                removePeer(peer: ExtendedPeerInfo, sendDisconnectToPeer?: boolean): Promise<void>;\n                                /**\n                                          * Remove all peers and all accounts that have been connected through those peers\n                                          */\n                                removeAllPeers(sendDisconnectToPeers?: boolean): Promise<void>;\n                                /**\n                                          * Allows the user to subscribe to specific events that are fired in the SDK\n                                          *\n                                          * @param internalEvent The event to subscribe to\n                                          * @param eventCallback The callback that will be called when the event occurs\n                                          */\n                                subscribeToEvent<K extends BeaconEvent>(internalEvent: K, eventCallback: BeaconEventHandlerFunction<BeaconEventType[K]>): Promise<void>;\n                                /**\n                                          * Check if we have permissions to send the specific message type to the active account.\n                                          * If no active account is set, only permission requests are allowed.\n                                          *\n                                          * @param type The type of the message\n                                          */\n                                checkPermissions(type: BeaconMessageType): Promise<boolean>;\n                                /**\n                                          * Send a permission request to the DApp. This should be done as the first step. The wallet will respond\n                                          * with an publicKey and permissions that were given. The account returned will be set as the \"activeAccount\"\n                                          * and will be used for the following requests.\n                                          *\n                                          * @param input The message details we need to prepare the PermissionRequest message.\n                                          */\n                                requestPermissions(input?: RequestPermissionInput): Promise<PermissionResponseOutput>;\n                                /**\n                                          * This method will send a \"SignPayloadRequest\" to the wallet. This method is meant to be used to sign\n                                          * arbitrary data (eg. a string). It will return the signature in the format of \"edsig...\"\n                                          *\n                                          * @param input The message details we need to prepare the SignPayloadRequest message.\n                                          */\n                                requestSignPayload(input: RequestSignPayloadInput): Promise<SignPayloadResponseOutput>;\n                                /**\n                                          * This method sends an OperationRequest to the wallet. This method should be used for all kinds of operations,\n                                          * eg. transaction or delegation. Not all properties have to be provided. Data like \"counter\" and fees will be\n                                          * fetched and calculated by the wallet (but they can still be provided if required).\n                                          *\n                                          * @param input The message details we need to prepare the OperationRequest message.\n                                          */\n                                requestOperation(input: RequestOperationInput): Promise<OperationResponseOutput>;\n                                /**\n                                          * Sends a \"BroadcastRequest\" to the wallet. This method can be used to inject an already signed transaction\n                                          * to the network.\n                                          *\n                                          * @param input The message details we need to prepare the BroadcastRequest message.\n                                          */\n                                requestBroadcast(input: RequestBroadcastInput): Promise<BroadcastResponseOutput>;\n                                protected setActivePeer(peer?: ExtendedPostMessagePairingResponse | ExtendedP2PPairingResponse): Promise<void>;\n                                /**\n                                          * A \"setter\" for when the transport needs to be changed.\n                                          */\n                                protected setTransport(transport?: Transport<any>): Promise<void>;\n                }\n        }\n    \n        module 'test/clients/dapp-client/DAppClientOptions' {\n                import { NetworkType, Storage } from 'test/';\n                import { BeaconEvent, BeaconEventType, BeaconEventHandlerFunction } from 'test/events';\n                import { ColorMode } from 'test/types/ColorMode';\n                import { BlockExplorer } from 'test/utils/block-explorer';\n                export interface DAppClientOptions {\n                                /**\n                                          * Name of the application\n                                          */\n                                name: string;\n                                /**\n                                          * A URL to the icon of the application\n                                          */\n                                iconUrl?: string;\n                                /**\n                                          * A URL to the website of the application\n                                          */\n                                appUrl?: string;\n                                /**\n                                          * The storage that will be used by the SDK\n                                          */\n                                storage?: Storage;\n                                /**\n                                          * An object that will be used to overwrite default event handler behaviour.\n                                          *\n                                          * If you plan to overwrite all default events, use \"disableDefaultEvents\" instead.\n                                          *\n                                          * This will overwrite the default event handler, so this can lead to unexpected behavior in some cases.\n                                          * We recommend that you overwrite all handlers if you want to use your own UI.\n                                          *\n                                          * If you simply want to be notified of events happening, but do not want to overwrite the default behavior,\n                                          * please use `subscribeToEvent()` on the DAppClient instead.\n                                          */\n                                eventHandlers?: {\n                                                [key in BeaconEvent]?: {\n                                                                handler: BeaconEventHandlerFunction<BeaconEventType[key]>;\n                                                };\n                                };\n                                /**\n                                          * Disable all default Events and UI elements. If passed together with \"eventHandlers\",\n                                          * the default eventHandlers will be removed, and the ones passed by the user will be added.\n                                          */\n                                disableDefaultEvents?: boolean;\n                                /**\n                                          * A list of matrix nodes to connect to. If a non-empty array is passed, the default options will be overwritten.\n                                          * One node will be randomly selected based on the local keypair and the other nodes will be used as a fallback in case the primary node goes down.\n                                          *\n                                          * Only provide the hostname, no https:// prefix. Eg. ['matrix.example.com']\n                                          */\n                                matrixNodes?: string[];\n                                /**\n                                          * The block explorer used by the SDK\n                                          */\n                                blockExplorer?: BlockExplorer;\n                                /**\n                                          * Indicates on which network the DApp is planning to run. This is currently used to adjust the URLs of web-wallets in the pairing alert if they use different URLs for testnets.\n                                          * You will still have to define the network you intend to use during the permission request.\n                                          */\n                                preferredNetwork?: NetworkType;\n                                /**\n                                          * Set the color mode for the UI elements (alerts and toasts)\n                                          */\n                                colorMode?: ColorMode;\n                }\n        }\n    \n        module 'test/clients/wallet-client/WalletClient' {\n                import { Client, WalletClientOptions, TransportType, BeaconRequestOutputMessage, BeaconResponseInputMessage, AppMetadata, PermissionInfo } from 'test/';\n                import { ConnectionContext } from 'test/types/ConnectionContext';\n                import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n                import { ExposedPromise } from 'test/utils/exposed-promise';\n                import { PeerInfo } from 'test/types/PeerInfo';\n                /**\n                          * The WalletClient has to be used in the wallet. It handles all the logic related to connecting to beacon-compatible\n                          * dapps and handling/responding to requests.\n                          */\n                export class WalletClient extends Client {\n                                /**\n                                          * Returns whether or not the transport is connected\n                                          */\n                                protected readonly _isConnected: ExposedPromise<boolean>;\n                                get isConnected(): Promise<boolean>;\n                                constructor(config: WalletClientOptions);\n                                init(): Promise<TransportType>;\n                                /**\n                                          * This method initiates a connection to the P2P network and registers a callback that will be called\n                                          * whenever a message is received.\n                                          *\n                                          * @param newMessageCallback The callback that will be invoked for every message the transport receives.\n                                          */\n                                connect(newMessageCallback: (message: BeaconRequestOutputMessage, connectionContext: ConnectionContext) => void): Promise<void>;\n                                /**\n                                          * The method will attempt to initiate a connection using the active transport.\n                                          */\n                                _connect(): Promise<void>;\n                                /**\n                                          * This method sends a response for a specific request back to the DApp\n                                          *\n                                          * @param message The BeaconResponseMessage that will be sent back to the DApp\n                                          */\n                                respond(message: BeaconResponseInputMessage): Promise<void>;\n                                getAppMetadataList(): Promise<AppMetadata[]>;\n                                getAppMetadata(senderId: string): Promise<AppMetadata | undefined>;\n                                removeAppMetadata(senderId: string): Promise<void>;\n                                removeAllAppMetadata(): Promise<void>;\n                                getPermissions(): Promise<PermissionInfo[]>;\n                                getPermission(accountIdentifier: string): Promise<PermissionInfo | undefined>;\n                                removePermission(accountIdentifier: string): Promise<void>;\n                                removeAllPermissions(): Promise<void>;\n                                /**\n                                          * Add a new peer to the known peers\n                                          * @param peer The new peer to add\n                                          */\n                                addPeer(peer: PeerInfo): Promise<void>;\n                                removePeer(peer: ExtendedP2PPairingResponse, sendDisconnectToPeer?: boolean): Promise<void>;\n                                removeAllPeers(sendDisconnectToPeers?: boolean): Promise<void>;\n                }\n        }\n    \n        module 'test/clients/wallet-client/WalletClientOptions' {\n                import { Storage } from 'test/';\n                export interface WalletClientOptions {\n                                /**\n                                          * Name of the application\n                                          */\n                                name: string;\n                                /**\n                                          * A URL to the icon of the application\n                                          */\n                                iconUrl?: string;\n                                /**\n                                          * A URL to the website of the application\n                                          */\n                                appUrl?: string;\n                                /**\n                                          * The storage that will be used by the SDK\n                                          */\n                                storage?: Storage;\n                                /**\n                                          * A list of matrix nodes to connect to. If a non-empty array is passed, the default options will be overwritten.\n                                          * One node will be randomly selected based on the local keypair and the other nodes will be used as a fallback in case the primary node goes down.\n                                          *\n                                          * Only provide the hostname, no https:// prefix. Eg. ['matrix.example.com']\n                                          */\n                                matrixNodes?: string[];\n                }\n        }\n    \n        module 'test/colorMode' {\n                import { ColorMode } from 'test/types/ColorMode';\n                export const setColorMode: (mode: ColorMode) => void;\n                export const getColorMode: () => ColorMode;\n        }\n    \n        module 'test/constants' {\n                export const SDK_VERSION: string;\n                export const BEACON_VERSION: string;\n        }\n    \n        module 'test/debug' {\n                export const setDebugEnabled: (enabled: boolean) => void;\n                export const getDebugEnabled: () => boolean;\n        }\n    \n        module 'test/errors/AbortedBeaconError' {\n                import { BeaconError } from 'test/';\n                export class AbortedBeaconError extends BeaconError {\n                        name: string;\n                        title: string;\n                        constructor();\n                }\n        }\n    \n        module 'test/errors/BeaconError' {\n                import { BeaconErrorType } from 'test/';\n                export abstract class BeaconError implements Error {\n                        name: string;\n                        message: string;\n                        title: string;\n                        description: string;\n                        get fullDescription(): string;\n                        constructor(errorType: BeaconErrorType, message: string);\n                        static getError(errorType: BeaconErrorType, errorData: any): BeaconError;\n                }\n        }\n    \n        module 'test/errors/BroadcastBeaconError' {\n                import { BeaconError } from 'test/';\n                export class BroadcastBeaconError extends BeaconError {\n                        name: string;\n                        title: string;\n                        constructor();\n                }\n        }\n    \n        module 'test/errors/NetworkNotSupportedBeaconError' {\n                import { BeaconError } from 'test/';\n                export class NetworkNotSupportedBeaconError extends BeaconError {\n                        name: string;\n                        title: string;\n                        constructor();\n                }\n        }\n    \n        module 'test/errors/NoAddressBeaconError' {\n                import { BeaconError } from 'test/';\n                export class NoAddressBeaconError extends BeaconError {\n                        name: string;\n                        title: string;\n                        constructor();\n                }\n        }\n    \n        module 'test/errors/NoPrivateKeyBeaconError' {\n                import { BeaconError } from 'test/';\n                export class NoPrivateKeyBeaconError extends BeaconError {\n                        name: string;\n                        title: string;\n                        constructor();\n                }\n        }\n    \n        module 'test/errors/NotGrantedBeaconError' {\n                import { BeaconError } from 'test/';\n                export class NotGrantedBeaconError extends BeaconError {\n                        name: string;\n                        title: string;\n                        constructor();\n                }\n        }\n    \n        module 'test/errors/ParametersInvalidBeaconError' {\n                import { BeaconError } from 'test/';\n                export class ParametersInvalidBeaconError extends BeaconError {\n                        name: string;\n                        title: string;\n                        constructor();\n                }\n        }\n    \n        module 'test/errors/SignatureTypeNotSupportedBeaconError' {\n                import { BeaconError } from 'test/';\n                export class SignatureTypeNotSupportedBeaconError extends BeaconError {\n                        name: string;\n                        title: string;\n                        constructor();\n                }\n        }\n    \n        module 'test/errors/TooManyOperationsBeaconError' {\n                import { BeaconError } from 'test/';\n                export class TooManyOperationsBeaconError extends BeaconError {\n                        name: string;\n                        title: string;\n                        constructor();\n                }\n        }\n    \n        module 'test/errors/TransactionInvalidBeaconError' {\n                import { BeaconError } from 'test/';\n                export class TransactionInvalidBeaconError extends BeaconError {\n                        readonly data: any;\n                        name: string;\n                        title: string;\n                        get fullDescription(): string;\n                        constructor(data: any);\n                }\n        }\n    \n        module 'test/errors/UnknownBeaconError' {\n                import { BeaconError } from 'test/';\n                export class UnknownBeaconError extends BeaconError {\n                        name: string;\n                        title: string;\n                        constructor();\n                }\n        }\n    \n        module 'test/events' {\n                import { AlertButton } from 'test/ui/alert/Alert';\n                import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n                import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n                import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n                import { BlockExplorer } from 'test/utils/block-explorer';\n                import { P2PPairingRequest, AccountInfo, ErrorResponse, PermissionResponseOutput, OperationResponseOutput, BroadcastResponseOutput, SignPayloadResponseOutput, Network, ConnectionContext, Transport, NetworkType, AcknowledgeResponse } from 'test/';\n                /**\n                          * The different events that can be emitted by the beacon-sdk\n                          */\n                export enum BeaconEvent {\n                                PERMISSION_REQUEST_SENT = \"PERMISSION_REQUEST_SENT\",\n                                PERMISSION_REQUEST_SUCCESS = \"PERMISSION_REQUEST_SUCCESS\",\n                                PERMISSION_REQUEST_ERROR = \"PERMISSION_REQUEST_ERROR\",\n                                OPERATION_REQUEST_SENT = \"OPERATION_REQUEST_SENT\",\n                                OPERATION_REQUEST_SUCCESS = \"OPERATION_REQUEST_SUCCESS\",\n                                OPERATION_REQUEST_ERROR = \"OPERATION_REQUEST_ERROR\",\n                                SIGN_REQUEST_SENT = \"SIGN_REQUEST_SENT\",\n                                SIGN_REQUEST_SUCCESS = \"SIGN_REQUEST_SUCCESS\",\n                                SIGN_REQUEST_ERROR = \"SIGN_REQUEST_ERROR\",\n                                BROADCAST_REQUEST_SENT = \"BROADCAST_REQUEST_SENT\",\n                                BROADCAST_REQUEST_SUCCESS = \"BROADCAST_REQUEST_SUCCESS\",\n                                BROADCAST_REQUEST_ERROR = \"BROADCAST_REQUEST_ERROR\",\n                                ACKNOWLEDGE_RECEIVED = \"ACKNOWLEDGE_RECEIVED\",\n                                LOCAL_RATE_LIMIT_REACHED = \"LOCAL_RATE_LIMIT_REACHED\",\n                                NO_PERMISSIONS = \"NO_PERMISSIONS\",\n                                ACTIVE_ACCOUNT_SET = \"ACTIVE_ACCOUNT_SET\",\n                                ACTIVE_TRANSPORT_SET = \"ACTIVE_TRANSPORT_SET\",\n                                PAIR_INIT = \"PAIR_INIT\",\n                                PAIR_SUCCESS = \"PAIR_SUCCESS\",\n                                CHANNEL_CLOSED = \"CHANNEL_CLOSED\",\n                                INTERNAL_ERROR = \"INTERNAL_ERROR\",\n                                UNKNOWN = \"UNKNOWN\"\n                }\n                export interface WalletInfo {\n                                name: string;\n                                icon?: string;\n                }\n                export interface ExtraInfo {\n                                resetCallback?(): Promise<void>;\n                }\n                interface RequestSentInfo {\n                                extraInfo: ExtraInfo;\n                                walletInfo: WalletInfo;\n                }\n                /**\n                          * The type of the payload of the different BeaconEvents\n                          */\n                export interface BeaconEventType {\n                                [BeaconEvent.PERMISSION_REQUEST_SENT]: RequestSentInfo;\n                                [BeaconEvent.PERMISSION_REQUEST_SUCCESS]: {\n                                                account: AccountInfo;\n                                                output: PermissionResponseOutput;\n                                                blockExplorer: BlockExplorer;\n                                                connectionContext: ConnectionContext;\n                                                walletInfo: WalletInfo;\n                                };\n                                [BeaconEvent.PERMISSION_REQUEST_ERROR]: {\n                                                errorResponse: ErrorResponse;\n                                                walletInfo: WalletInfo;\n                                };\n                                [BeaconEvent.OPERATION_REQUEST_SENT]: RequestSentInfo;\n                                [BeaconEvent.OPERATION_REQUEST_SUCCESS]: {\n                                                account: AccountInfo;\n                                                output: OperationResponseOutput;\n                                                blockExplorer: BlockExplorer;\n                                                connectionContext: ConnectionContext;\n                                                walletInfo: WalletInfo;\n                                };\n                                [BeaconEvent.OPERATION_REQUEST_ERROR]: {\n                                                errorResponse: ErrorResponse;\n                                                walletInfo: WalletInfo;\n                                };\n                                [BeaconEvent.SIGN_REQUEST_SENT]: RequestSentInfo;\n                                [BeaconEvent.SIGN_REQUEST_SUCCESS]: {\n                                                output: SignPayloadResponseOutput;\n                                                connectionContext: ConnectionContext;\n                                                walletInfo: WalletInfo;\n                                };\n                                [BeaconEvent.SIGN_REQUEST_ERROR]: {\n                                                errorResponse: ErrorResponse;\n                                                walletInfo: WalletInfo;\n                                };\n                                [BeaconEvent.BROADCAST_REQUEST_SENT]: RequestSentInfo;\n                                [BeaconEvent.BROADCAST_REQUEST_SUCCESS]: {\n                                                network: Network;\n                                                output: BroadcastResponseOutput;\n                                                blockExplorer: BlockExplorer;\n                                                connectionContext: ConnectionContext;\n                                                walletInfo: WalletInfo;\n                                };\n                                [BeaconEvent.BROADCAST_REQUEST_ERROR]: {\n                                                errorResponse: ErrorResponse;\n                                                walletInfo: WalletInfo;\n                                };\n                                [BeaconEvent.ACKNOWLEDGE_RECEIVED]: {\n                                                message: AcknowledgeResponse;\n                                                extraInfo: ExtraInfo;\n                                                walletInfo: WalletInfo;\n                                };\n                                [BeaconEvent.LOCAL_RATE_LIMIT_REACHED]: undefined;\n                                [BeaconEvent.NO_PERMISSIONS]: undefined;\n                                [BeaconEvent.ACTIVE_ACCOUNT_SET]: AccountInfo;\n                                [BeaconEvent.ACTIVE_TRANSPORT_SET]: Transport;\n                                [BeaconEvent.PAIR_INIT]: {\n                                                p2pPeerInfo: P2PPairingRequest;\n                                                postmessagePeerInfo: PostMessagePairingRequest;\n                                                preferredNetwork: NetworkType;\n                                                abortedHandler?(): void;\n                                };\n                                [BeaconEvent.PAIR_SUCCESS]: ExtendedPostMessagePairingResponse | ExtendedP2PPairingResponse;\n                                [BeaconEvent.CHANNEL_CLOSED]: string;\n                                [BeaconEvent.INTERNAL_ERROR]: string;\n                                [BeaconEvent.UNKNOWN]: undefined;\n                }\n                export type BeaconEventHandlerFunction<T = unknown> = (data: T, eventCallback?: AlertButton[]) => void | Promise<void>;\n                /**\n                          * The default event handlers\n                          */\n                export const defaultEventCallbacks: {\n                                [key in BeaconEvent]: BeaconEventHandlerFunction<BeaconEventType[key]>;\n                };\n                /**\n                          * Handles beacon events\n                          */\n                export class BeaconEventHandler {\n                                constructor(eventsToOverride?: {\n                                                [key in BeaconEvent]?: {\n                                                                handler: BeaconEventHandlerFunction<BeaconEventType[key]>;\n                                                };\n                                }, overrideAll?: boolean);\n                                /**\n                                          * A method to subscribe to a specific beacon event and register a callback\n                                          *\n                                          * @param event The event being emitted\n                                          * @param eventCallback The callback that will be invoked\n                                          */\n                                on<K extends BeaconEvent>(event: K, eventCallback: BeaconEventHandlerFunction<BeaconEventType[K]>): Promise<void>;\n                                /**\n                                          * Emit a beacon event\n                                          *\n                                          * @param event The event being emitted\n                                          * @param data The data to be emit\n                                          */\n                                emit<K extends BeaconEvent>(event: K, data?: BeaconEventType[K], eventCallback?: AlertButton[]): Promise<void>;\n                }\n                export {};\n        }\n    \n        module 'test/examples/broadcast-request' {\n                export {};\n        }\n    \n        module 'test/examples/custom-block-explorer' {\n                export {};\n        }\n    \n        module 'test/examples/disable-all-ui' {\n                export {};\n        }\n    \n        module 'test/examples/operation-request' {\n                export {};\n        }\n    \n        module 'test/examples/override-default-events' {\n                export {};\n        }\n    \n        module 'test/examples/permission-request' {\n                export {};\n        }\n    \n        module 'test/examples/sign-payload-request' {\n                export {};\n        }\n    \n        module 'test/examples/using-custom-network' {\n                export {};\n        }\n    \n        module 'test/examples/wallet-example' {\n                export {};\n        }\n    \n        module 'test/index' {\n                import { P2PCommunicationClient } from 'test/transports/clients/P2PCommunicationClient';\n                import { AppMetadata } from 'test/types/beacon/AppMetadata';\n                import { PermissionRequest } from 'test/types/beacon/messages/PermissionRequest';\n                import { Network } from 'test/types/beacon/Network';\n                import { BeaconBaseMessage } from 'test/types/beacon/BeaconBaseMessage';\n                import { BeaconMessageType } from 'test/types/beacon/BeaconMessageType';\n                import { PermissionScope } from 'test/types/beacon/PermissionScope';\n                import { PermissionResponse } from 'test/types/beacon/messages/PermissionResponse';\n                import { OperationRequest } from 'test/types/beacon/messages/OperationRequest';\n                import { OperationResponse } from 'test/types/beacon/messages/OperationResponse';\n                import { SignPayloadRequest } from 'test/types/beacon/messages/SignPayloadRequest';\n                import { SignPayloadResponse } from 'test/types/beacon/messages/SignPayloadResponse';\n                import { BroadcastRequest } from 'test/types/beacon/messages/BroadcastRequest';\n                import { BroadcastResponse } from 'test/types/beacon/messages/BroadcastResponse';\n                import { NetworkType } from 'test/types/beacon/NetworkType';\n                import { TezosBaseOperation } from 'test/types/tezos/TezosBaseOperation';\n                import { TezosOperationType } from 'test/types/tezos/OperationTypes';\n                import { TezosActivateAccountOperation } from 'test/types/tezos/operations/ActivateAccount';\n                import { TezosBallotOperation } from 'test/types/tezos/operations/Ballot';\n                import { TezosDelegationOperation } from 'test/types/tezos/operations/Delegation';\n                import { TezosDoubleBakingEvidenceOperation } from 'test/types/tezos/operations/DoubleBakingEvidence';\n                import { TezosBlockHeader } from 'test/types/tezos/TezosBlockHeader';\n                import { TezosDoubleEndorsementEvidenceOperation } from 'test/types/tezos/operations/DoubleEndorsementEvidence';\n                import { TezosEndorsementOperation } from 'test/types/tezos/operations/Endorsement';\n                import { TezosOriginationOperation } from 'test/types/tezos/operations/Origination';\n                import { TezosProposalOperation } from 'test/types/tezos/operations/Proposal';\n                import { TezosRevealOperation } from 'test/types/tezos/operations/Reveal';\n                import { TezosSeedNonceRevelationOperation } from 'test/types/tezos/operations/SeedNonceRevelation';\n                import { TezosTransactionOperation } from 'test/types/tezos/operations/Transaction';\n                import { MichelsonPrimitives } from 'test/types/tezos/MichelsonPrimitives';\n                import { TezosTransactionParameters } from 'test/types/tezos/TezosTransactionParameters';\n                import { Origin } from 'test/types/Origin';\n                import { AccountInfo, AccountIdentifier } from 'test/types/AccountInfo';\n                import { EncryptedExtensionMessage, ExtensionMessage } from 'test/types/ExtensionMessage';\n                import { ExtensionMessageTarget } from 'test/types/ExtensionMessageTarget';\n                import { TezosOperation } from 'test/types/tezos/TezosOperation';\n                import { Client } from 'test/clients/client/Client';\n                import { WalletClient } from 'test/clients/wallet-client/WalletClient';\n                import { DAppClient } from 'test/clients/dapp-client/DAppClient';\n                import { BeaconError } from 'test/errors/BeaconError';\n                import { BeaconErrorType } from 'test/types/BeaconErrorType';\n                import { BroadcastBeaconError } from 'test/errors/BroadcastBeaconError';\n                import { NetworkNotSupportedBeaconError } from 'test/errors/NetworkNotSupportedBeaconError';\n                import { NoAddressBeaconError } from 'test/errors/NoAddressBeaconError';\n                import { NoPrivateKeyBeaconError } from 'test/errors/NoPrivateKeyBeaconError';\n                import { NotGrantedBeaconError } from 'test/errors/NotGrantedBeaconError';\n                import { ParametersInvalidBeaconError } from 'test/errors/ParametersInvalidBeaconError';\n                import { TooManyOperationsBeaconError } from 'test/errors/TooManyOperationsBeaconError';\n                import { TransactionInvalidBeaconError } from 'test/errors/TransactionInvalidBeaconError';\n                import { UnknownBeaconError } from 'test/errors/UnknownBeaconError';\n                import { ErrorResponse } from 'test/types/beacon/messages/ErrorResponse';\n                import { TransportStatus } from 'test/types/transport/TransportStatus';\n                import { TransportType } from 'test/types/transport/TransportType';\n                import { PostMessageTransport } from 'test/transports/PostMessageTransport';\n                import { Transport } from 'test/transports/Transport';\n                import { P2PTransport } from 'test/transports/P2PTransport';\n                import { Storage } from 'test/storage/Storage';\n                import { StorageKey } from 'test/types/storage/StorageKey';\n                import { StorageKeyReturnDefaults } from 'test/types/storage/StorageKeyReturnDefaults';\n                import { StorageKeyReturnType } from 'test/types/storage/StorageKeyReturnType';\n                import { ExtendedP2PPairingRequest, P2PPairingRequest } from 'test/types/P2PPairingRequest';\n                import { ChromeStorage } from 'test/storage/ChromeStorage';\n                import { LocalStorage } from 'test/storage/LocalStorage';\n                import { getStorage } from 'test/storage/getStorage';\n                import { BeaconMessage } from 'test/types/beacon/BeaconMessage';\n                import { Serializer } from 'test/Serializer';\n                import { RequestPermissionInput } from 'test/types/RequestPermissionInput';\n                import { RequestSignPayloadInput } from 'test/types/RequestSignPayloadInput';\n                import { RequestOperationInput } from 'test/types/RequestOperationInput';\n                import { RequestBroadcastInput } from 'test/types/RequestBroadcastInput';\n                import { PermissionResponseInput, SignPayloadResponseInput, OperationResponseInput, BroadcastResponseInput, BeaconResponseInputMessage, AcknowledgeResponseInput, ErrorResponseInput } from 'test/types/beacon/messages/BeaconResponseInputMessage';\n                import { PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, BeaconResponseOutputMessage } from 'test/types/beacon/messages/BeaconResponseOutputMessage';\n                import { PermissionRequestInput, SignPayloadRequestInput, OperationRequestInput, BroadcastRequestInput, BeaconRequestInputMessage } from 'test/types/beacon/messages/BeaconRequestInputMessage';\n                import { PermissionRequestOutput, SignPayloadRequestOutput, OperationRequestOutput, BroadcastRequestOutput, BeaconRequestOutputMessage } from 'test/types/beacon/messages/BeaconRequestOutputMessage';\n                import { ClientOptions } from 'test/clients/client/ClientOptions';\n                import { DAppClientOptions } from 'test/clients/dapp-client/DAppClientOptions';\n                import { WalletClientOptions } from 'test/clients/wallet-client/WalletClientOptions';\n                import { PermissionInfo } from 'test/types/PermissionInfo';\n                import { SDK_VERSION, BEACON_VERSION } from 'test/constants';\n                import { AccountManager } from 'test/managers/AccountManager';\n                import { AppMetadataManager } from 'test/managers/AppMetadataManager';\n                import { PermissionManager } from 'test/managers/PermissionManager';\n                import { BeaconEvent, BeaconEventHandler, defaultEventCallbacks } from 'test/events';\n                import { getAddressFromPublicKey } from 'test/utils/crypto';\n                import { BeaconClient } from 'test/clients/beacon-client/BeaconClient';\n                import { BeaconClientOptions } from 'test/clients/beacon-client/BeaconClientOptions';\n                import { getAccountIdentifier } from 'test/utils/get-account-identifier';\n                import { ConnectionContext } from 'test/types/ConnectionContext';\n                import { Threshold } from 'test/types/beacon/Threshold';\n                import { PartialTezosTransactionOperation, PartialTezosOperation, PartialTezosDelegationOperation, PartialTezosOriginationOperation, PartialTezosRevealOperation } from 'test/types/tezos/PartialTezosOperation';\n                import { AbortedBeaconError } from 'test/errors/AbortedBeaconError';\n                import { ExtendedPeerInfo, PeerInfo } from 'test/types/PeerInfo';\n                import { availableTransports } from 'test/utils/available-transports';\n                import { AcknowledgeResponse } from 'test/types/beacon/messages/AcknowledgeResponse';\n                import { DisconnectMessage } from 'test/types/beacon/messages/DisconnectMessage';\n                import { DappP2PTransport } from 'test/transports/DappP2PTransport';\n                import { DappPostMessageTransport } from 'test/transports/DappPostMessageTransport';\n                import { WalletP2PTransport } from 'test/transports/WalletP2PTransport';\n                import { WalletPostMessageTransport } from 'test/transports/WalletPostMessageTransport';\n                import { getSenderId } from 'test/utils/get-sender-id';\n                import { SigningType } from 'test/types/beacon/SigningType';\n                import { SignatureTypeNotSupportedBeaconError } from 'test/errors/SignatureTypeNotSupportedBeaconError';\n                import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n                import { ExtendedPostMessagePairingRequest, PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n                import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n                import { PeerManager } from 'test/managers/PeerManager';\n                import { MessageBasedClient } from 'test/transports/clients/MessageBasedClient';\n                import { BeaconRequestMessage } from 'test/types/beacon/BeaconRequestMessage';\n                import { BeaconResponseMessage } from 'test/types/beacon/BeaconResponseMessage';\n                import { Pairing } from 'test/ui/alert/Pairing';\n                import { BlockExplorer } from 'test/utils/block-explorer';\n                import { TezblockBlockExplorer } from 'test/utils/tezblock-blockexplorer';\n                import { setDebugEnabled, getDebugEnabled } from 'test/debug';\n                import { ColorMode } from 'test/types/ColorMode';\n                export { TezosBaseOperation, TezosOperationType, TezosBlockHeader, MichelsonPrimitives, TezosTransactionParameters, TezosOperation };\n                export { TezosActivateAccountOperation, TezosBallotOperation, TezosDelegationOperation, TezosDoubleBakingEvidenceOperation, TezosDoubleEndorsementEvidenceOperation, TezosEndorsementOperation, TezosOriginationOperation, TezosProposalOperation, TezosRevealOperation, TezosSeedNonceRevelationOperation, TezosTransactionOperation, PartialTezosOperation, PartialTezosTransactionOperation, PartialTezosDelegationOperation, PartialTezosOriginationOperation, PartialTezosRevealOperation };\n                export { BeaconClient, BeaconClientOptions, Client, ClientOptions, DAppClient, DAppClientOptions, WalletClient, WalletClientOptions, P2PCommunicationClient };\n                export { AccountIdentifier, AppMetadata, Network, NetworkType, BeaconMessage, PermissionRequest, PermissionResponse, OperationRequest, OperationResponse, SignPayloadRequest, SignPayloadResponse, BroadcastRequest, BroadcastResponse, AcknowledgeResponse, DisconnectMessage, BeaconBaseMessage, BeaconMessageType, PermissionScope, Origin, AccountInfo, Threshold, SigningType, ExtensionMessageTarget, ExtensionMessage, EncryptedExtensionMessage, RequestPermissionInput, RequestSignPayloadInput, RequestOperationInput, RequestBroadcastInput, PermissionInfo };\n                export { PermissionResponseInput, SignPayloadResponseInput, OperationResponseInput, BroadcastResponseInput, AcknowledgeResponseInput, ErrorResponseInput, PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, PermissionRequestInput, SignPayloadRequestInput, OperationRequestInput, BroadcastRequestInput, PermissionRequestOutput, SignPayloadRequestOutput, OperationRequestOutput, BroadcastRequestOutput, BeaconRequestInputMessage, BeaconRequestOutputMessage, BeaconResponseInputMessage, BeaconResponseOutputMessage, BeaconRequestMessage, BeaconResponseMessage };\n                export { BeaconError, BeaconErrorType, ErrorResponse, AbortedBeaconError, BroadcastBeaconError, NetworkNotSupportedBeaconError, NoAddressBeaconError, NoPrivateKeyBeaconError, NotGrantedBeaconError, ParametersInvalidBeaconError, TooManyOperationsBeaconError, TransactionInvalidBeaconError, SignatureTypeNotSupportedBeaconError, UnknownBeaconError };\n                export { TransportStatus, TransportType, Transport, PostMessageTransport, P2PTransport, WalletP2PTransport, WalletPostMessageTransport, DappP2PTransport, DappPostMessageTransport, MessageBasedClient, Pairing };\n                export { BeaconEvent, BeaconEventHandler, defaultEventCallbacks };\n                export { Storage, StorageKey, StorageKeyReturnDefaults, StorageKeyReturnType, ChromeStorage, LocalStorage, getStorage };\n                export { PeerManager, AccountManager, AppMetadataManager, PermissionManager };\n                export { SDK_VERSION, BEACON_VERSION };\n                export { getSenderId, getAccountIdentifier, getAddressFromPublicKey };\n                export { PeerInfo, ExtendedPeerInfo, PostMessagePairingRequest, ExtendedPostMessagePairingRequest, ExtendedPostMessagePairingResponse, P2PPairingRequest, ExtendedP2PPairingRequest, ExtendedP2PPairingResponse };\n                export { BlockExplorer, TezblockBlockExplorer };\n                export { ConnectionContext, Serializer, availableTransports, ColorMode };\n                export { setDebugEnabled, getDebugEnabled };\n        }\n    \n        module 'test/interceptors/IncomingRequestInterceptor' {\n                import { BeaconRequestOutputMessage } from 'test/';\n                import { ConnectionContext } from 'test/types/ConnectionContext';\n                import { AppMetadataManager } from 'test/managers/AppMetadataManager';\n                import { BeaconRequestMessage } from 'test/types/beacon/BeaconRequestMessage';\n                interface IncomingRequestInterceptorOptions {\n                                message: BeaconRequestMessage;\n                                connectionInfo: ConnectionContext;\n                                appMetadataManager: AppMetadataManager;\n                                interceptorCallback(message: BeaconRequestOutputMessage, connectionInfo: ConnectionContext): void;\n                }\n                /**\n                          * The IncomingRequestInterceptor is used in the WalletClient to intercept an incoming request and enrich it with data, like app metadata.\n                          */\n                export class IncomingRequestInterceptor {\n                                /**\n                                          * The method that is called during the interception\n                                          *\n                                          * @param config\n                                          */\n                                static intercept(config: IncomingRequestInterceptorOptions): Promise<void>;\n                }\n                export {};\n        }\n    \n        module 'test/interceptors/OutgoingResponseInterceptor' {\n                import { BeaconMessage, BeaconResponseInputMessage, AppMetadata } from 'test/';\n                import { PermissionManager } from 'test/managers/PermissionManager';\n                import { AppMetadataManager } from 'test/managers/AppMetadataManager';\n                import { BeaconRequestMessage } from 'test/types/beacon/BeaconRequestMessage';\n                interface OutgoingResponseInterceptorOptions {\n                        senderId: string;\n                        request: BeaconRequestMessage;\n                        message: BeaconResponseInputMessage;\n                        ownAppMetadata: AppMetadata;\n                        permissionManager: PermissionManager;\n                        appMetadataManager: AppMetadataManager;\n                        interceptorCallback(message: BeaconMessage): void;\n                }\n                /**\n                      * The OutgoingResponseInterceptor is used in the WalletClient to intercept an outgoing response and enrich it with data.\n                      */\n                export class OutgoingResponseInterceptor {\n                        static intercept(config: OutgoingResponseInterceptorOptions): Promise<void>;\n                }\n                export {};\n        }\n    \n        module 'test/managers/AccountManager' {\n                import { Storage, AccountInfo, BeaconMessage } from 'test/';\n                /**\n                      * The AccountManager provides CRUD functionality for account entities and persists them to the provided storage.\n                      */\n                export class AccountManager {\n                        constructor(storage: Storage);\n                        getAccounts(): Promise<AccountInfo[]>;\n                        getAccount(accountIdentifier: string): Promise<AccountInfo | undefined>;\n                        addAccount(accountInfo: AccountInfo): Promise<void>;\n                        removeAccount(accountIdentifier: string): Promise<void>;\n                        removeAccounts(accountIdentifiers: string[]): Promise<void>;\n                        removeAllAccounts(): Promise<void>;\n                        hasPermission(message: BeaconMessage): Promise<boolean>;\n                }\n        }\n    \n        module 'test/managers/AppMetadataManager' {\n                import { Storage, AppMetadata } from 'test/';\n                /**\n                      * The AppMetadataManager provides CRUD functionality for app-metadata entities and persists them to the provided storage.\n                      */\n                export class AppMetadataManager {\n                        constructor(storage: Storage);\n                        getAppMetadataList(): Promise<AppMetadata[]>;\n                        getAppMetadata(senderId: string): Promise<AppMetadata | undefined>;\n                        addAppMetadata(appMetadata: AppMetadata): Promise<void>;\n                        removeAppMetadata(senderId: string): Promise<void>;\n                        removeAppMetadatas(senderIds: string[]): Promise<void>;\n                        removeAllAppMetadata(): Promise<void>;\n                }\n        }\n    \n        module 'test/managers/PeerManager' {\n                import { Storage, StorageKey, StorageKeyReturnType } from 'test/';\n                import { ArrayElem } from 'test/managers/StorageManager';\n                /**\n                      * The PeerManager provides CRUD functionality for peer entities and persists them to the provided storage.\n                      */\n                export class PeerManager<T extends StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET> {\n                        constructor(storage: Storage, key: T);\n                        hasPeer(publicKey: string): Promise<boolean>;\n                        getPeers(): Promise<StorageKeyReturnType[T]>;\n                        getPeer(publicKey: string): Promise<ArrayElem<StorageKeyReturnType[T]> | undefined>;\n                        addPeer(peerInfo: ArrayElem<StorageKeyReturnType[T]>): Promise<void>;\n                        removePeer(publicKey: string): Promise<void>;\n                        removePeers(publicKeys: string[]): Promise<void>;\n                        removeAllPeers(): Promise<void>;\n                }\n        }\n    \n        module 'test/managers/PermissionManager' {\n                import { BeaconMessage, Storage } from 'test/';\n                import { PermissionInfo } from 'test/types/PermissionInfo';\n                /**\n                      * The PermissionManager provides CRUD functionality for permission entities and persists them to the provided storage.\n                      */\n                export class PermissionManager {\n                        constructor(storage: Storage);\n                        getPermissions(): Promise<PermissionInfo[]>;\n                        getPermission(accountIdentifier: string): Promise<PermissionInfo | undefined>;\n                        addPermission(permissionInfo: PermissionInfo): Promise<void>;\n                        removePermission(accountIdentifier: string): Promise<void>;\n                        removePermissions(accountIdentifiers: string[]): Promise<void>;\n                        removeAllPermissions(): Promise<void>;\n                        hasPermission(message: BeaconMessage): Promise<boolean>;\n                }\n        }\n    \n        module 'test/managers/PermissionValidator' {\n                import { BeaconMessage } from 'test/';\n                import { PermissionEntity } from 'test/types/PermissionEntity';\n                /**\n                          * The PermissionValidator is used to check if permissions for a certain message type have been given\n                          */\n                export class PermissionValidator {\n                                /**\n                                          * Check if permissions were given for a certain message type.\n                                          *\n                                          * PermissionRequest and BroadcastRequest will always return true.\n                                          *\n                                          * @param message Beacon Message\n                                          */\n                                static hasPermission(message: BeaconMessage, getOne: (id: string) => Promise<PermissionEntity | undefined>, getAll: () => Promise<PermissionEntity[]>): Promise<boolean>;\n                }\n        }\n    \n        module 'test/managers/StorageManager' {\n                import { StorageKey, Storage, StorageKeyReturnType } from 'test/';\n                /** Type workaround for https://github.com/Microsoft/TypeScript/issues/7294#issuecomment-465794460 */\n                export type ArrayElem<A> = A extends (infer Elem)[] ? Elem : never;\n                /**\n                          * The StorageManager provides CRUD functionality for specific entities and persists them to the provided storage.\n                          */\n                export class StorageManager<T extends StorageKey.ACCOUNTS | StorageKey.APP_METADATA_LIST | StorageKey.PERMISSION_LIST | StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET> {\n                                constructor(storage: Storage, storageKey: T);\n                                getAll(): Promise<StorageKeyReturnType[T]>;\n                                getOne(predicate: (element: ArrayElem<StorageKeyReturnType[T]>) => boolean): Promise<ArrayElem<StorageKeyReturnType[T]> | undefined>;\n                                addOne(element: ArrayElem<StorageKeyReturnType[T]>, predicate: (element: ArrayElem<StorageKeyReturnType[T]>) => boolean, overwrite?: boolean): Promise<void>;\n                                remove(predicate: (element: ArrayElem<StorageKeyReturnType[T]>) => boolean): Promise<void>;\n                                removeAll(): Promise<void>;\n                }\n        }\n    \n        module 'test/matrix-client/MatrixClient' {\n                import { Storage } from 'test/storage/Storage';\n                import { MatrixClientStore } from 'test/matrix-client/MatrixClientStore';\n                import { MatrixRoom } from 'test/matrix-client/models/MatrixRoom';\n                import { MatrixRoomService } from 'test/matrix-client/services/MatrixRoomService';\n                import { MatrixUserService } from 'test/matrix-client/services/MatrixUserService';\n                import { MatrixEventService } from 'test/matrix-client/services/MatrixEventService';\n                import { MatrixClientEventEmitter } from 'test/matrix-client/MatrixClientEventEmitter';\n                import { MatrixClientEventType, MatrixClientEvent } from 'test/matrix-client/models/MatrixClientEvent';\n                interface MatrixClientOptions {\n                                baseUrl: string;\n                                storage: Storage;\n                }\n                interface MatrixLoginConfig {\n                                id: string;\n                                password: string;\n                                deviceId: string;\n                }\n                /**\n                          * The matrix client used to connect to the matrix network\n                          */\n                export class MatrixClient {\n                                /**\n                                          * Create a matrix client based on the options provided\n                                          *\n                                          * @param config\n                                          */\n                                static create(config: MatrixClientOptions): MatrixClient;\n                                /**\n                                          * Return all the rooms we are currently part of\n                                          */\n                                get joinedRooms(): MatrixRoom[];\n                                /**\n                                          * Return all the rooms to which we have received invitations\n                                          */\n                                get invitedRooms(): MatrixRoom[];\n                                /**\n                                          * Return all the rooms that we left\n                                          */\n                                get leftRooms(): MatrixRoom[];\n                                constructor(store: MatrixClientStore, eventEmitter: MatrixClientEventEmitter, userService: MatrixUserService, roomService: MatrixRoomService, eventService: MatrixEventService);\n                                /**\n                                          * Initiate the connection to the matrix node and log in\n                                          *\n                                          * @param user\n                                          */\n                                start(user: MatrixLoginConfig): Promise<void>;\n                                /**\n                                          * Subscribe to new matrix events\n                                          *\n                                          * @param event\n                                          * @param listener\n                                          */\n                                subscribe<T extends MatrixClientEventType>(event: T, listener: (event: MatrixClientEvent<T>) => void): void;\n                                /**\n                                          * Unsubscribe from matrix events\n                                          *\n                                          * @param event\n                                          * @param listener\n                                          */\n                                unsubscribe(event: MatrixClientEventType, listener?: (event: MatrixClientEvent<any>) => void): void;\n                                getRoomById(id: string): MatrixRoom;\n                                /**\n                                          * Create a private room with the supplied members\n                                          *\n                                          * @param members Members that will be in the room\n                                          */\n                                createTrustedPrivateRoom(...members: string[]): Promise<string>;\n                                /**\n                                          * Invite user to rooms\n                                          *\n                                          * @param user The user to be invited\n                                          * @param roomsOrIds The rooms the user will be invited to\n                                          */\n                                inviteToRooms(user: string, ...roomsOrIds: string[] | MatrixRoom[]): Promise<void>;\n                                /**\n                                          * Join rooms\n                                          *\n                                          * @param roomsOrIds\n                                          */\n                                joinRooms(...roomsOrIds: string[] | MatrixRoom[]): Promise<void>;\n                                /**\n                                          * Send a text message\n                                          *\n                                          * @param roomOrId\n                                          * @param message\n                                          */\n                                sendTextMessage(roomId: string, message: string): Promise<void>;\n                }\n                export {};\n        }\n    \n        module 'test/matrix-client/MatrixClientEventEmitter' {\n                import { EventEmitter } from 'events';\n                import { MatrixStateStore, MatrixStateUpdate } from 'test/matrix-client/MatrixClientStore';\n                export class MatrixClientEventEmitter extends EventEmitter {\n                                /**\n                                          * This method is called every time the state is changed\n                                          *\n                                          * @param _oldState\n                                          * @param _newState\n                                          * @param stateChange\n                                          */\n                                onStateChanged(_oldState: MatrixStateStore, _newState: MatrixStateStore, stateChange: Partial<MatrixStateUpdate>): void;\n                }\n        }\n    \n        module 'test/matrix-client/MatrixClientStore' {\n                import { MatrixRoom } from 'test/matrix-client/models/MatrixRoom';\n                import { Storage } from 'test/storage/Storage';\n                type OnStateChangedListener = (oldState: MatrixStateStore, newState: MatrixStateStore, stateChange: Partial<MatrixStateUpdate>) => void;\n                export interface MatrixState {\n                                isRunning: boolean;\n                                userId: string | undefined;\n                                deviceId: string | undefined;\n                                txnNo: number;\n                                accessToken: string | undefined;\n                                syncToken: string | undefined;\n                                pollingTimeout: number | undefined;\n                                pollingRetries: number;\n                                rooms: MatrixRoom[] | Record<string, MatrixRoom>;\n                }\n                export interface MatrixStateStore extends MatrixState {\n                                rooms: Record<string, MatrixRoom>;\n                }\n                export interface MatrixStateUpdate extends MatrixState {\n                                rooms: MatrixRoom[];\n                }\n                /**\n                          * The class managing the local state of matrix\n                          */\n                export class MatrixClientStore {\n                                constructor(storage: Storage);\n                                /**\n                                          * Get an item from the state\n                                          *\n                                          * @param key\n                                          */\n                                get<T extends keyof MatrixStateStore>(key: T): MatrixStateStore[T];\n                                /**\n                                          * Get the room from an ID or room instance\n                                          *\n                                          * @param roomOrId\n                                          */\n                                getRoom(roomOrId: string | MatrixRoom): MatrixRoom;\n                                /**\n                                          * Update the state with a partial state\n                                          *\n                                          * @param stateUpdate\n                                          */\n                                update(stateUpdate: Partial<MatrixStateUpdate>): Promise<void>;\n                                /**\n                                          * Register listeners that are called once the state has changed\n                                          *\n                                          * @param listener\n                                          * @param subscribed\n                                          */\n                                onStateChanged(listener: OnStateChangedListener, ...subscribed: (keyof MatrixState)[]): void;\n                }\n                export {};\n        }\n    \n        module 'test/matrix-client/MatrixHttpClient' {\n                import { MatrixRequest, MatrixRequestParams } from 'test/matrix-client/models/api/MatrixRequest';\n                interface HttpOptions {\n                                accessToken?: string;\n                }\n                /**\n                          * Handling the HTTP connection to the matrix synapse node\n                          */\n                export class MatrixHttpClient {\n                                constructor(baseUrl: string);\n                                /**\n                                          * Get data from the synapse node\n                                          *\n                                          * @param endpoint\n                                          * @param options\n                                          */\n                                get<T>(endpoint: string, params?: MatrixRequestParams<T>, options?: HttpOptions): Promise<T>;\n                                /**\n                                          * Post data to the synapse node\n                                          *\n                                          * @param endpoint\n                                          * @param body\n                                          * @param options\n                                          * @param params\n                                          */\n                                post<T>(endpoint: string, body: MatrixRequest<T>, options?: HttpOptions, params?: MatrixRequestParams<T>): Promise<T>;\n                                /**\n                                          * Put data to the synapse node\n                                          *\n                                          * @param endpoint\n                                          * @param body\n                                          * @param options\n                                          * @param params\n                                          */\n                                put<T>(endpoint: string, body: MatrixRequest<T>, options?: HttpOptions, params?: MatrixRequestParams<T>): Promise<T>;\n                }\n                export {};\n        }\n    \n        module 'test/matrix-client/models/api/MatrixEventSend' {\n                export interface MatrixEventSendRequest {\n                        content: any;\n                }\n                export interface MatrixEventSendResponse {\n                        type?: 'event_send';\n                        event_id: string;\n                }\n        }\n    \n        module 'test/matrix-client/models/api/MatrixLogin' {\n                export interface MatrixLoginRequest {\n                        type: 'm.login.password';\n                        identifier: {\n                                type: 'm.id.user';\n                                user: string;\n                        };\n                        password: string;\n                        device_id?: string;\n                }\n                export interface MatrixLoginResponse {\n                        type?: 'login';\n                        user_id: string;\n                        device_id: string;\n                        access_token: string;\n                }\n        }\n    \n        module 'test/matrix-client/models/api/MatrixRequest' {\n                import { MatrixLoginRequest, MatrixLoginResponse } from 'test/matrix-client/models/api/MatrixLogin';\n                import { MatrixRoomCreateRequest, MatrixRoomCreateResponse } from 'test/matrix-client/models/api/MatrixRoomCreate';\n                import { MatrixRoomInviteRequest, MatrixRoomInviteResponse } from 'test/matrix-client/models/api/MatrixRoomInvite';\n                import { MatrixRoomJoinRequest, MatrixRoomJoinResponse } from 'test/matrix-client/models/api/MatrixRoomJoin';\n                import { MatrixEventSendRequest, MatrixEventSendResponse } from 'test/matrix-client/models/api/MatrixEventSend';\n                import { MatrixSyncResponse, MatrixSyncRequestParams } from 'test/matrix-client/models/api/MatrixSync';\n                export type MatrixRequest<T> = T extends MatrixLoginResponse ? MatrixLoginRequest : T extends MatrixRoomCreateResponse ? MatrixRoomCreateRequest : T extends MatrixRoomInviteResponse ? MatrixRoomInviteRequest : T extends MatrixRoomJoinResponse ? MatrixRoomJoinRequest : T extends MatrixEventSendResponse ? MatrixEventSendRequest : never;\n                export type MatrixRequestParams<T> = T extends MatrixSyncResponse ? MatrixSyncRequestParams : never;\n        }\n    \n        module 'test/matrix-client/models/api/MatrixRoomCreate' {\n                export interface MatrixRoomCreateRequest {\n                        visibility?: 'public' | 'private';\n                        room_alias_name?: string;\n                        name?: string;\n                        topic?: string;\n                        invite?: string[];\n                        preset?: 'private_chat' | 'public_chat' | 'trusted_private_chat';\n                        is_direct?: boolean;\n                }\n                export interface MatrixRoomCreateResponse {\n                        type?: 'room_create';\n                        room_id: string;\n                }\n        }\n    \n        module 'test/matrix-client/models/api/MatrixRoomInvite' {\n                export interface MatrixRoomInviteRequest {\n                        user_id: string;\n                }\n                export interface MatrixRoomInviteResponse {\n                        type?: 'room_invite';\n                }\n        }\n    \n        module 'test/matrix-client/models/api/MatrixRoomJoin' {\n                export interface MatrixRoomJoinRequest {\n                }\n                export interface MatrixRoomJoinResponse {\n                        type?: 'room_join';\n                        room_id: string;\n                }\n        }\n    \n        module 'test/matrix-client/models/api/MatrixSync' {\n                import { MatrixStateEvent } from 'test/matrix-client/models/MatrixStateEvent';\n                export interface MatrixSyncJoinedRoom {\n                        state: {\n                                events: MatrixStateEvent[];\n                        };\n                        timeline: {\n                                events: MatrixStateEvent[];\n                        };\n                }\n                export interface MatrixSyncInvitedRoom {\n                        invite_state: {\n                                events: MatrixStateEvent[];\n                        };\n                }\n                export interface MatrixSyncLeftRoom {\n                        state: {\n                                events: MatrixStateEvent[];\n                        };\n                        timeline: {\n                                events: MatrixStateEvent[];\n                        };\n                }\n                export interface MatrixSyncRooms {\n                        join: {\n                                [key: string]: MatrixSyncJoinedRoom;\n                        };\n                        invite: {\n                                [key: string]: MatrixSyncInvitedRoom;\n                        };\n                        leave: {\n                                [key: string]: MatrixSyncLeftRoom;\n                        };\n                }\n                export interface MatrixSyncRequestParams {\n                        timeout?: number;\n                        since?: string;\n                }\n                export interface MatrixSyncResponse {\n                        type?: 'sync';\n                        next_batch: string;\n                        rooms: MatrixSyncRooms;\n                }\n        }\n    \n        module 'test/matrix-client/models/MatrixClientEvent' {\n                import { MatrixMessage } from 'test/matrix-client/models/MatrixMessage';\n                export enum MatrixClientEventType {\n                        INVITE = \"invite\",\n                        MESSAGE = \"message\"\n                }\n                export type MatrixClientEventContent<T> = T extends MatrixClientEventType.INVITE ? MatrixClientEventInviteContent : T extends MatrixClientEventType.MESSAGE ? MatrixClientEventMessageContent<any> : never;\n                export interface MatrixClientEventInviteContent {\n                        roomId: string;\n                }\n                export interface MatrixClientEventMessageContent<T> {\n                        roomId: string;\n                        message: MatrixMessage<T>;\n                }\n                export interface MatrixClientEvent<T extends MatrixClientEventType> {\n                        type: T;\n                        content: MatrixClientEventContent<T>;\n                }\n        }\n    \n        module 'test/matrix-client/models/MatrixMessage' {\n                import { MatrixStateEvent } from 'test/matrix-client/models/MatrixStateEvent';\n                export enum MatrixMessageType {\n                        TEXT = \"m.text\"\n                }\n                export class MatrixMessage<T> {\n                        readonly type: MatrixMessageType;\n                        readonly sender: string;\n                        readonly content: T;\n                        /**\n                              * Construct a message from a message event\n                              *\n                              * @param event\n                              */\n                        static from(event: MatrixStateEvent): MatrixMessage<any> | undefined;\n                }\n        }\n    \n        module 'test/matrix-client/models/MatrixRoom' {\n                import { MatrixSyncRooms } from 'test/matrix-client/models/api/MatrixSync';\n                import { MatrixMessage } from 'test/matrix-client/models/MatrixMessage';\n                export enum MatrixRoomStatus {\n                                UNKNOWN = 0,\n                                JOINED = 1,\n                                INVITED = 2,\n                                LEFT = 3\n                }\n                export class MatrixRoom {\n                                readonly id: string;\n                                readonly status: MatrixRoomStatus;\n                                readonly members: string[];\n                                messages: MatrixMessage<any>[];\n                                /**\n                                          * Reconstruct rooms from a sync response\n                                          *\n                                          * @param roomSync\n                                          */\n                                static fromSync(roomSync: MatrixSyncRooms): MatrixRoom[];\n                                /**\n                                          * Reconstruct a room from an ID or object\n                                          *\n                                          * @param roomOrId\n                                          * @param status\n                                          */\n                                static from(roomOrId: string | MatrixRoom, status?: MatrixRoomStatus): MatrixRoom;\n                                /**\n                                          * Merge new and old state and remove duplicates\n                                          *\n                                          * @param newState\n                                          * @param previousState\n                                          */\n                                static merge(newState: MatrixRoom, previousState?: MatrixRoom): MatrixRoom;\n                }\n        }\n    \n        module 'test/matrix-client/models/MatrixStateEvent' {\n                import { MatrixMessageType } from 'test/matrix-client/models/MatrixMessage';\n                export interface MatrixStateEventMessageText extends MatrixStateEventMessage {\n                        type: 'm.room.message';\n                        content: {\n                                msgtype: MatrixMessageType.TEXT;\n                                body: string;\n                        };\n                }\n                export interface MatrixStateEventMessageContent {\n                        msgtype: string;\n                        body: any;\n                        [key: string]: any;\n                }\n                export interface MatrixStateEventMessage extends MatrixStateEvent {\n                        type: 'm.room.message';\n                        content: MatrixStateEventMessageContent;\n                }\n                export interface MatrixStateEvent {\n                        type: string;\n                        sender: string;\n                        content: unknown;\n                        event_id?: string;\n                }\n        }\n    \n        module 'test/matrix-client/services/MatrixEventService' {\n                import { MatrixHttpClient } from 'test/matrix-client/MatrixHttpClient';\n                import { MatrixEventSendResponse } from 'test/matrix-client/models/api/MatrixEventSend';\n                import { MatrixSyncResponse } from 'test/matrix-client/models/api/MatrixSync';\n                import { MatrixStateEventMessageContent } from 'test/matrix-client/models/MatrixStateEvent';\n                interface MatrixScheduledEvent<T> {\n                                accessToken: string;\n                                roomId: string;\n                                type: MatrixEventType;\n                                content: any;\n                                txnId: string;\n                                onSuccess(response: T): void;\n                                onError(error: unknown): void;\n                }\n                type MatrixEventType = 'm.room.message';\n                export interface MatrixSyncOptions {\n                                syncToken?: string;\n                                pollingTimeout?: number;\n                }\n                /**\n                          * A service to help with matrix event management\n                          */\n                export class MatrixEventService {\n                                constructor(httpClient: MatrixHttpClient);\n                                /**\n                                          * Get the latest state from the matrix node\n                                          *\n                                          * @param accessToken\n                                          * @param options\n                                          */\n                                sync(accessToken: string, options?: MatrixSyncOptions): Promise<MatrixSyncResponse>;\n                                /**\n                                          * Send a message to a room\n                                          *\n                                          * @param accessToken\n                                          * @param room\n                                          * @param content\n                                          * @param txnId\n                                          */\n                                sendMessage(accessToken: string, roomId: string, content: MatrixStateEventMessageContent, txnId: string): Promise<MatrixEventSendResponse>;\n                                /**\n                                          * Schedules an event to be sent to the node\n                                          *\n                                          * @param event\n                                          */\n                                scheduleEvent(event: MatrixScheduledEvent<any>): void;\n                                /**\n                                          * Send an event to the matrix node\n                                          *\n                                          * @param scheduledEvent\n                                          */\n                                sendEvent(scheduledEvent: MatrixScheduledEvent<any>): Promise<void>;\n                }\n                export {};\n        }\n    \n        module 'test/matrix-client/services/MatrixRoomService' {\n                import { MatrixHttpClient } from 'test/matrix-client/MatrixHttpClient';\n                import { MatrixRoom } from 'test/matrix-client/models/MatrixRoom';\n                import { MatrixRoomCreateRequest, MatrixRoomCreateResponse } from 'test/matrix-client/models/api/MatrixRoomCreate';\n                import { MatrixRoomInviteResponse } from 'test/matrix-client/models/api/MatrixRoomInvite';\n                import { MatrixRoomJoinResponse } from 'test/matrix-client/models/api/MatrixRoomJoin';\n                /**\n                          * A service to help with matrix room management\n                          */\n                export class MatrixRoomService {\n                                constructor(httpClient: MatrixHttpClient);\n                                /**\n                                          * Create a room\n                                          *\n                                          * @param accessToken\n                                          * @param config\n                                          */\n                                createRoom(accessToken: string, config?: MatrixRoomCreateRequest): Promise<MatrixRoomCreateResponse>;\n                                /**\n                                          * Invite a user to a room\n                                          *\n                                          * @param accessToken\n                                          * @param user\n                                          * @param room\n                                          */\n                                inviteToRoom(accessToken: string, user: string, room: MatrixRoom): Promise<MatrixRoomInviteResponse>;\n                                /**\n                                          * Join a specific room\n                                          *\n                                          * @param accessToken\n                                          * @param room\n                                          */\n                                joinRoom(accessToken: string, room: MatrixRoom): Promise<MatrixRoomJoinResponse>;\n                                /**\n                                          * Get all joined rooms\n                                          *\n                                          * @param accessToken\n                                          */\n                                getJoinedRooms(accessToken: string): Promise<MatrixRoomJoinResponse>;\n                }\n        }\n    \n        module 'test/matrix-client/services/MatrixUserService' {\n                import { MatrixHttpClient } from 'test/matrix-client/MatrixHttpClient';\n                import { MatrixLoginResponse } from 'test/matrix-client/models/api/MatrixLogin';\n                export class MatrixUserService {\n                        constructor(httpClient: MatrixHttpClient);\n                        /**\n                              * Log in to the matrix node with username and password\n                              *\n                              * @param user\n                              * @param password\n                              * @param deviceId\n                              */\n                        login(user: string, password: string, deviceId: string): Promise<MatrixLoginResponse>;\n                }\n        }\n    \n        module 'test/matrix-client/utils/events' {\n                import { MatrixStateEvent, MatrixStateEventMessageText } from 'test/matrix-client/models/MatrixStateEvent';\n                /**\n                          * Check if an event is a create event\n                          *\n                          * @param event MatrixStateEvent\n                          */\n                export const isCreateEvent: (event: MatrixStateEvent) => boolean;\n                /**\n                          * Check if an event is a join event\n                          *\n                          * @param event MatrixStateEvent\n                          */\n                export const isJoinEvent: (event: MatrixStateEvent) => boolean;\n                /**\n                          * Check if an event is a message event\n                          *\n                          * @param event MatrixStateEvent\n                          */\n                export const isMessageEvent: (event: MatrixStateEvent) => boolean;\n                /**\n                          * Check if an event is a text message event\n                          *\n                          * @param event MatrixStateEvent\n                          */\n                export const isTextMessageEvent: (event: MatrixStateEvent) => event is MatrixStateEventMessageText;\n        }\n    \n        module 'test/migrations/migrate-0.7.0' {\n                import { PermissionScope, AccountIdentifier, Origin, Network } from 'test/';\n                export interface AccountInfoOld {\n                        accountIdentifier: AccountIdentifier;\n                        beaconId: string;\n                        origin: {\n                                type: Origin;\n                                id: string;\n                        };\n                        address: string;\n                        pubkey: string;\n                        network: Network;\n                        scopes: PermissionScope[];\n                        connectedAt: Date;\n                }\n                export interface P2PPairingRequestOld {\n                        name: string;\n                        pubKey: string;\n                        relayServer: string;\n                }\n                export const migrate_0_7_0: (storage: Storage) => Promise<void>;\n        }\n    \n        module 'test/migrations/migrations' {\n                import { Storage } from 'test/';\n                export const migrate: (storage: Storage) => Promise<void>;\n        }\n    \n        module 'test/MockWindow' {\n                type Callback = (message: unknown) => void;\n                /**\n                      * A mock for postmessage if run in node.js environment\n                      */\n                let windowRef: {\n                        postMessage: (message: string | Record<string, unknown>, _target?: string | undefined) => void;\n                        addEventListener: (_name: string, eventCallback: Callback) => void;\n                        removeEventListener: (_name: string, eventCallback: Callback) => void;\n                        location: {\n                                origin: string;\n                        };\n                };\n                const clearMockWindowState: () => void;\n                export { windowRef, clearMockWindowState };\n        }\n    \n        module 'test/Serializer' {\n                /**\n                          * The Serializer is used to serialize / deserialize JSON objects and encode them with bs58check\n                          */\n                export class Serializer {\n                                /**\n                                          * Serialize and bs58check encode an object\n                                          *\n                                          * @param message JSON object to serialize\n                                          */\n                                serialize(message: unknown): Promise<string>;\n                                /**\n                                          * Deserialize a bs58check encoded string\n                                          *\n                                          * @param encoded String to be deserialized\n                                          */\n                                deserialize(encoded: string): Promise<unknown>;\n                }\n        }\n    \n        module 'test/storage/ChromeStorage' {\n                import { Storage, StorageKey, StorageKeyReturnType } from 'test/';\n                export class ChromeStorage implements Storage {\n                        static isSupported(): Promise<boolean>;\n                        get<K extends StorageKey>(key: K): Promise<StorageKeyReturnType[K]>;\n                        set<K extends StorageKey>(key: K, value: StorageKeyReturnType[K]): Promise<void>;\n                        delete<K extends StorageKey>(key: K): Promise<void>;\n                }\n        }\n    \n        module 'test/storage/getStorage' {\n                import { Storage } from 'test/';\n                /**\n                      * Get a supported storage on this platform\n                      */\n                export const getStorage: () => Promise<Storage>;\n        }\n    \n        module 'test/storage/LocalStorage' {\n                import { Storage, StorageKey, StorageKeyReturnType } from 'test/';\n                export class LocalStorage implements Storage {\n                        constructor(prefix?: string | undefined);\n                        static isSupported(): Promise<boolean>;\n                        get<K extends StorageKey>(key: K): Promise<StorageKeyReturnType[K]>;\n                        set<K extends StorageKey>(key: K, value: StorageKeyReturnType[K]): Promise<void>;\n                        delete<K extends StorageKey>(key: K): Promise<void>;\n                }\n        }\n    \n        module 'test/storage/Storage' {\n                import { StorageKey } from 'test/types/storage/StorageKey';\n                import { StorageKeyReturnType } from 'test/types/storage/StorageKeyReturnType';\n                /**\n                          * The storage used in the SDK\n                          */\n                export abstract class Storage {\n                                /**\n                                          * Returns a promise that resolves to true if the storage option is available on this platform.\n                                          */\n                                static isSupported(): Promise<boolean>;\n                                /**\n                                          * Gets a value from storage and returns it\n                                          *\n                                          * @param key The storage key\n                                          */\n                                abstract get<K extends StorageKey>(key: K): Promise<StorageKeyReturnType[K]>;\n                                /**\n                                          * Sets a value in the storage and persist it\n                                          *\n                                          * @param key The storage key\n                                          * @param value The value to be persisted\n                                          */\n                                abstract set<K extends StorageKey>(key: K, value: StorageKeyReturnType[K]): Promise<void>;\n                                /**\n                                          * Delete a key from storage\n                                          *\n                                          * @param key The storage key\n                                          */\n                                abstract delete<K extends StorageKey>(key: K): Promise<void>;\n                }\n        }\n    \n        module 'test/transports/clients/CommunicationClient' {\n                import * as sodium from 'libsodium-wrappers';\n                import { P2PPairingRequest } from 'test/';\n                import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n                import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n                import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n                export abstract class CommunicationClient {\n                                protected readonly keyPair: sodium.KeyPair;\n                                constructor(keyPair: sodium.KeyPair);\n                                /**\n                                          * Get the public key\n                                          */\n                                getPublicKey(): Promise<string>;\n                                /**\n                                          * get the public key hash\n                                          */\n                                getPublicKeyHash(): Promise<string>;\n                                /**\n                                          * Create a cryptobox shared key\n                                          *\n                                          * @param otherPublicKey\n                                          * @param selfPrivateKey\n                                          */\n                                protected createCryptoBox(otherPublicKey: string, selfPrivateKey: Uint8Array): Promise<[Uint8Array, Uint8Array, Uint8Array]>;\n                                /**\n                                          * Create a cryptobox server\n                                          *\n                                          * @param otherPublicKey\n                                          * @param selfPrivateKey\n                                          */\n                                protected createCryptoBoxServer(otherPublicKey: string, selfPrivateKey: Uint8Array): Promise<sodium.CryptoKX>;\n                                /**\n                                          * Create a cryptobox client\n                                          *\n                                          * @param otherPublicKey\n                                          * @param selfPrivateKey\n                                          */\n                                protected createCryptoBoxClient(otherPublicKey: string, selfPrivateKey: Uint8Array): Promise<sodium.CryptoKX>;\n                                /**\n                                          * Encrypt a message for a specific publicKey (receiver, asymmetric)\n                                          *\n                                          * @param recipientPublicKey\n                                          * @param message\n                                          */\n                                protected encryptMessageAsymmetric(recipientPublicKey: string, message: string): Promise<string>;\n                                abstract unsubscribeFromEncryptedMessages(): Promise<void>;\n                                abstract unsubscribeFromEncryptedMessage(senderPublicKey: string): Promise<void>;\n                                abstract sendMessage(message: string, peer?: P2PPairingRequest | ExtendedP2PPairingResponse | PostMessagePairingRequest | ExtendedPostMessagePairingResponse): Promise<void>;\n                }\n        }\n    \n        module 'test/transports/clients/MessageBasedClient' {\n                import * as sodium from 'libsodium-wrappers';\n                import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n                import { PostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n                import { CommunicationClient } from 'test/transports/clients/CommunicationClient';\n                export abstract class MessageBasedClient extends CommunicationClient {\n                                protected readonly name: string;\n                                /**\n                                          * The listeners that will be notified of new messages\n                                          */\n                                protected abstract readonly activeListeners: Map<string, unknown>;\n                                constructor(name: string, keyPair: sodium.KeyPair);\n                                /**\n                                          * start the client and make sure all dependencies are ready\n                                          */\n                                start(): Promise<void>;\n                                /**\n                                          * Get the pairing request information. This will be shared with the peer during the connection setup\n                                          */\n                                getPairingRequestInfo(): Promise<PostMessagePairingRequest>;\n                                /**\n                                          * Get the pairing response information. This will be shared with the peer during the connection setup\n                                          */\n                                getPairingResponseInfo(request: PostMessagePairingRequest): Promise<PostMessagePairingResponse>;\n                                /**\n                                          * Unsubscribe from encrypted messages from a specific peer\n                                          *\n                                          * @param senderPublicKey\n                                          */\n                                unsubscribeFromEncryptedMessage(senderPublicKey: string): Promise<void>;\n                                /**\n                                          * Unsubscribe from all encrypted messages\n                                          */\n                                unsubscribeFromEncryptedMessages(): Promise<void>;\n                                /**\n                                          * Decrypt a message from a specific peer\n                                          *\n                                          * @param senderPublicKey\n                                          * @param payload\n                                          */\n                                protected decryptMessage(senderPublicKey: string, payload: string): Promise<string>;\n                                /**\n                                          * Encrypt a message for a specific publicKey (receiver)\n                                          *\n                                          * @param recipientPublicKey\n                                          * @param message\n                                          */\n                                protected encryptMessage(recipientPublicKey: string, message: string): Promise<string>;\n                                /**\n                                          * Initialize the connection\n                                          */\n                                abstract init(): Promise<void>;\n                }\n        }\n    \n        module 'test/transports/clients/P2PCommunicationClient' {\n                import * as sodium from 'libsodium-wrappers';\n                import { MatrixClientEvent, MatrixClientEventType, MatrixClientEventMessageContent } from 'test/matrix-client/models/MatrixClientEvent';\n                import { Storage } from 'test/storage/Storage';\n                import { P2PPairingRequest } from 'test/';\n                import { ExtendedP2PPairingResponse, P2PPairingResponse } from 'test/types/P2PPairingResponse';\n                import { CommunicationClient } from 'test/transports/clients/CommunicationClient';\n                export class P2PCommunicationClient extends CommunicationClient {\n                        readonly replicationCount: number;\n                        constructor(name: string, keyPair: sodium.KeyPair, replicationCount: number, storage: Storage, matrixNodes: string[], iconUrl?: string | undefined, appUrl?: string | undefined);\n                        getPairingRequestInfo(): Promise<P2PPairingRequest>;\n                        getPairingResponseInfo(request: P2PPairingRequest): Promise<P2PPairingResponse>;\n                        getRelayServer(publicKeyHash?: string, nonce?: string): Promise<string>;\n                        start(): Promise<void>;\n                        listenForEncryptedMessage(senderPublicKey: string, messageCallback: (message: string) => void): Promise<void>;\n                        unsubscribeFromEncryptedMessage(senderPublicKey: string): Promise<void>;\n                        unsubscribeFromEncryptedMessages(): Promise<void>;\n                        sendMessage(message: string, peer: P2PPairingRequest | ExtendedP2PPairingResponse): Promise<void>;\n                        deleteRoomIdFromRooms(roomId: string): Promise<void>;\n                        listenForChannelOpening(messageCallback: (pairingResponse: ExtendedP2PPairingResponse) => void): Promise<void>;\n                        sendPairingResponse(pairingRequest: P2PPairingRequest): Promise<void>;\n                        isTextMessage(content: MatrixClientEventMessageContent<any>): content is MatrixClientEventMessageContent<string>;\n                        isChannelOpenMessage(content: MatrixClientEventMessageContent<string>): Promise<boolean>;\n                        isSender(event: MatrixClientEvent<MatrixClientEventType.MESSAGE>, senderPublicKey: string): Promise<boolean>;\n                }\n        }\n    \n        module 'test/transports/clients/PostMessageClient' {\n                import { ConnectionContext } from 'test/';\n                import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n                import { EncryptedExtensionMessage } from 'test/types/ExtensionMessage';\n                import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n                import { MessageBasedClient } from 'test/transports/clients/MessageBasedClient';\n                export class PostMessageClient extends MessageBasedClient {\n                        protected readonly activeListeners: Map<string, (message: EncryptedExtensionMessage, context: ConnectionContext) => void>;\n                        init(): Promise<void>;\n                        listenForEncryptedMessage(senderPublicKey: string, messageCallback: (message: string, context: ConnectionContext) => void): Promise<void>;\n                        sendMessage(message: string, peer: PostMessagePairingRequest | ExtendedPostMessagePairingResponse): Promise<void>;\n                        listenForChannelOpening(messageCallback: (pairingResponse: ExtendedPostMessagePairingResponse) => void): Promise<void>;\n                        sendPairingRequest(id: string): Promise<void>;\n                        isChannelOpenMessage(message: any): Promise<boolean>;\n                }\n        }\n    \n        module 'test/transports/DappP2PTransport' {\n                import * as sodium from 'libsodium-wrappers';\n                import { Storage, StorageKey, P2PTransport } from 'test/';\n                import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n                export class DappP2PTransport extends P2PTransport<ExtendedP2PPairingResponse, StorageKey.TRANSPORT_P2P_PEERS_DAPP> {\n                        constructor(name: string, keyPair: sodium.KeyPair, storage: Storage, matrixNodes: string[], iconUrl?: string, appUrl?: string);\n                        startOpenChannelListener(): Promise<void>;\n                        listenForNewPeer(newPeerListener: (peer: ExtendedP2PPairingResponse) => void): Promise<void>;\n                        stopListeningForNewPeers(): Promise<void>;\n                }\n        }\n    \n        module 'test/transports/DappPostMessageTransport' {\n                import * as sodium from 'libsodium-wrappers';\n                import { StorageKey, PostMessageTransport, Storage } from 'test/';\n                import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n                export class DappPostMessageTransport extends PostMessageTransport<ExtendedPostMessagePairingResponse, StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP> {\n                        constructor(name: string, keyPair: sodium.KeyPair, storage: Storage);\n                        startOpenChannelListener(): Promise<void>;\n                        listenForNewPeer(newPeerListener: (peer: ExtendedPostMessagePairingResponse) => void): Promise<void>;\n                        stopListeningForNewPeers(): Promise<void>;\n                }\n        }\n    \n        module 'test/transports/P2PTransport' {\n                import * as sodium from 'libsodium-wrappers';\n                import { Storage, StorageKey, Transport, TransportType, P2PCommunicationClient, P2PPairingRequest } from 'test/';\n                import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n                export class P2PTransport<T extends P2PPairingRequest | ExtendedP2PPairingResponse, K extends StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET> extends Transport<T, K, P2PCommunicationClient> {\n                        readonly type: TransportType;\n                        constructor(name: string, keyPair: sodium.KeyPair, storage: Storage, matrixNodes: string[], storageKey: K, iconUrl?: string, appUrl?: string);\n                        static isAvailable(): Promise<boolean>;\n                        connect(): Promise<void>;\n                        startOpenChannelListener(): Promise<void>;\n                        getPairingRequestInfo(): Promise<P2PPairingRequest>;\n                        listen(publicKey: string): Promise<void>;\n                }\n        }\n    \n        module 'test/transports/PostMessageTransport' {\n                import * as sodium from 'libsodium-wrappers';\n                import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n                import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n                import { Extension } from 'test/types/Extension';\n                import { StorageKey } from 'test/types/storage/StorageKey';\n                import { TransportType } from 'test/types/transport/TransportType';\n                import { Storage } from 'test/storage/Storage';\n                import { PostMessageClient } from 'test/transports/clients/PostMessageClient';\n                import { Transport } from 'test/transports/Transport';\n                export class PostMessageTransport<T extends PostMessagePairingRequest | ExtendedPostMessagePairingResponse, K extends StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET> extends Transport<T, K, PostMessageClient> {\n                        readonly type: TransportType;\n                        constructor(name: string, keyPair: sodium.KeyPair, storage: Storage, storageKey: K);\n                        static isAvailable(): Promise<boolean>;\n                        static getAvailableExtensions(): Promise<Extension[]>;\n                        connect(): Promise<void>;\n                        startOpenChannelListener(): Promise<void>;\n                        getPairingRequestInfo(): Promise<PostMessagePairingRequest>;\n                        listen(publicKey: string): Promise<void>;\n                }\n        }\n    \n        module 'test/transports/Transport' {\n                import { ConnectionContext } from 'test/types/ConnectionContext';\n                import { TransportType, TransportStatus, PeerInfo, StorageKey } from 'test/';\n                import { PeerManager } from 'test/managers/PeerManager';\n                import { CommunicationClient } from 'test/transports/clients/CommunicationClient';\n                export abstract class Transport<T extends PeerInfo = PeerInfo, K extends StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET = any, S extends CommunicationClient = any> {\n                                /**\n                                          * The type of the transport\n                                          */\n                                readonly type: TransportType;\n                                /**\n                                          * The name of the app\n                                          */\n                                protected readonly name: string;\n                                /**\n                                          * The status of the transport\n                                          */\n                                protected _isConnected: TransportStatus;\n                                protected readonly peerManager: PeerManager<K>;\n                                /**\n                                          * The client handling the encryption/decryption of messages\n                                          */\n                                protected client: S;\n                                /**\n                                          * The listener that will be invoked when a new peer is connected\n                                          */\n                                protected newPeerListener?: (peer: T) => void;\n                                /**\n                                          * Return the status of the connection\n                                          */\n                                get connectionStatus(): TransportStatus;\n                                constructor(name: string, client: S, peerManager: PeerManager<K>);\n                                /**\n                                          * Returns a promise that resolves to true if the transport is available, false if it is not\n                                          */\n                                static isAvailable(): Promise<boolean>;\n                                /**\n                                          * Connect the transport\n                                          */\n                                connect(): Promise<void>;\n                                /**\n                                          * Send a message through the transport\n                                          *\n                                          * @param message The message to send\n                                          * @param recipient The recipient of the message\n                                          */\n                                send(message: string, peer?: PeerInfo): Promise<void>;\n                                /**\n                                          * Add a listener to be called when a new message is received\n                                          *\n                                          * @param listener The listener that will be registered\n                                          */\n                                addListener(listener: (message: unknown, connectionInfo: ConnectionContext) => void): Promise<void>;\n                                /**\n                                          * Remove a listener\n                                          *\n                                          * @param listener\n                                          */\n                                removeListener(listener: (message: string, connectionInfo: ConnectionContext) => void): Promise<void>;\n                                getPeers(): Promise<T[]>;\n                                addPeer(newPeer: T): Promise<void>;\n                                removePeer(peerToBeRemoved: T): Promise<void>;\n                                removeAllPeers(): Promise<void>;\n                                /**\n                                          * Notify the listeners when a new message comes in\n                                          *\n                                          * @param message Message\n                                          * @param connectionInfo Context info about the connection\n                                          */\n                                protected notifyListeners(message: unknown, connectionInfo: ConnectionContext): Promise<void>;\n                                abstract listen(publicKey: string): Promise<void>;\n                }\n        }\n    \n        module 'test/transports/WalletP2PTransport' {\n                import * as sodium from 'libsodium-wrappers';\n                import { Storage, StorageKey, P2PTransport, P2PPairingRequest } from 'test/';\n                export class WalletP2PTransport extends P2PTransport<P2PPairingRequest, StorageKey.TRANSPORT_P2P_PEERS_WALLET> {\n                        constructor(name: string, keyPair: sodium.KeyPair, storage: Storage, matrixNodes: string[], iconUrl?: string, appUrl?: string);\n                        addPeer(newPeer: P2PPairingRequest): Promise<void>;\n                }\n        }\n    \n        module 'test/transports/WalletPostMessageTransport' {\n                import * as sodium from 'libsodium-wrappers';\n                import { StorageKey, PostMessageTransport, Storage } from 'test/';\n                import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n                export class WalletPostMessageTransport extends PostMessageTransport<PostMessagePairingRequest, StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET> {\n                        constructor(name: string, keyPair: sodium.KeyPair, storage: Storage);\n                }\n        }\n    \n        module 'test/types/AccountInfo' {\n                import { Origin } from 'test/';\n                import { PermissionEntity } from 'test/types/PermissionEntity';\n                export type AccountIdentifier = string;\n                export interface AccountInfo extends PermissionEntity {\n                        accountIdentifier: AccountIdentifier;\n                        senderId: string;\n                        origin: {\n                                type: Origin;\n                                id: string;\n                        };\n                        publicKey: string;\n                        connectedAt: number;\n                }\n        }\n    \n        module 'test/types/beacon/AppMetadata' {\n                export interface AppMetadata {\n                        senderId: string;\n                        name: string;\n                        icon?: string;\n                }\n        }\n    \n        module 'test/types/beacon/BeaconBaseMessage' {\n                import { BeaconMessageType } from 'test/';\n                export interface BeaconBaseMessage {\n                        type: BeaconMessageType;\n                        version: string;\n                        id: string;\n                        senderId: string;\n                }\n        }\n    \n        module 'test/types/beacon/BeaconMessage' {\n                import { PermissionResponse, PermissionRequest, OperationRequest, OperationResponse, SignPayloadRequest, SignPayloadResponse, BroadcastRequest, BroadcastResponse, AcknowledgeResponse, DisconnectMessage, ErrorResponse } from 'test/';\n                export type BeaconMessage = PermissionRequest | PermissionResponse | OperationRequest | OperationResponse | SignPayloadRequest | SignPayloadResponse | BroadcastRequest | BroadcastResponse | AcknowledgeResponse | DisconnectMessage | ErrorResponse;\n        }\n    \n        module 'test/types/beacon/BeaconMessageType' {\n                export enum BeaconMessageType {\n                        PermissionRequest = \"permission_request\",\n                        SignPayloadRequest = \"sign_payload_request\",\n                        OperationRequest = \"operation_request\",\n                        BroadcastRequest = \"broadcast_request\",\n                        PermissionResponse = \"permission_response\",\n                        SignPayloadResponse = \"sign_payload_response\",\n                        OperationResponse = \"operation_response\",\n                        BroadcastResponse = \"broadcast_response\",\n                        Acknowledge = \"acknowledge\",\n                        Disconnect = \"disconnect\",\n                        Error = \"error\"\n                }\n        }\n    \n        module 'test/types/beacon/BeaconRequestMessage' {\n                import { PermissionRequest, OperationRequest, SignPayloadRequest, BroadcastRequest } from 'test/';\n                export type BeaconRequestMessage = PermissionRequest | OperationRequest | SignPayloadRequest | BroadcastRequest;\n        }\n    \n        module 'test/types/beacon/BeaconResponseMessage' {\n                import { PermissionResponse, OperationResponse, SignPayloadResponse, BroadcastResponse } from 'test/';\n                import { ErrorResponse } from 'test/types/beacon/messages/ErrorResponse';\n                export type BeaconResponseMessage = PermissionResponse | OperationResponse | SignPayloadResponse | BroadcastResponse | ErrorResponse;\n        }\n    \n        module 'test/types/beacon/messages/AcknowledgeResponse' {\n                import { BeaconBaseMessage, BeaconMessageType } from 'test/';\n                export interface AcknowledgeResponse extends BeaconBaseMessage {\n                        type: BeaconMessageType.Acknowledge;\n                }\n        }\n    \n        module 'test/types/beacon/messages/BeaconRequestInputMessage' {\n                import { PermissionRequest, OperationRequest, SignPayloadRequest, BroadcastRequest } from 'test/';\n                export type IgnoredRequestInputProperties = 'id' | 'senderId' | 'version';\n                export type PermissionRequestInput = Omit<PermissionRequest, IgnoredRequestInputProperties>;\n                export type OperationRequestInput = Omit<OperationRequest, IgnoredRequestInputProperties>;\n                export type SignPayloadRequestInput = Omit<SignPayloadRequest, IgnoredRequestInputProperties>;\n                export type BroadcastRequestInput = Omit<BroadcastRequest, IgnoredRequestInputProperties>;\n                export type BeaconRequestInputMessage = PermissionRequestInput | OperationRequestInput | SignPayloadRequestInput | BroadcastRequestInput;\n        }\n    \n        module 'test/types/beacon/messages/BeaconRequestOutputMessage' {\n                import { AppMetadata, PermissionRequest, OperationRequest, SignPayloadRequest, BroadcastRequest } from 'test/';\n                export type IgnoredRequestOutputProperties = 'version';\n                export interface ExtraResponseOutputProperties {\n                        appMetadata: AppMetadata;\n                }\n                export type PermissionRequestOutput = Omit<PermissionRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n                export type OperationRequestOutput = Omit<OperationRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n                export type SignPayloadRequestOutput = Omit<SignPayloadRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n                export type BroadcastRequestOutput = Omit<BroadcastRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n                export type BeaconRequestOutputMessage = PermissionRequestOutput | OperationRequestOutput | SignPayloadRequestOutput | BroadcastRequestOutput;\n        }\n    \n        module 'test/types/beacon/messages/BeaconResponseInputMessage' {\n                import { PermissionResponse, OperationResponse, SignPayloadResponse, BroadcastResponse, AcknowledgeResponse, ErrorResponse } from 'test/';\n                export type IgnoredResponseInputProperties = 'senderId' | 'version' | 'appMetadata';\n                export type PermissionResponseInput = Omit<PermissionResponse, IgnoredResponseInputProperties>;\n                export type OperationResponseInput = Omit<OperationResponse, IgnoredResponseInputProperties>;\n                export type SignPayloadResponseInput = Omit<SignPayloadResponse, IgnoredResponseInputProperties>;\n                export type BroadcastResponseInput = Omit<BroadcastResponse, IgnoredResponseInputProperties>;\n                export type AcknowledgeResponseInput = Omit<AcknowledgeResponse, IgnoredResponseInputProperties>;\n                export type ErrorResponseInput = Omit<ErrorResponse, IgnoredResponseInputProperties>;\n                export type BeaconResponseInputMessage = PermissionResponseInput | OperationResponseInput | SignPayloadResponseInput | BroadcastResponseInput | AcknowledgeResponseInput | ErrorResponseInput;\n        }\n    \n        module 'test/types/beacon/messages/BeaconResponseOutputMessage' {\n                import { PermissionResponse, OperationResponse, SignPayloadResponse, BroadcastResponse, AccountInfo } from 'test/';\n                export type IgnoredResponseOutputProperties = 'id' | 'version' | 'type';\n                export type PermissionResponseOutput = PermissionResponse & {\n                        address: string;\n                        accountInfo: AccountInfo;\n                };\n                export type OperationResponseOutput = OperationResponse;\n                export type SignPayloadResponseOutput = SignPayloadResponse;\n                export type BroadcastResponseOutput = BroadcastResponse;\n                export type BeaconResponseOutputMessage = PermissionResponseOutput | OperationResponseOutput | SignPayloadResponseOutput | BroadcastResponseOutput;\n        }\n    \n        module 'test/types/beacon/messages/BroadcastRequest' {\n                import { BeaconBaseMessage, BeaconMessageType, Network } from 'test/';\n                export interface BroadcastRequest extends BeaconBaseMessage {\n                        type: BeaconMessageType.BroadcastRequest;\n                        network: Network;\n                        signedTransaction: string;\n                }\n        }\n    \n        module 'test/types/beacon/messages/BroadcastResponse' {\n                import { BeaconBaseMessage, BeaconMessageType } from 'test/';\n                export interface BroadcastResponse extends BeaconBaseMessage {\n                        type: BeaconMessageType.BroadcastResponse;\n                        transactionHash: string;\n                }\n        }\n    \n        module 'test/types/beacon/messages/DisconnectMessage' {\n                import { BeaconBaseMessage, BeaconMessageType } from 'test/';\n                export interface DisconnectMessage extends BeaconBaseMessage {\n                        type: BeaconMessageType.Disconnect;\n                }\n        }\n    \n        module 'test/types/beacon/messages/ErrorResponse' {\n                import { BeaconBaseMessage, BeaconErrorType, BeaconMessageType } from 'test/';\n                export interface ErrorResponse extends BeaconBaseMessage {\n                        type: BeaconMessageType.Error;\n                        errorType: BeaconErrorType;\n                        errorData?: any;\n                }\n        }\n    \n        module 'test/types/beacon/messages/OperationRequest' {\n                import { BeaconBaseMessage, BeaconMessageType, Network } from 'test/';\n                import { PartialTezosOperation } from 'test/types/tezos/PartialTezosOperation';\n                export interface OperationRequest extends BeaconBaseMessage {\n                        type: BeaconMessageType.OperationRequest;\n                        network: Network;\n                        operationDetails: PartialTezosOperation[];\n                        sourceAddress: string;\n                }\n        }\n    \n        module 'test/types/beacon/messages/OperationResponse' {\n                import { BeaconBaseMessage, BeaconMessageType } from 'test/';\n                export interface OperationResponse extends BeaconBaseMessage {\n                        type: BeaconMessageType.OperationResponse;\n                        transactionHash: string;\n                }\n        }\n    \n        module 'test/types/beacon/messages/PermissionRequest' {\n                import { BeaconBaseMessage, BeaconMessageType, PermissionScope, AppMetadata, Network } from 'test/';\n                export interface PermissionRequest extends BeaconBaseMessage {\n                        type: BeaconMessageType.PermissionRequest;\n                        appMetadata: AppMetadata;\n                        network: Network;\n                        scopes: PermissionScope[];\n                }\n        }\n    \n        module 'test/types/beacon/messages/PermissionResponse' {\n                import { AppMetadata, BeaconBaseMessage, BeaconMessageType, Network, PermissionScope, Threshold } from 'test/';\n                export interface PermissionResponse extends BeaconBaseMessage {\n                        type: BeaconMessageType.PermissionResponse;\n                        appMetadata: AppMetadata;\n                        publicKey: string;\n                        network: Network;\n                        scopes: PermissionScope[];\n                        threshold?: Threshold;\n                }\n        }\n    \n        module 'test/types/beacon/messages/SignPayloadRequest' {\n                import { BeaconBaseMessage, BeaconMessageType, SigningType } from 'test/';\n                export interface SignPayloadRequest extends BeaconBaseMessage {\n                        type: BeaconMessageType.SignPayloadRequest;\n                        signingType: SigningType;\n                        payload: string;\n                        sourceAddress: string;\n                }\n        }\n    \n        module 'test/types/beacon/messages/SignPayloadResponse' {\n                import { BeaconBaseMessage, BeaconMessageType, SigningType } from 'test/';\n                export interface SignPayloadResponse extends BeaconBaseMessage {\n                        type: BeaconMessageType.SignPayloadResponse;\n                        signingType: SigningType;\n                        signature: string;\n                }\n        }\n    \n        module 'test/types/beacon/Network' {\n                import { NetworkType } from 'test/';\n                export interface Network {\n                        type: NetworkType;\n                        name?: string;\n                        rpcUrl?: string;\n                }\n        }\n    \n        module 'test/types/beacon/NetworkType' {\n                export enum NetworkType {\n                        MAINNET = \"mainnet\",\n                        DELPHINET = \"delphinet\",\n                        EDONET = \"edonet\",\n                        CUSTOM = \"custom\"\n                }\n        }\n    \n        module 'test/types/beacon/PermissionScope' {\n                export enum PermissionScope {\n                        SIGN = \"sign\",\n                        OPERATION_REQUEST = \"operation_request\",\n                        THRESHOLD = \"threshold\"\n                }\n        }\n    \n        module 'test/types/beacon/SigningType' {\n                export enum SigningType {\n                        RAW = \"raw\",\n                        OPERATION = \"operation\",\n                        MICHELINE = \"micheline\"\n                }\n        }\n    \n        module 'test/types/beacon/Threshold' {\n                export interface Threshold {\n                        amount: string;\n                        timeframe: string;\n                }\n        }\n    \n        module 'test/types/BeaconErrorType' {\n                export enum BeaconErrorType {\n                        BROADCAST_ERROR = \"BROADCAST_ERROR\",\n                        NETWORK_NOT_SUPPORTED = \"NETWORK_NOT_SUPPORTED\",\n                        NO_ADDRESS_ERROR = \"NO_ADDRESS_ERROR\",\n                        NO_PRIVATE_KEY_FOUND_ERROR = \"NO_PRIVATE_KEY_FOUND_ERROR\",\n                        NOT_GRANTED_ERROR = \"NOT_GRANTED_ERROR\",\n                        PARAMETERS_INVALID_ERROR = \"PARAMETERS_INVALID_ERROR\",\n                        TOO_MANY_OPERATIONS = \"TOO_MANY_OPERATIONS\",\n                        TRANSACTION_INVALID_ERROR = \"TRANSACTION_INVALID_ERROR\",\n                        SIGNATURE_TYPE_NOT_SUPPORTED = \"SIGNATURE_TYPE_NOT_SUPPORTED\",\n                        ABORTED_ERROR = \"ABORTED_ERROR\",\n                        UNKNOWN_ERROR = \"UNKNOWN_ERROR\"\n                }\n        }\n    \n        module 'test/types/ColorMode' {\n                export enum ColorMode {\n                        LIGHT = \"light\",\n                        DARK = \"dark\"\n                }\n        }\n    \n        module 'test/types/ConnectionContext' {\n                import { Origin } from 'test/';\n                export interface ConnectionContext {\n                        origin: Origin;\n                        id: string;\n                        extras?: {\n                                sender: chrome.runtime.MessageSender;\n                                sendResponse(response?: unknown): void;\n                        };\n                }\n        }\n    \n        module 'test/types/Extension' {\n                export interface Extension {\n                        id: string;\n                        name: string;\n                        shortName?: string;\n                        iconUrl?: string;\n                        color?: string;\n                }\n        }\n    \n        module 'test/types/ExtensionMessage' {\n                import { ExtensionMessageTarget } from 'test/';\n                export interface ExtensionMessage<T, U = unknown> {\n                        target: ExtensionMessageTarget;\n                        targetId?: string;\n                        sender?: U;\n                        payload: T;\n                }\n                export interface EncryptedExtensionMessage<U = unknown> {\n                        target: ExtensionMessageTarget;\n                        targetId?: string;\n                        sender?: U;\n                        encryptedPayload: string;\n                }\n        }\n    \n        module 'test/types/ExtensionMessageTarget' {\n                export enum ExtensionMessageTarget {\n                        BACKGROUND = \"toBackground\",\n                        PAGE = \"toPage\",\n                        EXTENSION = \"toExtension\"\n                }\n        }\n    \n        module 'test/types/Origin' {\n                export enum Origin {\n                        WEBSITE = \"website\",\n                        EXTENSION = \"extension\",\n                        P2P = \"p2p\"\n                }\n        }\n    \n        module 'test/types/P2PPairingRequest' {\n                import { PeerInfo } from 'test/types/PeerInfo';\n                export interface P2PPairingRequest extends PeerInfo {\n                        id: string;\n                        type: 'p2p-pairing-request';\n                        name: string;\n                        publicKey: string;\n                        relayServer: string;\n                        icon?: string;\n                        appUrl?: string;\n                }\n                export type ExtendedP2PPairingRequest = P2PPairingRequest & {\n                        senderId: string;\n                };\n        }\n    \n        module 'test/types/P2PPairingResponse' {\n                import { PeerInfo } from 'test/types/PeerInfo';\n                export interface P2PPairingResponse extends PeerInfo {\n                        id: string;\n                        type: 'p2p-pairing-response';\n                        name: string;\n                        publicKey: string;\n                        relayServer: string;\n                        icon?: string;\n                        appUrl?: string;\n                }\n                export type ExtendedP2PPairingResponse = P2PPairingResponse & {\n                        senderId: string;\n                };\n        }\n    \n        module 'test/types/PeerInfo' {\n                export interface PeerInfo {\n                        name: string;\n                        publicKey: string;\n                        version: string;\n                }\n                export type ExtendedPeerInfo = PeerInfo & {\n                        senderId: string;\n                };\n        }\n    \n        module 'test/types/PermissionEntity' {\n                import { Network, PermissionScope, Threshold } from 'test/';\n                export interface PermissionEntity {\n                        address: string;\n                        network: Network;\n                        scopes: PermissionScope[];\n                        threshold?: Threshold;\n                }\n        }\n    \n        module 'test/types/PermissionInfo' {\n                import { AppMetadata } from 'test/';\n                import { PermissionEntity } from 'test/types/PermissionEntity';\n                export interface PermissionInfo extends PermissionEntity {\n                        accountIdentifier: string;\n                        senderId: string;\n                        appMetadata: AppMetadata;\n                        website: string;\n                        publicKey: string;\n                        connectedAt: number;\n                }\n        }\n    \n        module 'test/types/PostMessagePairingRequest' {\n                import { PeerInfo } from 'test/types/PeerInfo';\n                export interface PostMessagePairingRequest extends PeerInfo {\n                        id: string;\n                        type: 'postmessage-pairing-request';\n                        name: string;\n                        publicKey: string;\n                        icon?: string;\n                        appUrl?: string;\n                }\n                export type ExtendedPostMessagePairingRequest = PostMessagePairingRequest & {\n                        senderId: string;\n                };\n        }\n    \n        module 'test/types/PostMessagePairingResponse' {\n                import { PeerInfo } from 'test/types/PeerInfo';\n                export interface PostMessagePairingResponse extends PeerInfo {\n                        id: string;\n                        type: 'postmessage-pairing-response';\n                        name: string;\n                        publicKey: string;\n                        icon?: string;\n                        appUrl?: string;\n                }\n                export type ExtendedPostMessagePairingResponse = PostMessagePairingResponse & {\n                        senderId: string;\n                        extensionId: string;\n                };\n        }\n    \n        module 'test/types/RequestBroadcastInput' {\n                import { Network } from 'test/';\n                export interface RequestBroadcastInput {\n                        network?: Network;\n                        signedTransaction: string;\n                }\n        }\n    \n        module 'test/types/RequestOperationInput' {\n                import { PartialTezosOperation } from 'test/types/tezos/PartialTezosOperation';\n                export interface RequestOperationInput {\n                        operationDetails: PartialTezosOperation[];\n                }\n        }\n    \n        module 'test/types/RequestPermissionInput' {\n                import { Network, PermissionScope } from 'test/';\n                export interface RequestPermissionInput {\n                        network?: Network;\n                        scopes?: PermissionScope[];\n                }\n        }\n    \n        module 'test/types/RequestSignPayloadInput' {\n                import { SigningType } from 'test/';\n                export interface RequestSignPayloadInput {\n                        signingType?: SigningType;\n                        payload: string;\n                        sourceAddress?: string;\n                }\n        }\n    \n        module 'test/types/storage/StorageKey' {\n                export enum StorageKey {\n                        TRANSPORT_P2P_PEERS_DAPP = \"beacon:communication-peers-dapp\",\n                        TRANSPORT_P2P_PEERS_WALLET = \"beacon:communication-peers-wallet\",\n                        TRANSPORT_POSTMESSAGE_PEERS_DAPP = \"beacon:postmessage-peers-dapp\",\n                        TRANSPORT_POSTMESSAGE_PEERS_WALLET = \"beacon:postmessage-peers-wallet\",\n                        ACCOUNTS = \"beacon:accounts\",\n                        ACTIVE_ACCOUNT = \"beacon:active-account\",\n                        ACTIVE_PEER = \"beacon:active-peer\",\n                        BEACON_SDK_SECRET_SEED = \"beacon:sdk-secret-seed\",\n                        APP_METADATA_LIST = \"beacon:app-metadata-list\",\n                        PERMISSION_LIST = \"beacon:permissions\",\n                        BEACON_SDK_VERSION = \"beacon:sdk_version\",\n                        MATRIX_PRESERVED_STATE = \"beacon:sdk-matrix-preserved-state\",\n                        MATRIX_PEER_ROOM_IDS = \"beacon:matrix-peer-rooms\"\n                }\n        }\n    \n        module 'test/types/storage/StorageKeyReturnDefaults' {\n                import { StorageKey, StorageKeyReturnType } from 'test/';\n                export type StorageKeyReturnDefaults = {\n                        [key in StorageKey]: StorageKeyReturnType[key];\n                };\n                export const defaultValues: StorageKeyReturnDefaults;\n        }\n    \n        module 'test/types/storage/StorageKeyReturnType' {\n                import { StorageKey, AccountInfo, AccountIdentifier, P2PPairingRequest, AppMetadata, PermissionInfo } from 'test/';\n                import { MatrixState } from 'test/matrix-client/MatrixClientStore';\n                import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n                import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n                import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n                export interface StorageKeyReturnType {\n                        [StorageKey.TRANSPORT_P2P_PEERS_DAPP]: P2PPairingRequest[];\n                        [StorageKey.TRANSPORT_P2P_PEERS_WALLET]: ExtendedP2PPairingResponse[];\n                        [StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP]: PostMessagePairingRequest[];\n                        [StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET]: ExtendedPostMessagePairingResponse[];\n                        [StorageKey.ACCOUNTS]: AccountInfo[];\n                        [StorageKey.ACTIVE_ACCOUNT]: AccountIdentifier | undefined;\n                        [StorageKey.ACTIVE_PEER]: string | undefined;\n                        [StorageKey.BEACON_SDK_SECRET_SEED]: string | undefined;\n                        [StorageKey.APP_METADATA_LIST]: AppMetadata[];\n                        [StorageKey.PERMISSION_LIST]: PermissionInfo[];\n                        [StorageKey.BEACON_SDK_VERSION]: string | undefined;\n                        [StorageKey.MATRIX_PRESERVED_STATE]: Partial<MatrixState>;\n                        [StorageKey.MATRIX_PEER_ROOM_IDS]: {\n                                [key: string]: string | undefined;\n                        };\n                }\n        }\n    \n        module 'test/types/tezos/MichelineMichelsonV1Expression' {\n                import { MichelsonPrimitives } from 'test/';\n                export type MichelineMichelsonV1Expression = {\n                        int: string;\n                } | {\n                        string: string;\n                } | {\n                        bytes: string;\n                } | MichelineMichelsonV1Expression[] | {\n                        prim: MichelsonPrimitives;\n                        args?: MichelineMichelsonV1Expression[];\n                        annots?: string[];\n                };\n        }\n    \n        module 'test/types/tezos/MichelsonPrimitives' {\n                export type MichelsonPrimitives = 'ADD' | 'IF_NONE' | 'SWAP' | 'set' | 'nat' | 'CHECK_SIGNATURE' | 'IF_LEFT' | 'LAMBDA' | 'Elt' | 'CREATE_CONTRACT' | 'NEG' | 'big_map' | 'map' | 'or' | 'BLAKE2B' | 'bytes' | 'SHA256' | 'SET_DELEGATE' | 'CONTRACT' | 'LSL' | 'SUB' | 'IMPLICIT_ACCOUNT' | 'PACK' | 'list' | 'PAIR' | 'Right' | 'contract' | 'GT' | 'LEFT' | 'STEPS_TO_QUOTA' | 'storage' | 'TRANSFER_TOKENS' | 'CDR' | 'SLICE' | 'PUSH' | 'False' | 'SHA512' | 'CHAIN_ID' | 'BALANCE' | 'signature' | 'DUG' | 'SELF' | 'EMPTY_BIG_MAP' | 'LSR' | 'OR' | 'XOR' | 'lambda' | 'COMPARE' | 'key' | 'option' | 'Unit' | 'Some' | 'UNPACK' | 'NEQ' | 'INT' | 'pair' | 'AMOUNT' | 'DIP' | 'ABS' | 'ISNAT' | 'EXEC' | 'NOW' | 'LOOP' | 'chain_id' | 'string' | 'MEM' | 'MAP' | 'None' | 'address' | 'CONCAT' | 'EMPTY_SET' | 'MUL' | 'LOOP_LEFT' | 'timestamp' | 'LT' | 'UPDATE' | 'DUP' | 'SOURCE' | 'mutez' | 'SENDER' | 'IF_CONS' | 'RIGHT' | 'CAR' | 'CONS' | 'LE' | 'NONE' | 'IF' | 'SOME' | 'GET' | 'Left' | 'CAST' | 'int' | 'SIZE' | 'key_hash' | 'unit' | 'DROP' | 'EMPTY_MAP' | 'NIL' | 'DIG' | 'APPLY' | 'bool' | 'RENAME' | 'operation' | 'True' | 'FAILWITH' | 'parameter' | 'HASH_KEY' | 'EQ' | 'NOT' | 'UNIT' | 'Pair' | 'ADDRESS' | 'EDIV' | 'CREATE_ACCOUNT' | 'GE' | 'ITER' | 'code' | 'AND';\n        }\n    \n        module 'test/types/tezos/operations/ActivateAccount' {\n                import { TezosBaseOperation, TezosOperationType } from 'test/';\n                export interface TezosActivateAccountOperation extends TezosBaseOperation {\n                        kind: TezosOperationType.ACTIVATE_ACCOUNT;\n                        pkh: string;\n                        secret: string;\n                }\n        }\n    \n        module 'test/types/tezos/operations/Ballot' {\n                import { TezosBaseOperation, TezosOperationType } from 'test/';\n                export interface TezosBallotOperation extends TezosBaseOperation {\n                        kind: TezosOperationType.BALLOT;\n                        source: string;\n                        period: string;\n                        proposal: string;\n                        ballot: 'nay' | 'yay' | 'pass';\n                }\n        }\n    \n        module 'test/types/tezos/operations/Delegation' {\n                import { TezosBaseOperation, TezosOperationType } from 'test/';\n                export interface TezosDelegationOperation extends TezosBaseOperation {\n                        kind: TezosOperationType.DELEGATION;\n                        source: string;\n                        fee: string;\n                        counter: string;\n                        gas_limit: string;\n                        storage_limit: string;\n                        delegate?: string;\n                }\n        }\n    \n        module 'test/types/tezos/operations/DoubleBakingEvidence' {\n                import { TezosBaseOperation, TezosOperationType, TezosBlockHeader } from 'test/';\n                export interface InlinedEndorsement {\n                        branch: string;\n                        operations: InlinedEndorsementContents;\n                        signature?: string;\n                }\n                export interface InlinedEndorsementContents {\n                        kind: 'endorsement';\n                        level: string;\n                }\n                export interface TezosDoubleBakingEvidenceOperation extends TezosBaseOperation {\n                        kind: TezosOperationType.DOUBLE_BAKING_EVIDENCE;\n                        bh1: TezosBlockHeader;\n                        bh2: TezosBlockHeader;\n                }\n        }\n    \n        module 'test/types/tezos/operations/DoubleEndorsementEvidence' {\n                import { TezosBaseOperation, TezosOperationType } from 'test/';\n                export interface InlinedEndorsement {\n                        branch: string;\n                        operations: InlinedEndorsementContents;\n                        signature?: string;\n                }\n                export interface InlinedEndorsementContents {\n                        kind: 'endorsement';\n                        level: string;\n                }\n                export interface TezosDoubleEndorsementEvidenceOperation extends TezosBaseOperation {\n                        kind: TezosOperationType.DOUBLE_ENDORSEMENT_EVIDENCE;\n                        op1: InlinedEndorsement;\n                        op2: InlinedEndorsement;\n                }\n        }\n    \n        module 'test/types/tezos/operations/Endorsement' {\n                import { TezosBaseOperation, TezosOperationType } from 'test/';\n                export interface TezosEndorsementOperation extends TezosBaseOperation {\n                        kind: TezosOperationType.ENDORSEMENT;\n                        level: string;\n                }\n        }\n    \n        module 'test/types/tezos/operations/Origination' {\n                import { TezosBaseOperation, TezosOperationType } from 'test/';\n                export interface TezosOriginationOperation extends TezosBaseOperation {\n                        kind: TezosOperationType.ORIGINATION;\n                        source: string;\n                        fee: string;\n                        counter: string;\n                        gas_limit: string;\n                        storage_limit: string;\n                        balance: string;\n                        delegate?: string;\n                        script: string;\n                }\n        }\n    \n        module 'test/types/tezos/operations/Proposal' {\n                import { TezosBaseOperation, TezosOperationType } from 'test/';\n                export interface TezosProposalOperation extends TezosBaseOperation {\n                        kind: TezosOperationType.PROPOSALS;\n                        period: string;\n                        proposals: string[];\n                }\n        }\n    \n        module 'test/types/tezos/operations/Reveal' {\n                import { TezosBaseOperation, TezosOperationType } from 'test/';\n                export interface TezosRevealOperation extends TezosBaseOperation {\n                        kind: TezosOperationType.REVEAL;\n                        source: string;\n                        fee: string;\n                        counter: string;\n                        gas_limit: string;\n                        storage_limit: string;\n                        public_key: string;\n                }\n        }\n    \n        module 'test/types/tezos/operations/SeedNonceRevelation' {\n                import { TezosBaseOperation, TezosOperationType } from 'test/';\n                export interface TezosSeedNonceRevelationOperation extends TezosBaseOperation {\n                        kind: TezosOperationType.SEED_NONCE_REVELATION;\n                        level: string;\n                        nonce: string;\n                }\n        }\n    \n        module 'test/types/tezos/operations/Transaction' {\n                import { TezosBaseOperation, TezosOperationType, TezosTransactionParameters } from 'test/';\n                export interface TezosTransactionOperation extends TezosBaseOperation {\n                        kind: TezosOperationType.TRANSACTION;\n                        source: string;\n                        fee: string;\n                        counter: string;\n                        gas_limit: string;\n                        storage_limit: string;\n                        amount: string;\n                        destination: string;\n                        parameters?: TezosTransactionParameters;\n                }\n        }\n    \n        module 'test/types/tezos/OperationTypes' {\n                export enum TezosOperationType {\n                        ENDORSEMENT = \"endorsement\",\n                        SEED_NONCE_REVELATION = \"seed_nonce_revelation\",\n                        DOUBLE_ENDORSEMENT_EVIDENCE = \"double_endorsement_evidence\",\n                        DOUBLE_BAKING_EVIDENCE = \"double_baking_evidence\",\n                        ACTIVATE_ACCOUNT = \"activate_account\",\n                        PROPOSALS = \"proposals\",\n                        BALLOT = \"ballot\",\n                        REVEAL = \"reveal\",\n                        TRANSACTION = \"transaction\",\n                        ORIGINATION = \"origination\",\n                        DELEGATION = \"delegation\"\n                }\n        }\n    \n        module 'test/types/tezos/PartialTezosOperation' {\n                import { TezosActivateAccountOperation } from 'test/types/tezos/operations/ActivateAccount';\n                import { TezosBallotOperation } from 'test/types/tezos/operations/Ballot';\n                import { TezosDelegationOperation } from 'test/types/tezos/operations/Delegation';\n                import { TezosDoubleBakingEvidenceOperation } from 'test/types/tezos/operations/DoubleBakingEvidence';\n                import { TezosEndorsementOperation } from 'test/types/tezos/operations/Endorsement';\n                import { TezosOriginationOperation } from 'test/types/tezos/operations/Origination';\n                import { TezosProposalOperation } from 'test/types/tezos/operations/Proposal';\n                import { TezosRevealOperation } from 'test/types/tezos/operations/Reveal';\n                import { TezosSeedNonceRevelationOperation } from 'test/types/tezos/operations/SeedNonceRevelation';\n                import { TezosTransactionOperation } from 'test/types/tezos/operations/Transaction';\n                type omittedProperties = 'source' | 'fee' | 'counter' | 'gas_limit' | 'storage_limit';\n                export type PartialTezosDelegationOperation = Omit<TezosDelegationOperation, omittedProperties>;\n                export type PartialTezosOriginationOperation = Omit<TezosOriginationOperation, omittedProperties>;\n                export type PartialTezosRevealOperation = Omit<TezosRevealOperation, omittedProperties>;\n                export type PartialTezosTransactionOperation = Omit<TezosTransactionOperation, omittedProperties>;\n                export type PartialTezosOperation = TezosActivateAccountOperation | TezosBallotOperation | PartialTezosDelegationOperation | TezosDoubleBakingEvidenceOperation | TezosEndorsementOperation | PartialTezosOriginationOperation | TezosProposalOperation | PartialTezosRevealOperation | TezosSeedNonceRevelationOperation | PartialTezosTransactionOperation;\n                export {};\n        }\n    \n        module 'test/types/tezos/TezosBaseOperation' {\n                import { TezosOperationType } from 'test/';\n                export interface TezosBaseOperation {\n                        kind: TezosOperationType;\n                }\n        }\n    \n        module 'test/types/tezos/TezosBlockHeader' {\n                export interface TezosBlockHeader {\n                        level: number;\n                        proto: number;\n                        predecessor: string;\n                        timestamp: string;\n                        validation_pass: number;\n                        operations_hash: string;\n                        fitness: string[];\n                        context: string;\n                        priority: number;\n                        proof_of_work_nonce: string;\n                        signature: string;\n                }\n        }\n    \n        module 'test/types/tezos/TezosOperation' {\n                import { TezosActivateAccountOperation, TezosBallotOperation, TezosDelegationOperation, TezosDoubleBakingEvidenceOperation, TezosEndorsementOperation, TezosOriginationOperation, TezosProposalOperation, TezosRevealOperation, TezosSeedNonceRevelationOperation, TezosTransactionOperation } from 'test/';\n                export type TezosOperation = TezosActivateAccountOperation | TezosBallotOperation | TezosDelegationOperation | TezosDoubleBakingEvidenceOperation | TezosEndorsementOperation | TezosOriginationOperation | TezosProposalOperation | TezosRevealOperation | TezosSeedNonceRevelationOperation | TezosTransactionOperation;\n        }\n    \n        module 'test/types/tezos/TezosTransactionParameters' {\n                import { MichelineMichelsonV1Expression } from 'test/types/tezos/MichelineMichelsonV1Expression';\n                export interface TezosTransactionParameters {\n                        entrypoint: 'default' | 'root' | 'do' | 'set_delegate' | 'remove_delegate' | string;\n                        value: MichelineMichelsonV1Expression;\n                }\n        }\n    \n        module 'test/types/transport/TransportStatus' {\n                export enum TransportStatus {\n                        NOT_CONNECTED = \"NOT_CONNECTED\",\n                        CONNECTING = \"CONNECTING\",\n                        CONNECTED = \"CONNECTED\"\n                }\n        }\n    \n        module 'test/types/transport/TransportType' {\n                export enum TransportType {\n                        CHROME_MESSAGE = \"chrome_message\",\n                        POST_MESSAGE = \"post_message\",\n                        LEDGER = \"ledger\",\n                        P2P = \"p2p\"\n                }\n        }\n    \n        module 'test/ui/alert/alert-templates' {\n                export const alertTemplates: {\n                        container: string;\n                        default: {\n                                html: string;\n                                css: string;\n                        };\n                        pair: {\n                                html: string;\n                                css: string;\n                        };\n                };\n        }\n    \n        module 'test/ui/alert/Alert' {\n                import { NetworkType } from 'test/';\n                export interface AlertButton {\n                                text: string;\n                                style?: 'solid' | 'outline';\n                                actionCallback?(): Promise<void>;\n                }\n                export interface AlertConfig {\n                                title: string;\n                                body?: string;\n                                timer?: number;\n                                buttons?: AlertButton[];\n                                pairingPayload?: {\n                                                p2pSyncCode: string;\n                                                postmessageSyncCode: string;\n                                                preferredNetwork: NetworkType;\n                                };\n                                closeButtonCallback?(): void;\n                }\n                /**\n                          * Close an alert by ID\n                          *\n                          * @param id ID of alert\n                          */\n                const closeAlert: (id: string) => Promise<void>;\n                /**\n                          * Close all alerts\n                          */\n                const closeAlerts: () => Promise<void>;\n                /**\n                          * Show an alert\n                          *\n                          * @param alertConfig The configuration of the alert\n                          */\n                const openAlert: (alertConfig: AlertConfig) => Promise<string>;\n                export { closeAlert, closeAlerts, openAlert };\n        }\n    \n        module 'test/ui/alert/Pairing' {\n                import { NetworkType } from 'test/';\n                export enum Platform {\n                        DESKTOP = 0,\n                        IOS = 1,\n                        ANDROID = 2\n                }\n                export enum WalletType {\n                        IOS = \"ios\",\n                        ANDROID = \"android\",\n                        EXTENSION = \"extension\",\n                        DESKTOP = \"desktop\",\n                        WEB = \"web\"\n                }\n                export interface AppBase {\n                        name: string;\n                        shortName: string;\n                        color: string;\n                        logo: string;\n                }\n                export interface ExtensionApp extends AppBase {\n                        id: string;\n                        link: string;\n                }\n                export interface WebApp extends AppBase {\n                        links: {\n                                [NetworkType.MAINNET]: string;\n                                [NetworkType.DELPHINET]?: string;\n                                [NetworkType.EDONET]?: string;\n                                [NetworkType.CUSTOM]?: string;\n                        };\n                }\n                export interface DesktopApp extends AppBase {\n                        deepLink: string;\n                }\n                export interface App extends AppBase {\n                        universalLink: string;\n                        deepLink?: string;\n                }\n                export interface PairingAlertWallet {\n                        name: string;\n                        shortName?: string;\n                        color?: string;\n                        logo?: string;\n                        enabled: boolean;\n                        clickHandler(): void;\n                }\n                export interface PairingAlertButton {\n                        title: string;\n                        text: string;\n                        clickHandler(): void;\n                }\n                export interface PairingAlertList {\n                        title: string;\n                        type: WalletType;\n                        wallets: PairingAlertWallet[];\n                }\n                export interface PairingAlertInfo {\n                        walletLists: PairingAlertList[];\n                        buttons: PairingAlertButton[];\n                        qrData: string;\n                }\n                export type StatusUpdateHandler = (walletType: WalletType, app?: PairingAlertWallet) => void;\n                export class Pairing {\n                        static getPlatfrom(): Promise<Platform>;\n                        static getPairingInfo(pairingPayload: {\n                                p2pSyncCode: string;\n                                postmessageSyncCode: string;\n                                preferredNetwork: NetworkType;\n                        }, statusUpdateHandler: StatusUpdateHandler, platform?: Platform): Promise<PairingAlertInfo>;\n                }\n        }\n    \n        module 'test/ui/alert/PairingAlert' {\n                import { NetworkType } from 'test/';\n                export const preparePairingAlert: (shadowRoot: ShadowRoot, pairingPayload: {\n                        p2pSyncCode: string;\n                        postmessageSyncCode: string;\n                        preferredNetwork: NetworkType;\n                }) => Promise<void>;\n        }\n    \n        module 'test/ui/alert/wallet-lists' {\n                import { App, DesktopApp, ExtensionApp, WebApp } from 'test/ui/alert/Pairing';\n                export const extensionList: ExtensionApp[];\n                export const desktopList: DesktopApp[];\n                export const webList: WebApp[];\n                export const iOSList: App[];\n        }\n    \n        module 'test/ui/toast/toast-templates' {\n                export const toastTemplates: {\n                        default: {\n                                html: string;\n                                css: string;\n                                poweredByBeacon: string;\n                        };\n                };\n        }\n    \n        module 'test/ui/toast/Toast' {\n                import { WalletInfo } from 'test/events';\n                export interface ToastAction {\n                                text: string;\n                                actionText?: string;\n                                actionCallback?(): Promise<void>;\n                }\n                export interface ToastConfig {\n                                body: string;\n                                timer?: number;\n                                forceNew?: boolean;\n                                state: 'loading' | 'acknowledge' | 'finished';\n                                actions?: ToastAction[];\n                                walletInfo?: WalletInfo;\n                }\n                /**\n                          * Close a toast\n                          */\n                const closeToast: () => Promise<void>;\n                /**\n                          * Create a new toast\n                          *\n                          * @param toastConfig Configuration of the toast\n                          */\n                const openToast: (toastConfig: ToastConfig) => Promise<void>;\n                export { closeToast, openToast };\n        }\n    \n        module 'test/utils/assert-never' {\n                /**\n                      * A helper function to make sure if/elses and switch/cases are exhaustive\n                      *\n                      * @param empty The data that has to be empty\n                      */\n                export function assertNever(empty: never): never;\n        }\n    \n        module 'test/utils/available-transports' {\n                /**\n                      * An object with promises to indicate whether or not that transport is available.\n                      */\n                export const availableTransports: {\n                        extension: Promise<boolean>;\n                        availableExtensions: Promise<import(\"../types/Extension\").Extension[]>;\n                };\n        }\n    \n        module 'test/utils/block-explorer' {\n                import { Network, NetworkType } from 'test/';\n                export abstract class BlockExplorer {\n                                readonly rpcUrls: {\n                                                [key in NetworkType]: string;\n                                };\n                                constructor(rpcUrls: {\n                                                [key in NetworkType]: string;\n                                });\n                                protected getLinkForNetwork(network: Network): Promise<string>;\n                                /**\n                                          * Return a blockexplorer link for an address\n                                          *\n                                          * @param address The address to be opened\n                                          * @param network The network that was used\n                                          */\n                                abstract getAddressLink(address: string, network: Network): Promise<string>;\n                                /**\n                                          * Return a blockexplorer link for a transaction hash\n                                          *\n                                          * @param transactionId The hash of the transaction\n                                          * @param network The network that was used\n                                          */\n                                abstract getTransactionLink(transactionId: string, network: Network): Promise<string>;\n                }\n        }\n    \n        module 'test/utils/crypto' {\n                import * as sodium from 'libsodium-wrappers';\n                /**\n                          * Convert a value to hex\n                          *\n                          * @param value\n                          */\n                export function toHex(value: any): string;\n                /**\n                          * Get the hex hash of a value\n                          *\n                          * @param key\n                          */\n                export function getHexHash(key: string | Buffer | Uint8Array): Promise<string>;\n                /**\n                          * Get a keypair from a seed\n                          *\n                          * @param seed\n                          */\n                export function getKeypairFromSeed(seed: string): Promise<sodium.KeyPair>;\n                /**\n                          * Encrypt a message with a shared key\n                          *\n                          * @param message\n                          * @param sharedKey\n                          */\n                export function encryptCryptoboxPayload(message: string, sharedKey: Uint8Array): Promise<string>;\n                /**\n                          * Decrypt a message with a shared key\n                          *\n                          * @param payload\n                          * @param sharedKey\n                          */\n                export function decryptCryptoboxPayload(payload: Uint8Array, sharedKey: Uint8Array): Promise<string>;\n                /**\n                          * Encrypt a message with a public key\n                          *\n                          * @param payload\n                          * @param publicKey\n                          */\n                export function sealCryptobox(payload: string | Buffer, publicKey: Uint8Array): Promise<string>;\n                /**\n                          * Decrypt a message with public + private key\n                          *\n                          * @param encryptedPayload\n                          * @param publicKey\n                          * @param privateKey\n                          */\n                export function openCryptobox(encryptedPayload: string | Buffer, publicKey: Uint8Array, privateKey: Uint8Array): Promise<string>;\n                /**\n                          * Get an address from the public key\n                          *\n                          * @param publicKey\n                          */\n                export function getAddressFromPublicKey(publicKey: string): Promise<string>;\n                /**\n                          * Get the recipient string used in the matrix message\n                          *\n                          * @param recipientHash\n                          * @param relayServer\n                          */\n                export function recipientString(recipientHash: string, relayServer: string): string;\n        }\n    \n        module 'test/utils/exposed-promise' {\n                export enum ExposedPromiseStatus {\n                        PENDING = \"pending\",\n                        RESOLVED = \"resolved\",\n                        REJECTED = \"rejected\"\n                }\n                type Resolve<T> = (value?: T) => void;\n                type Reject<U> = (reason?: U) => void;\n                /**\n                      * Exposed promise allow you to create a promise and then resolve it later, from the outside\n                      */\n                export class ExposedPromise<T = unknown, U = unknown> {\n                        get promise(): Promise<T>;\n                        get resolve(): Resolve<T>;\n                        get reject(): Reject<U>;\n                        get status(): ExposedPromiseStatus;\n                        get promiseResult(): T | undefined;\n                        get promiseError(): U | undefined;\n                        constructor();\n                        static resolve<T>(value?: T): ExposedPromise<T>;\n                        static reject<T = never, U = unknown>(reason?: U): ExposedPromise<T, U>;\n                        isPending(): boolean;\n                        isResolved(): boolean;\n                        isRejected(): boolean;\n                        isSettled(): boolean;\n                }\n                export {};\n        }\n    \n        module 'test/utils/generate-uuid' {\n                /**\n                      * Generate a random GUID\n                      */\n                export function generateGUID(): Promise<string>;\n        }\n    \n        module 'test/utils/get-account-identifier' {\n                import { Network } from 'test/';\n                /**\n                      * Generate a deterministic account identifier based on an address and a network\n                      *\n                      * @param address\n                      * @param network\n                      */\n                export const getAccountIdentifier: (address: string, network: Network) => Promise<string>;\n        }\n    \n        module 'test/utils/get-sender-id' {\n                /**\n                      * Generate a deterministic sender identifier based on a public key\n                      *\n                      * @param publicKey\n                      */\n                export const getSenderId: (publicKey: string) => Promise<string>;\n        }\n    \n        module 'test/utils/get-tzip10-link' {\n                export const getTzip10Link: (url: string, payload: string) => string;\n        }\n    \n        module 'test/utils/Logger' {\n                /**\n                      * The logger that is used internally\n                      */\n                export class Logger {\n                        constructor(service: string);\n                        debug(method: string, ...args: any[]): void;\n                        log(method: string, ...args: any[]): void;\n                        warn(method: string, ...args: any[]): void;\n                        error(method: string, ...args: any[]): void;\n                }\n        }\n    \n        module 'test/utils/platform' {\n                export const testUserAgent: (win: Window, expr: RegExp) => boolean;\n                export const isMobile: (win: Window) => boolean;\n                export const isIOS: (win: Window) => boolean;\n                export const isAndroid: (win: Window) => boolean;\n                export const isDesktop: (win: Window) => boolean;\n        }\n    \n        module 'test/utils/qr' {\n                /**\n                      * Convert data to a QR code\n                      *\n                      * @param payload The data to be encoded as a QR code\n                      * @param type How the QR code will be encoded\n                      */\n                export const getQrData: (payload: string, type?: \"data\" | \"svg\" | \"ascii\" | undefined) => string;\n        }\n    \n        module 'test/utils/replace-in-template' {\n                export const replaceInTemplate: (text: string, placeholder: string, value: string) => string;\n        }\n    \n        module 'test/utils/shorten-string' {\n                export const shortenString: (text: string) => string;\n        }\n    \n        module 'test/utils/tezblock-blockexplorer' {\n                import { Network, NetworkType } from 'test/';\n                import { BlockExplorer } from 'test/utils/block-explorer';\n                export class TezblockBlockExplorer extends BlockExplorer {\n                        readonly rpcUrls: {\n                                [key in NetworkType]: string;\n                        };\n                        constructor(rpcUrls?: {\n                                [key in NetworkType]: string;\n                        });\n                        getAddressLink(address: string, network: Network): Promise<string>;\n                        getTransactionLink(transactionId: string, network: Network): Promise<string>;\n                }\n        }\n    \n        module 'test/utils/utils' {\n                /**\n                      * A helper function to improve typings of object keys\n                      *\n                      * @param obj Object\n                      */\n                export function keys<O extends object>(obj: O): (keyof O)[];\n        }\n    \n        module 'test/' {\n                import { P2PCommunicationClient } from 'test/transports/clients/P2PCommunicationClient';\n                import { AppMetadata } from 'test/types/beacon/AppMetadata';\n                import { PermissionRequest } from 'test/types/beacon/messages/PermissionRequest';\n                import { Network } from 'test/types/beacon/Network';\n                import { BeaconBaseMessage } from 'test/types/beacon/BeaconBaseMessage';\n                import { BeaconMessageType } from 'test/types/beacon/BeaconMessageType';\n                import { PermissionScope } from 'test/types/beacon/PermissionScope';\n                import { PermissionResponse } from 'test/types/beacon/messages/PermissionResponse';\n                import { OperationRequest } from 'test/types/beacon/messages/OperationRequest';\n                import { OperationResponse } from 'test/types/beacon/messages/OperationResponse';\n                import { SignPayloadRequest } from 'test/types/beacon/messages/SignPayloadRequest';\n                import { SignPayloadResponse } from 'test/types/beacon/messages/SignPayloadResponse';\n                import { BroadcastRequest } from 'test/types/beacon/messages/BroadcastRequest';\n                import { BroadcastResponse } from 'test/types/beacon/messages/BroadcastResponse';\n                import { NetworkType } from 'test/types/beacon/NetworkType';\n                import { TezosBaseOperation } from 'test/types/tezos/TezosBaseOperation';\n                import { TezosOperationType } from 'test/types/tezos/OperationTypes';\n                import { TezosActivateAccountOperation } from 'test/types/tezos/operations/ActivateAccount';\n                import { TezosBallotOperation } from 'test/types/tezos/operations/Ballot';\n                import { TezosDelegationOperation } from 'test/types/tezos/operations/Delegation';\n                import { TezosDoubleBakingEvidenceOperation } from 'test/types/tezos/operations/DoubleBakingEvidence';\n                import { TezosBlockHeader } from 'test/types/tezos/TezosBlockHeader';\n                import { TezosDoubleEndorsementEvidenceOperation } from 'test/types/tezos/operations/DoubleEndorsementEvidence';\n                import { TezosEndorsementOperation } from 'test/types/tezos/operations/Endorsement';\n                import { TezosOriginationOperation } from 'test/types/tezos/operations/Origination';\n                import { TezosProposalOperation } from 'test/types/tezos/operations/Proposal';\n                import { TezosRevealOperation } from 'test/types/tezos/operations/Reveal';\n                import { TezosSeedNonceRevelationOperation } from 'test/types/tezos/operations/SeedNonceRevelation';\n                import { TezosTransactionOperation } from 'test/types/tezos/operations/Transaction';\n                import { MichelsonPrimitives } from 'test/types/tezos/MichelsonPrimitives';\n                import { TezosTransactionParameters } from 'test/types/tezos/TezosTransactionParameters';\n                import { Origin } from 'test/types/Origin';\n                import { AccountInfo, AccountIdentifier } from 'test/types/AccountInfo';\n                import { EncryptedExtensionMessage, ExtensionMessage } from 'test/types/ExtensionMessage';\n                import { ExtensionMessageTarget } from 'test/types/ExtensionMessageTarget';\n                import { TezosOperation } from 'test/types/tezos/TezosOperation';\n                import { Client } from 'test/clients/client/Client';\n                import { WalletClient } from 'test/clients/wallet-client/WalletClient';\n                import { DAppClient } from 'test/clients/dapp-client/DAppClient';\n                import { BeaconError } from 'test/errors/BeaconError';\n                import { BeaconErrorType } from 'test/types/BeaconErrorType';\n                import { BroadcastBeaconError } from 'test/errors/BroadcastBeaconError';\n                import { NetworkNotSupportedBeaconError } from 'test/errors/NetworkNotSupportedBeaconError';\n                import { NoAddressBeaconError } from 'test/errors/NoAddressBeaconError';\n                import { NoPrivateKeyBeaconError } from 'test/errors/NoPrivateKeyBeaconError';\n                import { NotGrantedBeaconError } from 'test/errors/NotGrantedBeaconError';\n                import { ParametersInvalidBeaconError } from 'test/errors/ParametersInvalidBeaconError';\n                import { TooManyOperationsBeaconError } from 'test/errors/TooManyOperationsBeaconError';\n                import { TransactionInvalidBeaconError } from 'test/errors/TransactionInvalidBeaconError';\n                import { UnknownBeaconError } from 'test/errors/UnknownBeaconError';\n                import { ErrorResponse } from 'test/types/beacon/messages/ErrorResponse';\n                import { TransportStatus } from 'test/types/transport/TransportStatus';\n                import { TransportType } from 'test/types/transport/TransportType';\n                import { PostMessageTransport } from 'test/transports/PostMessageTransport';\n                import { Transport } from 'test/transports/Transport';\n                import { P2PTransport } from 'test/transports/P2PTransport';\n                import { Storage } from 'test/storage/Storage';\n                import { StorageKey } from 'test/types/storage/StorageKey';\n                import { StorageKeyReturnDefaults } from 'test/types/storage/StorageKeyReturnDefaults';\n                import { StorageKeyReturnType } from 'test/types/storage/StorageKeyReturnType';\n                import { ExtendedP2PPairingRequest, P2PPairingRequest } from 'test/types/P2PPairingRequest';\n                import { ChromeStorage } from 'test/storage/ChromeStorage';\n                import { LocalStorage } from 'test/storage/LocalStorage';\n                import { getStorage } from 'test/storage/getStorage';\n                import { BeaconMessage } from 'test/types/beacon/BeaconMessage';\n                import { Serializer } from 'test/Serializer';\n                import { RequestPermissionInput } from 'test/types/RequestPermissionInput';\n                import { RequestSignPayloadInput } from 'test/types/RequestSignPayloadInput';\n                import { RequestOperationInput } from 'test/types/RequestOperationInput';\n                import { RequestBroadcastInput } from 'test/types/RequestBroadcastInput';\n                import { PermissionResponseInput, SignPayloadResponseInput, OperationResponseInput, BroadcastResponseInput, BeaconResponseInputMessage, AcknowledgeResponseInput, ErrorResponseInput } from 'test/types/beacon/messages/BeaconResponseInputMessage';\n                import { PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, BeaconResponseOutputMessage } from 'test/types/beacon/messages/BeaconResponseOutputMessage';\n                import { PermissionRequestInput, SignPayloadRequestInput, OperationRequestInput, BroadcastRequestInput, BeaconRequestInputMessage } from 'test/types/beacon/messages/BeaconRequestInputMessage';\n                import { PermissionRequestOutput, SignPayloadRequestOutput, OperationRequestOutput, BroadcastRequestOutput, BeaconRequestOutputMessage } from 'test/types/beacon/messages/BeaconRequestOutputMessage';\n                import { ClientOptions } from 'test/clients/client/ClientOptions';\n                import { DAppClientOptions } from 'test/clients/dapp-client/DAppClientOptions';\n                import { WalletClientOptions } from 'test/clients/wallet-client/WalletClientOptions';\n                import { PermissionInfo } from 'test/types/PermissionInfo';\n                import { SDK_VERSION, BEACON_VERSION } from 'test/constants';\n                import { AccountManager } from 'test/managers/AccountManager';\n                import { AppMetadataManager } from 'test/managers/AppMetadataManager';\n                import { PermissionManager } from 'test/managers/PermissionManager';\n                import { BeaconEvent, BeaconEventHandler, defaultEventCallbacks } from 'test/events';\n                import { getAddressFromPublicKey } from 'test/utils/crypto';\n                import { BeaconClient } from 'test/clients/beacon-client/BeaconClient';\n                import { BeaconClientOptions } from 'test/clients/beacon-client/BeaconClientOptions';\n                import { getAccountIdentifier } from 'test/utils/get-account-identifier';\n                import { ConnectionContext } from 'test/types/ConnectionContext';\n                import { Threshold } from 'test/types/beacon/Threshold';\n                import { PartialTezosTransactionOperation, PartialTezosOperation, PartialTezosDelegationOperation, PartialTezosOriginationOperation, PartialTezosRevealOperation } from 'test/types/tezos/PartialTezosOperation';\n                import { AbortedBeaconError } from 'test/errors/AbortedBeaconError';\n                import { ExtendedPeerInfo, PeerInfo } from 'test/types/PeerInfo';\n                import { availableTransports } from 'test/utils/available-transports';\n                import { AcknowledgeResponse } from 'test/types/beacon/messages/AcknowledgeResponse';\n                import { DisconnectMessage } from 'test/types/beacon/messages/DisconnectMessage';\n                import { DappP2PTransport } from 'test/transports/DappP2PTransport';\n                import { DappPostMessageTransport } from 'test/transports/DappPostMessageTransport';\n                import { WalletP2PTransport } from 'test/transports/WalletP2PTransport';\n                import { WalletPostMessageTransport } from 'test/transports/WalletPostMessageTransport';\n                import { getSenderId } from 'test/utils/get-sender-id';\n                import { SigningType } from 'test/types/beacon/SigningType';\n                import { SignatureTypeNotSupportedBeaconError } from 'test/errors/SignatureTypeNotSupportedBeaconError';\n                import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n                import { ExtendedPostMessagePairingRequest, PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n                import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n                import { PeerManager } from 'test/managers/PeerManager';\n                import { MessageBasedClient } from 'test/transports/clients/MessageBasedClient';\n                import { BeaconRequestMessage } from 'test/types/beacon/BeaconRequestMessage';\n                import { BeaconResponseMessage } from 'test/types/beacon/BeaconResponseMessage';\n                import { Pairing } from 'test/ui/alert/Pairing';\n                import { BlockExplorer } from 'test/utils/block-explorer';\n                import { TezblockBlockExplorer } from 'test/utils/tezblock-blockexplorer';\n                import { setDebugEnabled, getDebugEnabled } from 'test/debug';\n                import { ColorMode } from 'test/types/ColorMode';\n                export { TezosBaseOperation, TezosOperationType, TezosBlockHeader, MichelsonPrimitives, TezosTransactionParameters, TezosOperation };\n                export { TezosActivateAccountOperation, TezosBallotOperation, TezosDelegationOperation, TezosDoubleBakingEvidenceOperation, TezosDoubleEndorsementEvidenceOperation, TezosEndorsementOperation, TezosOriginationOperation, TezosProposalOperation, TezosRevealOperation, TezosSeedNonceRevelationOperation, TezosTransactionOperation, PartialTezosOperation, PartialTezosTransactionOperation, PartialTezosDelegationOperation, PartialTezosOriginationOperation, PartialTezosRevealOperation };\n                export { BeaconClient, BeaconClientOptions, Client, ClientOptions, DAppClient, DAppClientOptions, WalletClient, WalletClientOptions, P2PCommunicationClient };\n                export { AccountIdentifier, AppMetadata, Network, NetworkType, BeaconMessage, PermissionRequest, PermissionResponse, OperationRequest, OperationResponse, SignPayloadRequest, SignPayloadResponse, BroadcastRequest, BroadcastResponse, AcknowledgeResponse, DisconnectMessage, BeaconBaseMessage, BeaconMessageType, PermissionScope, Origin, AccountInfo, Threshold, SigningType, ExtensionMessageTarget, ExtensionMessage, EncryptedExtensionMessage, RequestPermissionInput, RequestSignPayloadInput, RequestOperationInput, RequestBroadcastInput, PermissionInfo };\n                export { PermissionResponseInput, SignPayloadResponseInput, OperationResponseInput, BroadcastResponseInput, AcknowledgeResponseInput, ErrorResponseInput, PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, PermissionRequestInput, SignPayloadRequestInput, OperationRequestInput, BroadcastRequestInput, PermissionRequestOutput, SignPayloadRequestOutput, OperationRequestOutput, BroadcastRequestOutput, BeaconRequestInputMessage, BeaconRequestOutputMessage, BeaconResponseInputMessage, BeaconResponseOutputMessage, BeaconRequestMessage, BeaconResponseMessage };\n                export { BeaconError, BeaconErrorType, ErrorResponse, AbortedBeaconError, BroadcastBeaconError, NetworkNotSupportedBeaconError, NoAddressBeaconError, NoPrivateKeyBeaconError, NotGrantedBeaconError, ParametersInvalidBeaconError, TooManyOperationsBeaconError, TransactionInvalidBeaconError, SignatureTypeNotSupportedBeaconError, UnknownBeaconError };\n                export { TransportStatus, TransportType, Transport, PostMessageTransport, P2PTransport, WalletP2PTransport, WalletPostMessageTransport, DappP2PTransport, DappPostMessageTransport, MessageBasedClient, Pairing };\n                export { BeaconEvent, BeaconEventHandler, defaultEventCallbacks };\n                export { Storage, StorageKey, StorageKeyReturnDefaults, StorageKeyReturnType, ChromeStorage, LocalStorage, getStorage };\n                export { PeerManager, AccountManager, AppMetadataManager, PermissionManager };\n                export { SDK_VERSION, BEACON_VERSION };\n                export { getSenderId, getAccountIdentifier, getAddressFromPublicKey };\n                export { PeerInfo, ExtendedPeerInfo, PostMessagePairingRequest, ExtendedPostMessagePairingRequest, ExtendedPostMessagePairingResponse, P2PPairingRequest, ExtendedP2PPairingRequest, ExtendedP2PPairingResponse };\n                export { BlockExplorer, TezblockBlockExplorer };\n                export { ConnectionContext, Serializer, availableTransports, ColorMode };\n                export { setDebugEnabled, getDebugEnabled };\n        }\n    }\n    \n    module 'test/transports/clients/CommunicationClient' {\n        import * as sodium from 'libsodium-wrappers';\n        import { P2PPairingRequest } from 'test/';\n        import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n        import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n        import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n        export abstract class CommunicationClient {\n                protected readonly keyPair: sodium.KeyPair;\n                constructor(keyPair: sodium.KeyPair);\n                /**\n                     * Get the public key\n                     */\n                getPublicKey(): Promise<string>;\n                /**\n                     * get the public key hash\n                     */\n                getPublicKeyHash(): Promise<string>;\n                /**\n                     * Create a cryptobox shared key\n                     *\n                     * @param otherPublicKey\n                     * @param selfPrivateKey\n                     */\n                protected createCryptoBox(otherPublicKey: string, selfPrivateKey: Uint8Array): Promise<[Uint8Array, Uint8Array, Uint8Array]>;\n                /**\n                     * Create a cryptobox server\n                     *\n                     * @param otherPublicKey\n                     * @param selfPrivateKey\n                     */\n                protected createCryptoBoxServer(otherPublicKey: string, selfPrivateKey: Uint8Array): Promise<sodium.CryptoKX>;\n                /**\n                     * Create a cryptobox client\n                     *\n                     * @param otherPublicKey\n                     * @param selfPrivateKey\n                     */\n                protected createCryptoBoxClient(otherPublicKey: string, selfPrivateKey: Uint8Array): Promise<sodium.CryptoKX>;\n                /**\n                     * Encrypt a message for a specific publicKey (receiver, asymmetric)\n                     *\n                     * @param recipientPublicKey\n                     * @param message\n                     */\n                protected encryptMessageAsymmetric(recipientPublicKey: string, message: string): Promise<string>;\n                abstract unsubscribeFromEncryptedMessages(): Promise<void>;\n                abstract unsubscribeFromEncryptedMessage(senderPublicKey: string): Promise<void>;\n                abstract sendMessage(message: string, peer?: P2PPairingRequest | ExtendedP2PPairingResponse | PostMessagePairingRequest | ExtendedPostMessagePairingResponse): Promise<void>;\n        }\n    }\n    \n    module 'test/transports/clients/MessageBasedClient' {\n        import * as sodium from 'libsodium-wrappers';\n        import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n        import { PostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n        import { CommunicationClient } from 'test/transports/clients/CommunicationClient';\n        export abstract class MessageBasedClient extends CommunicationClient {\n                protected readonly name: string;\n                /**\n                     * The listeners that will be notified of new messages\n                     */\n                protected abstract readonly activeListeners: Map<string, unknown>;\n                constructor(name: string, keyPair: sodium.KeyPair);\n                /**\n                     * start the client and make sure all dependencies are ready\n                     */\n                start(): Promise<void>;\n                /**\n                     * Get the pairing request information. This will be shared with the peer during the connection setup\n                     */\n                getPairingRequestInfo(): Promise<PostMessagePairingRequest>;\n                /**\n                     * Get the pairing response information. This will be shared with the peer during the connection setup\n                     */\n                getPairingResponseInfo(request: PostMessagePairingRequest): Promise<PostMessagePairingResponse>;\n                /**\n                     * Unsubscribe from encrypted messages from a specific peer\n                     *\n                     * @param senderPublicKey\n                     */\n                unsubscribeFromEncryptedMessage(senderPublicKey: string): Promise<void>;\n                /**\n                     * Unsubscribe from all encrypted messages\n                     */\n                unsubscribeFromEncryptedMessages(): Promise<void>;\n                /**\n                     * Decrypt a message from a specific peer\n                     *\n                     * @param senderPublicKey\n                     * @param payload\n                     */\n                protected decryptMessage(senderPublicKey: string, payload: string): Promise<string>;\n                /**\n                     * Encrypt a message for a specific publicKey (receiver)\n                     *\n                     * @param recipientPublicKey\n                     * @param message\n                     */\n                protected encryptMessage(recipientPublicKey: string, message: string): Promise<string>;\n                /**\n                     * Initialize the connection\n                     */\n                abstract init(): Promise<void>;\n        }\n    }\n    \n    module 'test/transports/clients/P2PCommunicationClient' {\n        import * as sodium from 'libsodium-wrappers';\n        import { MatrixClientEvent, MatrixClientEventType, MatrixClientEventMessageContent } from 'test/matrix-client/models/MatrixClientEvent';\n        import { Storage } from 'test/storage/Storage';\n        import { P2PPairingRequest } from 'test/';\n        import { ExtendedP2PPairingResponse, P2PPairingResponse } from 'test/types/P2PPairingResponse';\n        import { CommunicationClient } from 'test/transports/clients/CommunicationClient';\n        export class P2PCommunicationClient extends CommunicationClient {\n            readonly replicationCount: number;\n            constructor(name: string, keyPair: sodium.KeyPair, replicationCount: number, storage: Storage, matrixNodes: string[], iconUrl?: string | undefined, appUrl?: string | undefined);\n            getPairingRequestInfo(): Promise<P2PPairingRequest>;\n            getPairingResponseInfo(request: P2PPairingRequest): Promise<P2PPairingResponse>;\n            getRelayServer(publicKeyHash?: string, nonce?: string): Promise<string>;\n            start(): Promise<void>;\n            listenForEncryptedMessage(senderPublicKey: string, messageCallback: (message: string) => void): Promise<void>;\n            unsubscribeFromEncryptedMessage(senderPublicKey: string): Promise<void>;\n            unsubscribeFromEncryptedMessages(): Promise<void>;\n            sendMessage(message: string, peer: P2PPairingRequest | ExtendedP2PPairingResponse): Promise<void>;\n            deleteRoomIdFromRooms(roomId: string): Promise<void>;\n            listenForChannelOpening(messageCallback: (pairingResponse: ExtendedP2PPairingResponse) => void): Promise<void>;\n            sendPairingResponse(pairingRequest: P2PPairingRequest): Promise<void>;\n            isTextMessage(content: MatrixClientEventMessageContent<any>): content is MatrixClientEventMessageContent<string>;\n            isChannelOpenMessage(content: MatrixClientEventMessageContent<string>): Promise<boolean>;\n            isSender(event: MatrixClientEvent<MatrixClientEventType.MESSAGE>, senderPublicKey: string): Promise<boolean>;\n        }\n    }\n    \n    module 'test/transports/clients/PostMessageClient' {\n        import { ConnectionContext } from 'test/';\n        import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n        import { EncryptedExtensionMessage } from 'test/types/ExtensionMessage';\n        import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n        import { MessageBasedClient } from 'test/transports/clients/MessageBasedClient';\n        export class PostMessageClient extends MessageBasedClient {\n            protected readonly activeListeners: Map<string, (message: EncryptedExtensionMessage, context: ConnectionContext) => void>;\n            init(): Promise<void>;\n            listenForEncryptedMessage(senderPublicKey: string, messageCallback: (message: string, context: ConnectionContext) => void): Promise<void>;\n            sendMessage(message: string, peer: PostMessagePairingRequest | ExtendedPostMessagePairingResponse): Promise<void>;\n            listenForChannelOpening(messageCallback: (pairingResponse: ExtendedPostMessagePairingResponse) => void): Promise<void>;\n            sendPairingRequest(id: string): Promise<void>;\n            isChannelOpenMessage(message: any): Promise<boolean>;\n        }\n    }\n    \n    module 'test/transports/DappP2PTransport' {\n        import * as sodium from 'libsodium-wrappers';\n        import { Storage, StorageKey, P2PTransport } from 'test/';\n        import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n        export class DappP2PTransport extends P2PTransport<ExtendedP2PPairingResponse, StorageKey.TRANSPORT_P2P_PEERS_DAPP> {\n            constructor(name: string, keyPair: sodium.KeyPair, storage: Storage, matrixNodes: string[], iconUrl?: string, appUrl?: string);\n            startOpenChannelListener(): Promise<void>;\n            listenForNewPeer(newPeerListener: (peer: ExtendedP2PPairingResponse) => void): Promise<void>;\n            stopListeningForNewPeers(): Promise<void>;\n        }\n    }\n    \n    module 'test/transports/DappPostMessageTransport' {\n        import * as sodium from 'libsodium-wrappers';\n        import { StorageKey, PostMessageTransport, Storage } from 'test/';\n        import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n        export class DappPostMessageTransport extends PostMessageTransport<ExtendedPostMessagePairingResponse, StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP> {\n            constructor(name: string, keyPair: sodium.KeyPair, storage: Storage);\n            startOpenChannelListener(): Promise<void>;\n            listenForNewPeer(newPeerListener: (peer: ExtendedPostMessagePairingResponse) => void): Promise<void>;\n            stopListeningForNewPeers(): Promise<void>;\n        }\n    }\n    \n    module 'test/transports/P2PTransport' {\n        import * as sodium from 'libsodium-wrappers';\n        import { Storage, StorageKey, Transport, TransportType, P2PCommunicationClient, P2PPairingRequest } from 'test/';\n        import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n        export class P2PTransport<T extends P2PPairingRequest | ExtendedP2PPairingResponse, K extends StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET> extends Transport<T, K, P2PCommunicationClient> {\n            readonly type: TransportType;\n            constructor(name: string, keyPair: sodium.KeyPair, storage: Storage, matrixNodes: string[], storageKey: K, iconUrl?: string, appUrl?: string);\n            static isAvailable(): Promise<boolean>;\n            connect(): Promise<void>;\n            startOpenChannelListener(): Promise<void>;\n            getPairingRequestInfo(): Promise<P2PPairingRequest>;\n            listen(publicKey: string): Promise<void>;\n        }\n    }\n    \n    module 'test/transports/PostMessageTransport' {\n        import * as sodium from 'libsodium-wrappers';\n        import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n        import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n        import { Extension } from 'test/types/Extension';\n        import { StorageKey } from 'test/types/storage/StorageKey';\n        import { TransportType } from 'test/types/transport/TransportType';\n        import { Storage } from 'test/storage/Storage';\n        import { PostMessageClient } from 'test/transports/clients/PostMessageClient';\n        import { Transport } from 'test/transports/Transport';\n        export class PostMessageTransport<T extends PostMessagePairingRequest | ExtendedPostMessagePairingResponse, K extends StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET> extends Transport<T, K, PostMessageClient> {\n            readonly type: TransportType;\n            constructor(name: string, keyPair: sodium.KeyPair, storage: Storage, storageKey: K);\n            static isAvailable(): Promise<boolean>;\n            static getAvailableExtensions(): Promise<Extension[]>;\n            connect(): Promise<void>;\n            startOpenChannelListener(): Promise<void>;\n            getPairingRequestInfo(): Promise<PostMessagePairingRequest>;\n            listen(publicKey: string): Promise<void>;\n        }\n    }\n    \n    module 'test/transports/Transport' {\n        import { ConnectionContext } from 'test/types/ConnectionContext';\n        import { TransportType, TransportStatus, PeerInfo, StorageKey } from 'test/';\n        import { PeerManager } from 'test/managers/PeerManager';\n        import { CommunicationClient } from 'test/transports/clients/CommunicationClient';\n        export abstract class Transport<T extends PeerInfo = PeerInfo, K extends StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET = any, S extends CommunicationClient = any> {\n                /**\n                     * The type of the transport\n                     */\n                readonly type: TransportType;\n                /**\n                     * The name of the app\n                     */\n                protected readonly name: string;\n                /**\n                     * The status of the transport\n                     */\n                protected _isConnected: TransportStatus;\n                protected readonly peerManager: PeerManager<K>;\n                /**\n                     * The client handling the encryption/decryption of messages\n                     */\n                protected client: S;\n                /**\n                     * The listener that will be invoked when a new peer is connected\n                     */\n                protected newPeerListener?: (peer: T) => void;\n                /**\n                     * Return the status of the connection\n                     */\n                get connectionStatus(): TransportStatus;\n                constructor(name: string, client: S, peerManager: PeerManager<K>);\n                /**\n                     * Returns a promise that resolves to true if the transport is available, false if it is not\n                     */\n                static isAvailable(): Promise<boolean>;\n                /**\n                     * Connect the transport\n                     */\n                connect(): Promise<void>;\n                /**\n                     * Send a message through the transport\n                     *\n                     * @param message The message to send\n                     * @param recipient The recipient of the message\n                     */\n                send(message: string, peer?: PeerInfo): Promise<void>;\n                /**\n                     * Add a listener to be called when a new message is received\n                     *\n                     * @param listener The listener that will be registered\n                     */\n                addListener(listener: (message: unknown, connectionInfo: ConnectionContext) => void): Promise<void>;\n                /**\n                     * Remove a listener\n                     *\n                     * @param listener\n                     */\n                removeListener(listener: (message: string, connectionInfo: ConnectionContext) => void): Promise<void>;\n                getPeers(): Promise<T[]>;\n                addPeer(newPeer: T): Promise<void>;\n                removePeer(peerToBeRemoved: T): Promise<void>;\n                removeAllPeers(): Promise<void>;\n                /**\n                     * Notify the listeners when a new message comes in\n                     *\n                     * @param message Message\n                     * @param connectionInfo Context info about the connection\n                     */\n                protected notifyListeners(message: unknown, connectionInfo: ConnectionContext): Promise<void>;\n                abstract listen(publicKey: string): Promise<void>;\n        }\n    }\n    \n    module 'test/transports/WalletP2PTransport' {\n        import * as sodium from 'libsodium-wrappers';\n        import { Storage, StorageKey, P2PTransport, P2PPairingRequest } from 'test/';\n        export class WalletP2PTransport extends P2PTransport<P2PPairingRequest, StorageKey.TRANSPORT_P2P_PEERS_WALLET> {\n            constructor(name: string, keyPair: sodium.KeyPair, storage: Storage, matrixNodes: string[], iconUrl?: string, appUrl?: string);\n            addPeer(newPeer: P2PPairingRequest): Promise<void>;\n        }\n    }\n    \n    module 'test/transports/WalletPostMessageTransport' {\n        import * as sodium from 'libsodium-wrappers';\n        import { StorageKey, PostMessageTransport, Storage } from 'test/';\n        import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n        export class WalletPostMessageTransport extends PostMessageTransport<PostMessagePairingRequest, StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET> {\n            constructor(name: string, keyPair: sodium.KeyPair, storage: Storage);\n        }\n    }\n    \n    module 'test/types/AccountInfo' {\n        import { Origin } from 'test/';\n        import { PermissionEntity } from 'test/types/PermissionEntity';\n        export type AccountIdentifier = string;\n        export interface AccountInfo extends PermissionEntity {\n            accountIdentifier: AccountIdentifier;\n            senderId: string;\n            origin: {\n                type: Origin;\n                id: string;\n            };\n            publicKey: string;\n            connectedAt: number;\n        }\n    }\n    \n    module 'test/types/beacon/AppMetadata' {\n        export interface AppMetadata {\n            senderId: string;\n            name: string;\n            icon?: string;\n        }\n    }\n    \n    module 'test/types/beacon/BeaconBaseMessage' {\n        import { BeaconMessageType } from 'test/';\n        export interface BeaconBaseMessage {\n            type: BeaconMessageType;\n            version: string;\n            id: string;\n            senderId: string;\n        }\n    }\n    \n    module 'test/types/beacon/BeaconMessage' {\n        import { PermissionResponse, PermissionRequest, OperationRequest, OperationResponse, SignPayloadRequest, SignPayloadResponse, BroadcastRequest, BroadcastResponse, AcknowledgeResponse, DisconnectMessage, ErrorResponse } from 'test/';\n        export type BeaconMessage = PermissionRequest | PermissionResponse | OperationRequest | OperationResponse | SignPayloadRequest | SignPayloadResponse | BroadcastRequest | BroadcastResponse | AcknowledgeResponse | DisconnectMessage | ErrorResponse;\n    }\n    \n    module 'test/types/beacon/BeaconMessageType' {\n        export enum BeaconMessageType {\n            PermissionRequest = \"permission_request\",\n            SignPayloadRequest = \"sign_payload_request\",\n            OperationRequest = \"operation_request\",\n            BroadcastRequest = \"broadcast_request\",\n            PermissionResponse = \"permission_response\",\n            SignPayloadResponse = \"sign_payload_response\",\n            OperationResponse = \"operation_response\",\n            BroadcastResponse = \"broadcast_response\",\n            Acknowledge = \"acknowledge\",\n            Disconnect = \"disconnect\",\n            Error = \"error\"\n        }\n    }\n    \n    module 'test/types/beacon/BeaconRequestMessage' {\n        import { PermissionRequest, OperationRequest, SignPayloadRequest, BroadcastRequest } from 'test/';\n        export type BeaconRequestMessage = PermissionRequest | OperationRequest | SignPayloadRequest | BroadcastRequest;\n    }\n    \n    module 'test/types/beacon/BeaconResponseMessage' {\n        import { PermissionResponse, OperationResponse, SignPayloadResponse, BroadcastResponse } from 'test/';\n        import { ErrorResponse } from 'test/types/beacon/messages/ErrorResponse';\n        export type BeaconResponseMessage = PermissionResponse | OperationResponse | SignPayloadResponse | BroadcastResponse | ErrorResponse;\n    }\n    \n    module 'test/types/beacon/messages/AcknowledgeResponse' {\n        import { BeaconBaseMessage, BeaconMessageType } from 'test/';\n        export interface AcknowledgeResponse extends BeaconBaseMessage {\n            type: BeaconMessageType.Acknowledge;\n        }\n    }\n    \n    module 'test/types/beacon/messages/BeaconRequestInputMessage' {\n        import { PermissionRequest, OperationRequest, SignPayloadRequest, BroadcastRequest } from 'test/';\n        export type IgnoredRequestInputProperties = 'id' | 'senderId' | 'version';\n        export type PermissionRequestInput = Omit<PermissionRequest, IgnoredRequestInputProperties>;\n        export type OperationRequestInput = Omit<OperationRequest, IgnoredRequestInputProperties>;\n        export type SignPayloadRequestInput = Omit<SignPayloadRequest, IgnoredRequestInputProperties>;\n        export type BroadcastRequestInput = Omit<BroadcastRequest, IgnoredRequestInputProperties>;\n        export type BeaconRequestInputMessage = PermissionRequestInput | OperationRequestInput | SignPayloadRequestInput | BroadcastRequestInput;\n    }\n    \n    module 'test/types/beacon/messages/BeaconRequestOutputMessage' {\n        import { AppMetadata, PermissionRequest, OperationRequest, SignPayloadRequest, BroadcastRequest } from 'test/';\n        export type IgnoredRequestOutputProperties = 'version';\n        export interface ExtraResponseOutputProperties {\n            appMetadata: AppMetadata;\n        }\n        export type PermissionRequestOutput = Omit<PermissionRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n        export type OperationRequestOutput = Omit<OperationRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n        export type SignPayloadRequestOutput = Omit<SignPayloadRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n        export type BroadcastRequestOutput = Omit<BroadcastRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n        export type BeaconRequestOutputMessage = PermissionRequestOutput | OperationRequestOutput | SignPayloadRequestOutput | BroadcastRequestOutput;\n    }\n    \n    module 'test/types/beacon/messages/BeaconResponseInputMessage' {\n        import { PermissionResponse, OperationResponse, SignPayloadResponse, BroadcastResponse, AcknowledgeResponse, ErrorResponse } from 'test/';\n        export type IgnoredResponseInputProperties = 'senderId' | 'version' | 'appMetadata';\n        export type PermissionResponseInput = Omit<PermissionResponse, IgnoredResponseInputProperties>;\n        export type OperationResponseInput = Omit<OperationResponse, IgnoredResponseInputProperties>;\n        export type SignPayloadResponseInput = Omit<SignPayloadResponse, IgnoredResponseInputProperties>;\n        export type BroadcastResponseInput = Omit<BroadcastResponse, IgnoredResponseInputProperties>;\n        export type AcknowledgeResponseInput = Omit<AcknowledgeResponse, IgnoredResponseInputProperties>;\n        export type ErrorResponseInput = Omit<ErrorResponse, IgnoredResponseInputProperties>;\n        export type BeaconResponseInputMessage = PermissionResponseInput | OperationResponseInput | SignPayloadResponseInput | BroadcastResponseInput | AcknowledgeResponseInput | ErrorResponseInput;\n    }\n    \n    module 'test/types/beacon/messages/BeaconResponseOutputMessage' {\n        import { PermissionResponse, OperationResponse, SignPayloadResponse, BroadcastResponse, AccountInfo } from 'test/';\n        export type IgnoredResponseOutputProperties = 'id' | 'version' | 'type';\n        export type PermissionResponseOutput = PermissionResponse & {\n            address: string;\n            accountInfo: AccountInfo;\n        };\n        export type OperationResponseOutput = OperationResponse;\n        export type SignPayloadResponseOutput = SignPayloadResponse;\n        export type BroadcastResponseOutput = BroadcastResponse;\n        export type BeaconResponseOutputMessage = PermissionResponseOutput | OperationResponseOutput | SignPayloadResponseOutput | BroadcastResponseOutput;\n    }\n    \n    module 'test/types/beacon/messages/BroadcastRequest' {\n        import { BeaconBaseMessage, BeaconMessageType, Network } from 'test/';\n        export interface BroadcastRequest extends BeaconBaseMessage {\n            type: BeaconMessageType.BroadcastRequest;\n            network: Network;\n            signedTransaction: string;\n        }\n    }\n    \n    module 'test/types/beacon/messages/BroadcastResponse' {\n        import { BeaconBaseMessage, BeaconMessageType } from 'test/';\n        export interface BroadcastResponse extends BeaconBaseMessage {\n            type: BeaconMessageType.BroadcastResponse;\n            transactionHash: string;\n        }\n    }\n    \n    module 'test/types/beacon/messages/DisconnectMessage' {\n        import { BeaconBaseMessage, BeaconMessageType } from 'test/';\n        export interface DisconnectMessage extends BeaconBaseMessage {\n            type: BeaconMessageType.Disconnect;\n        }\n    }\n    \n    module 'test/types/beacon/messages/ErrorResponse' {\n        import { BeaconBaseMessage, BeaconErrorType, BeaconMessageType } from 'test/';\n        export interface ErrorResponse extends BeaconBaseMessage {\n            type: BeaconMessageType.Error;\n            errorType: BeaconErrorType;\n            errorData?: any;\n        }\n    }\n    \n    module 'test/types/beacon/messages/OperationRequest' {\n        import { BeaconBaseMessage, BeaconMessageType, Network } from 'test/';\n        import { PartialTezosOperation } from 'test/types/tezos/PartialTezosOperation';\n        export interface OperationRequest extends BeaconBaseMessage {\n            type: BeaconMessageType.OperationRequest;\n            network: Network;\n            operationDetails: PartialTezosOperation[];\n            sourceAddress: string;\n        }\n    }\n    \n    module 'test/types/beacon/messages/OperationResponse' {\n        import { BeaconBaseMessage, BeaconMessageType } from 'test/';\n        export interface OperationResponse extends BeaconBaseMessage {\n            type: BeaconMessageType.OperationResponse;\n            transactionHash: string;\n        }\n    }\n    \n    module 'test/types/beacon/messages/PermissionRequest' {\n        import { BeaconBaseMessage, BeaconMessageType, PermissionScope, AppMetadata, Network } from 'test/';\n        export interface PermissionRequest extends BeaconBaseMessage {\n            type: BeaconMessageType.PermissionRequest;\n            appMetadata: AppMetadata;\n            network: Network;\n            scopes: PermissionScope[];\n        }\n    }\n    \n    module 'test/types/beacon/messages/PermissionResponse' {\n        import { AppMetadata, BeaconBaseMessage, BeaconMessageType, Network, PermissionScope, Threshold } from 'test/';\n        export interface PermissionResponse extends BeaconBaseMessage {\n            type: BeaconMessageType.PermissionResponse;\n            appMetadata: AppMetadata;\n            publicKey: string;\n            network: Network;\n            scopes: PermissionScope[];\n            threshold?: Threshold;\n        }\n    }\n    \n    module 'test/types/beacon/messages/SignPayloadRequest' {\n        import { BeaconBaseMessage, BeaconMessageType, SigningType } from 'test/';\n        export interface SignPayloadRequest extends BeaconBaseMessage {\n            type: BeaconMessageType.SignPayloadRequest;\n            signingType: SigningType;\n            payload: string;\n            sourceAddress: string;\n        }\n    }\n    \n    module 'test/types/beacon/messages/SignPayloadResponse' {\n        import { BeaconBaseMessage, BeaconMessageType, SigningType } from 'test/';\n        export interface SignPayloadResponse extends BeaconBaseMessage {\n            type: BeaconMessageType.SignPayloadResponse;\n            signingType: SigningType;\n            signature: string;\n        }\n    }\n    \n    module 'test/types/beacon/Network' {\n        import { NetworkType } from 'test/';\n        export interface Network {\n            type: NetworkType;\n            name?: string;\n            rpcUrl?: string;\n        }\n    }\n    \n    module 'test/types/beacon/NetworkType' {\n        export enum NetworkType {\n            MAINNET = \"mainnet\",\n            DELPHINET = \"delphinet\",\n            EDONET = \"edonet\",\n            CUSTOM = \"custom\"\n        }\n    }\n    \n    module 'test/types/beacon/PermissionScope' {\n        export enum PermissionScope {\n            SIGN = \"sign\",\n            OPERATION_REQUEST = \"operation_request\",\n            THRESHOLD = \"threshold\"\n        }\n    }\n    \n    module 'test/types/beacon/SigningType' {\n        export enum SigningType {\n            RAW = \"raw\",\n            OPERATION = \"operation\",\n            MICHELINE = \"micheline\"\n        }\n    }\n    \n    module 'test/types/beacon/Threshold' {\n        export interface Threshold {\n            amount: string;\n            timeframe: string;\n        }\n    }\n    \n    module 'test/types/BeaconErrorType' {\n        export enum BeaconErrorType {\n            BROADCAST_ERROR = \"BROADCAST_ERROR\",\n            NETWORK_NOT_SUPPORTED = \"NETWORK_NOT_SUPPORTED\",\n            NO_ADDRESS_ERROR = \"NO_ADDRESS_ERROR\",\n            NO_PRIVATE_KEY_FOUND_ERROR = \"NO_PRIVATE_KEY_FOUND_ERROR\",\n            NOT_GRANTED_ERROR = \"NOT_GRANTED_ERROR\",\n            PARAMETERS_INVALID_ERROR = \"PARAMETERS_INVALID_ERROR\",\n            TOO_MANY_OPERATIONS = \"TOO_MANY_OPERATIONS\",\n            TRANSACTION_INVALID_ERROR = \"TRANSACTION_INVALID_ERROR\",\n            SIGNATURE_TYPE_NOT_SUPPORTED = \"SIGNATURE_TYPE_NOT_SUPPORTED\",\n            ABORTED_ERROR = \"ABORTED_ERROR\",\n            UNKNOWN_ERROR = \"UNKNOWN_ERROR\"\n        }\n    }\n    \n    module 'test/types/ColorMode' {\n        export enum ColorMode {\n            LIGHT = \"light\",\n            DARK = \"dark\"\n        }\n    }\n    \n    module 'test/types/ConnectionContext' {\n        import { Origin } from 'test/';\n        export interface ConnectionContext {\n            origin: Origin;\n            id: string;\n            extras?: {\n                sender: chrome.runtime.MessageSender;\n                sendResponse(response?: unknown): void;\n            };\n        }\n    }\n    \n    module 'test/types/Extension' {\n        export interface Extension {\n            id: string;\n            name: string;\n            shortName?: string;\n            iconUrl?: string;\n            color?: string;\n        }\n    }\n    \n    module 'test/types/ExtensionMessage' {\n        import { ExtensionMessageTarget } from 'test/';\n        export interface ExtensionMessage<T, U = unknown> {\n            target: ExtensionMessageTarget;\n            targetId?: string;\n            sender?: U;\n            payload: T;\n        }\n        export interface EncryptedExtensionMessage<U = unknown> {\n            target: ExtensionMessageTarget;\n            targetId?: string;\n            sender?: U;\n            encryptedPayload: string;\n        }\n    }\n    \n    module 'test/types/ExtensionMessageTarget' {\n        export enum ExtensionMessageTarget {\n            BACKGROUND = \"toBackground\",\n            PAGE = \"toPage\",\n            EXTENSION = \"toExtension\"\n        }\n    }\n    \n    module 'test/types/Origin' {\n        export enum Origin {\n            WEBSITE = \"website\",\n            EXTENSION = \"extension\",\n            P2P = \"p2p\"\n        }\n    }\n    \n    module 'test/types/P2PPairingRequest' {\n        import { PeerInfo } from 'test/types/PeerInfo';\n        export interface P2PPairingRequest extends PeerInfo {\n            id: string;\n            type: 'p2p-pairing-request';\n            name: string;\n            publicKey: string;\n            relayServer: string;\n            icon?: string;\n            appUrl?: string;\n        }\n        export type ExtendedP2PPairingRequest = P2PPairingRequest & {\n            senderId: string;\n        };\n    }\n    \n    module 'test/types/P2PPairingResponse' {\n        import { PeerInfo } from 'test/types/PeerInfo';\n        export interface P2PPairingResponse extends PeerInfo {\n            id: string;\n            type: 'p2p-pairing-response';\n            name: string;\n            publicKey: string;\n            relayServer: string;\n            icon?: string;\n            appUrl?: string;\n        }\n        export type ExtendedP2PPairingResponse = P2PPairingResponse & {\n            senderId: string;\n        };\n    }\n    \n    module 'test/types/PeerInfo' {\n        export interface PeerInfo {\n            name: string;\n            publicKey: string;\n            version: string;\n        }\n        export type ExtendedPeerInfo = PeerInfo & {\n            senderId: string;\n        };\n    }\n    \n    module 'test/types/PermissionEntity' {\n        import { Network, PermissionScope, Threshold } from 'test/';\n        export interface PermissionEntity {\n            address: string;\n            network: Network;\n            scopes: PermissionScope[];\n            threshold?: Threshold;\n        }\n    }\n    \n    module 'test/types/PermissionInfo' {\n        import { AppMetadata } from 'test/';\n        import { PermissionEntity } from 'test/types/PermissionEntity';\n        export interface PermissionInfo extends PermissionEntity {\n            accountIdentifier: string;\n            senderId: string;\n            appMetadata: AppMetadata;\n            website: string;\n            publicKey: string;\n            connectedAt: number;\n        }\n    }\n    \n    module 'test/types/PostMessagePairingRequest' {\n        import { PeerInfo } from 'test/types/PeerInfo';\n        export interface PostMessagePairingRequest extends PeerInfo {\n            id: string;\n            type: 'postmessage-pairing-request';\n            name: string;\n            publicKey: string;\n            icon?: string;\n            appUrl?: string;\n        }\n        export type ExtendedPostMessagePairingRequest = PostMessagePairingRequest & {\n            senderId: string;\n        };\n    }\n    \n    module 'test/types/PostMessagePairingResponse' {\n        import { PeerInfo } from 'test/types/PeerInfo';\n        export interface PostMessagePairingResponse extends PeerInfo {\n            id: string;\n            type: 'postmessage-pairing-response';\n            name: string;\n            publicKey: string;\n            icon?: string;\n            appUrl?: string;\n        }\n        export type ExtendedPostMessagePairingResponse = PostMessagePairingResponse & {\n            senderId: string;\n            extensionId: string;\n        };\n    }\n    \n    module 'test/types/RequestBroadcastInput' {\n        import { Network } from 'test/';\n        export interface RequestBroadcastInput {\n            network?: Network;\n            signedTransaction: string;\n        }\n    }\n    \n    module 'test/types/RequestOperationInput' {\n        import { PartialTezosOperation } from 'test/types/tezos/PartialTezosOperation';\n        export interface RequestOperationInput {\n            operationDetails: PartialTezosOperation[];\n        }\n    }\n    \n    module 'test/types/RequestPermissionInput' {\n        import { Network, PermissionScope } from 'test/';\n        export interface RequestPermissionInput {\n            network?: Network;\n            scopes?: PermissionScope[];\n        }\n    }\n    \n    module 'test/types/RequestSignPayloadInput' {\n        import { SigningType } from 'test/';\n        export interface RequestSignPayloadInput {\n            signingType?: SigningType;\n            payload: string;\n            sourceAddress?: string;\n        }\n    }\n    \n    module 'test/types/storage/StorageKey' {\n        export enum StorageKey {\n            TRANSPORT_P2P_PEERS_DAPP = \"beacon:communication-peers-dapp\",\n            TRANSPORT_P2P_PEERS_WALLET = \"beacon:communication-peers-wallet\",\n            TRANSPORT_POSTMESSAGE_PEERS_DAPP = \"beacon:postmessage-peers-dapp\",\n            TRANSPORT_POSTMESSAGE_PEERS_WALLET = \"beacon:postmessage-peers-wallet\",\n            ACCOUNTS = \"beacon:accounts\",\n            ACTIVE_ACCOUNT = \"beacon:active-account\",\n            ACTIVE_PEER = \"beacon:active-peer\",\n            BEACON_SDK_SECRET_SEED = \"beacon:sdk-secret-seed\",\n            APP_METADATA_LIST = \"beacon:app-metadata-list\",\n            PERMISSION_LIST = \"beacon:permissions\",\n            BEACON_SDK_VERSION = \"beacon:sdk_version\",\n            MATRIX_PRESERVED_STATE = \"beacon:sdk-matrix-preserved-state\",\n            MATRIX_PEER_ROOM_IDS = \"beacon:matrix-peer-rooms\"\n        }\n    }\n    \n    module 'test/types/storage/StorageKeyReturnDefaults' {\n        import { StorageKey, StorageKeyReturnType } from 'test/';\n        export type StorageKeyReturnDefaults = {\n            [key in StorageKey]: StorageKeyReturnType[key];\n        };\n        export const defaultValues: StorageKeyReturnDefaults;\n    }\n    \n    module 'test/types/storage/StorageKeyReturnType' {\n        import { StorageKey, AccountInfo, AccountIdentifier, P2PPairingRequest, AppMetadata, PermissionInfo } from 'test/';\n        import { MatrixState } from 'test/matrix-client/MatrixClientStore';\n        import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n        import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n        import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n        export interface StorageKeyReturnType {\n            [StorageKey.TRANSPORT_P2P_PEERS_DAPP]: P2PPairingRequest[];\n            [StorageKey.TRANSPORT_P2P_PEERS_WALLET]: ExtendedP2PPairingResponse[];\n            [StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP]: PostMessagePairingRequest[];\n            [StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET]: ExtendedPostMessagePairingResponse[];\n            [StorageKey.ACCOUNTS]: AccountInfo[];\n            [StorageKey.ACTIVE_ACCOUNT]: AccountIdentifier | undefined;\n            [StorageKey.ACTIVE_PEER]: string | undefined;\n            [StorageKey.BEACON_SDK_SECRET_SEED]: string | undefined;\n            [StorageKey.APP_METADATA_LIST]: AppMetadata[];\n            [StorageKey.PERMISSION_LIST]: PermissionInfo[];\n            [StorageKey.BEACON_SDK_VERSION]: string | undefined;\n            [StorageKey.MATRIX_PRESERVED_STATE]: Partial<MatrixState>;\n            [StorageKey.MATRIX_PEER_ROOM_IDS]: {\n                [key: string]: string | undefined;\n            };\n        }\n    }\n    \n    module 'test/types/tezos/MichelineMichelsonV1Expression' {\n        import { MichelsonPrimitives } from 'test/';\n        export type MichelineMichelsonV1Expression = {\n            int: string;\n        } | {\n            string: string;\n        } | {\n            bytes: string;\n        } | MichelineMichelsonV1Expression[] | {\n            prim: MichelsonPrimitives;\n            args?: MichelineMichelsonV1Expression[];\n            annots?: string[];\n        };\n    }\n    \n    module 'test/types/tezos/MichelsonPrimitives' {\n        export type MichelsonPrimitives = 'ADD' | 'IF_NONE' | 'SWAP' | 'set' | 'nat' | 'CHECK_SIGNATURE' | 'IF_LEFT' | 'LAMBDA' | 'Elt' | 'CREATE_CONTRACT' | 'NEG' | 'big_map' | 'map' | 'or' | 'BLAKE2B' | 'bytes' | 'SHA256' | 'SET_DELEGATE' | 'CONTRACT' | 'LSL' | 'SUB' | 'IMPLICIT_ACCOUNT' | 'PACK' | 'list' | 'PAIR' | 'Right' | 'contract' | 'GT' | 'LEFT' | 'STEPS_TO_QUOTA' | 'storage' | 'TRANSFER_TOKENS' | 'CDR' | 'SLICE' | 'PUSH' | 'False' | 'SHA512' | 'CHAIN_ID' | 'BALANCE' | 'signature' | 'DUG' | 'SELF' | 'EMPTY_BIG_MAP' | 'LSR' | 'OR' | 'XOR' | 'lambda' | 'COMPARE' | 'key' | 'option' | 'Unit' | 'Some' | 'UNPACK' | 'NEQ' | 'INT' | 'pair' | 'AMOUNT' | 'DIP' | 'ABS' | 'ISNAT' | 'EXEC' | 'NOW' | 'LOOP' | 'chain_id' | 'string' | 'MEM' | 'MAP' | 'None' | 'address' | 'CONCAT' | 'EMPTY_SET' | 'MUL' | 'LOOP_LEFT' | 'timestamp' | 'LT' | 'UPDATE' | 'DUP' | 'SOURCE' | 'mutez' | 'SENDER' | 'IF_CONS' | 'RIGHT' | 'CAR' | 'CONS' | 'LE' | 'NONE' | 'IF' | 'SOME' | 'GET' | 'Left' | 'CAST' | 'int' | 'SIZE' | 'key_hash' | 'unit' | 'DROP' | 'EMPTY_MAP' | 'NIL' | 'DIG' | 'APPLY' | 'bool' | 'RENAME' | 'operation' | 'True' | 'FAILWITH' | 'parameter' | 'HASH_KEY' | 'EQ' | 'NOT' | 'UNIT' | 'Pair' | 'ADDRESS' | 'EDIV' | 'CREATE_ACCOUNT' | 'GE' | 'ITER' | 'code' | 'AND';\n    }\n    \n    module 'test/types/tezos/operations/ActivateAccount' {\n        import { TezosBaseOperation, TezosOperationType } from 'test/';\n        export interface TezosActivateAccountOperation extends TezosBaseOperation {\n            kind: TezosOperationType.ACTIVATE_ACCOUNT;\n            pkh: string;\n            secret: string;\n        }\n    }\n    \n    module 'test/types/tezos/operations/Ballot' {\n        import { TezosBaseOperation, TezosOperationType } from 'test/';\n        export interface TezosBallotOperation extends TezosBaseOperation {\n            kind: TezosOperationType.BALLOT;\n            source: string;\n            period: string;\n            proposal: string;\n            ballot: 'nay' | 'yay' | 'pass';\n        }\n    }\n    \n    module 'test/types/tezos/operations/Delegation' {\n        import { TezosBaseOperation, TezosOperationType } from 'test/';\n        export interface TezosDelegationOperation extends TezosBaseOperation {\n            kind: TezosOperationType.DELEGATION;\n            source: string;\n            fee: string;\n            counter: string;\n            gas_limit: string;\n            storage_limit: string;\n            delegate?: string;\n        }\n    }\n    \n    module 'test/types/tezos/operations/DoubleBakingEvidence' {\n        import { TezosBaseOperation, TezosOperationType, TezosBlockHeader } from 'test/';\n        export interface InlinedEndorsement {\n            branch: string;\n            operations: InlinedEndorsementContents;\n            signature?: string;\n        }\n        export interface InlinedEndorsementContents {\n            kind: 'endorsement';\n            level: string;\n        }\n        export interface TezosDoubleBakingEvidenceOperation extends TezosBaseOperation {\n            kind: TezosOperationType.DOUBLE_BAKING_EVIDENCE;\n            bh1: TezosBlockHeader;\n            bh2: TezosBlockHeader;\n        }\n    }\n    \n    module 'test/types/tezos/operations/DoubleEndorsementEvidence' {\n        import { TezosBaseOperation, TezosOperationType } from 'test/';\n        export interface InlinedEndorsement {\n            branch: string;\n            operations: InlinedEndorsementContents;\n            signature?: string;\n        }\n        export interface InlinedEndorsementContents {\n            kind: 'endorsement';\n            level: string;\n        }\n        export interface TezosDoubleEndorsementEvidenceOperation extends TezosBaseOperation {\n            kind: TezosOperationType.DOUBLE_ENDORSEMENT_EVIDENCE;\n            op1: InlinedEndorsement;\n            op2: InlinedEndorsement;\n        }\n    }\n    \n    module 'test/types/tezos/operations/Endorsement' {\n        import { TezosBaseOperation, TezosOperationType } from 'test/';\n        export interface TezosEndorsementOperation extends TezosBaseOperation {\n            kind: TezosOperationType.ENDORSEMENT;\n            level: string;\n        }\n    }\n    \n    module 'test/types/tezos/operations/Origination' {\n        import { TezosBaseOperation, TezosOperationType } from 'test/';\n        export interface TezosOriginationOperation extends TezosBaseOperation {\n            kind: TezosOperationType.ORIGINATION;\n            source: string;\n            fee: string;\n            counter: string;\n            gas_limit: string;\n            storage_limit: string;\n            balance: string;\n            delegate?: string;\n            script: string;\n        }\n    }\n    \n    module 'test/types/tezos/operations/Proposal' {\n        import { TezosBaseOperation, TezosOperationType } from 'test/';\n        export interface TezosProposalOperation extends TezosBaseOperation {\n            kind: TezosOperationType.PROPOSALS;\n            period: string;\n            proposals: string[];\n        }\n    }\n    \n    module 'test/types/tezos/operations/Reveal' {\n        import { TezosBaseOperation, TezosOperationType } from 'test/';\n        export interface TezosRevealOperation extends TezosBaseOperation {\n            kind: TezosOperationType.REVEAL;\n            source: string;\n            fee: string;\n            counter: string;\n            gas_limit: string;\n            storage_limit: string;\n            public_key: string;\n        }\n    }\n    \n    module 'test/types/tezos/operations/SeedNonceRevelation' {\n        import { TezosBaseOperation, TezosOperationType } from 'test/';\n        export interface TezosSeedNonceRevelationOperation extends TezosBaseOperation {\n            kind: TezosOperationType.SEED_NONCE_REVELATION;\n            level: string;\n            nonce: string;\n        }\n    }\n    \n    module 'test/types/tezos/operations/Transaction' {\n        import { TezosBaseOperation, TezosOperationType, TezosTransactionParameters } from 'test/';\n        export interface TezosTransactionOperation extends TezosBaseOperation {\n            kind: TezosOperationType.TRANSACTION;\n            source: string;\n            fee: string;\n            counter: string;\n            gas_limit: string;\n            storage_limit: string;\n            amount: string;\n            destination: string;\n            parameters?: TezosTransactionParameters;\n        }\n    }\n    \n    module 'test/types/tezos/OperationTypes' {\n        export enum TezosOperationType {\n            ENDORSEMENT = \"endorsement\",\n            SEED_NONCE_REVELATION = \"seed_nonce_revelation\",\n            DOUBLE_ENDORSEMENT_EVIDENCE = \"double_endorsement_evidence\",\n            DOUBLE_BAKING_EVIDENCE = \"double_baking_evidence\",\n            ACTIVATE_ACCOUNT = \"activate_account\",\n            PROPOSALS = \"proposals\",\n            BALLOT = \"ballot\",\n            REVEAL = \"reveal\",\n            TRANSACTION = \"transaction\",\n            ORIGINATION = \"origination\",\n            DELEGATION = \"delegation\"\n        }\n    }\n    \n    module 'test/types/tezos/PartialTezosOperation' {\n        import { TezosActivateAccountOperation } from 'test/types/tezos/operations/ActivateAccount';\n        import { TezosBallotOperation } from 'test/types/tezos/operations/Ballot';\n        import { TezosDelegationOperation } from 'test/types/tezos/operations/Delegation';\n        import { TezosDoubleBakingEvidenceOperation } from 'test/types/tezos/operations/DoubleBakingEvidence';\n        import { TezosEndorsementOperation } from 'test/types/tezos/operations/Endorsement';\n        import { TezosOriginationOperation } from 'test/types/tezos/operations/Origination';\n        import { TezosProposalOperation } from 'test/types/tezos/operations/Proposal';\n        import { TezosRevealOperation } from 'test/types/tezos/operations/Reveal';\n        import { TezosSeedNonceRevelationOperation } from 'test/types/tezos/operations/SeedNonceRevelation';\n        import { TezosTransactionOperation } from 'test/types/tezos/operations/Transaction';\n        type omittedProperties = 'source' | 'fee' | 'counter' | 'gas_limit' | 'storage_limit';\n        export type PartialTezosDelegationOperation = Omit<TezosDelegationOperation, omittedProperties>;\n        export type PartialTezosOriginationOperation = Omit<TezosOriginationOperation, omittedProperties>;\n        export type PartialTezosRevealOperation = Omit<TezosRevealOperation, omittedProperties>;\n        export type PartialTezosTransactionOperation = Omit<TezosTransactionOperation, omittedProperties>;\n        export type PartialTezosOperation = TezosActivateAccountOperation | TezosBallotOperation | PartialTezosDelegationOperation | TezosDoubleBakingEvidenceOperation | TezosEndorsementOperation | PartialTezosOriginationOperation | TezosProposalOperation | PartialTezosRevealOperation | TezosSeedNonceRevelationOperation | PartialTezosTransactionOperation;\n        export {};\n    }\n    \n    module 'test/types/tezos/TezosBaseOperation' {\n        import { TezosOperationType } from 'test/';\n        export interface TezosBaseOperation {\n            kind: TezosOperationType;\n        }\n    }\n    \n    module 'test/types/tezos/TezosBlockHeader' {\n        export interface TezosBlockHeader {\n            level: number;\n            proto: number;\n            predecessor: string;\n            timestamp: string;\n            validation_pass: number;\n            operations_hash: string;\n            fitness: string[];\n            context: string;\n            priority: number;\n            proof_of_work_nonce: string;\n            signature: string;\n        }\n    }\n    \n    module 'test/types/tezos/TezosOperation' {\n        import { TezosActivateAccountOperation, TezosBallotOperation, TezosDelegationOperation, TezosDoubleBakingEvidenceOperation, TezosEndorsementOperation, TezosOriginationOperation, TezosProposalOperation, TezosRevealOperation, TezosSeedNonceRevelationOperation, TezosTransactionOperation } from 'test/';\n        export type TezosOperation = TezosActivateAccountOperation | TezosBallotOperation | TezosDelegationOperation | TezosDoubleBakingEvidenceOperation | TezosEndorsementOperation | TezosOriginationOperation | TezosProposalOperation | TezosRevealOperation | TezosSeedNonceRevelationOperation | TezosTransactionOperation;\n    }\n    \n    module 'test/types/tezos/TezosTransactionParameters' {\n        import { MichelineMichelsonV1Expression } from 'test/types/tezos/MichelineMichelsonV1Expression';\n        export interface TezosTransactionParameters {\n            entrypoint: 'default' | 'root' | 'do' | 'set_delegate' | 'remove_delegate' | string;\n            value: MichelineMichelsonV1Expression;\n        }\n    }\n    \n    module 'test/types/transport/TransportStatus' {\n        export enum TransportStatus {\n            NOT_CONNECTED = \"NOT_CONNECTED\",\n            CONNECTING = \"CONNECTING\",\n            CONNECTED = \"CONNECTED\"\n        }\n    }\n    \n    module 'test/types/transport/TransportType' {\n        export enum TransportType {\n            CHROME_MESSAGE = \"chrome_message\",\n            POST_MESSAGE = \"post_message\",\n            LEDGER = \"ledger\",\n            P2P = \"p2p\"\n        }\n    }\n    \n    module 'test/ui/alert/alert-templates' {\n        export const alertTemplates: {\n            container: string;\n            default: {\n                html: string;\n                css: string;\n            };\n            pair: {\n                html: string;\n                css: string;\n            };\n        };\n    }\n    \n    module 'test/ui/alert/Alert' {\n        import { NetworkType } from 'test/';\n        export interface AlertButton {\n                text: string;\n                style?: 'solid' | 'outline';\n                actionCallback?(): Promise<void>;\n        }\n        export interface AlertConfig {\n                title: string;\n                body?: string;\n                timer?: number;\n                buttons?: AlertButton[];\n                pairingPayload?: {\n                        p2pSyncCode: string;\n                        postmessageSyncCode: string;\n                        preferredNetwork: NetworkType;\n                };\n                closeButtonCallback?(): void;\n        }\n        /**\n             * Close an alert by ID\n             *\n             * @param id ID of alert\n             */\n        const closeAlert: (id: string) => Promise<void>;\n        /**\n             * Close all alerts\n             */\n        const closeAlerts: () => Promise<void>;\n        /**\n             * Show an alert\n             *\n             * @param alertConfig The configuration of the alert\n             */\n        const openAlert: (alertConfig: AlertConfig) => Promise<string>;\n        export { closeAlert, closeAlerts, openAlert };\n    }\n    \n    module 'test/ui/alert/Pairing' {\n        import { NetworkType } from 'test/';\n        export enum Platform {\n            DESKTOP = 0,\n            IOS = 1,\n            ANDROID = 2\n        }\n        export enum WalletType {\n            IOS = \"ios\",\n            ANDROID = \"android\",\n            EXTENSION = \"extension\",\n            DESKTOP = \"desktop\",\n            WEB = \"web\"\n        }\n        export interface AppBase {\n            name: string;\n            shortName: string;\n            color: string;\n            logo: string;\n        }\n        export interface ExtensionApp extends AppBase {\n            id: string;\n            link: string;\n        }\n        export interface WebApp extends AppBase {\n            links: {\n                [NetworkType.MAINNET]: string;\n                [NetworkType.DELPHINET]?: string;\n                [NetworkType.EDONET]?: string;\n                [NetworkType.CUSTOM]?: string;\n            };\n        }\n        export interface DesktopApp extends AppBase {\n            deepLink: string;\n        }\n        export interface App extends AppBase {\n            universalLink: string;\n            deepLink?: string;\n        }\n        export interface PairingAlertWallet {\n            name: string;\n            shortName?: string;\n            color?: string;\n            logo?: string;\n            enabled: boolean;\n            clickHandler(): void;\n        }\n        export interface PairingAlertButton {\n            title: string;\n            text: string;\n            clickHandler(): void;\n        }\n        export interface PairingAlertList {\n            title: string;\n            type: WalletType;\n            wallets: PairingAlertWallet[];\n        }\n        export interface PairingAlertInfo {\n            walletLists: PairingAlertList[];\n            buttons: PairingAlertButton[];\n            qrData: string;\n        }\n        export type StatusUpdateHandler = (walletType: WalletType, app?: PairingAlertWallet) => void;\n        export class Pairing {\n            static getPlatfrom(): Promise<Platform>;\n            static getPairingInfo(pairingPayload: {\n                p2pSyncCode: string;\n                postmessageSyncCode: string;\n                preferredNetwork: NetworkType;\n            }, statusUpdateHandler: StatusUpdateHandler, platform?: Platform): Promise<PairingAlertInfo>;\n        }\n    }\n    \n    module 'test/ui/alert/PairingAlert' {\n        import { NetworkType } from 'test/';\n        export const preparePairingAlert: (shadowRoot: ShadowRoot, pairingPayload: {\n            p2pSyncCode: string;\n            postmessageSyncCode: string;\n            preferredNetwork: NetworkType;\n        }) => Promise<void>;\n    }\n    \n    module 'test/ui/alert/wallet-lists' {\n        import { App, DesktopApp, ExtensionApp, WebApp } from 'test/ui/alert/Pairing';\n        export const extensionList: ExtensionApp[];\n        export const desktopList: DesktopApp[];\n        export const webList: WebApp[];\n        export const iOSList: App[];\n    }\n    \n    module 'test/ui/toast/toast-templates' {\n        export const toastTemplates: {\n            default: {\n                html: string;\n                css: string;\n                poweredByBeacon: string;\n            };\n        };\n    }\n    \n    module 'test/ui/toast/Toast' {\n        import { WalletInfo } from 'test/events';\n        export interface ToastAction {\n                text: string;\n                actionText?: string;\n                actionCallback?(): Promise<void>;\n        }\n        export interface ToastConfig {\n                body: string;\n                timer?: number;\n                forceNew?: boolean;\n                state: 'loading' | 'acknowledge' | 'finished';\n                actions?: ToastAction[];\n                walletInfo?: WalletInfo;\n        }\n        /**\n             * Close a toast\n             */\n        const closeToast: () => Promise<void>;\n        /**\n             * Create a new toast\n             *\n             * @param toastConfig Configuration of the toast\n             */\n        const openToast: (toastConfig: ToastConfig) => Promise<void>;\n        export { closeToast, openToast };\n    }\n    \n    module 'test/utils/assert-never' {\n        /**\n           * A helper function to make sure if/elses and switch/cases are exhaustive\n           *\n           * @param empty The data that has to be empty\n           */\n        export function assertNever(empty: never): never;\n    }\n    \n    module 'test/utils/available-transports' {\n        /**\n           * An object with promises to indicate whether or not that transport is available.\n           */\n        export const availableTransports: {\n            extension: Promise<boolean>;\n            availableExtensions: Promise<import(\"../types/Extension\").Extension[]>;\n        };\n    }\n    \n    module 'test/utils/block-explorer' {\n        import { Network, NetworkType } from 'test/';\n        export abstract class BlockExplorer {\n                readonly rpcUrls: {\n                        [key in NetworkType]: string;\n                };\n                constructor(rpcUrls: {\n                        [key in NetworkType]: string;\n                });\n                protected getLinkForNetwork(network: Network): Promise<string>;\n                /**\n                     * Return a blockexplorer link for an address\n                     *\n                     * @param address The address to be opened\n                     * @param network The network that was used\n                     */\n                abstract getAddressLink(address: string, network: Network): Promise<string>;\n                /**\n                     * Return a blockexplorer link for a transaction hash\n                     *\n                     * @param transactionId The hash of the transaction\n                     * @param network The network that was used\n                     */\n                abstract getTransactionLink(transactionId: string, network: Network): Promise<string>;\n        }\n    }\n    \n    module 'test/utils/crypto' {\n        import * as sodium from 'libsodium-wrappers';\n        /**\n             * Convert a value to hex\n             *\n             * @param value\n             */\n        export function toHex(value: any): string;\n        /**\n             * Get the hex hash of a value\n             *\n             * @param key\n             */\n        export function getHexHash(key: string | Buffer | Uint8Array): Promise<string>;\n        /**\n             * Get a keypair from a seed\n             *\n             * @param seed\n             */\n        export function getKeypairFromSeed(seed: string): Promise<sodium.KeyPair>;\n        /**\n             * Encrypt a message with a shared key\n             *\n             * @param message\n             * @param sharedKey\n             */\n        export function encryptCryptoboxPayload(message: string, sharedKey: Uint8Array): Promise<string>;\n        /**\n             * Decrypt a message with a shared key\n             *\n             * @param payload\n             * @param sharedKey\n             */\n        export function decryptCryptoboxPayload(payload: Uint8Array, sharedKey: Uint8Array): Promise<string>;\n        /**\n             * Encrypt a message with a public key\n             *\n             * @param payload\n             * @param publicKey\n             */\n        export function sealCryptobox(payload: string | Buffer, publicKey: Uint8Array): Promise<string>;\n        /**\n             * Decrypt a message with public + private key\n             *\n             * @param encryptedPayload\n             * @param publicKey\n             * @param privateKey\n             */\n        export function openCryptobox(encryptedPayload: string | Buffer, publicKey: Uint8Array, privateKey: Uint8Array): Promise<string>;\n        /**\n             * Get an address from the public key\n             *\n             * @param publicKey\n             */\n        export function getAddressFromPublicKey(publicKey: string): Promise<string>;\n        /**\n             * Get the recipient string used in the matrix message\n             *\n             * @param recipientHash\n             * @param relayServer\n             */\n        export function recipientString(recipientHash: string, relayServer: string): string;\n    }\n    \n    module 'test/utils/exposed-promise' {\n        export enum ExposedPromiseStatus {\n            PENDING = \"pending\",\n            RESOLVED = \"resolved\",\n            REJECTED = \"rejected\"\n        }\n        type Resolve<T> = (value?: T) => void;\n        type Reject<U> = (reason?: U) => void;\n        /**\n           * Exposed promise allow you to create a promise and then resolve it later, from the outside\n           */\n        export class ExposedPromise<T = unknown, U = unknown> {\n            get promise(): Promise<T>;\n            get resolve(): Resolve<T>;\n            get reject(): Reject<U>;\n            get status(): ExposedPromiseStatus;\n            get promiseResult(): T | undefined;\n            get promiseError(): U | undefined;\n            constructor();\n            static resolve<T>(value?: T): ExposedPromise<T>;\n            static reject<T = never, U = unknown>(reason?: U): ExposedPromise<T, U>;\n            isPending(): boolean;\n            isResolved(): boolean;\n            isRejected(): boolean;\n            isSettled(): boolean;\n        }\n        export {};\n    }\n    \n    module 'test/utils/generate-uuid' {\n        /**\n           * Generate a random GUID\n           */\n        export function generateGUID(): Promise<string>;\n    }\n    \n    module 'test/utils/get-account-identifier' {\n        import { Network } from 'test/';\n        /**\n           * Generate a deterministic account identifier based on an address and a network\n           *\n           * @param address\n           * @param network\n           */\n        export const getAccountIdentifier: (address: string, network: Network) => Promise<string>;\n    }\n    \n    module 'test/utils/get-sender-id' {\n        /**\n           * Generate a deterministic sender identifier based on a public key\n           *\n           * @param publicKey\n           */\n        export const getSenderId: (publicKey: string) => Promise<string>;\n    }\n    \n    module 'test/utils/get-tzip10-link' {\n        export const getTzip10Link: (url: string, payload: string) => string;\n    }\n    \n    module 'test/utils/Logger' {\n        /**\n           * The logger that is used internally\n           */\n        export class Logger {\n            constructor(service: string);\n            debug(method: string, ...args: any[]): void;\n            log(method: string, ...args: any[]): void;\n            warn(method: string, ...args: any[]): void;\n            error(method: string, ...args: any[]): void;\n        }\n    }\n    \n    module 'test/utils/platform' {\n        export const testUserAgent: (win: Window, expr: RegExp) => boolean;\n        export const isMobile: (win: Window) => boolean;\n        export const isIOS: (win: Window) => boolean;\n        export const isAndroid: (win: Window) => boolean;\n        export const isDesktop: (win: Window) => boolean;\n    }\n    \n    module 'test/utils/qr' {\n        /**\n           * Convert data to a QR code\n           *\n           * @param payload The data to be encoded as a QR code\n           * @param type How the QR code will be encoded\n           */\n        export const getQrData: (payload: string, type?: \"data\" | \"svg\" | \"ascii\" | undefined) => string;\n    }\n    \n    module 'test/utils/replace-in-template' {\n        export const replaceInTemplate: (text: string, placeholder: string, value: string) => string;\n    }\n    \n    module 'test/utils/shorten-string' {\n        export const shortenString: (text: string) => string;\n    }\n    \n    module 'test/utils/tezblock-blockexplorer' {\n        import { Network, NetworkType } from 'test/';\n        import { BlockExplorer } from 'test/utils/block-explorer';\n        export class TezblockBlockExplorer extends BlockExplorer {\n            readonly rpcUrls: {\n                [key in NetworkType]: string;\n            };\n            constructor(rpcUrls?: {\n                [key in NetworkType]: string;\n            });\n            getAddressLink(address: string, network: Network): Promise<string>;\n            getTransactionLink(transactionId: string, network: Network): Promise<string>;\n        }\n    }\n    \n    module 'test/utils/utils' {\n        /**\n           * A helper function to improve typings of object keys\n           *\n           * @param obj Object\n           */\n        export function keys<O extends object>(obj: O): (keyof O)[];\n    }\n    \n    module 'test/' {\n        import { P2PCommunicationClient } from 'test/transports/clients/P2PCommunicationClient';\n        import { AppMetadata } from 'test/types/beacon/AppMetadata';\n        import { PermissionRequest } from 'test/types/beacon/messages/PermissionRequest';\n        import { Network } from 'test/types/beacon/Network';\n        import { BeaconBaseMessage } from 'test/types/beacon/BeaconBaseMessage';\n        import { BeaconMessageType } from 'test/types/beacon/BeaconMessageType';\n        import { PermissionScope } from 'test/types/beacon/PermissionScope';\n        import { PermissionResponse } from 'test/types/beacon/messages/PermissionResponse';\n        import { OperationRequest } from 'test/types/beacon/messages/OperationRequest';\n        import { OperationResponse } from 'test/types/beacon/messages/OperationResponse';\n        import { SignPayloadRequest } from 'test/types/beacon/messages/SignPayloadRequest';\n        import { SignPayloadResponse } from 'test/types/beacon/messages/SignPayloadResponse';\n        import { BroadcastRequest } from 'test/types/beacon/messages/BroadcastRequest';\n        import { BroadcastResponse } from 'test/types/beacon/messages/BroadcastResponse';\n        import { NetworkType } from 'test/types/beacon/NetworkType';\n        import { TezosBaseOperation } from 'test/types/tezos/TezosBaseOperation';\n        import { TezosOperationType } from 'test/types/tezos/OperationTypes';\n        import { TezosActivateAccountOperation } from 'test/types/tezos/operations/ActivateAccount';\n        import { TezosBallotOperation } from 'test/types/tezos/operations/Ballot';\n        import { TezosDelegationOperation } from 'test/types/tezos/operations/Delegation';\n        import { TezosDoubleBakingEvidenceOperation } from 'test/types/tezos/operations/DoubleBakingEvidence';\n        import { TezosBlockHeader } from 'test/types/tezos/TezosBlockHeader';\n        import { TezosDoubleEndorsementEvidenceOperation } from 'test/types/tezos/operations/DoubleEndorsementEvidence';\n        import { TezosEndorsementOperation } from 'test/types/tezos/operations/Endorsement';\n        import { TezosOriginationOperation } from 'test/types/tezos/operations/Origination';\n        import { TezosProposalOperation } from 'test/types/tezos/operations/Proposal';\n        import { TezosRevealOperation } from 'test/types/tezos/operations/Reveal';\n        import { TezosSeedNonceRevelationOperation } from 'test/types/tezos/operations/SeedNonceRevelation';\n        import { TezosTransactionOperation } from 'test/types/tezos/operations/Transaction';\n        import { MichelsonPrimitives } from 'test/types/tezos/MichelsonPrimitives';\n        import { TezosTransactionParameters } from 'test/types/tezos/TezosTransactionParameters';\n        import { Origin } from 'test/types/Origin';\n        import { AccountInfo, AccountIdentifier } from 'test/types/AccountInfo';\n        import { EncryptedExtensionMessage, ExtensionMessage } from 'test/types/ExtensionMessage';\n        import { ExtensionMessageTarget } from 'test/types/ExtensionMessageTarget';\n        import { TezosOperation } from 'test/types/tezos/TezosOperation';\n        import { Client } from 'test/clients/client/Client';\n        import { WalletClient } from 'test/clients/wallet-client/WalletClient';\n        import { DAppClient } from 'test/clients/dapp-client/DAppClient';\n        import { BeaconError } from 'test/errors/BeaconError';\n        import { BeaconErrorType } from 'test/types/BeaconErrorType';\n        import { BroadcastBeaconError } from 'test/errors/BroadcastBeaconError';\n        import { NetworkNotSupportedBeaconError } from 'test/errors/NetworkNotSupportedBeaconError';\n        import { NoAddressBeaconError } from 'test/errors/NoAddressBeaconError';\n        import { NoPrivateKeyBeaconError } from 'test/errors/NoPrivateKeyBeaconError';\n        import { NotGrantedBeaconError } from 'test/errors/NotGrantedBeaconError';\n        import { ParametersInvalidBeaconError } from 'test/errors/ParametersInvalidBeaconError';\n        import { TooManyOperationsBeaconError } from 'test/errors/TooManyOperationsBeaconError';\n        import { TransactionInvalidBeaconError } from 'test/errors/TransactionInvalidBeaconError';\n        import { UnknownBeaconError } from 'test/errors/UnknownBeaconError';\n        import { ErrorResponse } from 'test/types/beacon/messages/ErrorResponse';\n        import { TransportStatus } from 'test/types/transport/TransportStatus';\n        import { TransportType } from 'test/types/transport/TransportType';\n        import { PostMessageTransport } from 'test/transports/PostMessageTransport';\n        import { Transport } from 'test/transports/Transport';\n        import { P2PTransport } from 'test/transports/P2PTransport';\n        import { Storage } from 'test/storage/Storage';\n        import { StorageKey } from 'test/types/storage/StorageKey';\n        import { StorageKeyReturnDefaults } from 'test/types/storage/StorageKeyReturnDefaults';\n        import { StorageKeyReturnType } from 'test/types/storage/StorageKeyReturnType';\n        import { ExtendedP2PPairingRequest, P2PPairingRequest } from 'test/types/P2PPairingRequest';\n        import { ChromeStorage } from 'test/storage/ChromeStorage';\n        import { LocalStorage } from 'test/storage/LocalStorage';\n        import { getStorage } from 'test/storage/getStorage';\n        import { BeaconMessage } from 'test/types/beacon/BeaconMessage';\n        import { Serializer } from 'test/Serializer';\n        import { RequestPermissionInput } from 'test/types/RequestPermissionInput';\n        import { RequestSignPayloadInput } from 'test/types/RequestSignPayloadInput';\n        import { RequestOperationInput } from 'test/types/RequestOperationInput';\n        import { RequestBroadcastInput } from 'test/types/RequestBroadcastInput';\n        import { PermissionResponseInput, SignPayloadResponseInput, OperationResponseInput, BroadcastResponseInput, BeaconResponseInputMessage, AcknowledgeResponseInput, ErrorResponseInput } from 'test/types/beacon/messages/BeaconResponseInputMessage';\n        import { PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, BeaconResponseOutputMessage } from 'test/types/beacon/messages/BeaconResponseOutputMessage';\n        import { PermissionRequestInput, SignPayloadRequestInput, OperationRequestInput, BroadcastRequestInput, BeaconRequestInputMessage } from 'test/types/beacon/messages/BeaconRequestInputMessage';\n        import { PermissionRequestOutput, SignPayloadRequestOutput, OperationRequestOutput, BroadcastRequestOutput, BeaconRequestOutputMessage } from 'test/types/beacon/messages/BeaconRequestOutputMessage';\n        import { ClientOptions } from 'test/clients/client/ClientOptions';\n        import { DAppClientOptions } from 'test/clients/dapp-client/DAppClientOptions';\n        import { WalletClientOptions } from 'test/clients/wallet-client/WalletClientOptions';\n        import { PermissionInfo } from 'test/types/PermissionInfo';\n        import { SDK_VERSION, BEACON_VERSION } from 'test/constants';\n        import { AccountManager } from 'test/managers/AccountManager';\n        import { AppMetadataManager } from 'test/managers/AppMetadataManager';\n        import { PermissionManager } from 'test/managers/PermissionManager';\n        import { BeaconEvent, BeaconEventHandler, defaultEventCallbacks } from 'test/events';\n        import { getAddressFromPublicKey } from 'test/utils/crypto';\n        import { BeaconClient } from 'test/clients/beacon-client/BeaconClient';\n        import { BeaconClientOptions } from 'test/clients/beacon-client/BeaconClientOptions';\n        import { getAccountIdentifier } from 'test/utils/get-account-identifier';\n        import { ConnectionContext } from 'test/types/ConnectionContext';\n        import { Threshold } from 'test/types/beacon/Threshold';\n        import { PartialTezosTransactionOperation, PartialTezosOperation, PartialTezosDelegationOperation, PartialTezosOriginationOperation, PartialTezosRevealOperation } from 'test/types/tezos/PartialTezosOperation';\n        import { AbortedBeaconError } from 'test/errors/AbortedBeaconError';\n        import { ExtendedPeerInfo, PeerInfo } from 'test/types/PeerInfo';\n        import { availableTransports } from 'test/utils/available-transports';\n        import { AcknowledgeResponse } from 'test/types/beacon/messages/AcknowledgeResponse';\n        import { DisconnectMessage } from 'test/types/beacon/messages/DisconnectMessage';\n        import { DappP2PTransport } from 'test/transports/DappP2PTransport';\n        import { DappPostMessageTransport } from 'test/transports/DappPostMessageTransport';\n        import { WalletP2PTransport } from 'test/transports/WalletP2PTransport';\n        import { WalletPostMessageTransport } from 'test/transports/WalletPostMessageTransport';\n        import { getSenderId } from 'test/utils/get-sender-id';\n        import { SigningType } from 'test/types/beacon/SigningType';\n        import { SignatureTypeNotSupportedBeaconError } from 'test/errors/SignatureTypeNotSupportedBeaconError';\n        import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n        import { ExtendedPostMessagePairingRequest, PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n        import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n        import { PeerManager } from 'test/managers/PeerManager';\n        import { MessageBasedClient } from 'test/transports/clients/MessageBasedClient';\n        import { BeaconRequestMessage } from 'test/types/beacon/BeaconRequestMessage';\n        import { BeaconResponseMessage } from 'test/types/beacon/BeaconResponseMessage';\n        import { Pairing } from 'test/ui/alert/Pairing';\n        import { BlockExplorer } from 'test/utils/block-explorer';\n        import { TezblockBlockExplorer } from 'test/utils/tezblock-blockexplorer';\n        import { setDebugEnabled, getDebugEnabled } from 'test/debug';\n        import { ColorMode } from 'test/types/ColorMode';\n        export { TezosBaseOperation, TezosOperationType, TezosBlockHeader, MichelsonPrimitives, TezosTransactionParameters, TezosOperation };\n        export { TezosActivateAccountOperation, TezosBallotOperation, TezosDelegationOperation, TezosDoubleBakingEvidenceOperation, TezosDoubleEndorsementEvidenceOperation, TezosEndorsementOperation, TezosOriginationOperation, TezosProposalOperation, TezosRevealOperation, TezosSeedNonceRevelationOperation, TezosTransactionOperation, PartialTezosOperation, PartialTezosTransactionOperation, PartialTezosDelegationOperation, PartialTezosOriginationOperation, PartialTezosRevealOperation };\n        export { BeaconClient, BeaconClientOptions, Client, ClientOptions, DAppClient, DAppClientOptions, WalletClient, WalletClientOptions, P2PCommunicationClient };\n        export { AccountIdentifier, AppMetadata, Network, NetworkType, BeaconMessage, PermissionRequest, PermissionResponse, OperationRequest, OperationResponse, SignPayloadRequest, SignPayloadResponse, BroadcastRequest, BroadcastResponse, AcknowledgeResponse, DisconnectMessage, BeaconBaseMessage, BeaconMessageType, PermissionScope, Origin, AccountInfo, Threshold, SigningType, ExtensionMessageTarget, ExtensionMessage, EncryptedExtensionMessage, RequestPermissionInput, RequestSignPayloadInput, RequestOperationInput, RequestBroadcastInput, PermissionInfo };\n        export { PermissionResponseInput, SignPayloadResponseInput, OperationResponseInput, BroadcastResponseInput, AcknowledgeResponseInput, ErrorResponseInput, PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, PermissionRequestInput, SignPayloadRequestInput, OperationRequestInput, BroadcastRequestInput, PermissionRequestOutput, SignPayloadRequestOutput, OperationRequestOutput, BroadcastRequestOutput, BeaconRequestInputMessage, BeaconRequestOutputMessage, BeaconResponseInputMessage, BeaconResponseOutputMessage, BeaconRequestMessage, BeaconResponseMessage };\n        export { BeaconError, BeaconErrorType, ErrorResponse, AbortedBeaconError, BroadcastBeaconError, NetworkNotSupportedBeaconError, NoAddressBeaconError, NoPrivateKeyBeaconError, NotGrantedBeaconError, ParametersInvalidBeaconError, TooManyOperationsBeaconError, TransactionInvalidBeaconError, SignatureTypeNotSupportedBeaconError, UnknownBeaconError };\n        export { TransportStatus, TransportType, Transport, PostMessageTransport, P2PTransport, WalletP2PTransport, WalletPostMessageTransport, DappP2PTransport, DappPostMessageTransport, MessageBasedClient, Pairing };\n        export { BeaconEvent, BeaconEventHandler, defaultEventCallbacks };\n        export { Storage, StorageKey, StorageKeyReturnDefaults, StorageKeyReturnType, ChromeStorage, LocalStorage, getStorage };\n        export { PeerManager, AccountManager, AppMetadataManager, PermissionManager };\n        export { SDK_VERSION, BEACON_VERSION };\n        export { getSenderId, getAccountIdentifier, getAddressFromPublicKey };\n        export { PeerInfo, ExtendedPeerInfo, PostMessagePairingRequest, ExtendedPostMessagePairingRequest, ExtendedPostMessagePairingResponse, P2PPairingRequest, ExtendedP2PPairingRequest, ExtendedP2PPairingResponse };\n        export { BlockExplorer, TezblockBlockExplorer };\n        export { ConnectionContext, Serializer, availableTransports, ColorMode };\n        export { setDebugEnabled, getDebugEnabled };\n    }\n}\n\ndeclare module 'beacon/transports/clients/CommunicationClient' {\n    import * as sodium from 'libsodium-wrappers';\n    import { P2PPairingRequest } from 'beacon/';\n    import { ExtendedP2PPairingResponse } from 'beacon/types/P2PPairingResponse';\n    import { PostMessagePairingRequest } from 'beacon/types/PostMessagePairingRequest';\n    import { ExtendedPostMessagePairingResponse } from 'beacon/types/PostMessagePairingResponse';\n    export abstract class CommunicationClient {\n        protected readonly keyPair: sodium.KeyPair;\n        constructor(keyPair: sodium.KeyPair);\n        /**\n          * Get the public key\n          */\n        getPublicKey(): Promise<string>;\n        /**\n          * get the public key hash\n          */\n        getPublicKeyHash(): Promise<string>;\n        /**\n          * Create a cryptobox shared key\n          *\n          * @param otherPublicKey\n          * @param selfPrivateKey\n          */\n        protected createCryptoBox(otherPublicKey: string, selfPrivateKey: Uint8Array): Promise<[Uint8Array, Uint8Array, Uint8Array]>;\n        /**\n          * Create a cryptobox server\n          *\n          * @param otherPublicKey\n          * @param selfPrivateKey\n          */\n        protected createCryptoBoxServer(otherPublicKey: string, selfPrivateKey: Uint8Array): Promise<sodium.CryptoKX>;\n        /**\n          * Create a cryptobox client\n          *\n          * @param otherPublicKey\n          * @param selfPrivateKey\n          */\n        protected createCryptoBoxClient(otherPublicKey: string, selfPrivateKey: Uint8Array): Promise<sodium.CryptoKX>;\n        /**\n          * Encrypt a message for a specific publicKey (receiver, asymmetric)\n          *\n          * @param recipientPublicKey\n          * @param message\n          */\n        protected encryptMessageAsymmetric(recipientPublicKey: string, message: string): Promise<string>;\n        abstract unsubscribeFromEncryptedMessages(): Promise<void>;\n        abstract unsubscribeFromEncryptedMessage(senderPublicKey: string): Promise<void>;\n        abstract sendMessage(message: string, peer?: P2PPairingRequest | ExtendedP2PPairingResponse | PostMessagePairingRequest | ExtendedPostMessagePairingResponse): Promise<void>;\n    }\n}\n\ndeclare module 'beacon/transports/clients/MessageBasedClient' {\n    import * as sodium from 'libsodium-wrappers';\n    import { PostMessagePairingRequest } from 'beacon/types/PostMessagePairingRequest';\n    import { PostMessagePairingResponse } from 'beacon/types/PostMessagePairingResponse';\n    import { CommunicationClient } from 'beacon/transports/clients/CommunicationClient';\n    export abstract class MessageBasedClient extends CommunicationClient {\n        protected readonly name: string;\n        /**\n          * The listeners that will be notified of new messages\n          */\n        protected abstract readonly activeListeners: Map<string, unknown>;\n        constructor(name: string, keyPair: sodium.KeyPair);\n        /**\n          * start the client and make sure all dependencies are ready\n          */\n        start(): Promise<void>;\n        /**\n          * Get the pairing request information. This will be shared with the peer during the connection setup\n          */\n        getPairingRequestInfo(): Promise<PostMessagePairingRequest>;\n        /**\n          * Get the pairing response information. This will be shared with the peer during the connection setup\n          */\n        getPairingResponseInfo(request: PostMessagePairingRequest): Promise<PostMessagePairingResponse>;\n        /**\n          * Unsubscribe from encrypted messages from a specific peer\n          *\n          * @param senderPublicKey\n          */\n        unsubscribeFromEncryptedMessage(senderPublicKey: string): Promise<void>;\n        /**\n          * Unsubscribe from all encrypted messages\n          */\n        unsubscribeFromEncryptedMessages(): Promise<void>;\n        /**\n          * Decrypt a message from a specific peer\n          *\n          * @param senderPublicKey\n          * @param payload\n          */\n        protected decryptMessage(senderPublicKey: string, payload: string): Promise<string>;\n        /**\n          * Encrypt a message for a specific publicKey (receiver)\n          *\n          * @param recipientPublicKey\n          * @param message\n          */\n        protected encryptMessage(recipientPublicKey: string, message: string): Promise<string>;\n        /**\n          * Initialize the connection\n          */\n        abstract init(): Promise<void>;\n    }\n}\n\ndeclare module 'beacon/transports/clients/P2PCommunicationClient' {\n    import * as sodium from 'libsodium-wrappers';\n    import { MatrixClientEvent, MatrixClientEventType, MatrixClientEventMessageContent } from 'beacon/matrix-client/models/MatrixClientEvent';\n    import { Storage } from 'beacon/storage/Storage';\n    import { P2PPairingRequest } from 'beacon/';\n    import { ExtendedP2PPairingResponse, P2PPairingResponse } from 'beacon/types/P2PPairingResponse';\n    import { CommunicationClient } from 'beacon/transports/clients/CommunicationClient';\n    export class P2PCommunicationClient extends CommunicationClient {\n        readonly replicationCount: number;\n        constructor(name: string, keyPair: sodium.KeyPair, replicationCount: number, storage: Storage, matrixNodes: string[], iconUrl?: string | undefined, appUrl?: string | undefined);\n        getPairingRequestInfo(): Promise<P2PPairingRequest>;\n        getPairingResponseInfo(request: P2PPairingRequest): Promise<P2PPairingResponse>;\n        getRelayServer(publicKeyHash?: string, nonce?: string): Promise<string>;\n        start(): Promise<void>;\n        listenForEncryptedMessage(senderPublicKey: string, messageCallback: (message: string) => void): Promise<void>;\n        unsubscribeFromEncryptedMessage(senderPublicKey: string): Promise<void>;\n        unsubscribeFromEncryptedMessages(): Promise<void>;\n        sendMessage(message: string, peer: P2PPairingRequest | ExtendedP2PPairingResponse): Promise<void>;\n        deleteRoomIdFromRooms(roomId: string): Promise<void>;\n        listenForChannelOpening(messageCallback: (pairingResponse: ExtendedP2PPairingResponse) => void): Promise<void>;\n        sendPairingResponse(pairingRequest: P2PPairingRequest): Promise<void>;\n        isTextMessage(content: MatrixClientEventMessageContent<any>): content is MatrixClientEventMessageContent<string>;\n        isChannelOpenMessage(content: MatrixClientEventMessageContent<string>): Promise<boolean>;\n        isSender(event: MatrixClientEvent<MatrixClientEventType.MESSAGE>, senderPublicKey: string): Promise<boolean>;\n    }\n}\n\ndeclare module 'beacon/transports/clients/PostMessageClient' {\n    import { ConnectionContext } from 'beacon/';\n    import { ExtendedPostMessagePairingResponse } from 'beacon/types/PostMessagePairingResponse';\n    import { EncryptedExtensionMessage } from 'beacon/types/ExtensionMessage';\n    import { PostMessagePairingRequest } from 'beacon/types/PostMessagePairingRequest';\n    import { MessageBasedClient } from 'beacon/transports/clients/MessageBasedClient';\n    export class PostMessageClient extends MessageBasedClient {\n        protected readonly activeListeners: Map<string, (message: EncryptedExtensionMessage, context: ConnectionContext) => void>;\n        init(): Promise<void>;\n        listenForEncryptedMessage(senderPublicKey: string, messageCallback: (message: string, context: ConnectionContext) => void): Promise<void>;\n        sendMessage(message: string, peer: PostMessagePairingRequest | ExtendedPostMessagePairingResponse): Promise<void>;\n        listenForChannelOpening(messageCallback: (pairingResponse: ExtendedPostMessagePairingResponse) => void): Promise<void>;\n        sendPairingRequest(id: string): Promise<void>;\n        isChannelOpenMessage(message: any): Promise<boolean>;\n    }\n}\n\ndeclare module 'beacon/transports/DappP2PTransport' {\n    import * as sodium from 'libsodium-wrappers';\n    import { Storage, StorageKey, P2PTransport } from 'beacon/';\n    import { ExtendedP2PPairingResponse } from 'beacon/types/P2PPairingResponse';\n    export class DappP2PTransport extends P2PTransport<ExtendedP2PPairingResponse, StorageKey.TRANSPORT_P2P_PEERS_DAPP> {\n        constructor(name: string, keyPair: sodium.KeyPair, storage: Storage, matrixNodes: string[], iconUrl?: string, appUrl?: string);\n        startOpenChannelListener(): Promise<void>;\n        listenForNewPeer(newPeerListener: (peer: ExtendedP2PPairingResponse) => void): Promise<void>;\n        stopListeningForNewPeers(): Promise<void>;\n    }\n}\n\ndeclare module 'beacon/transports/DappPostMessageTransport' {\n    import * as sodium from 'libsodium-wrappers';\n    import { StorageKey, PostMessageTransport, Storage } from 'beacon/';\n    import { ExtendedPostMessagePairingResponse } from 'beacon/types/PostMessagePairingResponse';\n    export class DappPostMessageTransport extends PostMessageTransport<ExtendedPostMessagePairingResponse, StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP> {\n        constructor(name: string, keyPair: sodium.KeyPair, storage: Storage);\n        startOpenChannelListener(): Promise<void>;\n        listenForNewPeer(newPeerListener: (peer: ExtendedPostMessagePairingResponse) => void): Promise<void>;\n        stopListeningForNewPeers(): Promise<void>;\n    }\n}\n\ndeclare module 'beacon/transports/P2PTransport' {\n    import * as sodium from 'libsodium-wrappers';\n    import { Storage, StorageKey, Transport, TransportType, P2PCommunicationClient, P2PPairingRequest } from 'beacon/';\n    import { ExtendedP2PPairingResponse } from 'beacon/types/P2PPairingResponse';\n    export class P2PTransport<T extends P2PPairingRequest | ExtendedP2PPairingResponse, K extends StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET> extends Transport<T, K, P2PCommunicationClient> {\n        readonly type: TransportType;\n        constructor(name: string, keyPair: sodium.KeyPair, storage: Storage, matrixNodes: string[], storageKey: K, iconUrl?: string, appUrl?: string);\n        static isAvailable(): Promise<boolean>;\n        connect(): Promise<void>;\n        startOpenChannelListener(): Promise<void>;\n        getPairingRequestInfo(): Promise<P2PPairingRequest>;\n        listen(publicKey: string): Promise<void>;\n    }\n}\n\ndeclare module 'beacon/transports/PostMessageTransport' {\n    import * as sodium from 'libsodium-wrappers';\n    import { PostMessagePairingRequest } from 'beacon/types/PostMessagePairingRequest';\n    import { ExtendedPostMessagePairingResponse } from 'beacon/types/PostMessagePairingResponse';\n    import { Extension } from 'beacon/types/Extension';\n    import { StorageKey } from 'beacon/types/storage/StorageKey';\n    import { TransportType } from 'beacon/types/transport/TransportType';\n    import { Storage } from 'beacon/storage/Storage';\n    import { PostMessageClient } from 'beacon/transports/clients/PostMessageClient';\n    import { Transport } from 'beacon/transports/Transport';\n    export class PostMessageTransport<T extends PostMessagePairingRequest | ExtendedPostMessagePairingResponse, K extends StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET> extends Transport<T, K, PostMessageClient> {\n        readonly type: TransportType;\n        constructor(name: string, keyPair: sodium.KeyPair, storage: Storage, storageKey: K);\n        static isAvailable(): Promise<boolean>;\n        static getAvailableExtensions(): Promise<Extension[]>;\n        connect(): Promise<void>;\n        startOpenChannelListener(): Promise<void>;\n        getPairingRequestInfo(): Promise<PostMessagePairingRequest>;\n        listen(publicKey: string): Promise<void>;\n    }\n}\n\ndeclare module 'beacon/transports/Transport' {\n    import { ConnectionContext } from 'beacon/types/ConnectionContext';\n    import { TransportType, TransportStatus, PeerInfo, StorageKey } from 'beacon/';\n    import { PeerManager } from 'beacon/managers/PeerManager';\n    import { CommunicationClient } from 'beacon/transports/clients/CommunicationClient';\n    export abstract class Transport<T extends PeerInfo = PeerInfo, K extends StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET = any, S extends CommunicationClient = any> {\n        /**\n          * The type of the transport\n          */\n        readonly type: TransportType;\n        /**\n          * The name of the app\n          */\n        protected readonly name: string;\n        /**\n          * The status of the transport\n          */\n        protected _isConnected: TransportStatus;\n        protected readonly peerManager: PeerManager<K>;\n        /**\n          * The client handling the encryption/decryption of messages\n          */\n        protected client: S;\n        /**\n          * The listener that will be invoked when a new peer is connected\n          */\n        protected newPeerListener?: (peer: T) => void;\n        /**\n          * Return the status of the connection\n          */\n        get connectionStatus(): TransportStatus;\n        constructor(name: string, client: S, peerManager: PeerManager<K>);\n        /**\n          * Returns a promise that resolves to true if the transport is available, false if it is not\n          */\n        static isAvailable(): Promise<boolean>;\n        /**\n          * Connect the transport\n          */\n        connect(): Promise<void>;\n        /**\n          * Send a message through the transport\n          *\n          * @param message The message to send\n          * @param recipient The recipient of the message\n          */\n        send(message: string, peer?: PeerInfo): Promise<void>;\n        /**\n          * Add a listener to be called when a new message is received\n          *\n          * @param listener The listener that will be registered\n          */\n        addListener(listener: (message: unknown, connectionInfo: ConnectionContext) => void): Promise<void>;\n        /**\n          * Remove a listener\n          *\n          * @param listener\n          */\n        removeListener(listener: (message: string, connectionInfo: ConnectionContext) => void): Promise<void>;\n        getPeers(): Promise<T[]>;\n        addPeer(newPeer: T): Promise<void>;\n        removePeer(peerToBeRemoved: T): Promise<void>;\n        removeAllPeers(): Promise<void>;\n        /**\n          * Notify the listeners when a new message comes in\n          *\n          * @param message Message\n          * @param connectionInfo Context info about the connection\n          */\n        protected notifyListeners(message: unknown, connectionInfo: ConnectionContext): Promise<void>;\n        abstract listen(publicKey: string): Promise<void>;\n    }\n}\n\ndeclare module 'beacon/transports/WalletP2PTransport' {\n    import * as sodium from 'libsodium-wrappers';\n    import { Storage, StorageKey, P2PTransport, P2PPairingRequest } from 'beacon/';\n    export class WalletP2PTransport extends P2PTransport<P2PPairingRequest, StorageKey.TRANSPORT_P2P_PEERS_WALLET> {\n        constructor(name: string, keyPair: sodium.KeyPair, storage: Storage, matrixNodes: string[], iconUrl?: string, appUrl?: string);\n        addPeer(newPeer: P2PPairingRequest): Promise<void>;\n    }\n}\n\ndeclare module 'beacon/transports/WalletPostMessageTransport' {\n    import * as sodium from 'libsodium-wrappers';\n    import { StorageKey, PostMessageTransport, Storage } from 'beacon/';\n    import { PostMessagePairingRequest } from 'beacon/types/PostMessagePairingRequest';\n    export class WalletPostMessageTransport extends PostMessageTransport<PostMessagePairingRequest, StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET> {\n        constructor(name: string, keyPair: sodium.KeyPair, storage: Storage);\n    }\n}\n\ndeclare module 'beacon/types/AccountInfo' {\n    import { Origin } from 'beacon/';\n    import { PermissionEntity } from 'beacon/types/PermissionEntity';\n    export type AccountIdentifier = string;\n    export interface AccountInfo extends PermissionEntity {\n        accountIdentifier: AccountIdentifier;\n        senderId: string;\n        origin: {\n            type: Origin;\n            id: string;\n        };\n        publicKey: string;\n        connectedAt: number;\n    }\n}\n\ndeclare module 'beacon/types/beacon/AppMetadata' {\n    export interface AppMetadata {\n        senderId: string;\n        name: string;\n        icon?: string;\n    }\n}\n\ndeclare module 'beacon/types/beacon/BeaconBaseMessage' {\n    import { BeaconMessageType } from 'beacon/';\n    export interface BeaconBaseMessage {\n        type: BeaconMessageType;\n        version: string;\n        id: string;\n        senderId: string;\n    }\n}\n\ndeclare module 'beacon/types/beacon/BeaconMessage' {\n    import { PermissionResponse, PermissionRequest, OperationRequest, OperationResponse, SignPayloadRequest, SignPayloadResponse, BroadcastRequest, BroadcastResponse, AcknowledgeResponse, DisconnectMessage, ErrorResponse } from 'beacon/';\n    export type BeaconMessage = PermissionRequest | PermissionResponse | OperationRequest | OperationResponse | SignPayloadRequest | SignPayloadResponse | BroadcastRequest | BroadcastResponse | AcknowledgeResponse | DisconnectMessage | ErrorResponse;\n}\n\ndeclare module 'beacon/types/beacon/BeaconMessageType' {\n    export enum BeaconMessageType {\n        PermissionRequest = \"permission_request\",\n        SignPayloadRequest = \"sign_payload_request\",\n        OperationRequest = \"operation_request\",\n        BroadcastRequest = \"broadcast_request\",\n        PermissionResponse = \"permission_response\",\n        SignPayloadResponse = \"sign_payload_response\",\n        OperationResponse = \"operation_response\",\n        BroadcastResponse = \"broadcast_response\",\n        Acknowledge = \"acknowledge\",\n        Disconnect = \"disconnect\",\n        Error = \"error\"\n    }\n}\n\ndeclare module 'beacon/types/beacon/BeaconRequestMessage' {\n    import { PermissionRequest, OperationRequest, SignPayloadRequest, BroadcastRequest } from 'beacon/';\n    export type BeaconRequestMessage = PermissionRequest | OperationRequest | SignPayloadRequest | BroadcastRequest;\n}\n\ndeclare module 'beacon/types/beacon/BeaconResponseMessage' {\n    import { PermissionResponse, OperationResponse, SignPayloadResponse, BroadcastResponse } from 'beacon/';\n    import { ErrorResponse } from 'beacon/types/beacon/messages/ErrorResponse';\n    export type BeaconResponseMessage = PermissionResponse | OperationResponse | SignPayloadResponse | BroadcastResponse | ErrorResponse;\n}\n\ndeclare module 'beacon/types/beacon/messages/AcknowledgeResponse' {\n    import { BeaconBaseMessage, BeaconMessageType } from 'beacon/';\n    export interface AcknowledgeResponse extends BeaconBaseMessage {\n        type: BeaconMessageType.Acknowledge;\n    }\n}\n\ndeclare module 'beacon/types/beacon/messages/BeaconRequestInputMessage' {\n    import { PermissionRequest, OperationRequest, SignPayloadRequest, BroadcastRequest } from 'beacon/';\n    export type IgnoredRequestInputProperties = 'id' | 'senderId' | 'version';\n    export type PermissionRequestInput = Omit<PermissionRequest, IgnoredRequestInputProperties>;\n    export type OperationRequestInput = Omit<OperationRequest, IgnoredRequestInputProperties>;\n    export type SignPayloadRequestInput = Omit<SignPayloadRequest, IgnoredRequestInputProperties>;\n    export type BroadcastRequestInput = Omit<BroadcastRequest, IgnoredRequestInputProperties>;\n    export type BeaconRequestInputMessage = PermissionRequestInput | OperationRequestInput | SignPayloadRequestInput | BroadcastRequestInput;\n}\n\ndeclare module 'beacon/types/beacon/messages/BeaconRequestOutputMessage' {\n    import { AppMetadata, PermissionRequest, OperationRequest, SignPayloadRequest, BroadcastRequest } from 'beacon/';\n    export type IgnoredRequestOutputProperties = 'version';\n    export interface ExtraResponseOutputProperties {\n        appMetadata: AppMetadata;\n    }\n    export type PermissionRequestOutput = Omit<PermissionRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n    export type OperationRequestOutput = Omit<OperationRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n    export type SignPayloadRequestOutput = Omit<SignPayloadRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n    export type BroadcastRequestOutput = Omit<BroadcastRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n    export type BeaconRequestOutputMessage = PermissionRequestOutput | OperationRequestOutput | SignPayloadRequestOutput | BroadcastRequestOutput;\n}\n\ndeclare module 'beacon/types/beacon/messages/BeaconResponseInputMessage' {\n    import { PermissionResponse, OperationResponse, SignPayloadResponse, BroadcastResponse, AcknowledgeResponse, ErrorResponse } from 'beacon/';\n    export type IgnoredResponseInputProperties = 'senderId' | 'version' | 'appMetadata';\n    export type PermissionResponseInput = Omit<PermissionResponse, IgnoredResponseInputProperties>;\n    export type OperationResponseInput = Omit<OperationResponse, IgnoredResponseInputProperties>;\n    export type SignPayloadResponseInput = Omit<SignPayloadResponse, IgnoredResponseInputProperties>;\n    export type BroadcastResponseInput = Omit<BroadcastResponse, IgnoredResponseInputProperties>;\n    export type AcknowledgeResponseInput = Omit<AcknowledgeResponse, IgnoredResponseInputProperties>;\n    export type ErrorResponseInput = Omit<ErrorResponse, IgnoredResponseInputProperties>;\n    export type BeaconResponseInputMessage = PermissionResponseInput | OperationResponseInput | SignPayloadResponseInput | BroadcastResponseInput | AcknowledgeResponseInput | ErrorResponseInput;\n}\n\ndeclare module 'beacon/types/beacon/messages/BeaconResponseOutputMessage' {\n    import { PermissionResponse, OperationResponse, SignPayloadResponse, BroadcastResponse, AccountInfo } from 'beacon/';\n    export type IgnoredResponseOutputProperties = 'id' | 'version' | 'type';\n    export type PermissionResponseOutput = PermissionResponse & {\n        address: string;\n        accountInfo: AccountInfo;\n    };\n    export type OperationResponseOutput = OperationResponse;\n    export type SignPayloadResponseOutput = SignPayloadResponse;\n    export type BroadcastResponseOutput = BroadcastResponse;\n    export type BeaconResponseOutputMessage = PermissionResponseOutput | OperationResponseOutput | SignPayloadResponseOutput | BroadcastResponseOutput;\n}\n\ndeclare module 'beacon/types/beacon/messages/BroadcastRequest' {\n    import { BeaconBaseMessage, BeaconMessageType, Network } from 'beacon/';\n    export interface BroadcastRequest extends BeaconBaseMessage {\n        type: BeaconMessageType.BroadcastRequest;\n        network: Network;\n        signedTransaction: string;\n    }\n}\n\ndeclare module 'beacon/types/beacon/messages/BroadcastResponse' {\n    import { BeaconBaseMessage, BeaconMessageType } from 'beacon/';\n    export interface BroadcastResponse extends BeaconBaseMessage {\n        type: BeaconMessageType.BroadcastResponse;\n        transactionHash: string;\n    }\n}\n\ndeclare module 'beacon/types/beacon/messages/DisconnectMessage' {\n    import { BeaconBaseMessage, BeaconMessageType } from 'beacon/';\n    export interface DisconnectMessage extends BeaconBaseMessage {\n        type: BeaconMessageType.Disconnect;\n    }\n}\n\ndeclare module 'beacon/types/beacon/messages/ErrorResponse' {\n    import { BeaconBaseMessage, BeaconErrorType, BeaconMessageType } from 'beacon/';\n    export interface ErrorResponse extends BeaconBaseMessage {\n        type: BeaconMessageType.Error;\n        errorType: BeaconErrorType;\n        errorData?: any;\n    }\n}\n\ndeclare module 'beacon/types/beacon/messages/OperationRequest' {\n    import { BeaconBaseMessage, BeaconMessageType, Network } from 'beacon/';\n    import { PartialTezosOperation } from 'beacon/types/tezos/PartialTezosOperation';\n    export interface OperationRequest extends BeaconBaseMessage {\n        type: BeaconMessageType.OperationRequest;\n        network: Network;\n        operationDetails: PartialTezosOperation[];\n        sourceAddress: string;\n    }\n}\n\ndeclare module 'beacon/types/beacon/messages/OperationResponse' {\n    import { BeaconBaseMessage, BeaconMessageType } from 'beacon/';\n    export interface OperationResponse extends BeaconBaseMessage {\n        type: BeaconMessageType.OperationResponse;\n        transactionHash: string;\n    }\n}\n\ndeclare module 'beacon/types/beacon/messages/PermissionRequest' {\n    import { BeaconBaseMessage, BeaconMessageType, PermissionScope, AppMetadata, Network } from 'beacon/';\n    export interface PermissionRequest extends BeaconBaseMessage {\n        type: BeaconMessageType.PermissionRequest;\n        appMetadata: AppMetadata;\n        network: Network;\n        scopes: PermissionScope[];\n    }\n}\n\ndeclare module 'beacon/types/beacon/messages/PermissionResponse' {\n    import { AppMetadata, BeaconBaseMessage, BeaconMessageType, Network, PermissionScope, Threshold } from 'beacon/';\n    export interface PermissionResponse extends BeaconBaseMessage {\n        type: BeaconMessageType.PermissionResponse;\n        appMetadata: AppMetadata;\n        publicKey: string;\n        network: Network;\n        scopes: PermissionScope[];\n        threshold?: Threshold;\n    }\n}\n\ndeclare module 'beacon/types/beacon/messages/SignPayloadRequest' {\n    import { BeaconBaseMessage, BeaconMessageType, SigningType } from 'beacon/';\n    export interface SignPayloadRequest extends BeaconBaseMessage {\n        type: BeaconMessageType.SignPayloadRequest;\n        signingType: SigningType;\n        payload: string;\n        sourceAddress: string;\n    }\n}\n\ndeclare module 'beacon/types/beacon/messages/SignPayloadResponse' {\n    import { BeaconBaseMessage, BeaconMessageType, SigningType } from 'beacon/';\n    export interface SignPayloadResponse extends BeaconBaseMessage {\n        type: BeaconMessageType.SignPayloadResponse;\n        signingType: SigningType;\n        signature: string;\n    }\n}\n\ndeclare module 'beacon/types/beacon/Network' {\n    import { NetworkType } from 'beacon/';\n    export interface Network {\n        type: NetworkType;\n        name?: string;\n        rpcUrl?: string;\n    }\n}\n\ndeclare module 'beacon/types/beacon/NetworkType' {\n    export enum NetworkType {\n        MAINNET = \"mainnet\",\n        DELPHINET = \"delphinet\",\n        EDONET = \"edonet\",\n        CUSTOM = \"custom\"\n    }\n}\n\ndeclare module 'beacon/types/beacon/PermissionScope' {\n    export enum PermissionScope {\n        SIGN = \"sign\",\n        OPERATION_REQUEST = \"operation_request\",\n        THRESHOLD = \"threshold\"\n    }\n}\n\ndeclare module 'beacon/types/beacon/SigningType' {\n    export enum SigningType {\n        RAW = \"raw\",\n        OPERATION = \"operation\",\n        MICHELINE = \"micheline\"\n    }\n}\n\ndeclare module 'beacon/types/beacon/Threshold' {\n    export interface Threshold {\n        amount: string;\n        timeframe: string;\n    }\n}\n\ndeclare module 'beacon/types/BeaconErrorType' {\n    export enum BeaconErrorType {\n        BROADCAST_ERROR = \"BROADCAST_ERROR\",\n        NETWORK_NOT_SUPPORTED = \"NETWORK_NOT_SUPPORTED\",\n        NO_ADDRESS_ERROR = \"NO_ADDRESS_ERROR\",\n        NO_PRIVATE_KEY_FOUND_ERROR = \"NO_PRIVATE_KEY_FOUND_ERROR\",\n        NOT_GRANTED_ERROR = \"NOT_GRANTED_ERROR\",\n        PARAMETERS_INVALID_ERROR = \"PARAMETERS_INVALID_ERROR\",\n        TOO_MANY_OPERATIONS = \"TOO_MANY_OPERATIONS\",\n        TRANSACTION_INVALID_ERROR = \"TRANSACTION_INVALID_ERROR\",\n        SIGNATURE_TYPE_NOT_SUPPORTED = \"SIGNATURE_TYPE_NOT_SUPPORTED\",\n        ABORTED_ERROR = \"ABORTED_ERROR\",\n        UNKNOWN_ERROR = \"UNKNOWN_ERROR\"\n    }\n}\n\ndeclare module 'beacon/types/ColorMode' {\n    export enum ColorMode {\n        LIGHT = \"light\",\n        DARK = \"dark\"\n    }\n}\n\ndeclare module 'beacon/types/ConnectionContext' {\n    import { Origin } from 'beacon/';\n    export interface ConnectionContext {\n        origin: Origin;\n        id: string;\n        extras?: {\n            sender: chrome.runtime.MessageSender;\n            sendResponse(response?: unknown): void;\n        };\n    }\n}\n\ndeclare module 'beacon/types/Extension' {\n    export interface Extension {\n        id: string;\n        name: string;\n        shortName?: string;\n        iconUrl?: string;\n        color?: string;\n    }\n}\n\ndeclare module 'beacon/types/ExtensionMessage' {\n    import { ExtensionMessageTarget } from 'beacon/';\n    export interface ExtensionMessage<T, U = unknown> {\n        target: ExtensionMessageTarget;\n        targetId?: string;\n        sender?: U;\n        payload: T;\n    }\n    export interface EncryptedExtensionMessage<U = unknown> {\n        target: ExtensionMessageTarget;\n        targetId?: string;\n        sender?: U;\n        encryptedPayload: string;\n    }\n}\n\ndeclare module 'beacon/types/ExtensionMessageTarget' {\n    export enum ExtensionMessageTarget {\n        BACKGROUND = \"toBackground\",\n        PAGE = \"toPage\",\n        EXTENSION = \"toExtension\"\n    }\n}\n\ndeclare module 'beacon/types/Origin' {\n    export enum Origin {\n        WEBSITE = \"website\",\n        EXTENSION = \"extension\",\n        P2P = \"p2p\"\n    }\n}\n\ndeclare module 'beacon/types/P2PPairingRequest' {\n    import { PeerInfo } from 'beacon/types/PeerInfo';\n    export interface P2PPairingRequest extends PeerInfo {\n        id: string;\n        type: 'p2p-pairing-request';\n        name: string;\n        publicKey: string;\n        relayServer: string;\n        icon?: string;\n        appUrl?: string;\n    }\n    export type ExtendedP2PPairingRequest = P2PPairingRequest & {\n        senderId: string;\n    };\n}\n\ndeclare module 'beacon/types/P2PPairingResponse' {\n    import { PeerInfo } from 'beacon/types/PeerInfo';\n    export interface P2PPairingResponse extends PeerInfo {\n        id: string;\n        type: 'p2p-pairing-response';\n        name: string;\n        publicKey: string;\n        relayServer: string;\n        icon?: string;\n        appUrl?: string;\n    }\n    export type ExtendedP2PPairingResponse = P2PPairingResponse & {\n        senderId: string;\n    };\n}\n\ndeclare module 'beacon/types/PeerInfo' {\n    export interface PeerInfo {\n        name: string;\n        publicKey: string;\n        version: string;\n    }\n    export type ExtendedPeerInfo = PeerInfo & {\n        senderId: string;\n    };\n}\n\ndeclare module 'beacon/types/PermissionEntity' {\n    import { Network, PermissionScope, Threshold } from 'beacon/';\n    export interface PermissionEntity {\n        address: string;\n        network: Network;\n        scopes: PermissionScope[];\n        threshold?: Threshold;\n    }\n}\n\ndeclare module 'beacon/types/PermissionInfo' {\n    import { AppMetadata } from 'beacon/';\n    import { PermissionEntity } from 'beacon/types/PermissionEntity';\n    export interface PermissionInfo extends PermissionEntity {\n        accountIdentifier: string;\n        senderId: string;\n        appMetadata: AppMetadata;\n        website: string;\n        publicKey: string;\n        connectedAt: number;\n    }\n}\n\ndeclare module 'beacon/types/PostMessagePairingRequest' {\n    import { PeerInfo } from 'beacon/types/PeerInfo';\n    export interface PostMessagePairingRequest extends PeerInfo {\n        id: string;\n        type: 'postmessage-pairing-request';\n        name: string;\n        publicKey: string;\n        icon?: string;\n        appUrl?: string;\n    }\n    export type ExtendedPostMessagePairingRequest = PostMessagePairingRequest & {\n        senderId: string;\n    };\n}\n\ndeclare module 'beacon/types/PostMessagePairingResponse' {\n    import { PeerInfo } from 'beacon/types/PeerInfo';\n    export interface PostMessagePairingResponse extends PeerInfo {\n        id: string;\n        type: 'postmessage-pairing-response';\n        name: string;\n        publicKey: string;\n        icon?: string;\n        appUrl?: string;\n    }\n    export type ExtendedPostMessagePairingResponse = PostMessagePairingResponse & {\n        senderId: string;\n        extensionId: string;\n    };\n}\n\ndeclare module 'beacon/types/RequestBroadcastInput' {\n    import { Network } from 'beacon/';\n    export interface RequestBroadcastInput {\n        network?: Network;\n        signedTransaction: string;\n    }\n}\n\ndeclare module 'beacon/types/RequestOperationInput' {\n    import { PartialTezosOperation } from 'beacon/types/tezos/PartialTezosOperation';\n    export interface RequestOperationInput {\n        operationDetails: PartialTezosOperation[];\n    }\n}\n\ndeclare module 'beacon/types/RequestPermissionInput' {\n    import { Network, PermissionScope } from 'beacon/';\n    export interface RequestPermissionInput {\n        network?: Network;\n        scopes?: PermissionScope[];\n    }\n}\n\ndeclare module 'beacon/types/RequestSignPayloadInput' {\n    import { SigningType } from 'beacon/';\n    export interface RequestSignPayloadInput {\n        signingType?: SigningType;\n        payload: string;\n        sourceAddress?: string;\n    }\n}\n\ndeclare module 'beacon/types/storage/StorageKey' {\n    export enum StorageKey {\n        TRANSPORT_P2P_PEERS_DAPP = \"beacon:communication-peers-dapp\",\n        TRANSPORT_P2P_PEERS_WALLET = \"beacon:communication-peers-wallet\",\n        TRANSPORT_POSTMESSAGE_PEERS_DAPP = \"beacon:postmessage-peers-dapp\",\n        TRANSPORT_POSTMESSAGE_PEERS_WALLET = \"beacon:postmessage-peers-wallet\",\n        ACCOUNTS = \"beacon:accounts\",\n        ACTIVE_ACCOUNT = \"beacon:active-account\",\n        ACTIVE_PEER = \"beacon:active-peer\",\n        BEACON_SDK_SECRET_SEED = \"beacon:sdk-secret-seed\",\n        APP_METADATA_LIST = \"beacon:app-metadata-list\",\n        PERMISSION_LIST = \"beacon:permissions\",\n        BEACON_SDK_VERSION = \"beacon:sdk_version\",\n        MATRIX_PRESERVED_STATE = \"beacon:sdk-matrix-preserved-state\",\n        MATRIX_PEER_ROOM_IDS = \"beacon:matrix-peer-rooms\"\n    }\n}\n\ndeclare module 'beacon/types/storage/StorageKeyReturnDefaults' {\n    import { StorageKey, StorageKeyReturnType } from 'beacon/';\n    export type StorageKeyReturnDefaults = {\n        [key in StorageKey]: StorageKeyReturnType[key];\n    };\n    export const defaultValues: StorageKeyReturnDefaults;\n}\n\ndeclare module 'beacon/types/storage/StorageKeyReturnType' {\n    import { StorageKey, AccountInfo, AccountIdentifier, P2PPairingRequest, AppMetadata, PermissionInfo } from 'beacon/';\n    import { MatrixState } from 'beacon/matrix-client/MatrixClientStore';\n    import { ExtendedP2PPairingResponse } from 'beacon/types/P2PPairingResponse';\n    import { PostMessagePairingRequest } from 'beacon/types/PostMessagePairingRequest';\n    import { ExtendedPostMessagePairingResponse } from 'beacon/types/PostMessagePairingResponse';\n    export interface StorageKeyReturnType {\n        [StorageKey.TRANSPORT_P2P_PEERS_DAPP]: P2PPairingRequest[];\n        [StorageKey.TRANSPORT_P2P_PEERS_WALLET]: ExtendedP2PPairingResponse[];\n        [StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP]: PostMessagePairingRequest[];\n        [StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET]: ExtendedPostMessagePairingResponse[];\n        [StorageKey.ACCOUNTS]: AccountInfo[];\n        [StorageKey.ACTIVE_ACCOUNT]: AccountIdentifier | undefined;\n        [StorageKey.ACTIVE_PEER]: string | undefined;\n        [StorageKey.BEACON_SDK_SECRET_SEED]: string | undefined;\n        [StorageKey.APP_METADATA_LIST]: AppMetadata[];\n        [StorageKey.PERMISSION_LIST]: PermissionInfo[];\n        [StorageKey.BEACON_SDK_VERSION]: string | undefined;\n        [StorageKey.MATRIX_PRESERVED_STATE]: Partial<MatrixState>;\n        [StorageKey.MATRIX_PEER_ROOM_IDS]: {\n            [key: string]: string | undefined;\n        };\n    }\n}\n\ndeclare module 'beacon/types/tezos/MichelineMichelsonV1Expression' {\n    import { MichelsonPrimitives } from 'beacon/';\n    export type MichelineMichelsonV1Expression = {\n        int: string;\n    } | {\n        string: string;\n    } | {\n        bytes: string;\n    } | MichelineMichelsonV1Expression[] | {\n        prim: MichelsonPrimitives;\n        args?: MichelineMichelsonV1Expression[];\n        annots?: string[];\n    };\n}\n\ndeclare module 'beacon/types/tezos/MichelsonPrimitives' {\n    export type MichelsonPrimitives = 'ADD' | 'IF_NONE' | 'SWAP' | 'set' | 'nat' | 'CHECK_SIGNATURE' | 'IF_LEFT' | 'LAMBDA' | 'Elt' | 'CREATE_CONTRACT' | 'NEG' | 'big_map' | 'map' | 'or' | 'BLAKE2B' | 'bytes' | 'SHA256' | 'SET_DELEGATE' | 'CONTRACT' | 'LSL' | 'SUB' | 'IMPLICIT_ACCOUNT' | 'PACK' | 'list' | 'PAIR' | 'Right' | 'contract' | 'GT' | 'LEFT' | 'STEPS_TO_QUOTA' | 'storage' | 'TRANSFER_TOKENS' | 'CDR' | 'SLICE' | 'PUSH' | 'False' | 'SHA512' | 'CHAIN_ID' | 'BALANCE' | 'signature' | 'DUG' | 'SELF' | 'EMPTY_BIG_MAP' | 'LSR' | 'OR' | 'XOR' | 'lambda' | 'COMPARE' | 'key' | 'option' | 'Unit' | 'Some' | 'UNPACK' | 'NEQ' | 'INT' | 'pair' | 'AMOUNT' | 'DIP' | 'ABS' | 'ISNAT' | 'EXEC' | 'NOW' | 'LOOP' | 'chain_id' | 'string' | 'MEM' | 'MAP' | 'None' | 'address' | 'CONCAT' | 'EMPTY_SET' | 'MUL' | 'LOOP_LEFT' | 'timestamp' | 'LT' | 'UPDATE' | 'DUP' | 'SOURCE' | 'mutez' | 'SENDER' | 'IF_CONS' | 'RIGHT' | 'CAR' | 'CONS' | 'LE' | 'NONE' | 'IF' | 'SOME' | 'GET' | 'Left' | 'CAST' | 'int' | 'SIZE' | 'key_hash' | 'unit' | 'DROP' | 'EMPTY_MAP' | 'NIL' | 'DIG' | 'APPLY' | 'bool' | 'RENAME' | 'operation' | 'True' | 'FAILWITH' | 'parameter' | 'HASH_KEY' | 'EQ' | 'NOT' | 'UNIT' | 'Pair' | 'ADDRESS' | 'EDIV' | 'CREATE_ACCOUNT' | 'GE' | 'ITER' | 'code' | 'AND';\n}\n\ndeclare module 'beacon/types/tezos/operations/ActivateAccount' {\n    import { TezosBaseOperation, TezosOperationType } from 'beacon/';\n    export interface TezosActivateAccountOperation extends TezosBaseOperation {\n        kind: TezosOperationType.ACTIVATE_ACCOUNT;\n        pkh: string;\n        secret: string;\n    }\n}\n\ndeclare module 'beacon/types/tezos/operations/Ballot' {\n    import { TezosBaseOperation, TezosOperationType } from 'beacon/';\n    export interface TezosBallotOperation extends TezosBaseOperation {\n        kind: TezosOperationType.BALLOT;\n        source: string;\n        period: string;\n        proposal: string;\n        ballot: 'nay' | 'yay' | 'pass';\n    }\n}\n\ndeclare module 'beacon/types/tezos/operations/Delegation' {\n    import { TezosBaseOperation, TezosOperationType } from 'beacon/';\n    export interface TezosDelegationOperation extends TezosBaseOperation {\n        kind: TezosOperationType.DELEGATION;\n        source: string;\n        fee: string;\n        counter: string;\n        gas_limit: string;\n        storage_limit: string;\n        delegate?: string;\n    }\n}\n\ndeclare module 'beacon/types/tezos/operations/DoubleBakingEvidence' {\n    import { TezosBaseOperation, TezosOperationType, TezosBlockHeader } from 'beacon/';\n    export interface InlinedEndorsement {\n        branch: string;\n        operations: InlinedEndorsementContents;\n        signature?: string;\n    }\n    export interface InlinedEndorsementContents {\n        kind: 'endorsement';\n        level: string;\n    }\n    export interface TezosDoubleBakingEvidenceOperation extends TezosBaseOperation {\n        kind: TezosOperationType.DOUBLE_BAKING_EVIDENCE;\n        bh1: TezosBlockHeader;\n        bh2: TezosBlockHeader;\n    }\n}\n\ndeclare module 'beacon/types/tezos/operations/DoubleEndorsementEvidence' {\n    import { TezosBaseOperation, TezosOperationType } from 'beacon/';\n    export interface InlinedEndorsement {\n        branch: string;\n        operations: InlinedEndorsementContents;\n        signature?: string;\n    }\n    export interface InlinedEndorsementContents {\n        kind: 'endorsement';\n        level: string;\n    }\n    export interface TezosDoubleEndorsementEvidenceOperation extends TezosBaseOperation {\n        kind: TezosOperationType.DOUBLE_ENDORSEMENT_EVIDENCE;\n        op1: InlinedEndorsement;\n        op2: InlinedEndorsement;\n    }\n}\n\ndeclare module 'beacon/types/tezos/operations/Endorsement' {\n    import { TezosBaseOperation, TezosOperationType } from 'beacon/';\n    export interface TezosEndorsementOperation extends TezosBaseOperation {\n        kind: TezosOperationType.ENDORSEMENT;\n        level: string;\n    }\n}\n\ndeclare module 'beacon/types/tezos/operations/Origination' {\n    import { TezosBaseOperation, TezosOperationType } from 'beacon/';\n    export interface TezosOriginationOperation extends TezosBaseOperation {\n        kind: TezosOperationType.ORIGINATION;\n        source: string;\n        fee: string;\n        counter: string;\n        gas_limit: string;\n        storage_limit: string;\n        balance: string;\n        delegate?: string;\n        script: string;\n    }\n}\n\ndeclare module 'beacon/types/tezos/operations/Proposal' {\n    import { TezosBaseOperation, TezosOperationType } from 'beacon/';\n    export interface TezosProposalOperation extends TezosBaseOperation {\n        kind: TezosOperationType.PROPOSALS;\n        period: string;\n        proposals: string[];\n    }\n}\n\ndeclare module 'beacon/types/tezos/operations/Reveal' {\n    import { TezosBaseOperation, TezosOperationType } from 'beacon/';\n    export interface TezosRevealOperation extends TezosBaseOperation {\n        kind: TezosOperationType.REVEAL;\n        source: string;\n        fee: string;\n        counter: string;\n        gas_limit: string;\n        storage_limit: string;\n        public_key: string;\n    }\n}\n\ndeclare module 'beacon/types/tezos/operations/SeedNonceRevelation' {\n    import { TezosBaseOperation, TezosOperationType } from 'beacon/';\n    export interface TezosSeedNonceRevelationOperation extends TezosBaseOperation {\n        kind: TezosOperationType.SEED_NONCE_REVELATION;\n        level: string;\n        nonce: string;\n    }\n}\n\ndeclare module 'beacon/types/tezos/operations/Transaction' {\n    import { TezosBaseOperation, TezosOperationType, TezosTransactionParameters } from 'beacon/';\n    export interface TezosTransactionOperation extends TezosBaseOperation {\n        kind: TezosOperationType.TRANSACTION;\n        source: string;\n        fee: string;\n        counter: string;\n        gas_limit: string;\n        storage_limit: string;\n        amount: string;\n        destination: string;\n        parameters?: TezosTransactionParameters;\n    }\n}\n\ndeclare module 'beacon/types/tezos/OperationTypes' {\n    export enum TezosOperationType {\n        ENDORSEMENT = \"endorsement\",\n        SEED_NONCE_REVELATION = \"seed_nonce_revelation\",\n        DOUBLE_ENDORSEMENT_EVIDENCE = \"double_endorsement_evidence\",\n        DOUBLE_BAKING_EVIDENCE = \"double_baking_evidence\",\n        ACTIVATE_ACCOUNT = \"activate_account\",\n        PROPOSALS = \"proposals\",\n        BALLOT = \"ballot\",\n        REVEAL = \"reveal\",\n        TRANSACTION = \"transaction\",\n        ORIGINATION = \"origination\",\n        DELEGATION = \"delegation\"\n    }\n}\n\ndeclare module 'beacon/types/tezos/PartialTezosOperation' {\n    import { TezosActivateAccountOperation } from 'beacon/types/tezos/operations/ActivateAccount';\n    import { TezosBallotOperation } from 'beacon/types/tezos/operations/Ballot';\n    import { TezosDelegationOperation } from 'beacon/types/tezos/operations/Delegation';\n    import { TezosDoubleBakingEvidenceOperation } from 'beacon/types/tezos/operations/DoubleBakingEvidence';\n    import { TezosEndorsementOperation } from 'beacon/types/tezos/operations/Endorsement';\n    import { TezosOriginationOperation } from 'beacon/types/tezos/operations/Origination';\n    import { TezosProposalOperation } from 'beacon/types/tezos/operations/Proposal';\n    import { TezosRevealOperation } from 'beacon/types/tezos/operations/Reveal';\n    import { TezosSeedNonceRevelationOperation } from 'beacon/types/tezos/operations/SeedNonceRevelation';\n    import { TezosTransactionOperation } from 'beacon/types/tezos/operations/Transaction';\n    type omittedProperties = 'source' | 'fee' | 'counter' | 'gas_limit' | 'storage_limit';\n    export type PartialTezosDelegationOperation = Omit<TezosDelegationOperation, omittedProperties>;\n    export type PartialTezosOriginationOperation = Omit<TezosOriginationOperation, omittedProperties>;\n    export type PartialTezosRevealOperation = Omit<TezosRevealOperation, omittedProperties>;\n    export type PartialTezosTransactionOperation = Omit<TezosTransactionOperation, omittedProperties>;\n    export type PartialTezosOperation = TezosActivateAccountOperation | TezosBallotOperation | PartialTezosDelegationOperation | TezosDoubleBakingEvidenceOperation | TezosEndorsementOperation | PartialTezosOriginationOperation | TezosProposalOperation | PartialTezosRevealOperation | TezosSeedNonceRevelationOperation | PartialTezosTransactionOperation;\n    export {};\n}\n\ndeclare module 'beacon/types/tezos/TezosBaseOperation' {\n    import { TezosOperationType } from 'beacon/';\n    export interface TezosBaseOperation {\n        kind: TezosOperationType;\n    }\n}\n\ndeclare module 'beacon/types/tezos/TezosBlockHeader' {\n    export interface TezosBlockHeader {\n        level: number;\n        proto: number;\n        predecessor: string;\n        timestamp: string;\n        validation_pass: number;\n        operations_hash: string;\n        fitness: string[];\n        context: string;\n        priority: number;\n        proof_of_work_nonce: string;\n        signature: string;\n    }\n}\n\ndeclare module 'beacon/types/tezos/TezosOperation' {\n    import { TezosActivateAccountOperation, TezosBallotOperation, TezosDelegationOperation, TezosDoubleBakingEvidenceOperation, TezosEndorsementOperation, TezosOriginationOperation, TezosProposalOperation, TezosRevealOperation, TezosSeedNonceRevelationOperation, TezosTransactionOperation } from 'beacon/';\n    export type TezosOperation = TezosActivateAccountOperation | TezosBallotOperation | TezosDelegationOperation | TezosDoubleBakingEvidenceOperation | TezosEndorsementOperation | TezosOriginationOperation | TezosProposalOperation | TezosRevealOperation | TezosSeedNonceRevelationOperation | TezosTransactionOperation;\n}\n\ndeclare module 'beacon/types/tezos/TezosTransactionParameters' {\n    import { MichelineMichelsonV1Expression } from 'beacon/types/tezos/MichelineMichelsonV1Expression';\n    export interface TezosTransactionParameters {\n        entrypoint: 'default' | 'root' | 'do' | 'set_delegate' | 'remove_delegate' | string;\n        value: MichelineMichelsonV1Expression;\n    }\n}\n\ndeclare module 'beacon/types/transport/TransportStatus' {\n    export enum TransportStatus {\n        NOT_CONNECTED = \"NOT_CONNECTED\",\n        CONNECTING = \"CONNECTING\",\n        CONNECTED = \"CONNECTED\"\n    }\n}\n\ndeclare module 'beacon/types/transport/TransportType' {\n    export enum TransportType {\n        CHROME_MESSAGE = \"chrome_message\",\n        POST_MESSAGE = \"post_message\",\n        LEDGER = \"ledger\",\n        P2P = \"p2p\"\n    }\n}\n\ndeclare module 'beacon/ui/alert/alert-templates' {\n    export const alertTemplates: {\n        container: string;\n        default: {\n            html: string;\n            css: string;\n        };\n        pair: {\n            html: string;\n            css: string;\n        };\n    };\n}\n\ndeclare module 'beacon/ui/alert/Alert' {\n    import { NetworkType } from 'beacon/';\n    export interface AlertButton {\n        text: string;\n        style?: 'solid' | 'outline';\n        actionCallback?(): Promise<void>;\n    }\n    export interface AlertConfig {\n        title: string;\n        body?: string;\n        timer?: number;\n        buttons?: AlertButton[];\n        pairingPayload?: {\n            p2pSyncCode: string;\n            postmessageSyncCode: string;\n            preferredNetwork: NetworkType;\n        };\n        closeButtonCallback?(): void;\n    }\n    /**\n      * Close an alert by ID\n      *\n      * @param id ID of alert\n      */\n    const closeAlert: (id: string) => Promise<void>;\n    /**\n      * Close all alerts\n      */\n    const closeAlerts: () => Promise<void>;\n    /**\n      * Show an alert\n      *\n      * @param alertConfig The configuration of the alert\n      */\n    const openAlert: (alertConfig: AlertConfig) => Promise<string>;\n    export { closeAlert, closeAlerts, openAlert };\n}\n\ndeclare module 'beacon/ui/alert/Pairing' {\n    import { NetworkType } from 'beacon/';\n    export enum Platform {\n        DESKTOP = 0,\n        IOS = 1,\n        ANDROID = 2\n    }\n    export enum WalletType {\n        IOS = \"ios\",\n        ANDROID = \"android\",\n        EXTENSION = \"extension\",\n        DESKTOP = \"desktop\",\n        WEB = \"web\"\n    }\n    export interface AppBase {\n        name: string;\n        shortName: string;\n        color: string;\n        logo: string;\n    }\n    export interface ExtensionApp extends AppBase {\n        id: string;\n        link: string;\n    }\n    export interface WebApp extends AppBase {\n        links: {\n            [NetworkType.MAINNET]: string;\n            [NetworkType.DELPHINET]?: string;\n            [NetworkType.EDONET]?: string;\n            [NetworkType.CUSTOM]?: string;\n        };\n    }\n    export interface DesktopApp extends AppBase {\n        deepLink: string;\n    }\n    export interface App extends AppBase {\n        universalLink: string;\n        deepLink?: string;\n    }\n    export interface PairingAlertWallet {\n        name: string;\n        shortName?: string;\n        color?: string;\n        logo?: string;\n        enabled: boolean;\n        clickHandler(): void;\n    }\n    export interface PairingAlertButton {\n        title: string;\n        text: string;\n        clickHandler(): void;\n    }\n    export interface PairingAlertList {\n        title: string;\n        type: WalletType;\n        wallets: PairingAlertWallet[];\n    }\n    export interface PairingAlertInfo {\n        walletLists: PairingAlertList[];\n        buttons: PairingAlertButton[];\n        qrData: string;\n    }\n    export type StatusUpdateHandler = (walletType: WalletType, app?: PairingAlertWallet) => void;\n    export class Pairing {\n        static getPlatfrom(): Promise<Platform>;\n        static getPairingInfo(pairingPayload: {\n            p2pSyncCode: string;\n            postmessageSyncCode: string;\n            preferredNetwork: NetworkType;\n        }, statusUpdateHandler: StatusUpdateHandler, platform?: Platform): Promise<PairingAlertInfo>;\n    }\n}\n\ndeclare module 'beacon/ui/alert/PairingAlert' {\n    import { NetworkType } from 'beacon/';\n    export const preparePairingAlert: (shadowRoot: ShadowRoot, pairingPayload: {\n        p2pSyncCode: string;\n        postmessageSyncCode: string;\n        preferredNetwork: NetworkType;\n    }) => Promise<void>;\n}\n\ndeclare module 'beacon/ui/alert/wallet-lists' {\n    import { App, DesktopApp, ExtensionApp, WebApp } from 'beacon/ui/alert/Pairing';\n    export const extensionList: ExtensionApp[];\n    export const desktopList: DesktopApp[];\n    export const webList: WebApp[];\n    export const iOSList: App[];\n}\n\ndeclare module 'beacon/ui/toast/toast-templates' {\n    export const toastTemplates: {\n        default: {\n            html: string;\n            css: string;\n            poweredByBeacon: string;\n        };\n    };\n}\n\ndeclare module 'beacon/ui/toast/Toast' {\n    import { WalletInfo } from 'beacon/events';\n    export interface ToastAction {\n        text: string;\n        actionText?: string;\n        actionCallback?(): Promise<void>;\n    }\n    export interface ToastConfig {\n        body: string;\n        timer?: number;\n        forceNew?: boolean;\n        state: 'loading' | 'acknowledge' | 'finished';\n        actions?: ToastAction[];\n        walletInfo?: WalletInfo;\n    }\n    /**\n      * Close a toast\n      */\n    const closeToast: () => Promise<void>;\n    /**\n      * Create a new toast\n      *\n      * @param toastConfig Configuration of the toast\n      */\n    const openToast: (toastConfig: ToastConfig) => Promise<void>;\n    export { closeToast, openToast };\n}\n\ndeclare module 'beacon/utils/assert-never' {\n    /**\n      * A helper function to make sure if/elses and switch/cases are exhaustive\n      *\n      * @param empty The data that has to be empty\n      */\n    export function assertNever(empty: never): never;\n}\n\ndeclare module 'beacon/utils/available-transports' {\n    /**\n      * An object with promises to indicate whether or not that transport is available.\n      */\n    export const availableTransports: {\n        extension: Promise<boolean>;\n        availableExtensions: Promise<import(\"beacon/types/Extension\").Extension[]>;\n    };\n}\n\ndeclare module 'beacon/utils/block-explorer' {\n    import { Network, NetworkType } from 'beacon/';\n    export abstract class BlockExplorer {\n        readonly rpcUrls: {\n            [key in NetworkType]: string;\n        };\n        constructor(rpcUrls: {\n            [key in NetworkType]: string;\n        });\n        protected getLinkForNetwork(network: Network): Promise<string>;\n        /**\n          * Return a blockexplorer link for an address\n          *\n          * @param address The address to be opened\n          * @param network The network that was used\n          */\n        abstract getAddressLink(address: string, network: Network): Promise<string>;\n        /**\n          * Return a blockexplorer link for a transaction hash\n          *\n          * @param transactionId The hash of the transaction\n          * @param network The network that was used\n          */\n        abstract getTransactionLink(transactionId: string, network: Network): Promise<string>;\n    }\n}\n\ndeclare module 'beacon/utils/crypto' {\n    import * as sodium from 'libsodium-wrappers';\n    /**\n      * Convert a value to hex\n      *\n      * @param value\n      */\n    export function toHex(value: any): string;\n    /**\n      * Get the hex hash of a value\n      *\n      * @param key\n      */\n    export function getHexHash(key: string | Buffer | Uint8Array): Promise<string>;\n    /**\n      * Get a keypair from a seed\n      *\n      * @param seed\n      */\n    export function getKeypairFromSeed(seed: string): Promise<sodium.KeyPair>;\n    /**\n      * Encrypt a message with a shared key\n      *\n      * @param message\n      * @param sharedKey\n      */\n    export function encryptCryptoboxPayload(message: string, sharedKey: Uint8Array): Promise<string>;\n    /**\n      * Decrypt a message with a shared key\n      *\n      * @param payload\n      * @param sharedKey\n      */\n    export function decryptCryptoboxPayload(payload: Uint8Array, sharedKey: Uint8Array): Promise<string>;\n    /**\n      * Encrypt a message with a public key\n      *\n      * @param payload\n      * @param publicKey\n      */\n    export function sealCryptobox(payload: string | Buffer, publicKey: Uint8Array): Promise<string>;\n    /**\n      * Decrypt a message with public + private key\n      *\n      * @param encryptedPayload\n      * @param publicKey\n      * @param privateKey\n      */\n    export function openCryptobox(encryptedPayload: string | Buffer, publicKey: Uint8Array, privateKey: Uint8Array): Promise<string>;\n    /**\n      * Get an address from the public key\n      *\n      * @param publicKey\n      */\n    export function getAddressFromPublicKey(publicKey: string): Promise<string>;\n    /**\n      * Get the recipient string used in the matrix message\n      *\n      * @param recipientHash\n      * @param relayServer\n      */\n    export function recipientString(recipientHash: string, relayServer: string): string;\n}\n\ndeclare module 'beacon/utils/exposed-promise' {\n    export enum ExposedPromiseStatus {\n        PENDING = \"pending\",\n        RESOLVED = \"resolved\",\n        REJECTED = \"rejected\"\n    }\n    type Resolve<T> = (value?: T) => void;\n    type Reject<U> = (reason?: U) => void;\n    /**\n      * Exposed promise allow you to create a promise and then resolve it later, from the outside\n      */\n    export class ExposedPromise<T = unknown, U = unknown> {\n        get promise(): Promise<T>;\n        get resolve(): Resolve<T>;\n        get reject(): Reject<U>;\n        get status(): ExposedPromiseStatus;\n        get promiseResult(): T | undefined;\n        get promiseError(): U | undefined;\n        constructor();\n        static resolve<T>(value?: T): ExposedPromise<T>;\n        static reject<T = never, U = unknown>(reason?: U): ExposedPromise<T, U>;\n        isPending(): boolean;\n        isResolved(): boolean;\n        isRejected(): boolean;\n        isSettled(): boolean;\n    }\n    export {};\n}\n\ndeclare module 'beacon/utils/generate-uuid' {\n    /**\n      * Generate a random GUID\n      */\n    export function generateGUID(): Promise<string>;\n}\n\ndeclare module 'beacon/utils/get-account-identifier' {\n    import { Network } from 'beacon/';\n    /**\n      * Generate a deterministic account identifier based on an address and a network\n      *\n      * @param address\n      * @param network\n      */\n    export const getAccountIdentifier: (address: string, network: Network) => Promise<string>;\n}\n\ndeclare module 'beacon/utils/get-sender-id' {\n    /**\n      * Generate a deterministic sender identifier based on a public key\n      *\n      * @param publicKey\n      */\n    export const getSenderId: (publicKey: string) => Promise<string>;\n}\n\ndeclare module 'beacon/utils/get-tzip10-link' {\n    export const getTzip10Link: (url: string, payload: string) => string;\n}\n\ndeclare module 'beacon/utils/Logger' {\n    /**\n      * The logger that is used internally\n      */\n    export class Logger {\n        constructor(service: string);\n        debug(method: string, ...args: any[]): void;\n        log(method: string, ...args: any[]): void;\n        warn(method: string, ...args: any[]): void;\n        error(method: string, ...args: any[]): void;\n    }\n}\n\ndeclare module 'beacon/utils/platform' {\n    export const testUserAgent: (win: Window, expr: RegExp) => boolean;\n    export const isMobile: (win: Window) => boolean;\n    export const isIOS: (win: Window) => boolean;\n    export const isAndroid: (win: Window) => boolean;\n    export const isDesktop: (win: Window) => boolean;\n}\n\ndeclare module 'beacon/utils/qr' {\n    /**\n      * Convert data to a QR code\n      *\n      * @param payload The data to be encoded as a QR code\n      * @param type How the QR code will be encoded\n      */\n    export const getQrData: (payload: string, type?: \"data\" | \"svg\" | \"ascii\" | undefined) => string;\n}\n\ndeclare module 'beacon/utils/replace-in-template' {\n    export const replaceInTemplate: (text: string, placeholder: string, value: string) => string;\n}\n\ndeclare module 'beacon/utils/shorten-string' {\n    export const shortenString: (text: string) => string;\n}\n\ndeclare module 'beacon/utils/tezblock-blockexplorer' {\n    import { Network, NetworkType } from 'beacon/';\n    import { BlockExplorer } from 'beacon/utils/block-explorer';\n    export class TezblockBlockExplorer extends BlockExplorer {\n        readonly rpcUrls: {\n            [key in NetworkType]: string;\n        };\n        constructor(rpcUrls?: {\n            [key in NetworkType]: string;\n        });\n        getAddressLink(address: string, network: Network): Promise<string>;\n        getTransactionLink(transactionId: string, network: Network): Promise<string>;\n    }\n}\n\ndeclare module 'beacon/utils/utils' {\n    /**\n      * A helper function to improve typings of object keys\n      *\n      * @param obj Object\n      */\n    export function keys<O extends object>(obj: O): (keyof O)[];\n}\n\ndeclare module 'beacon/' {\n    import { P2PCommunicationClient } from 'beacon/transports/clients/P2PCommunicationClient';\n    import { AppMetadata } from 'beacon/types/beacon/AppMetadata';\n    import { PermissionRequest } from 'beacon/types/beacon/messages/PermissionRequest';\n    import { Network } from 'beacon/types/beacon/Network';\n    import { BeaconBaseMessage } from 'beacon/types/beacon/BeaconBaseMessage';\n    import { BeaconMessageType } from 'beacon/types/beacon/BeaconMessageType';\n    import { PermissionScope } from 'beacon/types/beacon/PermissionScope';\n    import { PermissionResponse } from 'beacon/types/beacon/messages/PermissionResponse';\n    import { OperationRequest } from 'beacon/types/beacon/messages/OperationRequest';\n    import { OperationResponse } from 'beacon/types/beacon/messages/OperationResponse';\n    import { SignPayloadRequest } from 'beacon/types/beacon/messages/SignPayloadRequest';\n    import { SignPayloadResponse } from 'beacon/types/beacon/messages/SignPayloadResponse';\n    import { BroadcastRequest } from 'beacon/types/beacon/messages/BroadcastRequest';\n    import { BroadcastResponse } from 'beacon/types/beacon/messages/BroadcastResponse';\n    import { NetworkType } from 'beacon/types/beacon/NetworkType';\n    import { TezosBaseOperation } from 'beacon/types/tezos/TezosBaseOperation';\n    import { TezosOperationType } from 'beacon/types/tezos/OperationTypes';\n    import { TezosActivateAccountOperation } from 'beacon/types/tezos/operations/ActivateAccount';\n    import { TezosBallotOperation } from 'beacon/types/tezos/operations/Ballot';\n    import { TezosDelegationOperation } from 'beacon/types/tezos/operations/Delegation';\n    import { TezosDoubleBakingEvidenceOperation } from 'beacon/types/tezos/operations/DoubleBakingEvidence';\n    import { TezosBlockHeader } from 'beacon/types/tezos/TezosBlockHeader';\n    import { TezosDoubleEndorsementEvidenceOperation } from 'beacon/types/tezos/operations/DoubleEndorsementEvidence';\n    import { TezosEndorsementOperation } from 'beacon/types/tezos/operations/Endorsement';\n    import { TezosOriginationOperation } from 'beacon/types/tezos/operations/Origination';\n    import { TezosProposalOperation } from 'beacon/types/tezos/operations/Proposal';\n    import { TezosRevealOperation } from 'beacon/types/tezos/operations/Reveal';\n    import { TezosSeedNonceRevelationOperation } from 'beacon/types/tezos/operations/SeedNonceRevelation';\n    import { TezosTransactionOperation } from 'beacon/types/tezos/operations/Transaction';\n    import { MichelsonPrimitives } from 'beacon/types/tezos/MichelsonPrimitives';\n    import { TezosTransactionParameters } from 'beacon/types/tezos/TezosTransactionParameters';\n    import { Origin } from 'beacon/types/Origin';\n    import { AccountInfo, AccountIdentifier } from 'beacon/types/AccountInfo';\n    import { EncryptedExtensionMessage, ExtensionMessage } from 'beacon/types/ExtensionMessage';\n    import { ExtensionMessageTarget } from 'beacon/types/ExtensionMessageTarget';\n    import { TezosOperation } from 'beacon/types/tezos/TezosOperation';\n    import { Client } from 'beacon/clients/client/Client';\n    import { WalletClient } from 'beacon/clients/wallet-client/WalletClient';\n    import { DAppClient } from 'beacon/clients/dapp-client/DAppClient';\n    import { BeaconError } from 'beacon/errors/BeaconError';\n    import { BeaconErrorType } from 'beacon/types/BeaconErrorType';\n    import { BroadcastBeaconError } from 'beacon/errors/BroadcastBeaconError';\n    import { NetworkNotSupportedBeaconError } from 'beacon/errors/NetworkNotSupportedBeaconError';\n    import { NoAddressBeaconError } from 'beacon/errors/NoAddressBeaconError';\n    import { NoPrivateKeyBeaconError } from 'beacon/errors/NoPrivateKeyBeaconError';\n    import { NotGrantedBeaconError } from 'beacon/errors/NotGrantedBeaconError';\n    import { ParametersInvalidBeaconError } from 'beacon/errors/ParametersInvalidBeaconError';\n    import { TooManyOperationsBeaconError } from 'beacon/errors/TooManyOperationsBeaconError';\n    import { TransactionInvalidBeaconError } from 'beacon/errors/TransactionInvalidBeaconError';\n    import { UnknownBeaconError } from 'beacon/errors/UnknownBeaconError';\n    import { ErrorResponse } from 'beacon/types/beacon/messages/ErrorResponse';\n    import { TransportStatus } from 'beacon/types/transport/TransportStatus';\n    import { TransportType } from 'beacon/types/transport/TransportType';\n    import { PostMessageTransport } from 'beacon/transports/PostMessageTransport';\n    import { Transport } from 'beacon/transports/Transport';\n    import { P2PTransport } from 'beacon/transports/P2PTransport';\n    import { Storage } from 'beacon/storage/Storage';\n    import { StorageKey } from 'beacon/types/storage/StorageKey';\n    import { StorageKeyReturnDefaults } from 'beacon/types/storage/StorageKeyReturnDefaults';\n    import { StorageKeyReturnType } from 'beacon/types/storage/StorageKeyReturnType';\n    import { ExtendedP2PPairingRequest, P2PPairingRequest } from 'beacon/types/P2PPairingRequest';\n    import { ChromeStorage } from 'beacon/storage/ChromeStorage';\n    import { LocalStorage } from 'beacon/storage/LocalStorage';\n    import { getStorage } from 'beacon/storage/getStorage';\n    import { BeaconMessage } from 'beacon/types/beacon/BeaconMessage';\n    import { Serializer } from 'beacon/Serializer';\n    import { RequestPermissionInput } from 'beacon/types/RequestPermissionInput';\n    import { RequestSignPayloadInput } from 'beacon/types/RequestSignPayloadInput';\n    import { RequestOperationInput } from 'beacon/types/RequestOperationInput';\n    import { RequestBroadcastInput } from 'beacon/types/RequestBroadcastInput';\n    import { PermissionResponseInput, SignPayloadResponseInput, OperationResponseInput, BroadcastResponseInput, BeaconResponseInputMessage, AcknowledgeResponseInput, ErrorResponseInput } from 'beacon/types/beacon/messages/BeaconResponseInputMessage';\n    import { PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, BeaconResponseOutputMessage } from 'beacon/types/beacon/messages/BeaconResponseOutputMessage';\n    import { PermissionRequestInput, SignPayloadRequestInput, OperationRequestInput, BroadcastRequestInput, BeaconRequestInputMessage } from 'beacon/types/beacon/messages/BeaconRequestInputMessage';\n    import { PermissionRequestOutput, SignPayloadRequestOutput, OperationRequestOutput, BroadcastRequestOutput, BeaconRequestOutputMessage } from 'beacon/types/beacon/messages/BeaconRequestOutputMessage';\n    import { ClientOptions } from 'beacon/clients/client/ClientOptions';\n    import { DAppClientOptions } from 'beacon/clients/dapp-client/DAppClientOptions';\n    import { WalletClientOptions } from 'beacon/clients/wallet-client/WalletClientOptions';\n    import { PermissionInfo } from 'beacon/types/PermissionInfo';\n    import { SDK_VERSION, BEACON_VERSION } from 'beacon/constants';\n    import { AccountManager } from 'beacon/managers/AccountManager';\n    import { AppMetadataManager } from 'beacon/managers/AppMetadataManager';\n    import { PermissionManager } from 'beacon/managers/PermissionManager';\n    import { BeaconEvent, BeaconEventHandler, defaultEventCallbacks } from 'beacon/events';\n    import { getAddressFromPublicKey } from 'beacon/utils/crypto';\n    import { BeaconClient } from 'beacon/clients/beacon-client/BeaconClient';\n    import { BeaconClientOptions } from 'beacon/clients/beacon-client/BeaconClientOptions';\n    import { getAccountIdentifier } from 'beacon/utils/get-account-identifier';\n    import { ConnectionContext } from 'beacon/types/ConnectionContext';\n    import { Threshold } from 'beacon/types/beacon/Threshold';\n    import { PartialTezosTransactionOperation, PartialTezosOperation, PartialTezosDelegationOperation, PartialTezosOriginationOperation, PartialTezosRevealOperation } from 'beacon/types/tezos/PartialTezosOperation';\n    import { AbortedBeaconError } from 'beacon/errors/AbortedBeaconError';\n    import { ExtendedPeerInfo, PeerInfo } from 'beacon/types/PeerInfo';\n    import { availableTransports } from 'beacon/utils/available-transports';\n    import { AcknowledgeResponse } from 'beacon/types/beacon/messages/AcknowledgeResponse';\n    import { DisconnectMessage } from 'beacon/types/beacon/messages/DisconnectMessage';\n    import { DappP2PTransport } from 'beacon/transports/DappP2PTransport';\n    import { DappPostMessageTransport } from 'beacon/transports/DappPostMessageTransport';\n    import { WalletP2PTransport } from 'beacon/transports/WalletP2PTransport';\n    import { WalletPostMessageTransport } from 'beacon/transports/WalletPostMessageTransport';\n    import { getSenderId } from 'beacon/utils/get-sender-id';\n    import { SigningType } from 'beacon/types/beacon/SigningType';\n    import { SignatureTypeNotSupportedBeaconError } from 'beacon/errors/SignatureTypeNotSupportedBeaconError';\n    import { ExtendedP2PPairingResponse } from 'beacon/types/P2PPairingResponse';\n    import { ExtendedPostMessagePairingRequest, PostMessagePairingRequest } from 'beacon/types/PostMessagePairingRequest';\n    import { ExtendedPostMessagePairingResponse } from 'beacon/types/PostMessagePairingResponse';\n    import { PeerManager } from 'beacon/managers/PeerManager';\n    import { MessageBasedClient } from 'beacon/transports/clients/MessageBasedClient';\n    import { BeaconRequestMessage } from 'beacon/types/beacon/BeaconRequestMessage';\n    import { BeaconResponseMessage } from 'beacon/types/beacon/BeaconResponseMessage';\n    import { Pairing } from 'beacon/ui/alert/Pairing';\n    import { BlockExplorer } from 'beacon/utils/block-explorer';\n    import { TezblockBlockExplorer } from 'beacon/utils/tezblock-blockexplorer';\n    import { setDebugEnabled, getDebugEnabled } from 'beacon/debug';\n    import { ColorMode } from 'beacon/types/ColorMode';\n    export { TezosBaseOperation, TezosOperationType, TezosBlockHeader, MichelsonPrimitives, TezosTransactionParameters, TezosOperation };\n    export { TezosActivateAccountOperation, TezosBallotOperation, TezosDelegationOperation, TezosDoubleBakingEvidenceOperation, TezosDoubleEndorsementEvidenceOperation, TezosEndorsementOperation, TezosOriginationOperation, TezosProposalOperation, TezosRevealOperation, TezosSeedNonceRevelationOperation, TezosTransactionOperation, PartialTezosOperation, PartialTezosTransactionOperation, PartialTezosDelegationOperation, PartialTezosOriginationOperation, PartialTezosRevealOperation };\n    export { BeaconClient, BeaconClientOptions, Client, ClientOptions, DAppClient, DAppClientOptions, WalletClient, WalletClientOptions, P2PCommunicationClient };\n    export { AccountIdentifier, AppMetadata, Network, NetworkType, BeaconMessage, PermissionRequest, PermissionResponse, OperationRequest, OperationResponse, SignPayloadRequest, SignPayloadResponse, BroadcastRequest, BroadcastResponse, AcknowledgeResponse, DisconnectMessage, BeaconBaseMessage, BeaconMessageType, PermissionScope, Origin, AccountInfo, Threshold, SigningType, ExtensionMessageTarget, ExtensionMessage, EncryptedExtensionMessage, RequestPermissionInput, RequestSignPayloadInput, RequestOperationInput, RequestBroadcastInput, PermissionInfo };\n    export { PermissionResponseInput, SignPayloadResponseInput, OperationResponseInput, BroadcastResponseInput, AcknowledgeResponseInput, ErrorResponseInput, PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, PermissionRequestInput, SignPayloadRequestInput, OperationRequestInput, BroadcastRequestInput, PermissionRequestOutput, SignPayloadRequestOutput, OperationRequestOutput, BroadcastRequestOutput, BeaconRequestInputMessage, BeaconRequestOutputMessage, BeaconResponseInputMessage, BeaconResponseOutputMessage, BeaconRequestMessage, BeaconResponseMessage };\n    export { BeaconError, BeaconErrorType, ErrorResponse, AbortedBeaconError, BroadcastBeaconError, NetworkNotSupportedBeaconError, NoAddressBeaconError, NoPrivateKeyBeaconError, NotGrantedBeaconError, ParametersInvalidBeaconError, TooManyOperationsBeaconError, TransactionInvalidBeaconError, SignatureTypeNotSupportedBeaconError, UnknownBeaconError };\n    export { TransportStatus, TransportType, Transport, PostMessageTransport, P2PTransport, WalletP2PTransport, WalletPostMessageTransport, DappP2PTransport, DappPostMessageTransport, MessageBasedClient, Pairing };\n    export { BeaconEvent, BeaconEventHandler, defaultEventCallbacks };\n    export { Storage, StorageKey, StorageKeyReturnDefaults, StorageKeyReturnType, ChromeStorage, LocalStorage, getStorage };\n    export { PeerManager, AccountManager, AppMetadataManager, PermissionManager };\n    export { SDK_VERSION, BEACON_VERSION };\n    export { getSenderId, getAccountIdentifier, getAddressFromPublicKey };\n    export { PeerInfo, ExtendedPeerInfo, PostMessagePairingRequest, ExtendedPostMessagePairingRequest, ExtendedPostMessagePairingResponse, P2PPairingRequest, ExtendedP2PPairingRequest, ExtendedP2PPairingResponse };\n    export { BlockExplorer, TezblockBlockExplorer };\n    export { ConnectionContext, Serializer, availableTransports, ColorMode };\n    export { setDebugEnabled, getDebugEnabled };\n}\n\n"},{"name":"@airgap/beacon-sdk/storage/ChromeStorage.d.ts","dts":"import { Storage, StorageKey, StorageKeyReturnType } from '..';\nexport declare class ChromeStorage implements Storage {\n    static isSupported(): Promise<boolean>;\n    get<K extends StorageKey>(key: K): Promise<StorageKeyReturnType[K]>;\n    set<K extends StorageKey>(key: K, value: StorageKeyReturnType[K]): Promise<void>;\n    delete<K extends StorageKey>(key: K): Promise<void>;\n}\n"},{"name":"@airgap/beacon-sdk/storage/LocalStorage.d.ts","dts":"import { Storage, StorageKey, StorageKeyReturnType } from '..';\nexport declare class LocalStorage implements Storage {\n    private readonly prefix?;\n    constructor(prefix?: string | undefined);\n    static isSupported(): Promise<boolean>;\n    get<K extends StorageKey>(key: K): Promise<StorageKeyReturnType[K]>;\n    set<K extends StorageKey>(key: K, value: StorageKeyReturnType[K]): Promise<void>;\n    delete<K extends StorageKey>(key: K): Promise<void>;\n    private getPrefixedKey;\n}\n"},{"name":"@airgap/beacon-sdk/storage/Storage.d.ts","dts":"import { StorageKey } from '../types/storage/StorageKey';\nimport { StorageKeyReturnType } from '../types/storage/StorageKeyReturnType';\n/**\n * The storage used in the SDK\n */\nexport declare abstract class Storage {\n    /**\n     * Returns a promise that resolves to true if the storage option is available on this platform.\n     */\n    static isSupported(): Promise<boolean>;\n    /**\n     * Gets a value from storage and returns it\n     *\n     * @param key The storage key\n     */\n    abstract get<K extends StorageKey>(key: K): Promise<StorageKeyReturnType[K]>;\n    /**\n     * Sets a value in the storage and persist it\n     *\n     * @param key The storage key\n     * @param value The value to be persisted\n     */\n    abstract set<K extends StorageKey>(key: K, value: StorageKeyReturnType[K]): Promise<void>;\n    /**\n     * Delete a key from storage\n     *\n     * @param key The storage key\n     */\n    abstract delete<K extends StorageKey>(key: K): Promise<void>;\n}\n"},{"name":"@airgap/beacon-sdk/storage/getStorage.d.ts","dts":"import { Storage } from '..';\n/**\n * Get a supported storage on this platform\n */\nexport declare const getStorage: () => Promise<Storage>;\n"},{"name":"@airgap/beacon-sdk/transports/clients/CommunicationClient.d.ts","dts":"import * as sodium from 'libsodium-wrappers';\nimport { P2PPairingRequest } from '../..';\nimport { ExtendedP2PPairingResponse } from '../../types/P2PPairingResponse';\nimport { PostMessagePairingRequest } from '../../types/PostMessagePairingRequest';\nimport { ExtendedPostMessagePairingResponse } from '../../types/PostMessagePairingResponse';\nexport declare abstract class CommunicationClient {\n    protected readonly keyPair: sodium.KeyPair;\n    constructor(keyPair: sodium.KeyPair);\n    /**\n     * Get the public key\n     */\n    getPublicKey(): Promise<string>;\n    /**\n     * get the public key hash\n     */\n    getPublicKeyHash(): Promise<string>;\n    /**\n     * Create a cryptobox shared key\n     *\n     * @param otherPublicKey\n     * @param selfPrivateKey\n     */\n    protected createCryptoBox(otherPublicKey: string, selfPrivateKey: Uint8Array): Promise<[Uint8Array, Uint8Array, Uint8Array]>;\n    /**\n     * Create a cryptobox server\n     *\n     * @param otherPublicKey\n     * @param selfPrivateKey\n     */\n    protected createCryptoBoxServer(otherPublicKey: string, selfPrivateKey: Uint8Array): Promise<sodium.CryptoKX>;\n    /**\n     * Create a cryptobox client\n     *\n     * @param otherPublicKey\n     * @param selfPrivateKey\n     */\n    protected createCryptoBoxClient(otherPublicKey: string, selfPrivateKey: Uint8Array): Promise<sodium.CryptoKX>;\n    /**\n     * Encrypt a message for a specific publicKey (receiver, asymmetric)\n     *\n     * @param recipientPublicKey\n     * @param message\n     */\n    protected encryptMessageAsymmetric(recipientPublicKey: string, message: string): Promise<string>;\n    abstract unsubscribeFromEncryptedMessages(): Promise<void>;\n    abstract unsubscribeFromEncryptedMessage(senderPublicKey: string): Promise<void>;\n    abstract sendMessage(message: string, peer?: P2PPairingRequest | ExtendedP2PPairingResponse | PostMessagePairingRequest | ExtendedPostMessagePairingResponse): Promise<void>;\n}\n"},{"name":"@airgap/beacon-sdk/transports/clients/MessageBasedClient.d.ts","dts":"import * as sodium from 'libsodium-wrappers';\nimport { PostMessagePairingRequest } from '../../types/PostMessagePairingRequest';\nimport { PostMessagePairingResponse } from '../../types/PostMessagePairingResponse';\nimport { CommunicationClient } from './CommunicationClient';\nexport declare abstract class MessageBasedClient extends CommunicationClient {\n    protected readonly name: string;\n    /**\n     * The listeners that will be notified of new messages\n     */\n    protected abstract readonly activeListeners: Map<string, unknown>;\n    constructor(name: string, keyPair: sodium.KeyPair);\n    /**\n     * start the client and make sure all dependencies are ready\n     */\n    start(): Promise<void>;\n    /**\n     * Get the pairing request information. This will be shared with the peer during the connection setup\n     */\n    getPairingRequestInfo(): Promise<PostMessagePairingRequest>;\n    /**\n     * Get the pairing response information. This will be shared with the peer during the connection setup\n     */\n    getPairingResponseInfo(request: PostMessagePairingRequest): Promise<PostMessagePairingResponse>;\n    /**\n     * Unsubscribe from encrypted messages from a specific peer\n     *\n     * @param senderPublicKey\n     */\n    unsubscribeFromEncryptedMessage(senderPublicKey: string): Promise<void>;\n    /**\n     * Unsubscribe from all encrypted messages\n     */\n    unsubscribeFromEncryptedMessages(): Promise<void>;\n    /**\n     * Decrypt a message from a specific peer\n     *\n     * @param senderPublicKey\n     * @param payload\n     */\n    protected decryptMessage(senderPublicKey: string, payload: string): Promise<string>;\n    /**\n     * Encrypt a message for a specific publicKey (receiver)\n     *\n     * @param recipientPublicKey\n     * @param message\n     */\n    protected encryptMessage(recipientPublicKey: string, message: string): Promise<string>;\n    /**\n     * Initialize the connection\n     */\n    abstract init(): Promise<void>;\n}\n"},{"name":"@airgap/beacon-sdk/transports/clients/P2PCommunicationClient.d.ts","dts":"import * as sodium from 'libsodium-wrappers';\nimport { MatrixClientEvent, MatrixClientEventType, MatrixClientEventMessageContent } from '../../matrix-client/models/MatrixClientEvent';\nimport { Storage } from '../../storage/Storage';\nimport { P2PPairingRequest } from '../..';\nimport { ExtendedP2PPairingResponse, P2PPairingResponse } from '../../types/P2PPairingResponse';\nimport { CommunicationClient } from './CommunicationClient';\nexport declare class P2PCommunicationClient extends CommunicationClient {\n    private readonly name;\n    readonly replicationCount: number;\n    private readonly storage;\n    private readonly iconUrl?;\n    private readonly appUrl?;\n    private readonly clients;\n    private readonly KNOWN_RELAY_SERVERS;\n    private readonly activeListeners;\n    constructor(name: string, keyPair: sodium.KeyPair, replicationCount: number, storage: Storage, matrixNodes: string[], iconUrl?: string | undefined, appUrl?: string | undefined);\n    getPairingRequestInfo(): Promise<P2PPairingRequest>;\n    getPairingResponseInfo(request: P2PPairingRequest): Promise<P2PPairingResponse>;\n    getRelayServer(publicKeyHash?: string, nonce?: string): Promise<string>;\n    start(): Promise<void>;\n    listenForEncryptedMessage(senderPublicKey: string, messageCallback: (message: string) => void): Promise<void>;\n    unsubscribeFromEncryptedMessage(senderPublicKey: string): Promise<void>;\n    unsubscribeFromEncryptedMessages(): Promise<void>;\n    sendMessage(message: string, peer: P2PPairingRequest | ExtendedP2PPairingResponse): Promise<void>;\n    deleteRoomIdFromRooms(roomId: string): Promise<void>;\n    listenForChannelOpening(messageCallback: (pairingResponse: ExtendedP2PPairingResponse) => void): Promise<void>;\n    sendPairingResponse(pairingRequest: P2PPairingRequest): Promise<void>;\n    isTextMessage(content: MatrixClientEventMessageContent<any>): content is MatrixClientEventMessageContent<string>;\n    isChannelOpenMessage(content: MatrixClientEventMessageContent<string>): Promise<boolean>;\n    isSender(event: MatrixClientEvent<MatrixClientEventType.MESSAGE>, senderPublicKey: string): Promise<boolean>;\n    private getAbsoluteBigIntDifference;\n    private getRelevantRoom;\n    private getRelevantJoinedRoom;\n}\n"},{"name":"@airgap/beacon-sdk/transports/clients/PostMessageClient.d.ts","dts":"import { ConnectionContext } from '../..';\nimport { ExtendedPostMessagePairingResponse } from '../../types/PostMessagePairingResponse';\nimport { EncryptedExtensionMessage } from '../../types/ExtensionMessage';\nimport { PostMessagePairingRequest } from '../../types/PostMessagePairingRequest';\nimport { MessageBasedClient } from './MessageBasedClient';\nexport declare class PostMessageClient extends MessageBasedClient {\n    protected readonly activeListeners: Map<string, (message: EncryptedExtensionMessage, context: ConnectionContext) => void>;\n    init(): Promise<void>;\n    listenForEncryptedMessage(senderPublicKey: string, messageCallback: (message: string, context: ConnectionContext) => void): Promise<void>;\n    sendMessage(message: string, peer: PostMessagePairingRequest | ExtendedPostMessagePairingResponse): Promise<void>;\n    listenForChannelOpening(messageCallback: (pairingResponse: ExtendedPostMessagePairingResponse) => void): Promise<void>;\n    sendPairingRequest(id: string): Promise<void>;\n    isChannelOpenMessage(message: any): Promise<boolean>;\n    private subscribeToMessages;\n}\n"},{"name":"@airgap/beacon-sdk/transports/DappP2PTransport.d.ts","dts":"import * as sodium from 'libsodium-wrappers';\nimport { Storage, StorageKey, P2PTransport } from '..';\nimport { ExtendedP2PPairingResponse } from '../types/P2PPairingResponse';\nexport declare class DappP2PTransport extends P2PTransport<ExtendedP2PPairingResponse, StorageKey.TRANSPORT_P2P_PEERS_DAPP> {\n    constructor(name: string, keyPair: sodium.KeyPair, storage: Storage, matrixNodes: string[], iconUrl?: string, appUrl?: string);\n    startOpenChannelListener(): Promise<void>;\n    listenForNewPeer(newPeerListener: (peer: ExtendedP2PPairingResponse) => void): Promise<void>;\n    stopListeningForNewPeers(): Promise<void>;\n}\n"},{"name":"@airgap/beacon-sdk/transports/DappPostMessageTransport.d.ts","dts":"import * as sodium from 'libsodium-wrappers';\nimport { StorageKey, PostMessageTransport, Storage } from '..';\nimport { ExtendedPostMessagePairingResponse } from '../types/PostMessagePairingResponse';\nexport declare class DappPostMessageTransport extends PostMessageTransport<ExtendedPostMessagePairingResponse, StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP> {\n    constructor(name: string, keyPair: sodium.KeyPair, storage: Storage);\n    startOpenChannelListener(): Promise<void>;\n    listenForNewPeer(newPeerListener: (peer: ExtendedPostMessagePairingResponse) => void): Promise<void>;\n    stopListeningForNewPeers(): Promise<void>;\n}\n"},{"name":"@airgap/beacon-sdk/transports/P2PTransport.d.ts","dts":"import * as sodium from 'libsodium-wrappers';\nimport { Storage, StorageKey, Transport, TransportType, P2PCommunicationClient, P2PPairingRequest } from '..';\nimport { ExtendedP2PPairingResponse } from '../types/P2PPairingResponse';\nexport declare class P2PTransport<T extends P2PPairingRequest | ExtendedP2PPairingResponse, K extends StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET> extends Transport<T, K, P2PCommunicationClient> {\n    readonly type: TransportType;\n    constructor(name: string, keyPair: sodium.KeyPair, storage: Storage, matrixNodes: string[], storageKey: K, iconUrl?: string, appUrl?: string);\n    static isAvailable(): Promise<boolean>;\n    connect(): Promise<void>;\n    startOpenChannelListener(): Promise<void>;\n    getPairingRequestInfo(): Promise<P2PPairingRequest>;\n    listen(publicKey: string): Promise<void>;\n}\n"},{"name":"@airgap/beacon-sdk/transports/PostMessageTransport.d.ts","dts":"import * as sodium from 'libsodium-wrappers';\nimport { PostMessagePairingRequest } from '../types/PostMessagePairingRequest';\nimport { ExtendedPostMessagePairingResponse } from '../types/PostMessagePairingResponse';\nimport { Extension } from '../types/Extension';\nimport { StorageKey } from '../types/storage/StorageKey';\nimport { TransportType } from '../types/transport/TransportType';\nimport { Storage } from '../storage/Storage';\nimport { PostMessageClient } from './clients/PostMessageClient';\nimport { Transport } from './Transport';\nexport declare class PostMessageTransport<T extends PostMessagePairingRequest | ExtendedPostMessagePairingResponse, K extends StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET> extends Transport<T, K, PostMessageClient> {\n    readonly type: TransportType;\n    constructor(name: string, keyPair: sodium.KeyPair, storage: Storage, storageKey: K);\n    static isAvailable(): Promise<boolean>;\n    static getAvailableExtensions(): Promise<Extension[]>;\n    connect(): Promise<void>;\n    startOpenChannelListener(): Promise<void>;\n    getPairingRequestInfo(): Promise<PostMessagePairingRequest>;\n    listen(publicKey: string): Promise<void>;\n}\n"},{"name":"@airgap/beacon-sdk/transports/Transport.d.ts","dts":"import { ConnectionContext } from '../types/ConnectionContext';\nimport { TransportType, TransportStatus, PeerInfo, StorageKey } from '..';\nimport { PeerManager } from '../managers/PeerManager';\nimport { CommunicationClient } from './clients/CommunicationClient';\nexport declare abstract class Transport<T extends PeerInfo = PeerInfo, K extends StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET = any, S extends CommunicationClient = any> {\n    /**\n     * The type of the transport\n     */\n    readonly type: TransportType;\n    /**\n     * The name of the app\n     */\n    protected readonly name: string;\n    /**\n     * The status of the transport\n     */\n    protected _isConnected: TransportStatus;\n    protected readonly peerManager: PeerManager<K>;\n    /**\n     * The client handling the encryption/decryption of messages\n     */\n    protected client: S;\n    /**\n     * The listener that will be invoked when a new peer is connected\n     */\n    protected newPeerListener?: (peer: T) => void;\n    /**\n     * The listeners that will be notified when new messages are coming in\n     */\n    private listeners;\n    /**\n     * Return the status of the connection\n     */\n    get connectionStatus(): TransportStatus;\n    constructor(name: string, client: S, peerManager: PeerManager<K>);\n    /**\n     * Returns a promise that resolves to true if the transport is available, false if it is not\n     */\n    static isAvailable(): Promise<boolean>;\n    /**\n     * Connect the transport\n     */\n    connect(): Promise<void>;\n    /**\n     * Send a message through the transport\n     *\n     * @param message The message to send\n     * @param recipient The recipient of the message\n     */\n    send(message: string, peer?: PeerInfo): Promise<void>;\n    /**\n     * Add a listener to be called when a new message is received\n     *\n     * @param listener The listener that will be registered\n     */\n    addListener(listener: (message: unknown, connectionInfo: ConnectionContext) => void): Promise<void>;\n    /**\n     * Remove a listener\n     *\n     * @param listener\n     */\n    removeListener(listener: (message: string, connectionInfo: ConnectionContext) => void): Promise<void>;\n    getPeers(): Promise<T[]>;\n    addPeer(newPeer: T): Promise<void>;\n    removePeer(peerToBeRemoved: T): Promise<void>;\n    removeAllPeers(): Promise<void>;\n    /**\n     * Notify the listeners when a new message comes in\n     *\n     * @param message Message\n     * @param connectionInfo Context info about the connection\n     */\n    protected notifyListeners(message: unknown, connectionInfo: ConnectionContext): Promise<void>;\n    abstract listen(publicKey: string): Promise<void>;\n}\n"},{"name":"@airgap/beacon-sdk/transports/WalletP2PTransport.d.ts","dts":"import * as sodium from 'libsodium-wrappers';\nimport { Storage, StorageKey, P2PTransport, P2PPairingRequest } from '..';\nexport declare class WalletP2PTransport extends P2PTransport<P2PPairingRequest, StorageKey.TRANSPORT_P2P_PEERS_WALLET> {\n    constructor(name: string, keyPair: sodium.KeyPair, storage: Storage, matrixNodes: string[], iconUrl?: string, appUrl?: string);\n    addPeer(newPeer: P2PPairingRequest): Promise<void>;\n}\n"},{"name":"@airgap/beacon-sdk/transports/WalletPostMessageTransport.d.ts","dts":"import * as sodium from 'libsodium-wrappers';\nimport { StorageKey, PostMessageTransport, Storage } from '..';\nimport { PostMessagePairingRequest } from '../types/PostMessagePairingRequest';\nexport declare class WalletPostMessageTransport extends PostMessageTransport<PostMessagePairingRequest, StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET> {\n    constructor(name: string, keyPair: sodium.KeyPair, storage: Storage);\n}\n"},{"name":"@airgap/beacon-sdk/types/beacon/messages/AcknowledgeResponse.d.ts","dts":"import { BeaconBaseMessage, BeaconMessageType } from '../../..';\nexport interface AcknowledgeResponse extends BeaconBaseMessage {\n    type: BeaconMessageType.Acknowledge;\n}\n"},{"name":"@airgap/beacon-sdk/types/beacon/messages/BeaconRequestInputMessage.d.ts","dts":"import { PermissionRequest, OperationRequest, SignPayloadRequest, BroadcastRequest } from '../../..';\nexport declare type IgnoredRequestInputProperties = 'id' | 'senderId' | 'version';\nexport declare type PermissionRequestInput = Omit<PermissionRequest, IgnoredRequestInputProperties>;\nexport declare type OperationRequestInput = Omit<OperationRequest, IgnoredRequestInputProperties>;\nexport declare type SignPayloadRequestInput = Omit<SignPayloadRequest, IgnoredRequestInputProperties>;\nexport declare type BroadcastRequestInput = Omit<BroadcastRequest, IgnoredRequestInputProperties>;\nexport declare type BeaconRequestInputMessage = PermissionRequestInput | OperationRequestInput | SignPayloadRequestInput | BroadcastRequestInput;\n"},{"name":"@airgap/beacon-sdk/types/beacon/messages/BeaconRequestOutputMessage.d.ts","dts":"import { AppMetadata, PermissionRequest, OperationRequest, SignPayloadRequest, BroadcastRequest } from '../../..';\nexport declare type IgnoredRequestOutputProperties = 'version';\nexport interface ExtraResponseOutputProperties {\n    appMetadata: AppMetadata;\n}\nexport declare type PermissionRequestOutput = Omit<PermissionRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\nexport declare type OperationRequestOutput = Omit<OperationRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\nexport declare type SignPayloadRequestOutput = Omit<SignPayloadRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\nexport declare type BroadcastRequestOutput = Omit<BroadcastRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\nexport declare type BeaconRequestOutputMessage = PermissionRequestOutput | OperationRequestOutput | SignPayloadRequestOutput | BroadcastRequestOutput;\n"},{"name":"@airgap/beacon-sdk/types/beacon/messages/BeaconResponseInputMessage.d.ts","dts":"import { PermissionResponse, OperationResponse, SignPayloadResponse, BroadcastResponse, AcknowledgeResponse, ErrorResponse } from '../../..';\nexport declare type IgnoredResponseInputProperties = 'senderId' | 'version' | 'appMetadata';\nexport declare type PermissionResponseInput = Omit<PermissionResponse, IgnoredResponseInputProperties>;\nexport declare type OperationResponseInput = Omit<OperationResponse, IgnoredResponseInputProperties>;\nexport declare type SignPayloadResponseInput = Omit<SignPayloadResponse, IgnoredResponseInputProperties>;\nexport declare type BroadcastResponseInput = Omit<BroadcastResponse, IgnoredResponseInputProperties>;\nexport declare type AcknowledgeResponseInput = Omit<AcknowledgeResponse, IgnoredResponseInputProperties>;\nexport declare type ErrorResponseInput = Omit<ErrorResponse, IgnoredResponseInputProperties>;\nexport declare type BeaconResponseInputMessage = PermissionResponseInput | OperationResponseInput | SignPayloadResponseInput | BroadcastResponseInput | AcknowledgeResponseInput | ErrorResponseInput;\n"},{"name":"@airgap/beacon-sdk/types/beacon/messages/BeaconResponseOutputMessage.d.ts","dts":"import { PermissionResponse, OperationResponse, SignPayloadResponse, BroadcastResponse, AccountInfo } from '../../..';\nexport declare type IgnoredResponseOutputProperties = 'id' | 'version' | 'type';\nexport declare type PermissionResponseOutput = PermissionResponse & {\n    address: string;\n    accountInfo: AccountInfo;\n};\nexport declare type OperationResponseOutput = OperationResponse;\nexport declare type SignPayloadResponseOutput = SignPayloadResponse;\nexport declare type BroadcastResponseOutput = BroadcastResponse;\nexport declare type BeaconResponseOutputMessage = PermissionResponseOutput | OperationResponseOutput | SignPayloadResponseOutput | BroadcastResponseOutput;\n"},{"name":"@airgap/beacon-sdk/types/beacon/messages/BroadcastRequest.d.ts","dts":"import { BeaconBaseMessage, BeaconMessageType, Network } from '../../..';\nexport interface BroadcastRequest extends BeaconBaseMessage {\n    type: BeaconMessageType.BroadcastRequest;\n    network: Network;\n    signedTransaction: string;\n}\n"},{"name":"@airgap/beacon-sdk/types/beacon/messages/BroadcastResponse.d.ts","dts":"import { BeaconBaseMessage, BeaconMessageType } from '../../..';\nexport interface BroadcastResponse extends BeaconBaseMessage {\n    type: BeaconMessageType.BroadcastResponse;\n    transactionHash: string;\n}\n"},{"name":"@airgap/beacon-sdk/types/beacon/messages/DisconnectMessage.d.ts","dts":"import { BeaconBaseMessage, BeaconMessageType } from '../../..';\nexport interface DisconnectMessage extends BeaconBaseMessage {\n    type: BeaconMessageType.Disconnect;\n}\n"},{"name":"@airgap/beacon-sdk/types/beacon/messages/ErrorResponse.d.ts","dts":"import { BeaconBaseMessage, BeaconErrorType, BeaconMessageType } from '../../..';\nexport interface ErrorResponse extends BeaconBaseMessage {\n    type: BeaconMessageType.Error;\n    errorType: BeaconErrorType;\n    errorData?: any;\n}\n"},{"name":"@airgap/beacon-sdk/types/beacon/messages/OperationRequest.d.ts","dts":"import { BeaconBaseMessage, BeaconMessageType, Network } from '../../..';\nimport { PartialTezosOperation } from '../../tezos/PartialTezosOperation';\nexport interface OperationRequest extends BeaconBaseMessage {\n    type: BeaconMessageType.OperationRequest;\n    network: Network;\n    operationDetails: PartialTezosOperation[];\n    sourceAddress: string;\n}\n"},{"name":"@airgap/beacon-sdk/types/beacon/messages/OperationResponse.d.ts","dts":"import { BeaconBaseMessage, BeaconMessageType } from '../../..';\nexport interface OperationResponse extends BeaconBaseMessage {\n    type: BeaconMessageType.OperationResponse;\n    transactionHash: string;\n}\n"},{"name":"@airgap/beacon-sdk/types/beacon/messages/PermissionRequest.d.ts","dts":"import { BeaconBaseMessage, BeaconMessageType, PermissionScope, AppMetadata, Network } from '../../..';\nexport interface PermissionRequest extends BeaconBaseMessage {\n    type: BeaconMessageType.PermissionRequest;\n    appMetadata: AppMetadata;\n    network: Network;\n    scopes: PermissionScope[];\n}\n"},{"name":"@airgap/beacon-sdk/types/beacon/messages/PermissionResponse.d.ts","dts":"import { AppMetadata, BeaconBaseMessage, BeaconMessageType, Network, PermissionScope, Threshold } from '../../..';\nexport interface PermissionResponse extends BeaconBaseMessage {\n    type: BeaconMessageType.PermissionResponse;\n    appMetadata: AppMetadata;\n    publicKey: string;\n    network: Network;\n    scopes: PermissionScope[];\n    threshold?: Threshold;\n}\n"},{"name":"@airgap/beacon-sdk/types/beacon/messages/SignPayloadRequest.d.ts","dts":"import { BeaconBaseMessage, BeaconMessageType, SigningType } from '../../..';\nexport interface SignPayloadRequest extends BeaconBaseMessage {\n    type: BeaconMessageType.SignPayloadRequest;\n    signingType: SigningType;\n    payload: string;\n    sourceAddress: string;\n}\n"},{"name":"@airgap/beacon-sdk/types/beacon/messages/SignPayloadResponse.d.ts","dts":"import { BeaconBaseMessage, BeaconMessageType, SigningType } from '../../..';\nexport interface SignPayloadResponse extends BeaconBaseMessage {\n    type: BeaconMessageType.SignPayloadResponse;\n    signingType: SigningType;\n    signature: string;\n}\n"},{"name":"@airgap/beacon-sdk/types/beacon/AppMetadata.d.ts","dts":"export interface AppMetadata {\n    senderId: string;\n    name: string;\n    icon?: string;\n}\n"},{"name":"@airgap/beacon-sdk/types/beacon/BeaconBaseMessage.d.ts","dts":"import { BeaconMessageType } from '../..';\nexport interface BeaconBaseMessage {\n    type: BeaconMessageType;\n    version: string;\n    id: string;\n    senderId: string;\n}\n"},{"name":"@airgap/beacon-sdk/types/beacon/BeaconMessage.d.ts","dts":"import { PermissionResponse, PermissionRequest, OperationRequest, OperationResponse, SignPayloadRequest, SignPayloadResponse, BroadcastRequest, BroadcastResponse, AcknowledgeResponse, DisconnectMessage, ErrorResponse } from '../..';\nexport declare type BeaconMessage = PermissionRequest | PermissionResponse | OperationRequest | OperationResponse | SignPayloadRequest | SignPayloadResponse | BroadcastRequest | BroadcastResponse | AcknowledgeResponse | DisconnectMessage | ErrorResponse;\n"},{"name":"@airgap/beacon-sdk/types/beacon/BeaconMessageType.d.ts","dts":"export declare enum BeaconMessageType {\n    PermissionRequest = \"permission_request\",\n    SignPayloadRequest = \"sign_payload_request\",\n    OperationRequest = \"operation_request\",\n    BroadcastRequest = \"broadcast_request\",\n    PermissionResponse = \"permission_response\",\n    SignPayloadResponse = \"sign_payload_response\",\n    OperationResponse = \"operation_response\",\n    BroadcastResponse = \"broadcast_response\",\n    Acknowledge = \"acknowledge\",\n    Disconnect = \"disconnect\",\n    Error = \"error\"\n}\n"},{"name":"@airgap/beacon-sdk/types/beacon/BeaconRequestMessage.d.ts","dts":"import { PermissionRequest, OperationRequest, SignPayloadRequest, BroadcastRequest } from '../..';\nexport declare type BeaconRequestMessage = PermissionRequest | OperationRequest | SignPayloadRequest | BroadcastRequest;\n"},{"name":"@airgap/beacon-sdk/types/beacon/BeaconResponseMessage.d.ts","dts":"import { PermissionResponse, OperationResponse, SignPayloadResponse, BroadcastResponse } from '../..';\nimport { ErrorResponse } from './messages/ErrorResponse';\nexport declare type BeaconResponseMessage = PermissionResponse | OperationResponse | SignPayloadResponse | BroadcastResponse | ErrorResponse;\n"},{"name":"@airgap/beacon-sdk/types/beacon/Network.d.ts","dts":"import { NetworkType } from '../..';\nexport interface Network {\n    type: NetworkType;\n    name?: string;\n    rpcUrl?: string;\n}\n"},{"name":"@airgap/beacon-sdk/types/beacon/NetworkType.d.ts","dts":"export declare enum NetworkType {\n    MAINNET = \"mainnet\",\n    DELPHINET = \"delphinet\",\n    EDONET = \"edonet\",\n    CUSTOM = \"custom\"\n}\n"},{"name":"@airgap/beacon-sdk/types/beacon/PermissionScope.d.ts","dts":"export declare enum PermissionScope {\n    SIGN = \"sign\",\n    OPERATION_REQUEST = \"operation_request\",\n    THRESHOLD = \"threshold\"\n}\n"},{"name":"@airgap/beacon-sdk/types/beacon/SigningType.d.ts","dts":"export declare enum SigningType {\n    RAW = \"raw\",\n    OPERATION = \"operation\",\n    MICHELINE = \"micheline\"\n}\n"},{"name":"@airgap/beacon-sdk/types/beacon/Threshold.d.ts","dts":"export interface Threshold {\n    amount: string;\n    timeframe: string;\n}\n"},{"name":"@airgap/beacon-sdk/types/storage/StorageKey.d.ts","dts":"export declare enum StorageKey {\n    TRANSPORT_P2P_PEERS_DAPP = \"beacon:communication-peers-dapp\",\n    TRANSPORT_P2P_PEERS_WALLET = \"beacon:communication-peers-wallet\",\n    TRANSPORT_POSTMESSAGE_PEERS_DAPP = \"beacon:postmessage-peers-dapp\",\n    TRANSPORT_POSTMESSAGE_PEERS_WALLET = \"beacon:postmessage-peers-wallet\",\n    ACCOUNTS = \"beacon:accounts\",\n    ACTIVE_ACCOUNT = \"beacon:active-account\",\n    ACTIVE_PEER = \"beacon:active-peer\",\n    BEACON_SDK_SECRET_SEED = \"beacon:sdk-secret-seed\",\n    APP_METADATA_LIST = \"beacon:app-metadata-list\",\n    PERMISSION_LIST = \"beacon:permissions\",\n    BEACON_SDK_VERSION = \"beacon:sdk_version\",\n    MATRIX_PRESERVED_STATE = \"beacon:sdk-matrix-preserved-state\",\n    MATRIX_PEER_ROOM_IDS = \"beacon:matrix-peer-rooms\"\n}\n"},{"name":"@airgap/beacon-sdk/types/storage/StorageKeyReturnDefaults.d.ts","dts":"import { StorageKey, StorageKeyReturnType } from '../..';\nexport declare type StorageKeyReturnDefaults = {\n    [key in StorageKey]: StorageKeyReturnType[key];\n};\nexport declare const defaultValues: StorageKeyReturnDefaults;\n"},{"name":"@airgap/beacon-sdk/types/storage/StorageKeyReturnType.d.ts","dts":"import { StorageKey, AccountInfo, AccountIdentifier, P2PPairingRequest, AppMetadata, PermissionInfo } from '../..';\nimport { MatrixState } from '../../matrix-client/MatrixClientStore';\nimport { ExtendedP2PPairingResponse } from '../P2PPairingResponse';\nimport { PostMessagePairingRequest } from '../PostMessagePairingRequest';\nimport { ExtendedPostMessagePairingResponse } from '../PostMessagePairingResponse';\nexport interface StorageKeyReturnType {\n    [StorageKey.TRANSPORT_P2P_PEERS_DAPP]: P2PPairingRequest[];\n    [StorageKey.TRANSPORT_P2P_PEERS_WALLET]: ExtendedP2PPairingResponse[];\n    [StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP]: PostMessagePairingRequest[];\n    [StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET]: ExtendedPostMessagePairingResponse[];\n    [StorageKey.ACCOUNTS]: AccountInfo[];\n    [StorageKey.ACTIVE_ACCOUNT]: AccountIdentifier | undefined;\n    [StorageKey.ACTIVE_PEER]: string | undefined;\n    [StorageKey.BEACON_SDK_SECRET_SEED]: string | undefined;\n    [StorageKey.APP_METADATA_LIST]: AppMetadata[];\n    [StorageKey.PERMISSION_LIST]: PermissionInfo[];\n    [StorageKey.BEACON_SDK_VERSION]: string | undefined;\n    [StorageKey.MATRIX_PRESERVED_STATE]: Partial<MatrixState>;\n    [StorageKey.MATRIX_PEER_ROOM_IDS]: {\n        [key: string]: string | undefined;\n    };\n}\n"},{"name":"@airgap/beacon-sdk/types/tezos/operations/ActivateAccount.d.ts","dts":"import { TezosBaseOperation, TezosOperationType } from '../../..';\nexport interface TezosActivateAccountOperation extends TezosBaseOperation {\n    kind: TezosOperationType.ACTIVATE_ACCOUNT;\n    pkh: string;\n    secret: string;\n}\n"},{"name":"@airgap/beacon-sdk/types/tezos/operations/Ballot.d.ts","dts":"import { TezosBaseOperation, TezosOperationType } from '../../..';\nexport interface TezosBallotOperation extends TezosBaseOperation {\n    kind: TezosOperationType.BALLOT;\n    source: string;\n    period: string;\n    proposal: string;\n    ballot: 'nay' | 'yay' | 'pass';\n}\n"},{"name":"@airgap/beacon-sdk/types/tezos/operations/Delegation.d.ts","dts":"import { TezosBaseOperation, TezosOperationType } from '../../..';\nexport interface TezosDelegationOperation extends TezosBaseOperation {\n    kind: TezosOperationType.DELEGATION;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    delegate?: string;\n}\n"},{"name":"@airgap/beacon-sdk/types/tezos/operations/DoubleBakingEvidence.d.ts","dts":"import { TezosBaseOperation, TezosOperationType, TezosBlockHeader } from '../../..';\nexport interface InlinedEndorsement {\n    branch: string;\n    operations: InlinedEndorsementContents;\n    signature?: string;\n}\nexport interface InlinedEndorsementContents {\n    kind: 'endorsement';\n    level: string;\n}\nexport interface TezosDoubleBakingEvidenceOperation extends TezosBaseOperation {\n    kind: TezosOperationType.DOUBLE_BAKING_EVIDENCE;\n    bh1: TezosBlockHeader;\n    bh2: TezosBlockHeader;\n}\n"},{"name":"@airgap/beacon-sdk/types/tezos/operations/DoubleEndorsementEvidence.d.ts","dts":"import { TezosBaseOperation, TezosOperationType } from '../../..';\nexport interface InlinedEndorsement {\n    branch: string;\n    operations: InlinedEndorsementContents;\n    signature?: string;\n}\nexport interface InlinedEndorsementContents {\n    kind: 'endorsement';\n    level: string;\n}\nexport interface TezosDoubleEndorsementEvidenceOperation extends TezosBaseOperation {\n    kind: TezosOperationType.DOUBLE_ENDORSEMENT_EVIDENCE;\n    op1: InlinedEndorsement;\n    op2: InlinedEndorsement;\n}\n"},{"name":"@airgap/beacon-sdk/types/tezos/operations/Endorsement.d.ts","dts":"import { TezosBaseOperation, TezosOperationType } from '../../..';\nexport interface TezosEndorsementOperation extends TezosBaseOperation {\n    kind: TezosOperationType.ENDORSEMENT;\n    level: string;\n}\n"},{"name":"@airgap/beacon-sdk/types/tezos/operations/Origination.d.ts","dts":"import { TezosBaseOperation, TezosOperationType } from '../../..';\nexport interface TezosOriginationOperation extends TezosBaseOperation {\n    kind: TezosOperationType.ORIGINATION;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    balance: string;\n    delegate?: string;\n    script: string;\n}\n"},{"name":"@airgap/beacon-sdk/types/tezos/operations/Proposal.d.ts","dts":"import { TezosBaseOperation, TezosOperationType } from '../../..';\nexport interface TezosProposalOperation extends TezosBaseOperation {\n    kind: TezosOperationType.PROPOSALS;\n    period: string;\n    proposals: string[];\n}\n"},{"name":"@airgap/beacon-sdk/types/tezos/operations/Reveal.d.ts","dts":"import { TezosBaseOperation, TezosOperationType } from '../../..';\nexport interface TezosRevealOperation extends TezosBaseOperation {\n    kind: TezosOperationType.REVEAL;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    public_key: string;\n}\n"},{"name":"@airgap/beacon-sdk/types/tezos/operations/SeedNonceRevelation.d.ts","dts":"import { TezosBaseOperation, TezosOperationType } from '../../..';\nexport interface TezosSeedNonceRevelationOperation extends TezosBaseOperation {\n    kind: TezosOperationType.SEED_NONCE_REVELATION;\n    level: string;\n    nonce: string;\n}\n"},{"name":"@airgap/beacon-sdk/types/tezos/operations/Transaction.d.ts","dts":"import { TezosBaseOperation, TezosOperationType, TezosTransactionParameters } from '../../..';\nexport interface TezosTransactionOperation extends TezosBaseOperation {\n    kind: TezosOperationType.TRANSACTION;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    amount: string;\n    destination: string;\n    parameters?: TezosTransactionParameters;\n}\n"},{"name":"@airgap/beacon-sdk/types/tezos/MichelineMichelsonV1Expression.d.ts","dts":"import { MichelsonPrimitives } from '../..';\nexport declare type MichelineMichelsonV1Expression = {\n    int: string;\n} | {\n    string: string;\n} | {\n    bytes: string;\n} | MichelineMichelsonV1Expression[] | {\n    prim: MichelsonPrimitives;\n    args?: MichelineMichelsonV1Expression[];\n    annots?: string[];\n};\n"},{"name":"@airgap/beacon-sdk/types/tezos/MichelsonPrimitives.d.ts","dts":"export declare type MichelsonPrimitives = 'ADD' | 'IF_NONE' | 'SWAP' | 'set' | 'nat' | 'CHECK_SIGNATURE' | 'IF_LEFT' | 'LAMBDA' | 'Elt' | 'CREATE_CONTRACT' | 'NEG' | 'big_map' | 'map' | 'or' | 'BLAKE2B' | 'bytes' | 'SHA256' | 'SET_DELEGATE' | 'CONTRACT' | 'LSL' | 'SUB' | 'IMPLICIT_ACCOUNT' | 'PACK' | 'list' | 'PAIR' | 'Right' | 'contract' | 'GT' | 'LEFT' | 'STEPS_TO_QUOTA' | 'storage' | 'TRANSFER_TOKENS' | 'CDR' | 'SLICE' | 'PUSH' | 'False' | 'SHA512' | 'CHAIN_ID' | 'BALANCE' | 'signature' | 'DUG' | 'SELF' | 'EMPTY_BIG_MAP' | 'LSR' | 'OR' | 'XOR' | 'lambda' | 'COMPARE' | 'key' | 'option' | 'Unit' | 'Some' | 'UNPACK' | 'NEQ' | 'INT' | 'pair' | 'AMOUNT' | 'DIP' | 'ABS' | 'ISNAT' | 'EXEC' | 'NOW' | 'LOOP' | 'chain_id' | 'string' | 'MEM' | 'MAP' | 'None' | 'address' | 'CONCAT' | 'EMPTY_SET' | 'MUL' | 'LOOP_LEFT' | 'timestamp' | 'LT' | 'UPDATE' | 'DUP' | 'SOURCE' | 'mutez' | 'SENDER' | 'IF_CONS' | 'RIGHT' | 'CAR' | 'CONS' | 'LE' | 'NONE' | 'IF' | 'SOME' | 'GET' | 'Left' | 'CAST' | 'int' | 'SIZE' | 'key_hash' | 'unit' | 'DROP' | 'EMPTY_MAP' | 'NIL' | 'DIG' | 'APPLY' | 'bool' | 'RENAME' | 'operation' | 'True' | 'FAILWITH' | 'parameter' | 'HASH_KEY' | 'EQ' | 'NOT' | 'UNIT' | 'Pair' | 'ADDRESS' | 'EDIV' | 'CREATE_ACCOUNT' | 'GE' | 'ITER' | 'code' | 'AND';\n"},{"name":"@airgap/beacon-sdk/types/tezos/OperationTypes.d.ts","dts":"export declare enum TezosOperationType {\n    ENDORSEMENT = \"endorsement\",\n    SEED_NONCE_REVELATION = \"seed_nonce_revelation\",\n    DOUBLE_ENDORSEMENT_EVIDENCE = \"double_endorsement_evidence\",\n    DOUBLE_BAKING_EVIDENCE = \"double_baking_evidence\",\n    ACTIVATE_ACCOUNT = \"activate_account\",\n    PROPOSALS = \"proposals\",\n    BALLOT = \"ballot\",\n    REVEAL = \"reveal\",\n    TRANSACTION = \"transaction\",\n    ORIGINATION = \"origination\",\n    DELEGATION = \"delegation\"\n}\n"},{"name":"@airgap/beacon-sdk/types/tezos/PartialTezosOperation.d.ts","dts":"import { TezosActivateAccountOperation } from './operations/ActivateAccount';\nimport { TezosBallotOperation } from './operations/Ballot';\nimport { TezosDelegationOperation } from './operations/Delegation';\nimport { TezosDoubleBakingEvidenceOperation } from './operations/DoubleBakingEvidence';\nimport { TezosEndorsementOperation } from './operations/Endorsement';\nimport { TezosOriginationOperation } from './operations/Origination';\nimport { TezosProposalOperation } from './operations/Proposal';\nimport { TezosRevealOperation } from './operations/Reveal';\nimport { TezosSeedNonceRevelationOperation } from './operations/SeedNonceRevelation';\nimport { TezosTransactionOperation } from './operations/Transaction';\ndeclare type omittedProperties = 'source' | 'fee' | 'counter' | 'gas_limit' | 'storage_limit';\nexport declare type PartialTezosDelegationOperation = Omit<TezosDelegationOperation, omittedProperties>;\nexport declare type PartialTezosOriginationOperation = Omit<TezosOriginationOperation, omittedProperties>;\nexport declare type PartialTezosRevealOperation = Omit<TezosRevealOperation, omittedProperties>;\nexport declare type PartialTezosTransactionOperation = Omit<TezosTransactionOperation, omittedProperties>;\nexport declare type PartialTezosOperation = TezosActivateAccountOperation | TezosBallotOperation | PartialTezosDelegationOperation | TezosDoubleBakingEvidenceOperation | TezosEndorsementOperation | PartialTezosOriginationOperation | TezosProposalOperation | PartialTezosRevealOperation | TezosSeedNonceRevelationOperation | PartialTezosTransactionOperation;\nexport {};\n"},{"name":"@airgap/beacon-sdk/types/tezos/TezosBaseOperation.d.ts","dts":"import { TezosOperationType } from '../..';\nexport interface TezosBaseOperation {\n    kind: TezosOperationType;\n}\n"},{"name":"@airgap/beacon-sdk/types/tezos/TezosBlockHeader.d.ts","dts":"export interface TezosBlockHeader {\n    level: number;\n    proto: number;\n    predecessor: string;\n    timestamp: string;\n    validation_pass: number;\n    operations_hash: string;\n    fitness: string[];\n    context: string;\n    priority: number;\n    proof_of_work_nonce: string;\n    signature: string;\n}\n"},{"name":"@airgap/beacon-sdk/types/tezos/TezosOperation.d.ts","dts":"import { TezosActivateAccountOperation, TezosBallotOperation, TezosDelegationOperation, TezosDoubleBakingEvidenceOperation, TezosEndorsementOperation, TezosOriginationOperation, TezosProposalOperation, TezosRevealOperation, TezosSeedNonceRevelationOperation, TezosTransactionOperation } from '../..';\nexport declare type TezosOperation = TezosActivateAccountOperation | TezosBallotOperation | TezosDelegationOperation | TezosDoubleBakingEvidenceOperation | TezosEndorsementOperation | TezosOriginationOperation | TezosProposalOperation | TezosRevealOperation | TezosSeedNonceRevelationOperation | TezosTransactionOperation;\n"},{"name":"@airgap/beacon-sdk/types/tezos/TezosTransactionParameters.d.ts","dts":"import { MichelineMichelsonV1Expression } from './MichelineMichelsonV1Expression';\nexport interface TezosTransactionParameters {\n    entrypoint: 'default' | 'root' | 'do' | 'set_delegate' | 'remove_delegate' | string;\n    value: MichelineMichelsonV1Expression;\n}\n"},{"name":"@airgap/beacon-sdk/types/transport/TransportStatus.d.ts","dts":"export declare enum TransportStatus {\n    NOT_CONNECTED = \"NOT_CONNECTED\",\n    CONNECTING = \"CONNECTING\",\n    CONNECTED = \"CONNECTED\"\n}\n"},{"name":"@airgap/beacon-sdk/types/transport/TransportType.d.ts","dts":"export declare enum TransportType {\n    CHROME_MESSAGE = \"chrome_message\",\n    POST_MESSAGE = \"post_message\",\n    LEDGER = \"ledger\",\n    P2P = \"p2p\"\n}\n"},{"name":"@airgap/beacon-sdk/types/AccountInfo.d.ts","dts":"import { Origin } from '..';\nimport { PermissionEntity } from './PermissionEntity';\nexport declare type AccountIdentifier = string;\nexport interface AccountInfo extends PermissionEntity {\n    accountIdentifier: AccountIdentifier;\n    senderId: string;\n    origin: {\n        type: Origin;\n        id: string;\n    };\n    publicKey: string;\n    connectedAt: number;\n}\n"},{"name":"@airgap/beacon-sdk/types/BeaconErrorType.d.ts","dts":"export declare enum BeaconErrorType {\n    BROADCAST_ERROR = \"BROADCAST_ERROR\",\n    NETWORK_NOT_SUPPORTED = \"NETWORK_NOT_SUPPORTED\",\n    NO_ADDRESS_ERROR = \"NO_ADDRESS_ERROR\",\n    NO_PRIVATE_KEY_FOUND_ERROR = \"NO_PRIVATE_KEY_FOUND_ERROR\",\n    NOT_GRANTED_ERROR = \"NOT_GRANTED_ERROR\",\n    PARAMETERS_INVALID_ERROR = \"PARAMETERS_INVALID_ERROR\",\n    TOO_MANY_OPERATIONS = \"TOO_MANY_OPERATIONS\",\n    TRANSACTION_INVALID_ERROR = \"TRANSACTION_INVALID_ERROR\",\n    SIGNATURE_TYPE_NOT_SUPPORTED = \"SIGNATURE_TYPE_NOT_SUPPORTED\",\n    ABORTED_ERROR = \"ABORTED_ERROR\",\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\"\n}\n"},{"name":"@airgap/beacon-sdk/types/ColorMode.d.ts","dts":"export declare enum ColorMode {\n    LIGHT = \"light\",\n    DARK = \"dark\"\n}\n"},{"name":"@airgap/beacon-sdk/types/ConnectionContext.d.ts","dts":"/// <reference types=\"chrome\" />\nimport { Origin } from '..';\nexport interface ConnectionContext {\n    origin: Origin;\n    id: string;\n    extras?: {\n        sender: chrome.runtime.MessageSender;\n        sendResponse(response?: unknown): void;\n    };\n}\n"},{"name":"@airgap/beacon-sdk/types/Extension.d.ts","dts":"export interface Extension {\n    id: string;\n    name: string;\n    shortName?: string;\n    iconUrl?: string;\n    color?: string;\n}\n"},{"name":"@airgap/beacon-sdk/types/ExtensionMessage.d.ts","dts":"import { ExtensionMessageTarget } from '..';\nexport interface ExtensionMessage<T, U = unknown> {\n    target: ExtensionMessageTarget;\n    targetId?: string;\n    sender?: U;\n    payload: T;\n}\nexport interface EncryptedExtensionMessage<U = unknown> {\n    target: ExtensionMessageTarget;\n    targetId?: string;\n    sender?: U;\n    encryptedPayload: string;\n}\n"},{"name":"@airgap/beacon-sdk/types/ExtensionMessageTarget.d.ts","dts":"export declare enum ExtensionMessageTarget {\n    BACKGROUND = \"toBackground\",\n    PAGE = \"toPage\",\n    EXTENSION = \"toExtension\"\n}\n"},{"name":"@airgap/beacon-sdk/types/Origin.d.ts","dts":"export declare enum Origin {\n    WEBSITE = \"website\",\n    EXTENSION = \"extension\",\n    P2P = \"p2p\"\n}\n"},{"name":"@airgap/beacon-sdk/types/P2PPairingRequest.d.ts","dts":"import { PeerInfo } from './PeerInfo';\nexport interface P2PPairingRequest extends PeerInfo {\n    id: string;\n    type: 'p2p-pairing-request';\n    name: string;\n    publicKey: string;\n    relayServer: string;\n    icon?: string;\n    appUrl?: string;\n}\nexport declare type ExtendedP2PPairingRequest = P2PPairingRequest & {\n    senderId: string;\n};\n"},{"name":"@airgap/beacon-sdk/types/P2PPairingResponse.d.ts","dts":"import { PeerInfo } from './PeerInfo';\nexport interface P2PPairingResponse extends PeerInfo {\n    id: string;\n    type: 'p2p-pairing-response';\n    name: string;\n    publicKey: string;\n    relayServer: string;\n    icon?: string;\n    appUrl?: string;\n}\nexport declare type ExtendedP2PPairingResponse = P2PPairingResponse & {\n    senderId: string;\n};\n"},{"name":"@airgap/beacon-sdk/types/PeerInfo.d.ts","dts":"export interface PeerInfo {\n    name: string;\n    publicKey: string;\n    version: string;\n}\nexport declare type ExtendedPeerInfo = PeerInfo & {\n    senderId: string;\n};\n"},{"name":"@airgap/beacon-sdk/types/PermissionEntity.d.ts","dts":"import { Network, PermissionScope, Threshold } from '..';\nexport interface PermissionEntity {\n    address: string;\n    network: Network;\n    scopes: PermissionScope[];\n    threshold?: Threshold;\n}\n"},{"name":"@airgap/beacon-sdk/types/PermissionInfo.d.ts","dts":"import { AppMetadata } from '..';\nimport { PermissionEntity } from './PermissionEntity';\nexport interface PermissionInfo extends PermissionEntity {\n    accountIdentifier: string;\n    senderId: string;\n    appMetadata: AppMetadata;\n    website: string;\n    publicKey: string;\n    connectedAt: number;\n}\n"},{"name":"@airgap/beacon-sdk/types/PostMessagePairingRequest.d.ts","dts":"import { PeerInfo } from './PeerInfo';\nexport interface PostMessagePairingRequest extends PeerInfo {\n    id: string;\n    type: 'postmessage-pairing-request';\n    name: string;\n    publicKey: string;\n    icon?: string;\n    appUrl?: string;\n}\nexport declare type ExtendedPostMessagePairingRequest = PostMessagePairingRequest & {\n    senderId: string;\n};\n"},{"name":"@airgap/beacon-sdk/types/PostMessagePairingResponse.d.ts","dts":"import { PeerInfo } from './PeerInfo';\nexport interface PostMessagePairingResponse extends PeerInfo {\n    id: string;\n    type: 'postmessage-pairing-response';\n    name: string;\n    publicKey: string;\n    icon?: string;\n    appUrl?: string;\n}\nexport declare type ExtendedPostMessagePairingResponse = PostMessagePairingResponse & {\n    senderId: string;\n    extensionId: string;\n};\n"},{"name":"@airgap/beacon-sdk/types/RequestBroadcastInput.d.ts","dts":"import { Network } from '..';\nexport interface RequestBroadcastInput {\n    network?: Network;\n    signedTransaction: string;\n}\n"},{"name":"@airgap/beacon-sdk/types/RequestOperationInput.d.ts","dts":"import { PartialTezosOperation } from './tezos/PartialTezosOperation';\nexport interface RequestOperationInput {\n    operationDetails: PartialTezosOperation[];\n}\n"},{"name":"@airgap/beacon-sdk/types/RequestPermissionInput.d.ts","dts":"import { Network, PermissionScope } from '..';\nexport interface RequestPermissionInput {\n    network?: Network;\n    scopes?: PermissionScope[];\n}\n"},{"name":"@airgap/beacon-sdk/types/RequestSignPayloadInput.d.ts","dts":"import { SigningType } from '..';\nexport interface RequestSignPayloadInput {\n    signingType?: SigningType;\n    payload: string;\n    sourceAddress?: string;\n}\n"},{"name":"@airgap/beacon-sdk/ui/alert/Alert.d.ts","dts":"import { NetworkType } from '../..';\nexport interface AlertButton {\n    text: string;\n    style?: 'solid' | 'outline';\n    actionCallback?(): Promise<void>;\n}\nexport interface AlertConfig {\n    title: string;\n    body?: string;\n    timer?: number;\n    buttons?: AlertButton[];\n    pairingPayload?: {\n        p2pSyncCode: string;\n        postmessageSyncCode: string;\n        preferredNetwork: NetworkType;\n    };\n    closeButtonCallback?(): void;\n}\n/**\n * Close an alert by ID\n *\n * @param id ID of alert\n */\ndeclare const closeAlert: (id: string) => Promise<void>;\n/**\n * Close all alerts\n */\ndeclare const closeAlerts: () => Promise<void>;\n/**\n * Show an alert\n *\n * @param alertConfig The configuration of the alert\n */\ndeclare const openAlert: (alertConfig: AlertConfig) => Promise<string>;\nexport { closeAlert, closeAlerts, openAlert };\n"},{"name":"@airgap/beacon-sdk/ui/alert/Pairing.d.ts","dts":"import { NetworkType } from '../..';\nexport declare enum Platform {\n    DESKTOP = 0,\n    IOS = 1,\n    ANDROID = 2\n}\nexport declare enum WalletType {\n    IOS = \"ios\",\n    ANDROID = \"android\",\n    EXTENSION = \"extension\",\n    DESKTOP = \"desktop\",\n    WEB = \"web\"\n}\nexport interface AppBase {\n    name: string;\n    shortName: string;\n    color: string;\n    logo: string;\n}\nexport interface ExtensionApp extends AppBase {\n    id: string;\n    link: string;\n}\nexport interface WebApp extends AppBase {\n    links: {\n        [NetworkType.MAINNET]: string;\n        [NetworkType.DELPHINET]?: string;\n        [NetworkType.EDONET]?: string;\n        [NetworkType.CUSTOM]?: string;\n    };\n}\nexport interface DesktopApp extends AppBase {\n    deepLink: string;\n}\nexport interface App extends AppBase {\n    universalLink: string;\n    deepLink?: string;\n}\nexport interface PairingAlertWallet {\n    name: string;\n    shortName?: string;\n    color?: string;\n    logo?: string;\n    enabled: boolean;\n    clickHandler(): void;\n}\nexport interface PairingAlertButton {\n    title: string;\n    text: string;\n    clickHandler(): void;\n}\nexport interface PairingAlertList {\n    title: string;\n    type: WalletType;\n    wallets: PairingAlertWallet[];\n}\nexport interface PairingAlertInfo {\n    walletLists: PairingAlertList[];\n    buttons: PairingAlertButton[];\n    qrData: string;\n}\nexport declare type StatusUpdateHandler = (walletType: WalletType, app?: PairingAlertWallet) => void;\nexport declare class Pairing {\n    static getPlatfrom(): Promise<Platform>;\n    static getPairingInfo(pairingPayload: {\n        p2pSyncCode: string;\n        postmessageSyncCode: string;\n        preferredNetwork: NetworkType;\n    }, statusUpdateHandler: StatusUpdateHandler, platform?: Platform): Promise<PairingAlertInfo>;\n    private static getDesktopPairingAlert;\n    private static getIOSPairingAlert;\n    private static getAndroidPairingAlert;\n    private static getWebList;\n}\n"},{"name":"@airgap/beacon-sdk/ui/alert/PairingAlert.d.ts","dts":"import { NetworkType } from '../..';\nexport declare const preparePairingAlert: (shadowRoot: ShadowRoot, pairingPayload: {\n    p2pSyncCode: string;\n    postmessageSyncCode: string;\n    preferredNetwork: NetworkType;\n}) => Promise<void>;\n"},{"name":"@airgap/beacon-sdk/ui/alert/alert-templates.d.ts","dts":"export declare const alertTemplates: {\n    container: string;\n    default: {\n        html: string;\n        css: string;\n    };\n    pair: {\n        html: string;\n        css: string;\n    };\n};\n"},{"name":"@airgap/beacon-sdk/ui/alert/wallet-lists.d.ts","dts":"import { App, DesktopApp, ExtensionApp, WebApp } from './Pairing';\nexport declare const extensionList: ExtensionApp[];\nexport declare const desktopList: DesktopApp[];\nexport declare const webList: WebApp[];\nexport declare const iOSList: App[];\n"},{"name":"@airgap/beacon-sdk/ui/toast/Toast.d.ts","dts":"import { WalletInfo } from '../../events';\nexport interface ToastAction {\n    text: string;\n    actionText?: string;\n    actionCallback?(): Promise<void>;\n}\nexport interface ToastConfig {\n    body: string;\n    timer?: number;\n    forceNew?: boolean;\n    state: 'loading' | 'acknowledge' | 'finished';\n    actions?: ToastAction[];\n    walletInfo?: WalletInfo;\n}\n/**\n * Close a toast\n */\ndeclare const closeToast: () => Promise<void>;\n/**\n * Create a new toast\n *\n * @param toastConfig Configuration of the toast\n */\ndeclare const openToast: (toastConfig: ToastConfig) => Promise<void>;\nexport { closeToast, openToast };\n"},{"name":"@airgap/beacon-sdk/ui/toast/toast-templates.d.ts","dts":"export declare const toastTemplates: {\n    default: {\n        html: string;\n        css: string;\n        poweredByBeacon: string;\n    };\n};\n"},{"name":"@airgap/beacon-sdk/utils/Logger.d.ts","dts":"/**\n * The logger that is used internally\n */\nexport declare class Logger {\n    private readonly name;\n    constructor(service: string);\n    debug(method: string, ...args: any[]): void;\n    log(method: string, ...args: any[]): void;\n    warn(method: string, ...args: any[]): void;\n    error(method: string, ...args: any[]): void;\n    private _log;\n}\n"},{"name":"@airgap/beacon-sdk/utils/assert-never.d.ts","dts":"/**\n * A helper function to make sure if/elses and switch/cases are exhaustive\n *\n * @param empty The data that has to be empty\n */\nexport declare function assertNever(empty: never): never;\n"},{"name":"@airgap/beacon-sdk/utils/available-transports.d.ts","dts":"/**\n * An object with promises to indicate whether or not that transport is available.\n */\nexport declare const availableTransports: {\n    extension: Promise<boolean>;\n    availableExtensions: Promise<import(\"../types/Extension\").Extension[]>;\n};\n"},{"name":"@airgap/beacon-sdk/utils/block-explorer.d.ts","dts":"import { Network, NetworkType } from '..';\nexport declare abstract class BlockExplorer {\n    readonly rpcUrls: {\n        [key in NetworkType]: string;\n    };\n    constructor(rpcUrls: {\n        [key in NetworkType]: string;\n    });\n    protected getLinkForNetwork(network: Network): Promise<string>;\n    /**\n     * Return a blockexplorer link for an address\n     *\n     * @param address The address to be opened\n     * @param network The network that was used\n     */\n    abstract getAddressLink(address: string, network: Network): Promise<string>;\n    /**\n     * Return a blockexplorer link for a transaction hash\n     *\n     * @param transactionId The hash of the transaction\n     * @param network The network that was used\n     */\n    abstract getTransactionLink(transactionId: string, network: Network): Promise<string>;\n}\n"},{"name":"@airgap/beacon-sdk/utils/crypto.d.ts","dts":"/// <reference types=\"node\" />\nimport * as sodium from 'libsodium-wrappers';\n/**\n * Convert a value to hex\n *\n * @param value\n */\nexport declare function toHex(value: any): string;\n/**\n * Get the hex hash of a value\n *\n * @param key\n */\nexport declare function getHexHash(key: string | Buffer | Uint8Array): Promise<string>;\n/**\n * Get a keypair from a seed\n *\n * @param seed\n */\nexport declare function getKeypairFromSeed(seed: string): Promise<sodium.KeyPair>;\n/**\n * Encrypt a message with a shared key\n *\n * @param message\n * @param sharedKey\n */\nexport declare function encryptCryptoboxPayload(message: string, sharedKey: Uint8Array): Promise<string>;\n/**\n * Decrypt a message with a shared key\n *\n * @param payload\n * @param sharedKey\n */\nexport declare function decryptCryptoboxPayload(payload: Uint8Array, sharedKey: Uint8Array): Promise<string>;\n/**\n * Encrypt a message with a public key\n *\n * @param payload\n * @param publicKey\n */\nexport declare function sealCryptobox(payload: string | Buffer, publicKey: Uint8Array): Promise<string>;\n/**\n * Decrypt a message with public + private key\n *\n * @param encryptedPayload\n * @param publicKey\n * @param privateKey\n */\nexport declare function openCryptobox(encryptedPayload: string | Buffer, publicKey: Uint8Array, privateKey: Uint8Array): Promise<string>;\n/**\n * Get an address from the public key\n *\n * @param publicKey\n */\nexport declare function getAddressFromPublicKey(publicKey: string): Promise<string>;\n/**\n * Get the recipient string used in the matrix message\n *\n * @param recipientHash\n * @param relayServer\n */\nexport declare function recipientString(recipientHash: string, relayServer: string): string;\n"},{"name":"@airgap/beacon-sdk/utils/exposed-promise.d.ts","dts":"export declare enum ExposedPromiseStatus {\n    PENDING = \"pending\",\n    RESOLVED = \"resolved\",\n    REJECTED = \"rejected\"\n}\ndeclare type Resolve<T> = (value?: T) => void;\ndeclare type Reject<U> = (reason?: U) => void;\n/**\n * Exposed promise allow you to create a promise and then resolve it later, from the outside\n */\nexport declare class ExposedPromise<T = unknown, U = unknown> {\n    private readonly _promise;\n    private _resolve;\n    private _reject;\n    private _status;\n    private _promiseResult;\n    private _promiseError;\n    get promise(): Promise<T>;\n    get resolve(): Resolve<T>;\n    get reject(): Reject<U>;\n    get status(): ExposedPromiseStatus;\n    get promiseResult(): T | undefined;\n    get promiseError(): U | undefined;\n    constructor();\n    static resolve<T>(value?: T): ExposedPromise<T>;\n    static reject<T = never, U = unknown>(reason?: U): ExposedPromise<T, U>;\n    isPending(): boolean;\n    isResolved(): boolean;\n    isRejected(): boolean;\n    isSettled(): boolean;\n}\nexport {};\n"},{"name":"@airgap/beacon-sdk/utils/generate-uuid.d.ts","dts":"/**\n * Generate a random GUID\n */\nexport declare function generateGUID(): Promise<string>;\n"},{"name":"@airgap/beacon-sdk/utils/get-account-identifier.d.ts","dts":"import { Network } from '..';\n/**\n * Generate a deterministic account identifier based on an address and a network\n *\n * @param address\n * @param network\n */\nexport declare const getAccountIdentifier: (address: string, network: Network) => Promise<string>;\n"},{"name":"@airgap/beacon-sdk/utils/get-sender-id.d.ts","dts":"/**\n * Generate a deterministic sender identifier based on a public key\n *\n * @param publicKey\n */\nexport declare const getSenderId: (publicKey: string) => Promise<string>;\n"},{"name":"@airgap/beacon-sdk/utils/get-tzip10-link.d.ts","dts":"export declare const getTzip10Link: (url: string, payload: string) => string;\n"},{"name":"@airgap/beacon-sdk/utils/platform.d.ts","dts":"export declare const testUserAgent: (win: Window, expr: RegExp) => boolean;\nexport declare const isMobile: (win: Window) => boolean;\nexport declare const isIOS: (win: Window) => boolean;\nexport declare const isAndroid: (win: Window) => boolean;\nexport declare const isDesktop: (win: Window) => boolean;\n"},{"name":"@airgap/beacon-sdk/utils/qr.d.ts","dts":"/**\n * Convert data to a QR code\n *\n * @param payload The data to be encoded as a QR code\n * @param type How the QR code will be encoded\n */\nexport declare const getQrData: (payload: string, type?: \"data\" | \"svg\" | \"ascii\" | undefined) => string;\n"},{"name":"@airgap/beacon-sdk/utils/replace-in-template.d.ts","dts":"export declare const replaceInTemplate: (text: string, placeholder: string, value: string) => string;\n"},{"name":"@airgap/beacon-sdk/utils/shorten-string.d.ts","dts":"export declare const shortenString: (text: string) => string;\n"},{"name":"@airgap/beacon-sdk/utils/tezblock-blockexplorer.d.ts","dts":"import { Network, NetworkType } from '..';\nimport { BlockExplorer } from './block-explorer';\nexport declare class TezblockBlockExplorer extends BlockExplorer {\n    readonly rpcUrls: {\n        [key in NetworkType]: string;\n    };\n    constructor(rpcUrls?: {\n        [key in NetworkType]: string;\n    });\n    getAddressLink(address: string, network: Network): Promise<string>;\n    getTransactionLink(transactionId: string, network: Network): Promise<string>;\n}\n"},{"name":"@airgap/beacon-sdk/utils/utils.d.ts","dts":"/**\n * A helper function to improve typings of object keys\n *\n * @param obj Object\n */\nexport declare function keys<O extends object>(obj: O): (keyof O)[];\n"},{"name":"@airgap/beacon-sdk/MockWindow.d.ts","dts":"declare type Callback = (message: unknown) => void;\n/**\n * A mock for postmessage if run in node.js environment\n */\ndeclare let windowRef: {\n    postMessage: (message: string | Record<string, unknown>, _target?: string | undefined) => void;\n    addEventListener: (_name: string, eventCallback: Callback) => void;\n    removeEventListener: (_name: string, eventCallback: Callback) => void;\n    location: {\n        origin: string;\n    };\n};\ndeclare const clearMockWindowState: () => void;\nexport { windowRef, clearMockWindowState };\n"},{"name":"@airgap/beacon-sdk/Serializer.d.ts","dts":"/**\n * The Serializer is used to serialize / deserialize JSON objects and encode them with bs58check\n */\nexport declare class Serializer {\n    /**\n     * Serialize and bs58check encode an object\n     *\n     * @param message JSON object to serialize\n     */\n    serialize(message: unknown): Promise<string>;\n    /**\n     * Deserialize a bs58check encoded string\n     *\n     * @param encoded String to be deserialized\n     */\n    deserialize(encoded: string): Promise<unknown>;\n}\n"},{"name":"@airgap/beacon-sdk/beacon-message-events.d.ts","dts":"import { BeaconEvent } from './events';\nimport { BeaconMessageType } from '.';\nexport declare const messageEvents: {\n    [key in BeaconMessageType]: {\n        sent: BeaconEvent;\n        success: BeaconEvent;\n        error: BeaconEvent;\n    };\n};\n"},{"name":"@airgap/beacon-sdk/colorMode.d.ts","dts":"import { ColorMode } from './types/ColorMode';\nexport declare const setColorMode: (mode: ColorMode) => void;\nexport declare const getColorMode: () => ColorMode;\n"},{"name":"@airgap/beacon-sdk/constants.d.ts","dts":"export declare const SDK_VERSION: string;\nexport declare const BEACON_VERSION: string;\n"},{"name":"@airgap/beacon-sdk/debug.d.ts","dts":"export declare const setDebugEnabled: (enabled: boolean) => void;\nexport declare const getDebugEnabled: () => boolean;\n"},{"name":"@airgap/beacon-sdk/dts-bundle.tmp.test.d.ts","dts":"export * from './beacon-message-events';\nexport * from './clients/beacon-client/BeaconClient';\nexport * from './clients/beacon-client/BeaconClientOptions';\nexport * from './clients/client/Client';\nexport * from './clients/client/ClientOptions';\nexport * from './clients/dapp-client/DAppClient';\nexport * from './clients/dapp-client/DAppClientOptions';\nexport * from './clients/wallet-client/WalletClient';\nexport * from './clients/wallet-client/WalletClientOptions';\nexport * from './colorMode';\nexport * from './constants';\nexport * from './debug';\nexport * from './errors/AbortedBeaconError';\nexport * from './errors/BeaconError';\nexport * from './errors/BroadcastBeaconError';\nexport * from './errors/NetworkNotSupportedBeaconError';\nexport * from './errors/NoAddressBeaconError';\nexport * from './errors/NoPrivateKeyBeaconError';\nexport * from './errors/NotGrantedBeaconError';\nexport * from './errors/ParametersInvalidBeaconError';\nexport * from './errors/SignatureTypeNotSupportedBeaconError';\nexport * from './errors/TooManyOperationsBeaconError';\nexport * from './errors/TransactionInvalidBeaconError';\nexport * from './errors/UnknownBeaconError';\nexport * from './events';\nexport * from './examples/broadcast-request';\nexport * from './examples/custom-block-explorer';\nexport * from './examples/disable-all-ui';\nexport * from './examples/operation-request';\nexport * from './examples/override-default-events';\nexport * from './examples/permission-request';\nexport * from './examples/sign-payload-request';\nexport * from './examples/using-custom-network';\nexport * from './examples/wallet-example';\nexport * from './index';\nexport * from './interceptors/IncomingRequestInterceptor';\nexport * from './interceptors/OutgoingResponseInterceptor';\nexport * from './managers/AccountManager';\nexport * from './managers/AppMetadataManager';\nexport * from './managers/PeerManager';\nexport * from './managers/PermissionManager';\nexport * from './managers/PermissionValidator';\nexport * from './managers/StorageManager';\nexport * from './matrix-client/MatrixClient';\nexport * from './matrix-client/MatrixClientEventEmitter';\nexport * from './matrix-client/MatrixClientStore';\nexport * from './matrix-client/MatrixHttpClient';\nexport * from './matrix-client/models/api/MatrixEventSend';\nexport * from './matrix-client/models/api/MatrixLogin';\nexport * from './matrix-client/models/api/MatrixRequest';\nexport * from './matrix-client/models/api/MatrixRoomCreate';\nexport * from './matrix-client/models/api/MatrixRoomInvite';\nexport * from './matrix-client/models/api/MatrixRoomJoin';\nexport * from './matrix-client/models/api/MatrixSync';\nexport * from './matrix-client/models/MatrixClientEvent';\nexport * from './matrix-client/models/MatrixMessage';\nexport * from './matrix-client/models/MatrixRoom';\nexport * from './matrix-client/models/MatrixStateEvent';\nexport * from './matrix-client/services/MatrixEventService';\nexport * from './matrix-client/services/MatrixRoomService';\nexport * from './matrix-client/services/MatrixUserService';\nexport * from './matrix-client/utils/events';\nexport * from './migrations/migrate-0.7.0';\nexport * from './migrations/migrations';\nexport * from './MockWindow';\nexport * from './scripts/index';\nexport * from './Serializer';\nexport * from './storage/ChromeStorage';\nexport * from './storage/getStorage';\nexport * from './storage/LocalStorage';\nexport * from './storage/Storage';\nexport * from './test';\nexport * from './transports/clients/CommunicationClient';\nexport * from './transports/clients/MessageBasedClient';\nexport * from './transports/clients/P2PCommunicationClient';\nexport * from './transports/clients/PostMessageClient';\nexport * from './transports/DappP2PTransport';\nexport * from './transports/DappPostMessageTransport';\nexport * from './transports/P2PTransport';\nexport * from './transports/PostMessageTransport';\nexport * from './transports/Transport';\nexport * from './transports/WalletP2PTransport';\nexport * from './transports/WalletPostMessageTransport';\nexport * from './types/AccountInfo';\nexport * from './types/beacon/AppMetadata';\nexport * from './types/beacon/BeaconBaseMessage';\nexport * from './types/beacon/BeaconMessage';\nexport * from './types/beacon/BeaconMessageType';\nexport * from './types/beacon/BeaconRequestMessage';\nexport * from './types/beacon/BeaconResponseMessage';\nexport * from './types/beacon/messages/AcknowledgeResponse';\nexport * from './types/beacon/messages/BeaconRequestInputMessage';\nexport * from './types/beacon/messages/BeaconRequestOutputMessage';\nexport * from './types/beacon/messages/BeaconResponseInputMessage';\nexport * from './types/beacon/messages/BeaconResponseOutputMessage';\nexport * from './types/beacon/messages/BroadcastRequest';\nexport * from './types/beacon/messages/BroadcastResponse';\nexport * from './types/beacon/messages/DisconnectMessage';\nexport * from './types/beacon/messages/ErrorResponse';\nexport * from './types/beacon/messages/OperationRequest';\nexport * from './types/beacon/messages/OperationResponse';\nexport * from './types/beacon/messages/PermissionRequest';\nexport * from './types/beacon/messages/PermissionResponse';\nexport * from './types/beacon/messages/SignPayloadRequest';\nexport * from './types/beacon/messages/SignPayloadResponse';\nexport * from './types/beacon/Network';\nexport * from './types/beacon/NetworkType';\nexport * from './types/beacon/PermissionScope';\nexport * from './types/beacon/SigningType';\nexport * from './types/beacon/Threshold';\nexport * from './types/BeaconErrorType';\nexport * from './types/ColorMode';\nexport * from './types/ConnectionContext';\nexport * from './types/Extension';\nexport * from './types/ExtensionMessage';\nexport * from './types/ExtensionMessageTarget';\nexport * from './types/Origin';\nexport * from './types/P2PPairingRequest';\nexport * from './types/P2PPairingResponse';\nexport * from './types/PeerInfo';\nexport * from './types/PermissionEntity';\nexport * from './types/PermissionInfo';\nexport * from './types/PostMessagePairingRequest';\nexport * from './types/PostMessagePairingResponse';\nexport * from './types/RequestBroadcastInput';\nexport * from './types/RequestOperationInput';\nexport * from './types/RequestPermissionInput';\nexport * from './types/RequestSignPayloadInput';\nexport * from './types/storage/StorageKey';\nexport * from './types/storage/StorageKeyReturnDefaults';\nexport * from './types/storage/StorageKeyReturnType';\nexport * from './types/tezos/MichelineMichelsonV1Expression';\nexport * from './types/tezos/MichelsonPrimitives';\nexport * from './types/tezos/operations/ActivateAccount';\nexport * from './types/tezos/operations/Ballot';\nexport * from './types/tezos/operations/Delegation';\nexport * from './types/tezos/operations/DoubleBakingEvidence';\nexport * from './types/tezos/operations/DoubleEndorsementEvidence';\nexport * from './types/tezos/operations/Endorsement';\nexport * from './types/tezos/operations/Origination';\nexport * from './types/tezos/operations/Proposal';\nexport * from './types/tezos/operations/Reveal';\nexport * from './types/tezos/operations/SeedNonceRevelation';\nexport * from './types/tezos/operations/Transaction';\nexport * from './types/tezos/OperationTypes';\nexport * from './types/tezos/PartialTezosOperation';\nexport * from './types/tezos/TezosBaseOperation';\nexport * from './types/tezos/TezosBlockHeader';\nexport * from './types/tezos/TezosOperation';\nexport * from './types/tezos/TezosTransactionParameters';\nexport * from './types/transport/TransportStatus';\nexport * from './types/transport/TransportType';\nexport * from './ui/alert/alert-templates';\nexport * from './ui/alert/Alert';\nexport * from './ui/alert/Pairing';\nexport * from './ui/alert/PairingAlert';\nexport * from './ui/alert/wallet-lists';\nexport * from './ui/toast/toast-templates';\nexport * from './ui/toast/Toast';\nexport * from './utils/assert-never';\nexport * from './utils/available-transports';\nexport * from './utils/block-explorer';\nexport * from './utils/crypto';\nexport * from './utils/exposed-promise';\nexport * from './utils/generate-uuid';\nexport * from './utils/get-account-identifier';\nexport * from './utils/get-sender-id';\nexport * from './utils/get-tzip10-link';\nexport * from './utils/Logger';\nexport * from './utils/platform';\nexport * from './utils/qr';\nexport * from './utils/replace-in-template';\nexport * from './utils/shorten-string';\nexport * from './utils/tezblock-blockexplorer';\nexport * from './utils/utils';\n"},{"name":"@airgap/beacon-sdk/events.d.ts","dts":"import { AlertButton } from './ui/alert/Alert';\nimport { ExtendedP2PPairingResponse } from './types/P2PPairingResponse';\nimport { PostMessagePairingRequest } from './types/PostMessagePairingRequest';\nimport { ExtendedPostMessagePairingResponse } from './types/PostMessagePairingResponse';\nimport { BlockExplorer } from './utils/block-explorer';\nimport { P2PPairingRequest, AccountInfo, ErrorResponse, PermissionResponseOutput, OperationResponseOutput, BroadcastResponseOutput, SignPayloadResponseOutput, Network, ConnectionContext, Transport, NetworkType, AcknowledgeResponse } from '.';\n/**\n * The different events that can be emitted by the beacon-sdk\n */\nexport declare enum BeaconEvent {\n    PERMISSION_REQUEST_SENT = \"PERMISSION_REQUEST_SENT\",\n    PERMISSION_REQUEST_SUCCESS = \"PERMISSION_REQUEST_SUCCESS\",\n    PERMISSION_REQUEST_ERROR = \"PERMISSION_REQUEST_ERROR\",\n    OPERATION_REQUEST_SENT = \"OPERATION_REQUEST_SENT\",\n    OPERATION_REQUEST_SUCCESS = \"OPERATION_REQUEST_SUCCESS\",\n    OPERATION_REQUEST_ERROR = \"OPERATION_REQUEST_ERROR\",\n    SIGN_REQUEST_SENT = \"SIGN_REQUEST_SENT\",\n    SIGN_REQUEST_SUCCESS = \"SIGN_REQUEST_SUCCESS\",\n    SIGN_REQUEST_ERROR = \"SIGN_REQUEST_ERROR\",\n    BROADCAST_REQUEST_SENT = \"BROADCAST_REQUEST_SENT\",\n    BROADCAST_REQUEST_SUCCESS = \"BROADCAST_REQUEST_SUCCESS\",\n    BROADCAST_REQUEST_ERROR = \"BROADCAST_REQUEST_ERROR\",\n    ACKNOWLEDGE_RECEIVED = \"ACKNOWLEDGE_RECEIVED\",\n    LOCAL_RATE_LIMIT_REACHED = \"LOCAL_RATE_LIMIT_REACHED\",\n    NO_PERMISSIONS = \"NO_PERMISSIONS\",\n    ACTIVE_ACCOUNT_SET = \"ACTIVE_ACCOUNT_SET\",\n    ACTIVE_TRANSPORT_SET = \"ACTIVE_TRANSPORT_SET\",\n    PAIR_INIT = \"PAIR_INIT\",\n    PAIR_SUCCESS = \"PAIR_SUCCESS\",\n    CHANNEL_CLOSED = \"CHANNEL_CLOSED\",\n    INTERNAL_ERROR = \"INTERNAL_ERROR\",\n    UNKNOWN = \"UNKNOWN\"\n}\nexport interface WalletInfo {\n    name: string;\n    icon?: string;\n}\nexport interface ExtraInfo {\n    resetCallback?(): Promise<void>;\n}\ninterface RequestSentInfo {\n    extraInfo: ExtraInfo;\n    walletInfo: WalletInfo;\n}\n/**\n * The type of the payload of the different BeaconEvents\n */\nexport interface BeaconEventType {\n    [BeaconEvent.PERMISSION_REQUEST_SENT]: RequestSentInfo;\n    [BeaconEvent.PERMISSION_REQUEST_SUCCESS]: {\n        account: AccountInfo;\n        output: PermissionResponseOutput;\n        blockExplorer: BlockExplorer;\n        connectionContext: ConnectionContext;\n        walletInfo: WalletInfo;\n    };\n    [BeaconEvent.PERMISSION_REQUEST_ERROR]: {\n        errorResponse: ErrorResponse;\n        walletInfo: WalletInfo;\n    };\n    [BeaconEvent.OPERATION_REQUEST_SENT]: RequestSentInfo;\n    [BeaconEvent.OPERATION_REQUEST_SUCCESS]: {\n        account: AccountInfo;\n        output: OperationResponseOutput;\n        blockExplorer: BlockExplorer;\n        connectionContext: ConnectionContext;\n        walletInfo: WalletInfo;\n    };\n    [BeaconEvent.OPERATION_REQUEST_ERROR]: {\n        errorResponse: ErrorResponse;\n        walletInfo: WalletInfo;\n    };\n    [BeaconEvent.SIGN_REQUEST_SENT]: RequestSentInfo;\n    [BeaconEvent.SIGN_REQUEST_SUCCESS]: {\n        output: SignPayloadResponseOutput;\n        connectionContext: ConnectionContext;\n        walletInfo: WalletInfo;\n    };\n    [BeaconEvent.SIGN_REQUEST_ERROR]: {\n        errorResponse: ErrorResponse;\n        walletInfo: WalletInfo;\n    };\n    [BeaconEvent.BROADCAST_REQUEST_SENT]: RequestSentInfo;\n    [BeaconEvent.BROADCAST_REQUEST_SUCCESS]: {\n        network: Network;\n        output: BroadcastResponseOutput;\n        blockExplorer: BlockExplorer;\n        connectionContext: ConnectionContext;\n        walletInfo: WalletInfo;\n    };\n    [BeaconEvent.BROADCAST_REQUEST_ERROR]: {\n        errorResponse: ErrorResponse;\n        walletInfo: WalletInfo;\n    };\n    [BeaconEvent.ACKNOWLEDGE_RECEIVED]: {\n        message: AcknowledgeResponse;\n        extraInfo: ExtraInfo;\n        walletInfo: WalletInfo;\n    };\n    [BeaconEvent.LOCAL_RATE_LIMIT_REACHED]: undefined;\n    [BeaconEvent.NO_PERMISSIONS]: undefined;\n    [BeaconEvent.ACTIVE_ACCOUNT_SET]: AccountInfo;\n    [BeaconEvent.ACTIVE_TRANSPORT_SET]: Transport;\n    [BeaconEvent.PAIR_INIT]: {\n        p2pPeerInfo: P2PPairingRequest;\n        postmessagePeerInfo: PostMessagePairingRequest;\n        preferredNetwork: NetworkType;\n        abortedHandler?(): void;\n    };\n    [BeaconEvent.PAIR_SUCCESS]: ExtendedPostMessagePairingResponse | ExtendedP2PPairingResponse;\n    [BeaconEvent.CHANNEL_CLOSED]: string;\n    [BeaconEvent.INTERNAL_ERROR]: string;\n    [BeaconEvent.UNKNOWN]: undefined;\n}\nexport declare type BeaconEventHandlerFunction<T = unknown> = (data: T, eventCallback?: AlertButton[]) => void | Promise<void>;\n/**\n * The default event handlers\n */\nexport declare const defaultEventCallbacks: {\n    [key in BeaconEvent]: BeaconEventHandlerFunction<BeaconEventType[key]>;\n};\n/**\n * Handles beacon events\n */\nexport declare class BeaconEventHandler {\n    private readonly callbackMap;\n    constructor(eventsToOverride?: {\n        [key in BeaconEvent]?: {\n            handler: BeaconEventHandlerFunction<BeaconEventType[key]>;\n        };\n    }, overrideAll?: boolean);\n    /**\n     * A method to subscribe to a specific beacon event and register a callback\n     *\n     * @param event The event being emitted\n     * @param eventCallback The callback that will be invoked\n     */\n    on<K extends BeaconEvent>(event: K, eventCallback: BeaconEventHandlerFunction<BeaconEventType[K]>): Promise<void>;\n    /**\n     * Emit a beacon event\n     *\n     * @param event The event being emitted\n     * @param data The data to be emit\n     */\n    emit<K extends BeaconEvent>(event: K, data?: BeaconEventType[K], eventCallback?: AlertButton[]): Promise<void>;\n    /**\n     * Override beacon event default callbacks. This can be used to disable default alert/toast behaviour\n     *\n     * @param eventsToOverride An object with the events to override\n     */\n    private overrideDefaults;\n    /**\n     * Set all event callbacks to a specific handler.\n     */\n    private setAllHandlers;\n}\nexport {};\n"},{"name":"@airgap/beacon-sdk/index.d.ts","dts":"import { P2PCommunicationClient } from './transports/clients/P2PCommunicationClient';\nimport { AppMetadata } from './types/beacon/AppMetadata';\nimport { PermissionRequest } from './types/beacon/messages/PermissionRequest';\nimport { Network } from './types/beacon/Network';\nimport { BeaconBaseMessage } from './types/beacon/BeaconBaseMessage';\nimport { BeaconMessageType } from './types/beacon/BeaconMessageType';\nimport { PermissionScope } from './types/beacon/PermissionScope';\nimport { PermissionResponse } from './types/beacon/messages/PermissionResponse';\nimport { OperationRequest } from './types/beacon/messages/OperationRequest';\nimport { OperationResponse } from './types/beacon/messages/OperationResponse';\nimport { SignPayloadRequest } from './types/beacon/messages/SignPayloadRequest';\nimport { SignPayloadResponse } from './types/beacon/messages/SignPayloadResponse';\nimport { BroadcastRequest } from './types/beacon/messages/BroadcastRequest';\nimport { BroadcastResponse } from './types/beacon/messages/BroadcastResponse';\nimport { NetworkType } from './types/beacon/NetworkType';\nimport { TezosBaseOperation } from './types/tezos/TezosBaseOperation';\nimport { TezosOperationType } from './types/tezos/OperationTypes';\nimport { TezosActivateAccountOperation } from './types/tezos/operations/ActivateAccount';\nimport { TezosBallotOperation } from './types/tezos/operations/Ballot';\nimport { TezosDelegationOperation } from './types/tezos/operations/Delegation';\nimport { TezosDoubleBakingEvidenceOperation } from './types/tezos/operations/DoubleBakingEvidence';\nimport { TezosBlockHeader } from './types/tezos/TezosBlockHeader';\nimport { TezosDoubleEndorsementEvidenceOperation } from './types/tezos/operations/DoubleEndorsementEvidence';\nimport { TezosEndorsementOperation } from './types/tezos/operations/Endorsement';\nimport { TezosOriginationOperation } from './types/tezos/operations/Origination';\nimport { TezosProposalOperation } from './types/tezos/operations/Proposal';\nimport { TezosRevealOperation } from './types/tezos/operations/Reveal';\nimport { TezosSeedNonceRevelationOperation } from './types/tezos/operations/SeedNonceRevelation';\nimport { TezosTransactionOperation } from './types/tezos/operations/Transaction';\nimport { MichelsonPrimitives } from './types/tezos/MichelsonPrimitives';\nimport { TezosTransactionParameters } from './types/tezos/TezosTransactionParameters';\nimport { Origin } from './types/Origin';\nimport { AccountInfo, AccountIdentifier } from './types/AccountInfo';\nimport { EncryptedExtensionMessage, ExtensionMessage } from './types/ExtensionMessage';\nimport { ExtensionMessageTarget } from './types/ExtensionMessageTarget';\nimport { TezosOperation } from './types/tezos/TezosOperation';\nimport { Client } from './clients/client/Client';\nimport { WalletClient } from './clients/wallet-client/WalletClient';\nimport { DAppClient } from './clients/dapp-client/DAppClient';\nimport { BeaconError } from './errors/BeaconError';\nimport { BeaconErrorType } from './types/BeaconErrorType';\nimport { BroadcastBeaconError } from './errors/BroadcastBeaconError';\nimport { NetworkNotSupportedBeaconError } from './errors/NetworkNotSupportedBeaconError';\nimport { NoAddressBeaconError } from './errors/NoAddressBeaconError';\nimport { NoPrivateKeyBeaconError } from './errors/NoPrivateKeyBeaconError';\nimport { NotGrantedBeaconError } from './errors/NotGrantedBeaconError';\nimport { ParametersInvalidBeaconError } from './errors/ParametersInvalidBeaconError';\nimport { TooManyOperationsBeaconError } from './errors/TooManyOperationsBeaconError';\nimport { TransactionInvalidBeaconError } from './errors/TransactionInvalidBeaconError';\nimport { UnknownBeaconError } from './errors/UnknownBeaconError';\nimport { ErrorResponse } from './types/beacon/messages/ErrorResponse';\nimport { TransportStatus } from './types/transport/TransportStatus';\nimport { TransportType } from './types/transport/TransportType';\nimport { PostMessageTransport } from './transports/PostMessageTransport';\nimport { Transport } from './transports/Transport';\nimport { P2PTransport } from './transports/P2PTransport';\nimport { Storage } from './storage/Storage';\nimport { StorageKey } from './types/storage/StorageKey';\nimport { StorageKeyReturnDefaults } from './types/storage/StorageKeyReturnDefaults';\nimport { StorageKeyReturnType } from './types/storage/StorageKeyReturnType';\nimport { ExtendedP2PPairingRequest, P2PPairingRequest } from './types/P2PPairingRequest';\nimport { ChromeStorage } from './storage/ChromeStorage';\nimport { LocalStorage } from './storage/LocalStorage';\nimport { getStorage } from './storage/getStorage';\nimport { BeaconMessage } from './types/beacon/BeaconMessage';\nimport { Serializer } from './Serializer';\nimport { RequestPermissionInput } from './types/RequestPermissionInput';\nimport { RequestSignPayloadInput } from './types/RequestSignPayloadInput';\nimport { RequestOperationInput } from './types/RequestOperationInput';\nimport { RequestBroadcastInput } from './types/RequestBroadcastInput';\nimport { PermissionResponseInput, SignPayloadResponseInput, OperationResponseInput, BroadcastResponseInput, BeaconResponseInputMessage, AcknowledgeResponseInput, ErrorResponseInput } from './types/beacon/messages/BeaconResponseInputMessage';\nimport { PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, BeaconResponseOutputMessage } from './types/beacon/messages/BeaconResponseOutputMessage';\nimport { PermissionRequestInput, SignPayloadRequestInput, OperationRequestInput, BroadcastRequestInput, BeaconRequestInputMessage } from './types/beacon/messages/BeaconRequestInputMessage';\nimport { PermissionRequestOutput, SignPayloadRequestOutput, OperationRequestOutput, BroadcastRequestOutput, BeaconRequestOutputMessage } from './types/beacon/messages/BeaconRequestOutputMessage';\nimport { ClientOptions } from './clients/client/ClientOptions';\nimport { DAppClientOptions } from './clients/dapp-client/DAppClientOptions';\nimport { WalletClientOptions } from './clients/wallet-client/WalletClientOptions';\nimport { PermissionInfo } from './types/PermissionInfo';\nimport { SDK_VERSION, BEACON_VERSION } from './constants';\nimport { AccountManager } from './managers/AccountManager';\nimport { AppMetadataManager } from './managers/AppMetadataManager';\nimport { PermissionManager } from './managers/PermissionManager';\nimport { BeaconEvent, BeaconEventHandler, defaultEventCallbacks } from './events';\nimport { getAddressFromPublicKey } from './utils/crypto';\nimport { BeaconClient } from './clients/beacon-client/BeaconClient';\nimport { BeaconClientOptions } from './clients/beacon-client/BeaconClientOptions';\nimport { getAccountIdentifier } from './utils/get-account-identifier';\nimport { ConnectionContext } from './types/ConnectionContext';\nimport { Threshold } from './types/beacon/Threshold';\nimport { PartialTezosTransactionOperation, PartialTezosOperation, PartialTezosDelegationOperation, PartialTezosOriginationOperation, PartialTezosRevealOperation } from './types/tezos/PartialTezosOperation';\nimport { AbortedBeaconError } from './errors/AbortedBeaconError';\nimport { ExtendedPeerInfo, PeerInfo } from './types/PeerInfo';\nimport { availableTransports } from './utils/available-transports';\nimport { AcknowledgeResponse } from './types/beacon/messages/AcknowledgeResponse';\nimport { DisconnectMessage } from './types/beacon/messages/DisconnectMessage';\nimport { DappP2PTransport } from './transports/DappP2PTransport';\nimport { DappPostMessageTransport } from './transports/DappPostMessageTransport';\nimport { WalletP2PTransport } from './transports/WalletP2PTransport';\nimport { WalletPostMessageTransport } from './transports/WalletPostMessageTransport';\nimport { getSenderId } from './utils/get-sender-id';\nimport { SigningType } from './types/beacon/SigningType';\nimport { SignatureTypeNotSupportedBeaconError } from './errors/SignatureTypeNotSupportedBeaconError';\nimport { ExtendedP2PPairingResponse } from './types/P2PPairingResponse';\nimport { ExtendedPostMessagePairingRequest, PostMessagePairingRequest } from './types/PostMessagePairingRequest';\nimport { ExtendedPostMessagePairingResponse } from './types/PostMessagePairingResponse';\nimport { PeerManager } from './managers/PeerManager';\nimport { MessageBasedClient } from './transports/clients/MessageBasedClient';\nimport { BeaconRequestMessage } from './types/beacon/BeaconRequestMessage';\nimport { BeaconResponseMessage } from './types/beacon/BeaconResponseMessage';\nimport { Pairing } from './ui/alert/Pairing';\nimport { BlockExplorer } from './utils/block-explorer';\nimport { TezblockBlockExplorer } from './utils/tezblock-blockexplorer';\nimport { setDebugEnabled, getDebugEnabled } from './debug';\nimport { ColorMode } from './types/ColorMode';\nexport { TezosBaseOperation, TezosOperationType, TezosBlockHeader, MichelsonPrimitives, TezosTransactionParameters, TezosOperation };\nexport { TezosActivateAccountOperation, TezosBallotOperation, TezosDelegationOperation, TezosDoubleBakingEvidenceOperation, TezosDoubleEndorsementEvidenceOperation, TezosEndorsementOperation, TezosOriginationOperation, TezosProposalOperation, TezosRevealOperation, TezosSeedNonceRevelationOperation, TezosTransactionOperation, PartialTezosOperation, PartialTezosTransactionOperation, PartialTezosDelegationOperation, PartialTezosOriginationOperation, PartialTezosRevealOperation };\nexport { BeaconClient, BeaconClientOptions, Client, ClientOptions, DAppClient, DAppClientOptions, WalletClient, WalletClientOptions, P2PCommunicationClient };\nexport { AccountIdentifier, AppMetadata, Network, NetworkType, BeaconMessage, PermissionRequest, PermissionResponse, OperationRequest, OperationResponse, SignPayloadRequest, SignPayloadResponse, BroadcastRequest, BroadcastResponse, AcknowledgeResponse, DisconnectMessage, BeaconBaseMessage, BeaconMessageType, PermissionScope, Origin, AccountInfo, Threshold, SigningType, ExtensionMessageTarget, ExtensionMessage, EncryptedExtensionMessage, RequestPermissionInput, RequestSignPayloadInput, RequestOperationInput, RequestBroadcastInput, PermissionInfo };\nexport { PermissionResponseInput, SignPayloadResponseInput, OperationResponseInput, BroadcastResponseInput, AcknowledgeResponseInput, ErrorResponseInput, PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, PermissionRequestInput, SignPayloadRequestInput, OperationRequestInput, BroadcastRequestInput, PermissionRequestOutput, SignPayloadRequestOutput, OperationRequestOutput, BroadcastRequestOutput, BeaconRequestInputMessage, BeaconRequestOutputMessage, BeaconResponseInputMessage, BeaconResponseOutputMessage, BeaconRequestMessage, BeaconResponseMessage };\nexport { BeaconError, BeaconErrorType, ErrorResponse, AbortedBeaconError, BroadcastBeaconError, NetworkNotSupportedBeaconError, NoAddressBeaconError, NoPrivateKeyBeaconError, NotGrantedBeaconError, ParametersInvalidBeaconError, TooManyOperationsBeaconError, TransactionInvalidBeaconError, SignatureTypeNotSupportedBeaconError, UnknownBeaconError };\nexport { TransportStatus, TransportType, Transport, PostMessageTransport, P2PTransport, WalletP2PTransport, WalletPostMessageTransport, DappP2PTransport, DappPostMessageTransport, MessageBasedClient, Pairing };\nexport { BeaconEvent, BeaconEventHandler, defaultEventCallbacks };\nexport { Storage, StorageKey, StorageKeyReturnDefaults, StorageKeyReturnType, ChromeStorage, LocalStorage, getStorage };\nexport { PeerManager, AccountManager, AppMetadataManager, PermissionManager };\nexport { SDK_VERSION, BEACON_VERSION };\nexport { getSenderId, getAccountIdentifier, getAddressFromPublicKey };\nexport { PeerInfo, ExtendedPeerInfo, PostMessagePairingRequest, ExtendedPostMessagePairingRequest, ExtendedPostMessagePairingResponse, P2PPairingRequest, ExtendedP2PPairingRequest, ExtendedP2PPairingResponse };\nexport { BlockExplorer, TezblockBlockExplorer };\nexport { ConnectionContext, Serializer, availableTransports, ColorMode };\nexport { setDebugEnabled, getDebugEnabled };\n"},{"name":"@airgap/beacon-sdk/test.d.ts","dts":"// Generated by dts-bundle v0.7.3\n// Dependencies for this module:\n//   ../../../../../libsodium-wrappers\n//   ../../../../../events\n//   test.d.ts\n\nexport * from 'test/beacon-message-events';\nexport * from 'test/clients/beacon-client/BeaconClient';\nexport * from 'test/clients/beacon-client/BeaconClientOptions';\nexport * from 'test/clients/client/Client';\nexport * from 'test/clients/client/ClientOptions';\nexport * from 'test/clients/dapp-client/DAppClient';\nexport * from 'test/clients/dapp-client/DAppClientOptions';\nexport * from 'test/clients/wallet-client/WalletClient';\nexport * from 'test/clients/wallet-client/WalletClientOptions';\nexport * from 'test/colorMode';\nexport * from 'test/constants';\nexport * from 'test/debug';\nexport * from 'test/errors/AbortedBeaconError';\nexport * from 'test/errors/BeaconError';\nexport * from 'test/errors/BroadcastBeaconError';\nexport * from 'test/errors/NetworkNotSupportedBeaconError';\nexport * from 'test/errors/NoAddressBeaconError';\nexport * from 'test/errors/NoPrivateKeyBeaconError';\nexport * from 'test/errors/NotGrantedBeaconError';\nexport * from 'test/errors/ParametersInvalidBeaconError';\nexport * from 'test/errors/SignatureTypeNotSupportedBeaconError';\nexport * from 'test/errors/TooManyOperationsBeaconError';\nexport * from 'test/errors/TransactionInvalidBeaconError';\nexport * from 'test/errors/UnknownBeaconError';\nexport * from 'test/events';\nexport * from 'test/examples/broadcast-request';\nexport * from 'test/examples/custom-block-explorer';\nexport * from 'test/examples/disable-all-ui';\nexport * from 'test/examples/operation-request';\nexport * from 'test/examples/override-default-events';\nexport * from 'test/examples/permission-request';\nexport * from 'test/examples/sign-payload-request';\nexport * from 'test/examples/using-custom-network';\nexport * from 'test/examples/wallet-example';\nexport * from 'test/index';\nexport * from 'test/interceptors/IncomingRequestInterceptor';\nexport * from 'test/interceptors/OutgoingResponseInterceptor';\nexport * from 'test/managers/AccountManager';\nexport * from 'test/managers/AppMetadataManager';\nexport * from 'test/managers/PeerManager';\nexport * from 'test/managers/PermissionManager';\nexport * from 'test/managers/PermissionValidator';\nexport * from 'test/managers/StorageManager';\nexport * from 'test/matrix-client/MatrixClient';\nexport * from 'test/matrix-client/MatrixClientEventEmitter';\nexport * from 'test/matrix-client/MatrixClientStore';\nexport * from 'test/matrix-client/MatrixHttpClient';\nexport * from 'test/matrix-client/models/api/MatrixEventSend';\nexport * from 'test/matrix-client/models/api/MatrixLogin';\nexport * from 'test/matrix-client/models/api/MatrixRequest';\nexport * from 'test/matrix-client/models/api/MatrixRoomCreate';\nexport * from 'test/matrix-client/models/api/MatrixRoomInvite';\nexport * from 'test/matrix-client/models/api/MatrixRoomJoin';\nexport * from 'test/matrix-client/models/api/MatrixSync';\nexport * from 'test/matrix-client/models/MatrixClientEvent';\nexport * from 'test/matrix-client/models/MatrixMessage';\nexport * from 'test/matrix-client/models/MatrixRoom';\nexport * from 'test/matrix-client/models/MatrixStateEvent';\nexport * from 'test/matrix-client/services/MatrixEventService';\nexport * from 'test/matrix-client/services/MatrixRoomService';\nexport * from 'test/matrix-client/services/MatrixUserService';\nexport * from 'test/matrix-client/utils/events';\nexport * from 'test/migrations/migrate-0.7.0';\nexport * from 'test/migrations/migrations';\nexport * from 'test/MockWindow';\nexport * from 'test/Serializer';\nexport * from 'test/storage/ChromeStorage';\nexport * from 'test/storage/getStorage';\nexport * from 'test/storage/LocalStorage';\nexport * from 'test/storage/Storage';\nexport * from 'test/test';\nexport * from 'test/transports/clients/CommunicationClient';\nexport * from 'test/transports/clients/MessageBasedClient';\nexport * from 'test/transports/clients/P2PCommunicationClient';\nexport * from 'test/transports/clients/PostMessageClient';\nexport * from 'test/transports/DappP2PTransport';\nexport * from 'test/transports/DappPostMessageTransport';\nexport * from 'test/transports/P2PTransport';\nexport * from 'test/transports/PostMessageTransport';\nexport * from 'test/transports/Transport';\nexport * from 'test/transports/WalletP2PTransport';\nexport * from 'test/transports/WalletPostMessageTransport';\nexport * from 'test/types/AccountInfo';\nexport * from 'test/types/beacon/AppMetadata';\nexport * from 'test/types/beacon/BeaconBaseMessage';\nexport * from 'test/types/beacon/BeaconMessage';\nexport * from 'test/types/beacon/BeaconMessageType';\nexport * from 'test/types/beacon/BeaconRequestMessage';\nexport * from 'test/types/beacon/BeaconResponseMessage';\nexport * from 'test/types/beacon/messages/AcknowledgeResponse';\nexport * from 'test/types/beacon/messages/BeaconRequestInputMessage';\nexport * from 'test/types/beacon/messages/BeaconRequestOutputMessage';\nexport * from 'test/types/beacon/messages/BeaconResponseInputMessage';\nexport * from 'test/types/beacon/messages/BeaconResponseOutputMessage';\nexport * from 'test/types/beacon/messages/BroadcastRequest';\nexport * from 'test/types/beacon/messages/BroadcastResponse';\nexport * from 'test/types/beacon/messages/DisconnectMessage';\nexport * from 'test/types/beacon/messages/ErrorResponse';\nexport * from 'test/types/beacon/messages/OperationRequest';\nexport * from 'test/types/beacon/messages/OperationResponse';\nexport * from 'test/types/beacon/messages/PermissionRequest';\nexport * from 'test/types/beacon/messages/PermissionResponse';\nexport * from 'test/types/beacon/messages/SignPayloadRequest';\nexport * from 'test/types/beacon/messages/SignPayloadResponse';\nexport * from 'test/types/beacon/Network';\nexport * from 'test/types/beacon/NetworkType';\nexport * from 'test/types/beacon/PermissionScope';\nexport * from 'test/types/beacon/SigningType';\nexport * from 'test/types/beacon/Threshold';\nexport * from 'test/types/BeaconErrorType';\nexport * from 'test/types/ColorMode';\nexport * from 'test/types/ConnectionContext';\nexport * from 'test/types/Extension';\nexport * from 'test/types/ExtensionMessage';\nexport * from 'test/types/ExtensionMessageTarget';\nexport * from 'test/types/Origin';\nexport * from 'test/types/P2PPairingRequest';\nexport * from 'test/types/P2PPairingResponse';\nexport * from 'test/types/PeerInfo';\nexport * from 'test/types/PermissionEntity';\nexport * from 'test/types/PermissionInfo';\nexport * from 'test/types/PostMessagePairingRequest';\nexport * from 'test/types/PostMessagePairingResponse';\nexport * from 'test/types/RequestBroadcastInput';\nexport * from 'test/types/RequestOperationInput';\nexport * from 'test/types/RequestPermissionInput';\nexport * from 'test/types/RequestSignPayloadInput';\nexport * from 'test/types/storage/StorageKey';\nexport * from 'test/types/storage/StorageKeyReturnDefaults';\nexport * from 'test/types/storage/StorageKeyReturnType';\nexport * from 'test/types/tezos/MichelineMichelsonV1Expression';\nexport * from 'test/types/tezos/MichelsonPrimitives';\nexport * from 'test/types/tezos/operations/ActivateAccount';\nexport * from 'test/types/tezos/operations/Ballot';\nexport * from 'test/types/tezos/operations/Delegation';\nexport * from 'test/types/tezos/operations/DoubleBakingEvidence';\nexport * from 'test/types/tezos/operations/DoubleEndorsementEvidence';\nexport * from 'test/types/tezos/operations/Endorsement';\nexport * from 'test/types/tezos/operations/Origination';\nexport * from 'test/types/tezos/operations/Proposal';\nexport * from 'test/types/tezos/operations/Reveal';\nexport * from 'test/types/tezos/operations/SeedNonceRevelation';\nexport * from 'test/types/tezos/operations/Transaction';\nexport * from 'test/types/tezos/OperationTypes';\nexport * from 'test/types/tezos/PartialTezosOperation';\nexport * from 'test/types/tezos/TezosBaseOperation';\nexport * from 'test/types/tezos/TezosBlockHeader';\nexport * from 'test/types/tezos/TezosOperation';\nexport * from 'test/types/tezos/TezosTransactionParameters';\nexport * from 'test/types/transport/TransportStatus';\nexport * from 'test/types/transport/TransportType';\nexport * from 'test/ui/alert/alert-templates';\nexport * from 'test/ui/alert/Alert';\nexport * from 'test/ui/alert/Pairing';\nexport * from 'test/ui/alert/PairingAlert';\nexport * from 'test/ui/alert/wallet-lists';\nexport * from 'test/ui/toast/toast-templates';\nexport * from 'test/ui/toast/Toast';\nexport * from 'test/utils/assert-never';\nexport * from 'test/utils/available-transports';\nexport * from 'test/utils/block-explorer';\nexport * from 'test/utils/crypto';\nexport * from 'test/utils/exposed-promise';\nexport * from 'test/utils/generate-uuid';\nexport * from 'test/utils/get-account-identifier';\nexport * from 'test/utils/get-sender-id';\nexport * from 'test/utils/get-tzip10-link';\nexport * from 'test/utils/Logger';\nexport * from 'test/utils/platform';\nexport * from 'test/utils/qr';\nexport * from 'test/utils/replace-in-template';\nexport * from 'test/utils/shorten-string';\nexport * from 'test/utils/tezblock-blockexplorer';\nexport * from 'test/utils/utils';\n\ndeclare module 'test/beacon-message-events' {\n    import { BeaconEvent } from 'test/events';\n    import { BeaconMessageType } from 'test/';\n    export const messageEvents: {\n        [key in BeaconMessageType]: {\n            sent: BeaconEvent;\n            success: BeaconEvent;\n            error: BeaconEvent;\n        };\n    };\n}\n\ndeclare module 'test/clients/beacon-client/BeaconClient' {\n    import * as sodium from 'libsodium-wrappers';\n    import { ExposedPromise } from 'test/utils/exposed-promise';\n    import { Storage } from 'test/';\n    import { BeaconEventHandler } from 'test/events';\n    import { BeaconClientOptions } from 'test/clients/beacon-client/BeaconClientOptions';\n    /**\n        * The beacon client is an abstract client that handles everything that is shared between all other clients.\n        * Specifically, it handles managing the beaconId and and the local keypair.\n        */\n    export abstract class BeaconClient {\n            /**\n                * The name of the client\n                */\n            readonly name: string;\n            /**\n                * The URL of the dApp Icon. This can be used to display the icon of the dApp on in the wallet\n                */\n            readonly iconUrl?: string;\n            /**\n                * The URL of the dApp.\n                */\n            readonly appUrl?: string;\n            /** The beaconId is a public key that is used to identify one specific application (dapp or wallet).\n                * This is used inside a message to specify the sender, for example.\n                */\n            protected _beaconId: ExposedPromise<string>;\n            get beaconId(): Promise<string>;\n            protected storage: Storage;\n            protected readonly events: BeaconEventHandler;\n            /**\n                * The local keypair that is used for the communication encryption\n                */\n            protected _keyPair: ExposedPromise<sodium.KeyPair>;\n            protected get keyPair(): Promise<sodium.KeyPair>;\n            constructor(config: BeaconClientOptions);\n            /**\n                * This resets the SDK. After using this method, this instance is no longer usable. You will have to instanciate a new client.\n                */\n            destroy(): Promise<void>;\n    }\n}\n\ndeclare module 'test/clients/beacon-client/BeaconClientOptions' {\n    import { Storage } from 'test/';\n    export interface BeaconClientOptions {\n            /**\n                * Name of the application\n                */\n            name: string;\n            /**\n                * A URL to the icon of the application\n                */\n            iconUrl?: string;\n            /**\n                * A URL to the website of the application\n                */\n            appUrl?: string;\n            /**\n                * The storage that will be used by the SDK\n                */\n            storage: Storage;\n    }\n}\n\ndeclare module 'test/clients/client/Client' {\n    import { ExposedPromise } from 'test/utils/exposed-promise';\n    import { ConnectionContext } from 'test/types/ConnectionContext';\n    import { TransportType, TransportStatus, AccountInfo, PeerInfo, Transport, AppMetadata } from 'test/';\n    import { BeaconEventHandler } from 'test/events';\n    import { BeaconClient } from 'test/clients/beacon-client/BeaconClient';\n    import { AccountManager } from 'test/managers/AccountManager';\n    import { BeaconRequestMessage } from 'test/types/beacon/BeaconRequestMessage';\n    import { ClientOptions } from 'test/clients/client/ClientOptions';\n    /**\n        * This abstract class handles the a big part of the logic that is shared between the dapp and wallet client.\n        * For example, it selects and manages the transport and accounts.\n        */\n    export abstract class Client extends BeaconClient {\n            protected readonly accountManager: AccountManager;\n            protected handleResponse: (_event: BeaconRequestMessage, connectionInfo: ConnectionContext) => void;\n            /**\n                * How many requests can be sent after another\n                */\n            protected readonly rateLimit: number;\n            /**\n                * The time window in seconds in which the \"rateLimit\" is checked\n                */\n            protected readonly rateLimitWindowInSeconds: number;\n            /**\n                * Stores the times when requests have been made to determine if the rate limit has been reached\n                */\n            protected requestCounter: number[];\n            protected readonly events: BeaconEventHandler;\n            protected readonly matrixNodes: string[];\n            protected _transport: ExposedPromise<Transport<any>>;\n            protected get transport(): Promise<Transport<any>>;\n            /**\n                * Returns the connection status of the Client\n                */\n            get connectionStatus(): TransportStatus;\n            /**\n                * Returns whether or not the transaport is ready\n                */\n            get ready(): Promise<void>;\n            constructor(config: ClientOptions);\n            /**\n                * Return all locally known accounts\n                */\n            getAccounts(): Promise<AccountInfo[]>;\n            /**\n                * Return the account by ID\n                * @param accountIdentifier The ID of an account\n                */\n            getAccount(accountIdentifier: string): Promise<AccountInfo | undefined>;\n            /**\n                * Remove the account by ID\n                * @param accountIdentifier The ID of an account\n                */\n            removeAccount(accountIdentifier: string): Promise<void>;\n            /**\n                * Remove all locally stored accounts\n                */\n            removeAllAccounts(): Promise<void>;\n            /**\n                * Add a new request (current timestamp) to the pending requests, remove old ones and check if we are above the limit\n                */\n            addRequestAndCheckIfRateLimited(): Promise<boolean>;\n            /**\n                * This method initializes the client. It will check if the connection should be established to a\n                * browser extension or if the P2P transport should be used.\n                *\n                * @param transport A transport that can be provided by the user\n                */\n            init(transport: Transport<any>): Promise<TransportType>;\n            /**\n                * Returns the metadata of this DApp\n                */\n            getOwnAppMetadata(): Promise<AppMetadata>;\n            /**\n                * Return all known peers\n                */\n            getPeers(): Promise<PeerInfo[]>;\n            /**\n                * Add a new peer to the known peers\n                * @param peer The new peer to add\n                */\n            addPeer(peer: PeerInfo): Promise<void>;\n            /**\n                * A \"setter\" for when the transport needs to be changed.\n                */\n            protected setTransport(transport?: Transport<any>): Promise<void>;\n            protected addListener(transport: Transport<any>): Promise<void>;\n            protected sendDisconnectToPeer(peer: PeerInfo, transport?: Transport<any>): Promise<void>;\n    }\n}\n\ndeclare module 'test/clients/client/ClientOptions' {\n    import { Storage } from 'test/';\n    import { BeaconEvent, BeaconEventHandlerFunction, BeaconEventType } from 'test/events';\n    export interface ClientOptions {\n            /**\n                * Name of the application\n                */\n            name: string;\n            /**\n                * A URL to the icon of the application\n                */\n            iconUrl?: string;\n            /**\n                * A URL to the website of the application\n                */\n            appUrl?: string;\n            /**\n                * The storage that will be used by the SDK\n                */\n            storage: Storage;\n            /**\n                * An object that will be used to overwrite default event handler behaviour.\n                *\n                * If you plan to overwrite all default events, use \"disableDefaultEvents\" instead.\n                *\n                * This will overwrite the default event handler, so this can lead to unexpected behavior in some cases.\n                * We recommend that you overwrite all handlers if you want to use your own UI.\n                *\n                * If you simply want to be notified of events happening, but do not want to overwrite the default behavior,\n                * please use `subscribeToEvent()` on the DAppClient instead.\n                */\n            eventHandlers?: {\n                    [key in BeaconEvent]?: {\n                            handler: BeaconEventHandlerFunction<BeaconEventType[key]>;\n                    };\n            };\n            /**\n                * Disable all default Events and UI elements. If passed together with \"eventHandlers\",\n                * the default eventHandlers will be removed, and the ones passed by the user will be added.\n                */\n            disableDefaultEvents?: boolean;\n            /**\n                * A list of matrix nodes to connect to. If a non-empty array is passed, the default options will be overwritten.\n                * One node will be randomly selected based on the local keypair and the other nodes will be used as a fallback in case the primary node goes down.\n                *\n                * Only provide the hostname, no https:// prefix. Eg. ['matrix.example.com']\n                */\n            matrixNodes?: string[];\n    }\n}\n\ndeclare module 'test/clients/dapp-client/DAppClient' {\n    import { BeaconEvent, BeaconEventHandlerFunction, BeaconEventType } from 'test/events';\n    import { AccountInfo, Client, TransportType, BeaconMessageType, NetworkType, RequestPermissionInput, RequestSignPayloadInput, RequestOperationInput, RequestBroadcastInput, PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, Transport, DappP2PTransport, DappPostMessageTransport, AppMetadata } from 'test/';\n    import { BlockExplorer } from 'test/utils/block-explorer';\n    import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n    import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n    import { ExtendedPeerInfo } from 'test/types/PeerInfo';\n    import { ColorMode } from 'test/types/ColorMode';\n    import { DAppClientOptions } from 'test/clients/dapp-client/DAppClientOptions';\n    /**\n        * The DAppClient has to be used in decentralized applications. It handles all the logic related to connecting to beacon-compatible\n        * wallets and sending requests.\n        */\n    export class DAppClient extends Client {\n            /**\n                * The block explorer used by the SDK\n                */\n            readonly blockExplorer: BlockExplorer;\n            preferredNetwork: NetworkType;\n            protected postMessageTransport: DappPostMessageTransport | undefined;\n            protected p2pTransport: DappP2PTransport | undefined;\n            constructor(config: DAppClientOptions);\n            initInternalTransports(): Promise<void>;\n            init(transport?: Transport<any>): Promise<TransportType>;\n            /**\n                * Returns the active account\n                */\n            getActiveAccount(): Promise<AccountInfo | undefined>;\n            /**\n                * Sets the active account\n                *\n                * @param account The account that will be set as the active account\n                */\n            setActiveAccount(account?: AccountInfo): Promise<void>;\n            /**\n                * Clear the active account\n                */\n            clearActiveAccount(): Promise<void>;\n            setColorMode(colorMode: ColorMode): Promise<void>;\n            getColorMode(): Promise<ColorMode>;\n            /**\n                * @deprecated\n                *\n                * Use getOwnAppMetadata instead\n                */\n            getAppMetadata(): Promise<AppMetadata>;\n            /**\n                * Will remove the account from the local storage and set a new active account if necessary.\n                *\n                * @param accountIdentifier ID of the account\n                */\n            removeAccount(accountIdentifier: string): Promise<void>;\n            /**\n                * Remove all accounts and set active account to undefined\n                */\n            removeAllAccounts(): Promise<void>;\n            /**\n                * Removes a peer and all the accounts that have been connected through that peer\n                *\n                * @param peer Peer to be removed\n                */\n            removePeer(peer: ExtendedPeerInfo, sendDisconnectToPeer?: boolean): Promise<void>;\n            /**\n                * Remove all peers and all accounts that have been connected through those peers\n                */\n            removeAllPeers(sendDisconnectToPeers?: boolean): Promise<void>;\n            /**\n                * Allows the user to subscribe to specific events that are fired in the SDK\n                *\n                * @param internalEvent The event to subscribe to\n                * @param eventCallback The callback that will be called when the event occurs\n                */\n            subscribeToEvent<K extends BeaconEvent>(internalEvent: K, eventCallback: BeaconEventHandlerFunction<BeaconEventType[K]>): Promise<void>;\n            /**\n                * Check if we have permissions to send the specific message type to the active account.\n                * If no active account is set, only permission requests are allowed.\n                *\n                * @param type The type of the message\n                */\n            checkPermissions(type: BeaconMessageType): Promise<boolean>;\n            /**\n                * Send a permission request to the DApp. This should be done as the first step. The wallet will respond\n                * with an publicKey and permissions that were given. The account returned will be set as the \"activeAccount\"\n                * and will be used for the following requests.\n                *\n                * @param input The message details we need to prepare the PermissionRequest message.\n                */\n            requestPermissions(input?: RequestPermissionInput): Promise<PermissionResponseOutput>;\n            /**\n                * This method will send a \"SignPayloadRequest\" to the wallet. This method is meant to be used to sign\n                * arbitrary data (eg. a string). It will return the signature in the format of \"edsig...\"\n                *\n                * @param input The message details we need to prepare the SignPayloadRequest message.\n                */\n            requestSignPayload(input: RequestSignPayloadInput): Promise<SignPayloadResponseOutput>;\n            /**\n                * This method sends an OperationRequest to the wallet. This method should be used for all kinds of operations,\n                * eg. transaction or delegation. Not all properties have to be provided. Data like \"counter\" and fees will be\n                * fetched and calculated by the wallet (but they can still be provided if required).\n                *\n                * @param input The message details we need to prepare the OperationRequest message.\n                */\n            requestOperation(input: RequestOperationInput): Promise<OperationResponseOutput>;\n            /**\n                * Sends a \"BroadcastRequest\" to the wallet. This method can be used to inject an already signed transaction\n                * to the network.\n                *\n                * @param input The message details we need to prepare the BroadcastRequest message.\n                */\n            requestBroadcast(input: RequestBroadcastInput): Promise<BroadcastResponseOutput>;\n            protected setActivePeer(peer?: ExtendedPostMessagePairingResponse | ExtendedP2PPairingResponse): Promise<void>;\n            /**\n                * A \"setter\" for when the transport needs to be changed.\n                */\n            protected setTransport(transport?: Transport<any>): Promise<void>;\n    }\n}\n\ndeclare module 'test/clients/dapp-client/DAppClientOptions' {\n    import { NetworkType, Storage } from 'test/';\n    import { BeaconEvent, BeaconEventType, BeaconEventHandlerFunction } from 'test/events';\n    import { ColorMode } from 'test/types/ColorMode';\n    import { BlockExplorer } from 'test/utils/block-explorer';\n    export interface DAppClientOptions {\n            /**\n                * Name of the application\n                */\n            name: string;\n            /**\n                * A URL to the icon of the application\n                */\n            iconUrl?: string;\n            /**\n                * A URL to the website of the application\n                */\n            appUrl?: string;\n            /**\n                * The storage that will be used by the SDK\n                */\n            storage?: Storage;\n            /**\n                * An object that will be used to overwrite default event handler behaviour.\n                *\n                * If you plan to overwrite all default events, use \"disableDefaultEvents\" instead.\n                *\n                * This will overwrite the default event handler, so this can lead to unexpected behavior in some cases.\n                * We recommend that you overwrite all handlers if you want to use your own UI.\n                *\n                * If you simply want to be notified of events happening, but do not want to overwrite the default behavior,\n                * please use `subscribeToEvent()` on the DAppClient instead.\n                */\n            eventHandlers?: {\n                    [key in BeaconEvent]?: {\n                            handler: BeaconEventHandlerFunction<BeaconEventType[key]>;\n                    };\n            };\n            /**\n                * Disable all default Events and UI elements. If passed together with \"eventHandlers\",\n                * the default eventHandlers will be removed, and the ones passed by the user will be added.\n                */\n            disableDefaultEvents?: boolean;\n            /**\n                * A list of matrix nodes to connect to. If a non-empty array is passed, the default options will be overwritten.\n                * One node will be randomly selected based on the local keypair and the other nodes will be used as a fallback in case the primary node goes down.\n                *\n                * Only provide the hostname, no https:// prefix. Eg. ['matrix.example.com']\n                */\n            matrixNodes?: string[];\n            /**\n                * The block explorer used by the SDK\n                */\n            blockExplorer?: BlockExplorer;\n            /**\n                * Indicates on which network the DApp is planning to run. This is currently used to adjust the URLs of web-wallets in the pairing alert if they use different URLs for testnets.\n                * You will still have to define the network you intend to use during the permission request.\n                */\n            preferredNetwork?: NetworkType;\n            /**\n                * Set the color mode for the UI elements (alerts and toasts)\n                */\n            colorMode?: ColorMode;\n    }\n}\n\ndeclare module 'test/clients/wallet-client/WalletClient' {\n    import { Client, WalletClientOptions, TransportType, BeaconRequestOutputMessage, BeaconResponseInputMessage, AppMetadata, PermissionInfo } from 'test/';\n    import { ConnectionContext } from 'test/types/ConnectionContext';\n    import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n    import { ExposedPromise } from 'test/utils/exposed-promise';\n    import { PeerInfo } from 'test/types/PeerInfo';\n    /**\n        * The WalletClient has to be used in the wallet. It handles all the logic related to connecting to beacon-compatible\n        * dapps and handling/responding to requests.\n        */\n    export class WalletClient extends Client {\n            /**\n                * Returns whether or not the transport is connected\n                */\n            protected readonly _isConnected: ExposedPromise<boolean>;\n            get isConnected(): Promise<boolean>;\n            constructor(config: WalletClientOptions);\n            init(): Promise<TransportType>;\n            /**\n                * This method initiates a connection to the P2P network and registers a callback that will be called\n                * whenever a message is received.\n                *\n                * @param newMessageCallback The callback that will be invoked for every message the transport receives.\n                */\n            connect(newMessageCallback: (message: BeaconRequestOutputMessage, connectionContext: ConnectionContext) => void): Promise<void>;\n            /**\n                * The method will attempt to initiate a connection using the active transport.\n                */\n            _connect(): Promise<void>;\n            /**\n                * This method sends a response for a specific request back to the DApp\n                *\n                * @param message The BeaconResponseMessage that will be sent back to the DApp\n                */\n            respond(message: BeaconResponseInputMessage): Promise<void>;\n            getAppMetadataList(): Promise<AppMetadata[]>;\n            getAppMetadata(senderId: string): Promise<AppMetadata | undefined>;\n            removeAppMetadata(senderId: string): Promise<void>;\n            removeAllAppMetadata(): Promise<void>;\n            getPermissions(): Promise<PermissionInfo[]>;\n            getPermission(accountIdentifier: string): Promise<PermissionInfo | undefined>;\n            removePermission(accountIdentifier: string): Promise<void>;\n            removeAllPermissions(): Promise<void>;\n            /**\n                * Add a new peer to the known peers\n                * @param peer The new peer to add\n                */\n            addPeer(peer: PeerInfo): Promise<void>;\n            removePeer(peer: ExtendedP2PPairingResponse, sendDisconnectToPeer?: boolean): Promise<void>;\n            removeAllPeers(sendDisconnectToPeers?: boolean): Promise<void>;\n    }\n}\n\ndeclare module 'test/clients/wallet-client/WalletClientOptions' {\n    import { Storage } from 'test/';\n    export interface WalletClientOptions {\n            /**\n                * Name of the application\n                */\n            name: string;\n            /**\n                * A URL to the icon of the application\n                */\n            iconUrl?: string;\n            /**\n                * A URL to the website of the application\n                */\n            appUrl?: string;\n            /**\n                * The storage that will be used by the SDK\n                */\n            storage?: Storage;\n            /**\n                * A list of matrix nodes to connect to. If a non-empty array is passed, the default options will be overwritten.\n                * One node will be randomly selected based on the local keypair and the other nodes will be used as a fallback in case the primary node goes down.\n                *\n                * Only provide the hostname, no https:// prefix. Eg. ['matrix.example.com']\n                */\n            matrixNodes?: string[];\n    }\n}\n\ndeclare module 'test/colorMode' {\n    import { ColorMode } from 'test/types/ColorMode';\n    export const setColorMode: (mode: ColorMode) => void;\n    export const getColorMode: () => ColorMode;\n}\n\ndeclare module 'test/constants' {\n    export const SDK_VERSION: string;\n    export const BEACON_VERSION: string;\n}\n\ndeclare module 'test/debug' {\n    export const setDebugEnabled: (enabled: boolean) => void;\n    export const getDebugEnabled: () => boolean;\n}\n\ndeclare module 'test/errors/AbortedBeaconError' {\n    import { BeaconError } from 'test/';\n    export class AbortedBeaconError extends BeaconError {\n        name: string;\n        title: string;\n        constructor();\n    }\n}\n\ndeclare module 'test/errors/BeaconError' {\n    import { BeaconErrorType } from 'test/';\n    export abstract class BeaconError implements Error {\n        name: string;\n        message: string;\n        title: string;\n        description: string;\n        get fullDescription(): string;\n        constructor(errorType: BeaconErrorType, message: string);\n        static getError(errorType: BeaconErrorType, errorData: any): BeaconError;\n    }\n}\n\ndeclare module 'test/errors/BroadcastBeaconError' {\n    import { BeaconError } from 'test/';\n    export class BroadcastBeaconError extends BeaconError {\n        name: string;\n        title: string;\n        constructor();\n    }\n}\n\ndeclare module 'test/errors/NetworkNotSupportedBeaconError' {\n    import { BeaconError } from 'test/';\n    export class NetworkNotSupportedBeaconError extends BeaconError {\n        name: string;\n        title: string;\n        constructor();\n    }\n}\n\ndeclare module 'test/errors/NoAddressBeaconError' {\n    import { BeaconError } from 'test/';\n    export class NoAddressBeaconError extends BeaconError {\n        name: string;\n        title: string;\n        constructor();\n    }\n}\n\ndeclare module 'test/errors/NoPrivateKeyBeaconError' {\n    import { BeaconError } from 'test/';\n    export class NoPrivateKeyBeaconError extends BeaconError {\n        name: string;\n        title: string;\n        constructor();\n    }\n}\n\ndeclare module 'test/errors/NotGrantedBeaconError' {\n    import { BeaconError } from 'test/';\n    export class NotGrantedBeaconError extends BeaconError {\n        name: string;\n        title: string;\n        constructor();\n    }\n}\n\ndeclare module 'test/errors/ParametersInvalidBeaconError' {\n    import { BeaconError } from 'test/';\n    export class ParametersInvalidBeaconError extends BeaconError {\n        name: string;\n        title: string;\n        constructor();\n    }\n}\n\ndeclare module 'test/errors/SignatureTypeNotSupportedBeaconError' {\n    import { BeaconError } from 'test/';\n    export class SignatureTypeNotSupportedBeaconError extends BeaconError {\n        name: string;\n        title: string;\n        constructor();\n    }\n}\n\ndeclare module 'test/errors/TooManyOperationsBeaconError' {\n    import { BeaconError } from 'test/';\n    export class TooManyOperationsBeaconError extends BeaconError {\n        name: string;\n        title: string;\n        constructor();\n    }\n}\n\ndeclare module 'test/errors/TransactionInvalidBeaconError' {\n    import { BeaconError } from 'test/';\n    export class TransactionInvalidBeaconError extends BeaconError {\n        readonly data: any;\n        name: string;\n        title: string;\n        get fullDescription(): string;\n        constructor(data: any);\n    }\n}\n\ndeclare module 'test/errors/UnknownBeaconError' {\n    import { BeaconError } from 'test/';\n    export class UnknownBeaconError extends BeaconError {\n        name: string;\n        title: string;\n        constructor();\n    }\n}\n\ndeclare module 'test/events' {\n    import { AlertButton } from 'test/ui/alert/Alert';\n    import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n    import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n    import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n    import { BlockExplorer } from 'test/utils/block-explorer';\n    import { P2PPairingRequest, AccountInfo, ErrorResponse, PermissionResponseOutput, OperationResponseOutput, BroadcastResponseOutput, SignPayloadResponseOutput, Network, ConnectionContext, Transport, NetworkType, AcknowledgeResponse } from 'test/';\n    /**\n        * The different events that can be emitted by the beacon-sdk\n        */\n    export enum BeaconEvent {\n            PERMISSION_REQUEST_SENT = \"PERMISSION_REQUEST_SENT\",\n            PERMISSION_REQUEST_SUCCESS = \"PERMISSION_REQUEST_SUCCESS\",\n            PERMISSION_REQUEST_ERROR = \"PERMISSION_REQUEST_ERROR\",\n            OPERATION_REQUEST_SENT = \"OPERATION_REQUEST_SENT\",\n            OPERATION_REQUEST_SUCCESS = \"OPERATION_REQUEST_SUCCESS\",\n            OPERATION_REQUEST_ERROR = \"OPERATION_REQUEST_ERROR\",\n            SIGN_REQUEST_SENT = \"SIGN_REQUEST_SENT\",\n            SIGN_REQUEST_SUCCESS = \"SIGN_REQUEST_SUCCESS\",\n            SIGN_REQUEST_ERROR = \"SIGN_REQUEST_ERROR\",\n            BROADCAST_REQUEST_SENT = \"BROADCAST_REQUEST_SENT\",\n            BROADCAST_REQUEST_SUCCESS = \"BROADCAST_REQUEST_SUCCESS\",\n            BROADCAST_REQUEST_ERROR = \"BROADCAST_REQUEST_ERROR\",\n            ACKNOWLEDGE_RECEIVED = \"ACKNOWLEDGE_RECEIVED\",\n            LOCAL_RATE_LIMIT_REACHED = \"LOCAL_RATE_LIMIT_REACHED\",\n            NO_PERMISSIONS = \"NO_PERMISSIONS\",\n            ACTIVE_ACCOUNT_SET = \"ACTIVE_ACCOUNT_SET\",\n            ACTIVE_TRANSPORT_SET = \"ACTIVE_TRANSPORT_SET\",\n            PAIR_INIT = \"PAIR_INIT\",\n            PAIR_SUCCESS = \"PAIR_SUCCESS\",\n            CHANNEL_CLOSED = \"CHANNEL_CLOSED\",\n            INTERNAL_ERROR = \"INTERNAL_ERROR\",\n            UNKNOWN = \"UNKNOWN\"\n    }\n    export interface WalletInfo {\n            name: string;\n            icon?: string;\n    }\n    export interface ExtraInfo {\n            resetCallback?(): Promise<void>;\n    }\n    interface RequestSentInfo {\n            extraInfo: ExtraInfo;\n            walletInfo: WalletInfo;\n    }\n    /**\n        * The type of the payload of the different BeaconEvents\n        */\n    export interface BeaconEventType {\n            [BeaconEvent.PERMISSION_REQUEST_SENT]: RequestSentInfo;\n            [BeaconEvent.PERMISSION_REQUEST_SUCCESS]: {\n                    account: AccountInfo;\n                    output: PermissionResponseOutput;\n                    blockExplorer: BlockExplorer;\n                    connectionContext: ConnectionContext;\n                    walletInfo: WalletInfo;\n            };\n            [BeaconEvent.PERMISSION_REQUEST_ERROR]: {\n                    errorResponse: ErrorResponse;\n                    walletInfo: WalletInfo;\n            };\n            [BeaconEvent.OPERATION_REQUEST_SENT]: RequestSentInfo;\n            [BeaconEvent.OPERATION_REQUEST_SUCCESS]: {\n                    account: AccountInfo;\n                    output: OperationResponseOutput;\n                    blockExplorer: BlockExplorer;\n                    connectionContext: ConnectionContext;\n                    walletInfo: WalletInfo;\n            };\n            [BeaconEvent.OPERATION_REQUEST_ERROR]: {\n                    errorResponse: ErrorResponse;\n                    walletInfo: WalletInfo;\n            };\n            [BeaconEvent.SIGN_REQUEST_SENT]: RequestSentInfo;\n            [BeaconEvent.SIGN_REQUEST_SUCCESS]: {\n                    output: SignPayloadResponseOutput;\n                    connectionContext: ConnectionContext;\n                    walletInfo: WalletInfo;\n            };\n            [BeaconEvent.SIGN_REQUEST_ERROR]: {\n                    errorResponse: ErrorResponse;\n                    walletInfo: WalletInfo;\n            };\n            [BeaconEvent.BROADCAST_REQUEST_SENT]: RequestSentInfo;\n            [BeaconEvent.BROADCAST_REQUEST_SUCCESS]: {\n                    network: Network;\n                    output: BroadcastResponseOutput;\n                    blockExplorer: BlockExplorer;\n                    connectionContext: ConnectionContext;\n                    walletInfo: WalletInfo;\n            };\n            [BeaconEvent.BROADCAST_REQUEST_ERROR]: {\n                    errorResponse: ErrorResponse;\n                    walletInfo: WalletInfo;\n            };\n            [BeaconEvent.ACKNOWLEDGE_RECEIVED]: {\n                    message: AcknowledgeResponse;\n                    extraInfo: ExtraInfo;\n                    walletInfo: WalletInfo;\n            };\n            [BeaconEvent.LOCAL_RATE_LIMIT_REACHED]: undefined;\n            [BeaconEvent.NO_PERMISSIONS]: undefined;\n            [BeaconEvent.ACTIVE_ACCOUNT_SET]: AccountInfo;\n            [BeaconEvent.ACTIVE_TRANSPORT_SET]: Transport;\n            [BeaconEvent.PAIR_INIT]: {\n                    p2pPeerInfo: P2PPairingRequest;\n                    postmessagePeerInfo: PostMessagePairingRequest;\n                    preferredNetwork: NetworkType;\n                    abortedHandler?(): void;\n            };\n            [BeaconEvent.PAIR_SUCCESS]: ExtendedPostMessagePairingResponse | ExtendedP2PPairingResponse;\n            [BeaconEvent.CHANNEL_CLOSED]: string;\n            [BeaconEvent.INTERNAL_ERROR]: string;\n            [BeaconEvent.UNKNOWN]: undefined;\n    }\n    export type BeaconEventHandlerFunction<T = unknown> = (data: T, eventCallback?: AlertButton[]) => void | Promise<void>;\n    /**\n        * The default event handlers\n        */\n    export const defaultEventCallbacks: {\n            [key in BeaconEvent]: BeaconEventHandlerFunction<BeaconEventType[key]>;\n    };\n    /**\n        * Handles beacon events\n        */\n    export class BeaconEventHandler {\n            constructor(eventsToOverride?: {\n                    [key in BeaconEvent]?: {\n                            handler: BeaconEventHandlerFunction<BeaconEventType[key]>;\n                    };\n            }, overrideAll?: boolean);\n            /**\n                * A method to subscribe to a specific beacon event and register a callback\n                *\n                * @param event The event being emitted\n                * @param eventCallback The callback that will be invoked\n                */\n            on<K extends BeaconEvent>(event: K, eventCallback: BeaconEventHandlerFunction<BeaconEventType[K]>): Promise<void>;\n            /**\n                * Emit a beacon event\n                *\n                * @param event The event being emitted\n                * @param data The data to be emit\n                */\n            emit<K extends BeaconEvent>(event: K, data?: BeaconEventType[K], eventCallback?: AlertButton[]): Promise<void>;\n    }\n    export {};\n}\n\ndeclare module 'test/examples/broadcast-request' {\n    export {};\n}\n\ndeclare module 'test/examples/custom-block-explorer' {\n    export {};\n}\n\ndeclare module 'test/examples/disable-all-ui' {\n    export {};\n}\n\ndeclare module 'test/examples/operation-request' {\n    export {};\n}\n\ndeclare module 'test/examples/override-default-events' {\n    export {};\n}\n\ndeclare module 'test/examples/permission-request' {\n    export {};\n}\n\ndeclare module 'test/examples/sign-payload-request' {\n    export {};\n}\n\ndeclare module 'test/examples/using-custom-network' {\n    export {};\n}\n\ndeclare module 'test/examples/wallet-example' {\n    export {};\n}\n\ndeclare module 'test/index' {\n    import { P2PCommunicationClient } from 'test/transports/clients/P2PCommunicationClient';\n    import { AppMetadata } from 'test/types/beacon/AppMetadata';\n    import { PermissionRequest } from 'test/types/beacon/messages/PermissionRequest';\n    import { Network } from 'test/types/beacon/Network';\n    import { BeaconBaseMessage } from 'test/types/beacon/BeaconBaseMessage';\n    import { BeaconMessageType } from 'test/types/beacon/BeaconMessageType';\n    import { PermissionScope } from 'test/types/beacon/PermissionScope';\n    import { PermissionResponse } from 'test/types/beacon/messages/PermissionResponse';\n    import { OperationRequest } from 'test/types/beacon/messages/OperationRequest';\n    import { OperationResponse } from 'test/types/beacon/messages/OperationResponse';\n    import { SignPayloadRequest } from 'test/types/beacon/messages/SignPayloadRequest';\n    import { SignPayloadResponse } from 'test/types/beacon/messages/SignPayloadResponse';\n    import { BroadcastRequest } from 'test/types/beacon/messages/BroadcastRequest';\n    import { BroadcastResponse } from 'test/types/beacon/messages/BroadcastResponse';\n    import { NetworkType } from 'test/types/beacon/NetworkType';\n    import { TezosBaseOperation } from 'test/types/tezos/TezosBaseOperation';\n    import { TezosOperationType } from 'test/types/tezos/OperationTypes';\n    import { TezosActivateAccountOperation } from 'test/types/tezos/operations/ActivateAccount';\n    import { TezosBallotOperation } from 'test/types/tezos/operations/Ballot';\n    import { TezosDelegationOperation } from 'test/types/tezos/operations/Delegation';\n    import { TezosDoubleBakingEvidenceOperation } from 'test/types/tezos/operations/DoubleBakingEvidence';\n    import { TezosBlockHeader } from 'test/types/tezos/TezosBlockHeader';\n    import { TezosDoubleEndorsementEvidenceOperation } from 'test/types/tezos/operations/DoubleEndorsementEvidence';\n    import { TezosEndorsementOperation } from 'test/types/tezos/operations/Endorsement';\n    import { TezosOriginationOperation } from 'test/types/tezos/operations/Origination';\n    import { TezosProposalOperation } from 'test/types/tezos/operations/Proposal';\n    import { TezosRevealOperation } from 'test/types/tezos/operations/Reveal';\n    import { TezosSeedNonceRevelationOperation } from 'test/types/tezos/operations/SeedNonceRevelation';\n    import { TezosTransactionOperation } from 'test/types/tezos/operations/Transaction';\n    import { MichelsonPrimitives } from 'test/types/tezos/MichelsonPrimitives';\n    import { TezosTransactionParameters } from 'test/types/tezos/TezosTransactionParameters';\n    import { Origin } from 'test/types/Origin';\n    import { AccountInfo, AccountIdentifier } from 'test/types/AccountInfo';\n    import { EncryptedExtensionMessage, ExtensionMessage } from 'test/types/ExtensionMessage';\n    import { ExtensionMessageTarget } from 'test/types/ExtensionMessageTarget';\n    import { TezosOperation } from 'test/types/tezos/TezosOperation';\n    import { Client } from 'test/clients/client/Client';\n    import { WalletClient } from 'test/clients/wallet-client/WalletClient';\n    import { DAppClient } from 'test/clients/dapp-client/DAppClient';\n    import { BeaconError } from 'test/errors/BeaconError';\n    import { BeaconErrorType } from 'test/types/BeaconErrorType';\n    import { BroadcastBeaconError } from 'test/errors/BroadcastBeaconError';\n    import { NetworkNotSupportedBeaconError } from 'test/errors/NetworkNotSupportedBeaconError';\n    import { NoAddressBeaconError } from 'test/errors/NoAddressBeaconError';\n    import { NoPrivateKeyBeaconError } from 'test/errors/NoPrivateKeyBeaconError';\n    import { NotGrantedBeaconError } from 'test/errors/NotGrantedBeaconError';\n    import { ParametersInvalidBeaconError } from 'test/errors/ParametersInvalidBeaconError';\n    import { TooManyOperationsBeaconError } from 'test/errors/TooManyOperationsBeaconError';\n    import { TransactionInvalidBeaconError } from 'test/errors/TransactionInvalidBeaconError';\n    import { UnknownBeaconError } from 'test/errors/UnknownBeaconError';\n    import { ErrorResponse } from 'test/types/beacon/messages/ErrorResponse';\n    import { TransportStatus } from 'test/types/transport/TransportStatus';\n    import { TransportType } from 'test/types/transport/TransportType';\n    import { PostMessageTransport } from 'test/transports/PostMessageTransport';\n    import { Transport } from 'test/transports/Transport';\n    import { P2PTransport } from 'test/transports/P2PTransport';\n    import { Storage } from 'test/storage/Storage';\n    import { StorageKey } from 'test/types/storage/StorageKey';\n    import { StorageKeyReturnDefaults } from 'test/types/storage/StorageKeyReturnDefaults';\n    import { StorageKeyReturnType } from 'test/types/storage/StorageKeyReturnType';\n    import { ExtendedP2PPairingRequest, P2PPairingRequest } from 'test/types/P2PPairingRequest';\n    import { ChromeStorage } from 'test/storage/ChromeStorage';\n    import { LocalStorage } from 'test/storage/LocalStorage';\n    import { getStorage } from 'test/storage/getStorage';\n    import { BeaconMessage } from 'test/types/beacon/BeaconMessage';\n    import { Serializer } from 'test/Serializer';\n    import { RequestPermissionInput } from 'test/types/RequestPermissionInput';\n    import { RequestSignPayloadInput } from 'test/types/RequestSignPayloadInput';\n    import { RequestOperationInput } from 'test/types/RequestOperationInput';\n    import { RequestBroadcastInput } from 'test/types/RequestBroadcastInput';\n    import { PermissionResponseInput, SignPayloadResponseInput, OperationResponseInput, BroadcastResponseInput, BeaconResponseInputMessage, AcknowledgeResponseInput, ErrorResponseInput } from 'test/types/beacon/messages/BeaconResponseInputMessage';\n    import { PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, BeaconResponseOutputMessage } from 'test/types/beacon/messages/BeaconResponseOutputMessage';\n    import { PermissionRequestInput, SignPayloadRequestInput, OperationRequestInput, BroadcastRequestInput, BeaconRequestInputMessage } from 'test/types/beacon/messages/BeaconRequestInputMessage';\n    import { PermissionRequestOutput, SignPayloadRequestOutput, OperationRequestOutput, BroadcastRequestOutput, BeaconRequestOutputMessage } from 'test/types/beacon/messages/BeaconRequestOutputMessage';\n    import { ClientOptions } from 'test/clients/client/ClientOptions';\n    import { DAppClientOptions } from 'test/clients/dapp-client/DAppClientOptions';\n    import { WalletClientOptions } from 'test/clients/wallet-client/WalletClientOptions';\n    import { PermissionInfo } from 'test/types/PermissionInfo';\n    import { SDK_VERSION, BEACON_VERSION } from 'test/constants';\n    import { AccountManager } from 'test/managers/AccountManager';\n    import { AppMetadataManager } from 'test/managers/AppMetadataManager';\n    import { PermissionManager } from 'test/managers/PermissionManager';\n    import { BeaconEvent, BeaconEventHandler, defaultEventCallbacks } from 'test/events';\n    import { getAddressFromPublicKey } from 'test/utils/crypto';\n    import { BeaconClient } from 'test/clients/beacon-client/BeaconClient';\n    import { BeaconClientOptions } from 'test/clients/beacon-client/BeaconClientOptions';\n    import { getAccountIdentifier } from 'test/utils/get-account-identifier';\n    import { ConnectionContext } from 'test/types/ConnectionContext';\n    import { Threshold } from 'test/types/beacon/Threshold';\n    import { PartialTezosTransactionOperation, PartialTezosOperation, PartialTezosDelegationOperation, PartialTezosOriginationOperation, PartialTezosRevealOperation } from 'test/types/tezos/PartialTezosOperation';\n    import { AbortedBeaconError } from 'test/errors/AbortedBeaconError';\n    import { ExtendedPeerInfo, PeerInfo } from 'test/types/PeerInfo';\n    import { availableTransports } from 'test/utils/available-transports';\n    import { AcknowledgeResponse } from 'test/types/beacon/messages/AcknowledgeResponse';\n    import { DisconnectMessage } from 'test/types/beacon/messages/DisconnectMessage';\n    import { DappP2PTransport } from 'test/transports/DappP2PTransport';\n    import { DappPostMessageTransport } from 'test/transports/DappPostMessageTransport';\n    import { WalletP2PTransport } from 'test/transports/WalletP2PTransport';\n    import { WalletPostMessageTransport } from 'test/transports/WalletPostMessageTransport';\n    import { getSenderId } from 'test/utils/get-sender-id';\n    import { SigningType } from 'test/types/beacon/SigningType';\n    import { SignatureTypeNotSupportedBeaconError } from 'test/errors/SignatureTypeNotSupportedBeaconError';\n    import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n    import { ExtendedPostMessagePairingRequest, PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n    import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n    import { PeerManager } from 'test/managers/PeerManager';\n    import { MessageBasedClient } from 'test/transports/clients/MessageBasedClient';\n    import { BeaconRequestMessage } from 'test/types/beacon/BeaconRequestMessage';\n    import { BeaconResponseMessage } from 'test/types/beacon/BeaconResponseMessage';\n    import { Pairing } from 'test/ui/alert/Pairing';\n    import { BlockExplorer } from 'test/utils/block-explorer';\n    import { TezblockBlockExplorer } from 'test/utils/tezblock-blockexplorer';\n    import { setDebugEnabled, getDebugEnabled } from 'test/debug';\n    import { ColorMode } from 'test/types/ColorMode';\n    export { TezosBaseOperation, TezosOperationType, TezosBlockHeader, MichelsonPrimitives, TezosTransactionParameters, TezosOperation };\n    export { TezosActivateAccountOperation, TezosBallotOperation, TezosDelegationOperation, TezosDoubleBakingEvidenceOperation, TezosDoubleEndorsementEvidenceOperation, TezosEndorsementOperation, TezosOriginationOperation, TezosProposalOperation, TezosRevealOperation, TezosSeedNonceRevelationOperation, TezosTransactionOperation, PartialTezosOperation, PartialTezosTransactionOperation, PartialTezosDelegationOperation, PartialTezosOriginationOperation, PartialTezosRevealOperation };\n    export { BeaconClient, BeaconClientOptions, Client, ClientOptions, DAppClient, DAppClientOptions, WalletClient, WalletClientOptions, P2PCommunicationClient };\n    export { AccountIdentifier, AppMetadata, Network, NetworkType, BeaconMessage, PermissionRequest, PermissionResponse, OperationRequest, OperationResponse, SignPayloadRequest, SignPayloadResponse, BroadcastRequest, BroadcastResponse, AcknowledgeResponse, DisconnectMessage, BeaconBaseMessage, BeaconMessageType, PermissionScope, Origin, AccountInfo, Threshold, SigningType, ExtensionMessageTarget, ExtensionMessage, EncryptedExtensionMessage, RequestPermissionInput, RequestSignPayloadInput, RequestOperationInput, RequestBroadcastInput, PermissionInfo };\n    export { PermissionResponseInput, SignPayloadResponseInput, OperationResponseInput, BroadcastResponseInput, AcknowledgeResponseInput, ErrorResponseInput, PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, PermissionRequestInput, SignPayloadRequestInput, OperationRequestInput, BroadcastRequestInput, PermissionRequestOutput, SignPayloadRequestOutput, OperationRequestOutput, BroadcastRequestOutput, BeaconRequestInputMessage, BeaconRequestOutputMessage, BeaconResponseInputMessage, BeaconResponseOutputMessage, BeaconRequestMessage, BeaconResponseMessage };\n    export { BeaconError, BeaconErrorType, ErrorResponse, AbortedBeaconError, BroadcastBeaconError, NetworkNotSupportedBeaconError, NoAddressBeaconError, NoPrivateKeyBeaconError, NotGrantedBeaconError, ParametersInvalidBeaconError, TooManyOperationsBeaconError, TransactionInvalidBeaconError, SignatureTypeNotSupportedBeaconError, UnknownBeaconError };\n    export { TransportStatus, TransportType, Transport, PostMessageTransport, P2PTransport, WalletP2PTransport, WalletPostMessageTransport, DappP2PTransport, DappPostMessageTransport, MessageBasedClient, Pairing };\n    export { BeaconEvent, BeaconEventHandler, defaultEventCallbacks };\n    export { Storage, StorageKey, StorageKeyReturnDefaults, StorageKeyReturnType, ChromeStorage, LocalStorage, getStorage };\n    export { PeerManager, AccountManager, AppMetadataManager, PermissionManager };\n    export { SDK_VERSION, BEACON_VERSION };\n    export { getSenderId, getAccountIdentifier, getAddressFromPublicKey };\n    export { PeerInfo, ExtendedPeerInfo, PostMessagePairingRequest, ExtendedPostMessagePairingRequest, ExtendedPostMessagePairingResponse, P2PPairingRequest, ExtendedP2PPairingRequest, ExtendedP2PPairingResponse };\n    export { BlockExplorer, TezblockBlockExplorer };\n    export { ConnectionContext, Serializer, availableTransports, ColorMode };\n    export { setDebugEnabled, getDebugEnabled };\n}\n\ndeclare module 'test/interceptors/IncomingRequestInterceptor' {\n    import { BeaconRequestOutputMessage } from 'test/';\n    import { ConnectionContext } from 'test/types/ConnectionContext';\n    import { AppMetadataManager } from 'test/managers/AppMetadataManager';\n    import { BeaconRequestMessage } from 'test/types/beacon/BeaconRequestMessage';\n    interface IncomingRequestInterceptorOptions {\n            message: BeaconRequestMessage;\n            connectionInfo: ConnectionContext;\n            appMetadataManager: AppMetadataManager;\n            interceptorCallback(message: BeaconRequestOutputMessage, connectionInfo: ConnectionContext): void;\n    }\n    /**\n        * The IncomingRequestInterceptor is used in the WalletClient to intercept an incoming request and enrich it with data, like app metadata.\n        */\n    export class IncomingRequestInterceptor {\n            /**\n                * The method that is called during the interception\n                *\n                * @param config\n                */\n            static intercept(config: IncomingRequestInterceptorOptions): Promise<void>;\n    }\n    export {};\n}\n\ndeclare module 'test/interceptors/OutgoingResponseInterceptor' {\n    import { BeaconMessage, BeaconResponseInputMessage, AppMetadata } from 'test/';\n    import { PermissionManager } from 'test/managers/PermissionManager';\n    import { AppMetadataManager } from 'test/managers/AppMetadataManager';\n    import { BeaconRequestMessage } from 'test/types/beacon/BeaconRequestMessage';\n    interface OutgoingResponseInterceptorOptions {\n        senderId: string;\n        request: BeaconRequestMessage;\n        message: BeaconResponseInputMessage;\n        ownAppMetadata: AppMetadata;\n        permissionManager: PermissionManager;\n        appMetadataManager: AppMetadataManager;\n        interceptorCallback(message: BeaconMessage): void;\n    }\n    /**\n      * The OutgoingResponseInterceptor is used in the WalletClient to intercept an outgoing response and enrich it with data.\n      */\n    export class OutgoingResponseInterceptor {\n        static intercept(config: OutgoingResponseInterceptorOptions): Promise<void>;\n    }\n    export {};\n}\n\ndeclare module 'test/managers/AccountManager' {\n    import { Storage, AccountInfo, BeaconMessage } from 'test/';\n    /**\n      * The AccountManager provides CRUD functionality for account entities and persists them to the provided storage.\n      */\n    export class AccountManager {\n        constructor(storage: Storage);\n        getAccounts(): Promise<AccountInfo[]>;\n        getAccount(accountIdentifier: string): Promise<AccountInfo | undefined>;\n        addAccount(accountInfo: AccountInfo): Promise<void>;\n        removeAccount(accountIdentifier: string): Promise<void>;\n        removeAccounts(accountIdentifiers: string[]): Promise<void>;\n        removeAllAccounts(): Promise<void>;\n        hasPermission(message: BeaconMessage): Promise<boolean>;\n    }\n}\n\ndeclare module 'test/managers/AppMetadataManager' {\n    import { Storage, AppMetadata } from 'test/';\n    /**\n      * The AppMetadataManager provides CRUD functionality for app-metadata entities and persists them to the provided storage.\n      */\n    export class AppMetadataManager {\n        constructor(storage: Storage);\n        getAppMetadataList(): Promise<AppMetadata[]>;\n        getAppMetadata(senderId: string): Promise<AppMetadata | undefined>;\n        addAppMetadata(appMetadata: AppMetadata): Promise<void>;\n        removeAppMetadata(senderId: string): Promise<void>;\n        removeAppMetadatas(senderIds: string[]): Promise<void>;\n        removeAllAppMetadata(): Promise<void>;\n    }\n}\n\ndeclare module 'test/managers/PeerManager' {\n    import { Storage, StorageKey, StorageKeyReturnType } from 'test/';\n    import { ArrayElem } from 'test/managers/StorageManager';\n    /**\n      * The PeerManager provides CRUD functionality for peer entities and persists them to the provided storage.\n      */\n    export class PeerManager<T extends StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET> {\n        constructor(storage: Storage, key: T);\n        hasPeer(publicKey: string): Promise<boolean>;\n        getPeers(): Promise<StorageKeyReturnType[T]>;\n        getPeer(publicKey: string): Promise<ArrayElem<StorageKeyReturnType[T]> | undefined>;\n        addPeer(peerInfo: ArrayElem<StorageKeyReturnType[T]>): Promise<void>;\n        removePeer(publicKey: string): Promise<void>;\n        removePeers(publicKeys: string[]): Promise<void>;\n        removeAllPeers(): Promise<void>;\n    }\n}\n\ndeclare module 'test/managers/PermissionManager' {\n    import { BeaconMessage, Storage } from 'test/';\n    import { PermissionInfo } from 'test/types/PermissionInfo';\n    /**\n      * The PermissionManager provides CRUD functionality for permission entities and persists them to the provided storage.\n      */\n    export class PermissionManager {\n        constructor(storage: Storage);\n        getPermissions(): Promise<PermissionInfo[]>;\n        getPermission(accountIdentifier: string): Promise<PermissionInfo | undefined>;\n        addPermission(permissionInfo: PermissionInfo): Promise<void>;\n        removePermission(accountIdentifier: string): Promise<void>;\n        removePermissions(accountIdentifiers: string[]): Promise<void>;\n        removeAllPermissions(): Promise<void>;\n        hasPermission(message: BeaconMessage): Promise<boolean>;\n    }\n}\n\ndeclare module 'test/managers/PermissionValidator' {\n    import { BeaconMessage } from 'test/';\n    import { PermissionEntity } from 'test/types/PermissionEntity';\n    /**\n        * The PermissionValidator is used to check if permissions for a certain message type have been given\n        */\n    export class PermissionValidator {\n            /**\n                * Check if permissions were given for a certain message type.\n                *\n                * PermissionRequest and BroadcastRequest will always return true.\n                *\n                * @param message Beacon Message\n                */\n            static hasPermission(message: BeaconMessage, getOne: (id: string) => Promise<PermissionEntity | undefined>, getAll: () => Promise<PermissionEntity[]>): Promise<boolean>;\n    }\n}\n\ndeclare module 'test/managers/StorageManager' {\n    import { StorageKey, Storage, StorageKeyReturnType } from 'test/';\n    /** Type workaround for https://github.com/Microsoft/TypeScript/issues/7294#issuecomment-465794460 */\n    export type ArrayElem<A> = A extends (infer Elem)[] ? Elem : never;\n    /**\n        * The StorageManager provides CRUD functionality for specific entities and persists them to the provided storage.\n        */\n    export class StorageManager<T extends StorageKey.ACCOUNTS | StorageKey.APP_METADATA_LIST | StorageKey.PERMISSION_LIST | StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET> {\n            constructor(storage: Storage, storageKey: T);\n            getAll(): Promise<StorageKeyReturnType[T]>;\n            getOne(predicate: (element: ArrayElem<StorageKeyReturnType[T]>) => boolean): Promise<ArrayElem<StorageKeyReturnType[T]> | undefined>;\n            addOne(element: ArrayElem<StorageKeyReturnType[T]>, predicate: (element: ArrayElem<StorageKeyReturnType[T]>) => boolean, overwrite?: boolean): Promise<void>;\n            remove(predicate: (element: ArrayElem<StorageKeyReturnType[T]>) => boolean): Promise<void>;\n            removeAll(): Promise<void>;\n    }\n}\n\ndeclare module 'test/matrix-client/MatrixClient' {\n    import { Storage } from 'test/storage/Storage';\n    import { MatrixClientStore } from 'test/matrix-client/MatrixClientStore';\n    import { MatrixRoom } from 'test/matrix-client/models/MatrixRoom';\n    import { MatrixRoomService } from 'test/matrix-client/services/MatrixRoomService';\n    import { MatrixUserService } from 'test/matrix-client/services/MatrixUserService';\n    import { MatrixEventService } from 'test/matrix-client/services/MatrixEventService';\n    import { MatrixClientEventEmitter } from 'test/matrix-client/MatrixClientEventEmitter';\n    import { MatrixClientEventType, MatrixClientEvent } from 'test/matrix-client/models/MatrixClientEvent';\n    interface MatrixClientOptions {\n            baseUrl: string;\n            storage: Storage;\n    }\n    interface MatrixLoginConfig {\n            id: string;\n            password: string;\n            deviceId: string;\n    }\n    /**\n        * The matrix client used to connect to the matrix network\n        */\n    export class MatrixClient {\n            /**\n                * Create a matrix client based on the options provided\n                *\n                * @param config\n                */\n            static create(config: MatrixClientOptions): MatrixClient;\n            /**\n                * Return all the rooms we are currently part of\n                */\n            get joinedRooms(): MatrixRoom[];\n            /**\n                * Return all the rooms to which we have received invitations\n                */\n            get invitedRooms(): MatrixRoom[];\n            /**\n                * Return all the rooms that we left\n                */\n            get leftRooms(): MatrixRoom[];\n            constructor(store: MatrixClientStore, eventEmitter: MatrixClientEventEmitter, userService: MatrixUserService, roomService: MatrixRoomService, eventService: MatrixEventService);\n            /**\n                * Initiate the connection to the matrix node and log in\n                *\n                * @param user\n                */\n            start(user: MatrixLoginConfig): Promise<void>;\n            /**\n                * Subscribe to new matrix events\n                *\n                * @param event\n                * @param listener\n                */\n            subscribe<T extends MatrixClientEventType>(event: T, listener: (event: MatrixClientEvent<T>) => void): void;\n            /**\n                * Unsubscribe from matrix events\n                *\n                * @param event\n                * @param listener\n                */\n            unsubscribe(event: MatrixClientEventType, listener?: (event: MatrixClientEvent<any>) => void): void;\n            getRoomById(id: string): MatrixRoom;\n            /**\n                * Create a private room with the supplied members\n                *\n                * @param members Members that will be in the room\n                */\n            createTrustedPrivateRoom(...members: string[]): Promise<string>;\n            /**\n                * Invite user to rooms\n                *\n                * @param user The user to be invited\n                * @param roomsOrIds The rooms the user will be invited to\n                */\n            inviteToRooms(user: string, ...roomsOrIds: string[] | MatrixRoom[]): Promise<void>;\n            /**\n                * Join rooms\n                *\n                * @param roomsOrIds\n                */\n            joinRooms(...roomsOrIds: string[] | MatrixRoom[]): Promise<void>;\n            /**\n                * Send a text message\n                *\n                * @param roomOrId\n                * @param message\n                */\n            sendTextMessage(roomId: string, message: string): Promise<void>;\n    }\n    export {};\n}\n\ndeclare module 'test/matrix-client/MatrixClientEventEmitter' {\n    import { EventEmitter } from 'events';\n    import { MatrixStateStore, MatrixStateUpdate } from 'test/matrix-client/MatrixClientStore';\n    export class MatrixClientEventEmitter extends EventEmitter {\n            /**\n                * This method is called every time the state is changed\n                *\n                * @param _oldState\n                * @param _newState\n                * @param stateChange\n                */\n            onStateChanged(_oldState: MatrixStateStore, _newState: MatrixStateStore, stateChange: Partial<MatrixStateUpdate>): void;\n    }\n}\n\ndeclare module 'test/matrix-client/MatrixClientStore' {\n    import { MatrixRoom } from 'test/matrix-client/models/MatrixRoom';\n    import { Storage } from 'test/storage/Storage';\n    type OnStateChangedListener = (oldState: MatrixStateStore, newState: MatrixStateStore, stateChange: Partial<MatrixStateUpdate>) => void;\n    export interface MatrixState {\n            isRunning: boolean;\n            userId: string | undefined;\n            deviceId: string | undefined;\n            txnNo: number;\n            accessToken: string | undefined;\n            syncToken: string | undefined;\n            pollingTimeout: number | undefined;\n            pollingRetries: number;\n            rooms: MatrixRoom[] | Record<string, MatrixRoom>;\n    }\n    export interface MatrixStateStore extends MatrixState {\n            rooms: Record<string, MatrixRoom>;\n    }\n    export interface MatrixStateUpdate extends MatrixState {\n            rooms: MatrixRoom[];\n    }\n    /**\n        * The class managing the local state of matrix\n        */\n    export class MatrixClientStore {\n            constructor(storage: Storage);\n            /**\n                * Get an item from the state\n                *\n                * @param key\n                */\n            get<T extends keyof MatrixStateStore>(key: T): MatrixStateStore[T];\n            /**\n                * Get the room from an ID or room instance\n                *\n                * @param roomOrId\n                */\n            getRoom(roomOrId: string | MatrixRoom): MatrixRoom;\n            /**\n                * Update the state with a partial state\n                *\n                * @param stateUpdate\n                */\n            update(stateUpdate: Partial<MatrixStateUpdate>): Promise<void>;\n            /**\n                * Register listeners that are called once the state has changed\n                *\n                * @param listener\n                * @param subscribed\n                */\n            onStateChanged(listener: OnStateChangedListener, ...subscribed: (keyof MatrixState)[]): void;\n    }\n    export {};\n}\n\ndeclare module 'test/matrix-client/MatrixHttpClient' {\n    import { MatrixRequest, MatrixRequestParams } from 'test/matrix-client/models/api/MatrixRequest';\n    interface HttpOptions {\n            accessToken?: string;\n    }\n    /**\n        * Handling the HTTP connection to the matrix synapse node\n        */\n    export class MatrixHttpClient {\n            constructor(baseUrl: string);\n            /**\n                * Get data from the synapse node\n                *\n                * @param endpoint\n                * @param options\n                */\n            get<T>(endpoint: string, params?: MatrixRequestParams<T>, options?: HttpOptions): Promise<T>;\n            /**\n                * Post data to the synapse node\n                *\n                * @param endpoint\n                * @param body\n                * @param options\n                * @param params\n                */\n            post<T>(endpoint: string, body: MatrixRequest<T>, options?: HttpOptions, params?: MatrixRequestParams<T>): Promise<T>;\n            /**\n                * Put data to the synapse node\n                *\n                * @param endpoint\n                * @param body\n                * @param options\n                * @param params\n                */\n            put<T>(endpoint: string, body: MatrixRequest<T>, options?: HttpOptions, params?: MatrixRequestParams<T>): Promise<T>;\n    }\n    export {};\n}\n\ndeclare module 'test/matrix-client/models/api/MatrixEventSend' {\n    export interface MatrixEventSendRequest {\n        content: any;\n    }\n    export interface MatrixEventSendResponse {\n        type?: 'event_send';\n        event_id: string;\n    }\n}\n\ndeclare module 'test/matrix-client/models/api/MatrixLogin' {\n    export interface MatrixLoginRequest {\n        type: 'm.login.password';\n        identifier: {\n            type: 'm.id.user';\n            user: string;\n        };\n        password: string;\n        device_id?: string;\n    }\n    export interface MatrixLoginResponse {\n        type?: 'login';\n        user_id: string;\n        device_id: string;\n        access_token: string;\n    }\n}\n\ndeclare module 'test/matrix-client/models/api/MatrixRequest' {\n    import { MatrixLoginRequest, MatrixLoginResponse } from 'test/matrix-client/models/api/MatrixLogin';\n    import { MatrixRoomCreateRequest, MatrixRoomCreateResponse } from 'test/matrix-client/models/api/MatrixRoomCreate';\n    import { MatrixRoomInviteRequest, MatrixRoomInviteResponse } from 'test/matrix-client/models/api/MatrixRoomInvite';\n    import { MatrixRoomJoinRequest, MatrixRoomJoinResponse } from 'test/matrix-client/models/api/MatrixRoomJoin';\n    import { MatrixEventSendRequest, MatrixEventSendResponse } from 'test/matrix-client/models/api/MatrixEventSend';\n    import { MatrixSyncResponse, MatrixSyncRequestParams } from 'test/matrix-client/models/api/MatrixSync';\n    export type MatrixRequest<T> = T extends MatrixLoginResponse ? MatrixLoginRequest : T extends MatrixRoomCreateResponse ? MatrixRoomCreateRequest : T extends MatrixRoomInviteResponse ? MatrixRoomInviteRequest : T extends MatrixRoomJoinResponse ? MatrixRoomJoinRequest : T extends MatrixEventSendResponse ? MatrixEventSendRequest : never;\n    export type MatrixRequestParams<T> = T extends MatrixSyncResponse ? MatrixSyncRequestParams : never;\n}\n\ndeclare module 'test/matrix-client/models/api/MatrixRoomCreate' {\n    export interface MatrixRoomCreateRequest {\n        visibility?: 'public' | 'private';\n        room_alias_name?: string;\n        name?: string;\n        topic?: string;\n        invite?: string[];\n        preset?: 'private_chat' | 'public_chat' | 'trusted_private_chat';\n        is_direct?: boolean;\n    }\n    export interface MatrixRoomCreateResponse {\n        type?: 'room_create';\n        room_id: string;\n    }\n}\n\ndeclare module 'test/matrix-client/models/api/MatrixRoomInvite' {\n    export interface MatrixRoomInviteRequest {\n        user_id: string;\n    }\n    export interface MatrixRoomInviteResponse {\n        type?: 'room_invite';\n    }\n}\n\ndeclare module 'test/matrix-client/models/api/MatrixRoomJoin' {\n    export interface MatrixRoomJoinRequest {\n    }\n    export interface MatrixRoomJoinResponse {\n        type?: 'room_join';\n        room_id: string;\n    }\n}\n\ndeclare module 'test/matrix-client/models/api/MatrixSync' {\n    import { MatrixStateEvent } from 'test/matrix-client/models/MatrixStateEvent';\n    export interface MatrixSyncJoinedRoom {\n        state: {\n            events: MatrixStateEvent[];\n        };\n        timeline: {\n            events: MatrixStateEvent[];\n        };\n    }\n    export interface MatrixSyncInvitedRoom {\n        invite_state: {\n            events: MatrixStateEvent[];\n        };\n    }\n    export interface MatrixSyncLeftRoom {\n        state: {\n            events: MatrixStateEvent[];\n        };\n        timeline: {\n            events: MatrixStateEvent[];\n        };\n    }\n    export interface MatrixSyncRooms {\n        join: {\n            [key: string]: MatrixSyncJoinedRoom;\n        };\n        invite: {\n            [key: string]: MatrixSyncInvitedRoom;\n        };\n        leave: {\n            [key: string]: MatrixSyncLeftRoom;\n        };\n    }\n    export interface MatrixSyncRequestParams {\n        timeout?: number;\n        since?: string;\n    }\n    export interface MatrixSyncResponse {\n        type?: 'sync';\n        next_batch: string;\n        rooms: MatrixSyncRooms;\n    }\n}\n\ndeclare module 'test/matrix-client/models/MatrixClientEvent' {\n    import { MatrixMessage } from 'test/matrix-client/models/MatrixMessage';\n    export enum MatrixClientEventType {\n        INVITE = \"invite\",\n        MESSAGE = \"message\"\n    }\n    export type MatrixClientEventContent<T> = T extends MatrixClientEventType.INVITE ? MatrixClientEventInviteContent : T extends MatrixClientEventType.MESSAGE ? MatrixClientEventMessageContent<any> : never;\n    export interface MatrixClientEventInviteContent {\n        roomId: string;\n    }\n    export interface MatrixClientEventMessageContent<T> {\n        roomId: string;\n        message: MatrixMessage<T>;\n    }\n    export interface MatrixClientEvent<T extends MatrixClientEventType> {\n        type: T;\n        content: MatrixClientEventContent<T>;\n    }\n}\n\ndeclare module 'test/matrix-client/models/MatrixMessage' {\n    import { MatrixStateEvent } from 'test/matrix-client/models/MatrixStateEvent';\n    export enum MatrixMessageType {\n        TEXT = \"m.text\"\n    }\n    export class MatrixMessage<T> {\n        readonly type: MatrixMessageType;\n        readonly sender: string;\n        readonly content: T;\n        /**\n          * Construct a message from a message event\n          *\n          * @param event\n          */\n        static from(event: MatrixStateEvent): MatrixMessage<any> | undefined;\n    }\n}\n\ndeclare module 'test/matrix-client/models/MatrixRoom' {\n    import { MatrixSyncRooms } from 'test/matrix-client/models/api/MatrixSync';\n    import { MatrixMessage } from 'test/matrix-client/models/MatrixMessage';\n    export enum MatrixRoomStatus {\n            UNKNOWN = 0,\n            JOINED = 1,\n            INVITED = 2,\n            LEFT = 3\n    }\n    export class MatrixRoom {\n            readonly id: string;\n            readonly status: MatrixRoomStatus;\n            readonly members: string[];\n            messages: MatrixMessage<any>[];\n            /**\n                * Reconstruct rooms from a sync response\n                *\n                * @param roomSync\n                */\n            static fromSync(roomSync: MatrixSyncRooms): MatrixRoom[];\n            /**\n                * Reconstruct a room from an ID or object\n                *\n                * @param roomOrId\n                * @param status\n                */\n            static from(roomOrId: string | MatrixRoom, status?: MatrixRoomStatus): MatrixRoom;\n            /**\n                * Merge new and old state and remove duplicates\n                *\n                * @param newState\n                * @param previousState\n                */\n            static merge(newState: MatrixRoom, previousState?: MatrixRoom): MatrixRoom;\n    }\n}\n\ndeclare module 'test/matrix-client/models/MatrixStateEvent' {\n    import { MatrixMessageType } from 'test/matrix-client/models/MatrixMessage';\n    export interface MatrixStateEventMessageText extends MatrixStateEventMessage {\n        type: 'm.room.message';\n        content: {\n            msgtype: MatrixMessageType.TEXT;\n            body: string;\n        };\n    }\n    export interface MatrixStateEventMessageContent {\n        msgtype: string;\n        body: any;\n        [key: string]: any;\n    }\n    export interface MatrixStateEventMessage extends MatrixStateEvent {\n        type: 'm.room.message';\n        content: MatrixStateEventMessageContent;\n    }\n    export interface MatrixStateEvent {\n        type: string;\n        sender: string;\n        content: unknown;\n        event_id?: string;\n    }\n}\n\ndeclare module 'test/matrix-client/services/MatrixEventService' {\n    import { MatrixHttpClient } from 'test/matrix-client/MatrixHttpClient';\n    import { MatrixEventSendResponse } from 'test/matrix-client/models/api/MatrixEventSend';\n    import { MatrixSyncResponse } from 'test/matrix-client/models/api/MatrixSync';\n    import { MatrixStateEventMessageContent } from 'test/matrix-client/models/MatrixStateEvent';\n    interface MatrixScheduledEvent<T> {\n            accessToken: string;\n            roomId: string;\n            type: MatrixEventType;\n            content: any;\n            txnId: string;\n            onSuccess(response: T): void;\n            onError(error: unknown): void;\n    }\n    type MatrixEventType = 'm.room.message';\n    export interface MatrixSyncOptions {\n            syncToken?: string;\n            pollingTimeout?: number;\n    }\n    /**\n        * A service to help with matrix event management\n        */\n    export class MatrixEventService {\n            constructor(httpClient: MatrixHttpClient);\n            /**\n                * Get the latest state from the matrix node\n                *\n                * @param accessToken\n                * @param options\n                */\n            sync(accessToken: string, options?: MatrixSyncOptions): Promise<MatrixSyncResponse>;\n            /**\n                * Send a message to a room\n                *\n                * @param accessToken\n                * @param room\n                * @param content\n                * @param txnId\n                */\n            sendMessage(accessToken: string, roomId: string, content: MatrixStateEventMessageContent, txnId: string): Promise<MatrixEventSendResponse>;\n            /**\n                * Schedules an event to be sent to the node\n                *\n                * @param event\n                */\n            scheduleEvent(event: MatrixScheduledEvent<any>): void;\n            /**\n                * Send an event to the matrix node\n                *\n                * @param scheduledEvent\n                */\n            sendEvent(scheduledEvent: MatrixScheduledEvent<any>): Promise<void>;\n    }\n    export {};\n}\n\ndeclare module 'test/matrix-client/services/MatrixRoomService' {\n    import { MatrixHttpClient } from 'test/matrix-client/MatrixHttpClient';\n    import { MatrixRoom } from 'test/matrix-client/models/MatrixRoom';\n    import { MatrixRoomCreateRequest, MatrixRoomCreateResponse } from 'test/matrix-client/models/api/MatrixRoomCreate';\n    import { MatrixRoomInviteResponse } from 'test/matrix-client/models/api/MatrixRoomInvite';\n    import { MatrixRoomJoinResponse } from 'test/matrix-client/models/api/MatrixRoomJoin';\n    /**\n        * A service to help with matrix room management\n        */\n    export class MatrixRoomService {\n            constructor(httpClient: MatrixHttpClient);\n            /**\n                * Create a room\n                *\n                * @param accessToken\n                * @param config\n                */\n            createRoom(accessToken: string, config?: MatrixRoomCreateRequest): Promise<MatrixRoomCreateResponse>;\n            /**\n                * Invite a user to a room\n                *\n                * @param accessToken\n                * @param user\n                * @param room\n                */\n            inviteToRoom(accessToken: string, user: string, room: MatrixRoom): Promise<MatrixRoomInviteResponse>;\n            /**\n                * Join a specific room\n                *\n                * @param accessToken\n                * @param room\n                */\n            joinRoom(accessToken: string, room: MatrixRoom): Promise<MatrixRoomJoinResponse>;\n            /**\n                * Get all joined rooms\n                *\n                * @param accessToken\n                */\n            getJoinedRooms(accessToken: string): Promise<MatrixRoomJoinResponse>;\n    }\n}\n\ndeclare module 'test/matrix-client/services/MatrixUserService' {\n    import { MatrixHttpClient } from 'test/matrix-client/MatrixHttpClient';\n    import { MatrixLoginResponse } from 'test/matrix-client/models/api/MatrixLogin';\n    export class MatrixUserService {\n        constructor(httpClient: MatrixHttpClient);\n        /**\n          * Log in to the matrix node with username and password\n          *\n          * @param user\n          * @param password\n          * @param deviceId\n          */\n        login(user: string, password: string, deviceId: string): Promise<MatrixLoginResponse>;\n    }\n}\n\ndeclare module 'test/matrix-client/utils/events' {\n    import { MatrixStateEvent, MatrixStateEventMessageText } from 'test/matrix-client/models/MatrixStateEvent';\n    /**\n        * Check if an event is a create event\n        *\n        * @param event MatrixStateEvent\n        */\n    export const isCreateEvent: (event: MatrixStateEvent) => boolean;\n    /**\n        * Check if an event is a join event\n        *\n        * @param event MatrixStateEvent\n        */\n    export const isJoinEvent: (event: MatrixStateEvent) => boolean;\n    /**\n        * Check if an event is a message event\n        *\n        * @param event MatrixStateEvent\n        */\n    export const isMessageEvent: (event: MatrixStateEvent) => boolean;\n    /**\n        * Check if an event is a text message event\n        *\n        * @param event MatrixStateEvent\n        */\n    export const isTextMessageEvent: (event: MatrixStateEvent) => event is MatrixStateEventMessageText;\n}\n\ndeclare module 'test/migrations/migrate-0.7.0' {\n    import { PermissionScope, AccountIdentifier, Origin, Network } from 'test/';\n    export interface AccountInfoOld {\n        accountIdentifier: AccountIdentifier;\n        beaconId: string;\n        origin: {\n            type: Origin;\n            id: string;\n        };\n        address: string;\n        pubkey: string;\n        network: Network;\n        scopes: PermissionScope[];\n        connectedAt: Date;\n    }\n    export interface P2PPairingRequestOld {\n        name: string;\n        pubKey: string;\n        relayServer: string;\n    }\n    export const migrate_0_7_0: (storage: Storage) => Promise<void>;\n}\n\ndeclare module 'test/migrations/migrations' {\n    import { Storage } from 'test/';\n    export const migrate: (storage: Storage) => Promise<void>;\n}\n\ndeclare module 'test/MockWindow' {\n    type Callback = (message: unknown) => void;\n    /**\n      * A mock for postmessage if run in node.js environment\n      */\n    let windowRef: {\n        postMessage: (message: string | Record<string, unknown>, _target?: string | undefined) => void;\n        addEventListener: (_name: string, eventCallback: Callback) => void;\n        removeEventListener: (_name: string, eventCallback: Callback) => void;\n        location: {\n            origin: string;\n        };\n    };\n    const clearMockWindowState: () => void;\n    export { windowRef, clearMockWindowState };\n}\n\ndeclare module 'test/Serializer' {\n    /**\n        * The Serializer is used to serialize / deserialize JSON objects and encode them with bs58check\n        */\n    export class Serializer {\n            /**\n                * Serialize and bs58check encode an object\n                *\n                * @param message JSON object to serialize\n                */\n            serialize(message: unknown): Promise<string>;\n            /**\n                * Deserialize a bs58check encoded string\n                *\n                * @param encoded String to be deserialized\n                */\n            deserialize(encoded: string): Promise<unknown>;\n    }\n}\n\ndeclare module 'test/storage/ChromeStorage' {\n    import { Storage, StorageKey, StorageKeyReturnType } from 'test/';\n    export class ChromeStorage implements Storage {\n        static isSupported(): Promise<boolean>;\n        get<K extends StorageKey>(key: K): Promise<StorageKeyReturnType[K]>;\n        set<K extends StorageKey>(key: K, value: StorageKeyReturnType[K]): Promise<void>;\n        delete<K extends StorageKey>(key: K): Promise<void>;\n    }\n}\n\ndeclare module 'test/storage/getStorage' {\n    import { Storage } from 'test/';\n    /**\n      * Get a supported storage on this platform\n      */\n    export const getStorage: () => Promise<Storage>;\n}\n\ndeclare module 'test/storage/LocalStorage' {\n    import { Storage, StorageKey, StorageKeyReturnType } from 'test/';\n    export class LocalStorage implements Storage {\n        constructor(prefix?: string | undefined);\n        static isSupported(): Promise<boolean>;\n        get<K extends StorageKey>(key: K): Promise<StorageKeyReturnType[K]>;\n        set<K extends StorageKey>(key: K, value: StorageKeyReturnType[K]): Promise<void>;\n        delete<K extends StorageKey>(key: K): Promise<void>;\n    }\n}\n\ndeclare module 'test/storage/Storage' {\n    import { StorageKey } from 'test/types/storage/StorageKey';\n    import { StorageKeyReturnType } from 'test/types/storage/StorageKeyReturnType';\n    /**\n        * The storage used in the SDK\n        */\n    export abstract class Storage {\n            /**\n                * Returns a promise that resolves to true if the storage option is available on this platform.\n                */\n            static isSupported(): Promise<boolean>;\n            /**\n                * Gets a value from storage and returns it\n                *\n                * @param key The storage key\n                */\n            abstract get<K extends StorageKey>(key: K): Promise<StorageKeyReturnType[K]>;\n            /**\n                * Sets a value in the storage and persist it\n                *\n                * @param key The storage key\n                * @param value The value to be persisted\n                */\n            abstract set<K extends StorageKey>(key: K, value: StorageKeyReturnType[K]): Promise<void>;\n            /**\n                * Delete a key from storage\n                *\n                * @param key The storage key\n                */\n            abstract delete<K extends StorageKey>(key: K): Promise<void>;\n    }\n}\n\ndeclare module 'test/test' {\n    \n    export * from 'test/beacon-message-events';\n    export * from 'test/clients/beacon-client/BeaconClient';\n    export * from 'test/clients/beacon-client/BeaconClientOptions';\n    export * from 'test/clients/client/Client';\n    export * from 'test/clients/client/ClientOptions';\n    export * from 'test/clients/dapp-client/DAppClient';\n    export * from 'test/clients/dapp-client/DAppClientOptions';\n    export * from 'test/clients/wallet-client/WalletClient';\n    export * from 'test/clients/wallet-client/WalletClientOptions';\n    export * from 'test/colorMode';\n    export * from 'test/constants';\n    export * from 'test/debug';\n    export * from 'test/errors/AbortedBeaconError';\n    export * from 'test/errors/BeaconError';\n    export * from 'test/errors/BroadcastBeaconError';\n    export * from 'test/errors/NetworkNotSupportedBeaconError';\n    export * from 'test/errors/NoAddressBeaconError';\n    export * from 'test/errors/NoPrivateKeyBeaconError';\n    export * from 'test/errors/NotGrantedBeaconError';\n    export * from 'test/errors/ParametersInvalidBeaconError';\n    export * from 'test/errors/SignatureTypeNotSupportedBeaconError';\n    export * from 'test/errors/TooManyOperationsBeaconError';\n    export * from 'test/errors/TransactionInvalidBeaconError';\n    export * from 'test/errors/UnknownBeaconError';\n    export * from 'test/events';\n    export * from 'test/examples/broadcast-request';\n    export * from 'test/examples/custom-block-explorer';\n    export * from 'test/examples/disable-all-ui';\n    export * from 'test/examples/operation-request';\n    export * from 'test/examples/override-default-events';\n    export * from 'test/examples/permission-request';\n    export * from 'test/examples/sign-payload-request';\n    export * from 'test/examples/using-custom-network';\n    export * from 'test/examples/wallet-example';\n    export * from 'test/index';\n    export * from 'test/interceptors/IncomingRequestInterceptor';\n    export * from 'test/interceptors/OutgoingResponseInterceptor';\n    export * from 'test/managers/AccountManager';\n    export * from 'test/managers/AppMetadataManager';\n    export * from 'test/managers/PeerManager';\n    export * from 'test/managers/PermissionManager';\n    export * from 'test/managers/PermissionValidator';\n    export * from 'test/managers/StorageManager';\n    export * from 'test/matrix-client/MatrixClient';\n    export * from 'test/matrix-client/MatrixClientEventEmitter';\n    export * from 'test/matrix-client/MatrixClientStore';\n    export * from 'test/matrix-client/MatrixHttpClient';\n    export * from 'test/matrix-client/models/api/MatrixEventSend';\n    export * from 'test/matrix-client/models/api/MatrixLogin';\n    export * from 'test/matrix-client/models/api/MatrixRequest';\n    export * from 'test/matrix-client/models/api/MatrixRoomCreate';\n    export * from 'test/matrix-client/models/api/MatrixRoomInvite';\n    export * from 'test/matrix-client/models/api/MatrixRoomJoin';\n    export * from 'test/matrix-client/models/api/MatrixSync';\n    export * from 'test/matrix-client/models/MatrixClientEvent';\n    export * from 'test/matrix-client/models/MatrixMessage';\n    export * from 'test/matrix-client/models/MatrixRoom';\n    export * from 'test/matrix-client/models/MatrixStateEvent';\n    export * from 'test/matrix-client/services/MatrixEventService';\n    export * from 'test/matrix-client/services/MatrixRoomService';\n    export * from 'test/matrix-client/services/MatrixUserService';\n    export * from 'test/matrix-client/utils/events';\n    export * from 'test/migrations/migrate-0.7.0';\n    export * from 'test/migrations/migrations';\n    export * from 'test/MockWindow';\n    export * from 'test/Serializer';\n    export * from 'test/storage/ChromeStorage';\n    export * from 'test/storage/getStorage';\n    export * from 'test/storage/LocalStorage';\n    export * from 'test/storage/Storage';\n    export * from 'test/transports/clients/CommunicationClient';\n    export * from 'test/transports/clients/MessageBasedClient';\n    export * from 'test/transports/clients/P2PCommunicationClient';\n    export * from 'test/transports/clients/PostMessageClient';\n    export * from 'test/transports/DappP2PTransport';\n    export * from 'test/transports/DappPostMessageTransport';\n    export * from 'test/transports/P2PTransport';\n    export * from 'test/transports/PostMessageTransport';\n    export * from 'test/transports/Transport';\n    export * from 'test/transports/WalletP2PTransport';\n    export * from 'test/transports/WalletPostMessageTransport';\n    export * from 'test/types/AccountInfo';\n    export * from 'test/types/beacon/AppMetadata';\n    export * from 'test/types/beacon/BeaconBaseMessage';\n    export * from 'test/types/beacon/BeaconMessage';\n    export * from 'test/types/beacon/BeaconMessageType';\n    export * from 'test/types/beacon/BeaconRequestMessage';\n    export * from 'test/types/beacon/BeaconResponseMessage';\n    export * from 'test/types/beacon/messages/AcknowledgeResponse';\n    export * from 'test/types/beacon/messages/BeaconRequestInputMessage';\n    export * from 'test/types/beacon/messages/BeaconRequestOutputMessage';\n    export * from 'test/types/beacon/messages/BeaconResponseInputMessage';\n    export * from 'test/types/beacon/messages/BeaconResponseOutputMessage';\n    export * from 'test/types/beacon/messages/BroadcastRequest';\n    export * from 'test/types/beacon/messages/BroadcastResponse';\n    export * from 'test/types/beacon/messages/DisconnectMessage';\n    export * from 'test/types/beacon/messages/ErrorResponse';\n    export * from 'test/types/beacon/messages/OperationRequest';\n    export * from 'test/types/beacon/messages/OperationResponse';\n    export * from 'test/types/beacon/messages/PermissionRequest';\n    export * from 'test/types/beacon/messages/PermissionResponse';\n    export * from 'test/types/beacon/messages/SignPayloadRequest';\n    export * from 'test/types/beacon/messages/SignPayloadResponse';\n    export * from 'test/types/beacon/Network';\n    export * from 'test/types/beacon/NetworkType';\n    export * from 'test/types/beacon/PermissionScope';\n    export * from 'test/types/beacon/SigningType';\n    export * from 'test/types/beacon/Threshold';\n    export * from 'test/types/BeaconErrorType';\n    export * from 'test/types/ColorMode';\n    export * from 'test/types/ConnectionContext';\n    export * from 'test/types/Extension';\n    export * from 'test/types/ExtensionMessage';\n    export * from 'test/types/ExtensionMessageTarget';\n    export * from 'test/types/Origin';\n    export * from 'test/types/P2PPairingRequest';\n    export * from 'test/types/P2PPairingResponse';\n    export * from 'test/types/PeerInfo';\n    export * from 'test/types/PermissionEntity';\n    export * from 'test/types/PermissionInfo';\n    export * from 'test/types/PostMessagePairingRequest';\n    export * from 'test/types/PostMessagePairingResponse';\n    export * from 'test/types/RequestBroadcastInput';\n    export * from 'test/types/RequestOperationInput';\n    export * from 'test/types/RequestPermissionInput';\n    export * from 'test/types/RequestSignPayloadInput';\n    export * from 'test/types/storage/StorageKey';\n    export * from 'test/types/storage/StorageKeyReturnDefaults';\n    export * from 'test/types/storage/StorageKeyReturnType';\n    export * from 'test/types/tezos/MichelineMichelsonV1Expression';\n    export * from 'test/types/tezos/MichelsonPrimitives';\n    export * from 'test/types/tezos/operations/ActivateAccount';\n    export * from 'test/types/tezos/operations/Ballot';\n    export * from 'test/types/tezos/operations/Delegation';\n    export * from 'test/types/tezos/operations/DoubleBakingEvidence';\n    export * from 'test/types/tezos/operations/DoubleEndorsementEvidence';\n    export * from 'test/types/tezos/operations/Endorsement';\n    export * from 'test/types/tezos/operations/Origination';\n    export * from 'test/types/tezos/operations/Proposal';\n    export * from 'test/types/tezos/operations/Reveal';\n    export * from 'test/types/tezos/operations/SeedNonceRevelation';\n    export * from 'test/types/tezos/operations/Transaction';\n    export * from 'test/types/tezos/OperationTypes';\n    export * from 'test/types/tezos/PartialTezosOperation';\n    export * from 'test/types/tezos/TezosBaseOperation';\n    export * from 'test/types/tezos/TezosBlockHeader';\n    export * from 'test/types/tezos/TezosOperation';\n    export * from 'test/types/tezos/TezosTransactionParameters';\n    export * from 'test/types/transport/TransportStatus';\n    export * from 'test/types/transport/TransportType';\n    export * from 'test/ui/alert/alert-templates';\n    export * from 'test/ui/alert/Alert';\n    export * from 'test/ui/alert/Pairing';\n    export * from 'test/ui/alert/PairingAlert';\n    export * from 'test/ui/alert/wallet-lists';\n    export * from 'test/ui/toast/toast-templates';\n    export * from 'test/ui/toast/Toast';\n    export * from 'test/utils/assert-never';\n    export * from 'test/utils/available-transports';\n    export * from 'test/utils/block-explorer';\n    export * from 'test/utils/crypto';\n    export * from 'test/utils/exposed-promise';\n    export * from 'test/utils/generate-uuid';\n    export * from 'test/utils/get-account-identifier';\n    export * from 'test/utils/get-sender-id';\n    export * from 'test/utils/get-tzip10-link';\n    export * from 'test/utils/Logger';\n    export * from 'test/utils/platform';\n    export * from 'test/utils/qr';\n    export * from 'test/utils/replace-in-template';\n    export * from 'test/utils/shorten-string';\n    export * from 'test/utils/tezblock-blockexplorer';\n    export * from 'test/utils/utils';\n    \n    declare module 'test/beacon-message-events' {\n            import { BeaconEvent } from 'test/events';\n            import { BeaconMessageType } from 'test/';\n            export const messageEvents: {\n                    [key in BeaconMessageType]: {\n                            sent: BeaconEvent;\n                            success: BeaconEvent;\n                            error: BeaconEvent;\n                    };\n            };\n    }\n    \n    declare module 'test/clients/beacon-client/BeaconClient' {\n            import * as sodium from 'libsodium-wrappers';\n            import { ExposedPromise } from 'test/utils/exposed-promise';\n            import { Storage } from 'test/';\n            import { BeaconEventHandler } from 'test/events';\n            import { BeaconClientOptions } from 'test/clients/beacon-client/BeaconClientOptions';\n            /**\n                     * The beacon client is an abstract client that handles everything that is shared between all other clients.\n                     * Specifically, it handles managing the beaconId and and the local keypair.\n                     */\n            export abstract class BeaconClient {\n                            /**\n                                     * The name of the client\n                                     */\n                            readonly name: string;\n                            /**\n                                     * The URL of the dApp Icon. This can be used to display the icon of the dApp on in the wallet\n                                     */\n                            readonly iconUrl?: string;\n                            /**\n                                     * The URL of the dApp.\n                                     */\n                            readonly appUrl?: string;\n                            /** The beaconId is a public key that is used to identify one specific application (dapp or wallet).\n                                     * This is used inside a message to specify the sender, for example.\n                                     */\n                            protected _beaconId: ExposedPromise<string>;\n                            get beaconId(): Promise<string>;\n                            protected storage: Storage;\n                            protected readonly events: BeaconEventHandler;\n                            /**\n                                     * The local keypair that is used for the communication encryption\n                                     */\n                            protected _keyPair: ExposedPromise<sodium.KeyPair>;\n                            protected get keyPair(): Promise<sodium.KeyPair>;\n                            constructor(config: BeaconClientOptions);\n                            /**\n                                     * This resets the SDK. After using this method, this instance is no longer usable. You will have to instanciate a new client.\n                                     */\n                            destroy(): Promise<void>;\n            }\n    }\n    \n    declare module 'test/clients/beacon-client/BeaconClientOptions' {\n            import { Storage } from 'test/';\n            export interface BeaconClientOptions {\n                            /**\n                                     * Name of the application\n                                     */\n                            name: string;\n                            /**\n                                     * A URL to the icon of the application\n                                     */\n                            iconUrl?: string;\n                            /**\n                                     * A URL to the website of the application\n                                     */\n                            appUrl?: string;\n                            /**\n                                     * The storage that will be used by the SDK\n                                     */\n                            storage: Storage;\n            }\n    }\n    \n    declare module 'test/clients/client/Client' {\n            import { ExposedPromise } from 'test/utils/exposed-promise';\n            import { ConnectionContext } from 'test/types/ConnectionContext';\n            import { TransportType, TransportStatus, AccountInfo, PeerInfo, Transport, AppMetadata } from 'test/';\n            import { BeaconEventHandler } from 'test/events';\n            import { BeaconClient } from 'test/clients/beacon-client/BeaconClient';\n            import { AccountManager } from 'test/managers/AccountManager';\n            import { BeaconRequestMessage } from 'test/types/beacon/BeaconRequestMessage';\n            import { ClientOptions } from 'test/clients/client/ClientOptions';\n            /**\n                     * This abstract class handles the a big part of the logic that is shared between the dapp and wallet client.\n                     * For example, it selects and manages the transport and accounts.\n                     */\n            export abstract class Client extends BeaconClient {\n                            protected readonly accountManager: AccountManager;\n                            protected handleResponse: (_event: BeaconRequestMessage, connectionInfo: ConnectionContext) => void;\n                            /**\n                                     * How many requests can be sent after another\n                                     */\n                            protected readonly rateLimit: number;\n                            /**\n                                     * The time window in seconds in which the \"rateLimit\" is checked\n                                     */\n                            protected readonly rateLimitWindowInSeconds: number;\n                            /**\n                                     * Stores the times when requests have been made to determine if the rate limit has been reached\n                                     */\n                            protected requestCounter: number[];\n                            protected readonly events: BeaconEventHandler;\n                            protected readonly matrixNodes: string[];\n                            protected _transport: ExposedPromise<Transport<any>>;\n                            protected get transport(): Promise<Transport<any>>;\n                            /**\n                                     * Returns the connection status of the Client\n                                     */\n                            get connectionStatus(): TransportStatus;\n                            /**\n                                     * Returns whether or not the transaport is ready\n                                     */\n                            get ready(): Promise<void>;\n                            constructor(config: ClientOptions);\n                            /**\n                                     * Return all locally known accounts\n                                     */\n                            getAccounts(): Promise<AccountInfo[]>;\n                            /**\n                                     * Return the account by ID\n                                     * @param accountIdentifier The ID of an account\n                                     */\n                            getAccount(accountIdentifier: string): Promise<AccountInfo | undefined>;\n                            /**\n                                     * Remove the account by ID\n                                     * @param accountIdentifier The ID of an account\n                                     */\n                            removeAccount(accountIdentifier: string): Promise<void>;\n                            /**\n                                     * Remove all locally stored accounts\n                                     */\n                            removeAllAccounts(): Promise<void>;\n                            /**\n                                     * Add a new request (current timestamp) to the pending requests, remove old ones and check if we are above the limit\n                                     */\n                            addRequestAndCheckIfRateLimited(): Promise<boolean>;\n                            /**\n                                     * This method initializes the client. It will check if the connection should be established to a\n                                     * browser extension or if the P2P transport should be used.\n                                     *\n                                     * @param transport A transport that can be provided by the user\n                                     */\n                            init(transport: Transport<any>): Promise<TransportType>;\n                            /**\n                                     * Returns the metadata of this DApp\n                                     */\n                            getOwnAppMetadata(): Promise<AppMetadata>;\n                            /**\n                                     * Return all known peers\n                                     */\n                            getPeers(): Promise<PeerInfo[]>;\n                            /**\n                                     * Add a new peer to the known peers\n                                     * @param peer The new peer to add\n                                     */\n                            addPeer(peer: PeerInfo): Promise<void>;\n                            /**\n                                     * A \"setter\" for when the transport needs to be changed.\n                                     */\n                            protected setTransport(transport?: Transport<any>): Promise<void>;\n                            protected addListener(transport: Transport<any>): Promise<void>;\n                            protected sendDisconnectToPeer(peer: PeerInfo, transport?: Transport<any>): Promise<void>;\n            }\n    }\n    \n    declare module 'test/clients/client/ClientOptions' {\n            import { Storage } from 'test/';\n            import { BeaconEvent, BeaconEventHandlerFunction, BeaconEventType } from 'test/events';\n            export interface ClientOptions {\n                            /**\n                                     * Name of the application\n                                     */\n                            name: string;\n                            /**\n                                     * A URL to the icon of the application\n                                     */\n                            iconUrl?: string;\n                            /**\n                                     * A URL to the website of the application\n                                     */\n                            appUrl?: string;\n                            /**\n                                     * The storage that will be used by the SDK\n                                     */\n                            storage: Storage;\n                            /**\n                                     * An object that will be used to overwrite default event handler behaviour.\n                                     *\n                                     * If you plan to overwrite all default events, use \"disableDefaultEvents\" instead.\n                                     *\n                                     * This will overwrite the default event handler, so this can lead to unexpected behavior in some cases.\n                                     * We recommend that you overwrite all handlers if you want to use your own UI.\n                                     *\n                                     * If you simply want to be notified of events happening, but do not want to overwrite the default behavior,\n                                     * please use `subscribeToEvent()` on the DAppClient instead.\n                                     */\n                            eventHandlers?: {\n                                            [key in BeaconEvent]?: {\n                                                            handler: BeaconEventHandlerFunction<BeaconEventType[key]>;\n                                            };\n                            };\n                            /**\n                                     * Disable all default Events and UI elements. If passed together with \"eventHandlers\",\n                                     * the default eventHandlers will be removed, and the ones passed by the user will be added.\n                                     */\n                            disableDefaultEvents?: boolean;\n                            /**\n                                     * A list of matrix nodes to connect to. If a non-empty array is passed, the default options will be overwritten.\n                                     * One node will be randomly selected based on the local keypair and the other nodes will be used as a fallback in case the primary node goes down.\n                                     *\n                                     * Only provide the hostname, no https:// prefix. Eg. ['matrix.example.com']\n                                     */\n                            matrixNodes?: string[];\n            }\n    }\n    \n    declare module 'test/clients/dapp-client/DAppClient' {\n            import { BeaconEvent, BeaconEventHandlerFunction, BeaconEventType } from 'test/events';\n            import { AccountInfo, Client, TransportType, BeaconMessageType, NetworkType, RequestPermissionInput, RequestSignPayloadInput, RequestOperationInput, RequestBroadcastInput, PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, Transport, DappP2PTransport, DappPostMessageTransport, AppMetadata } from 'test/';\n            import { BlockExplorer } from 'test/utils/block-explorer';\n            import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n            import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n            import { ExtendedPeerInfo } from 'test/types/PeerInfo';\n            import { ColorMode } from 'test/types/ColorMode';\n            import { DAppClientOptions } from 'test/clients/dapp-client/DAppClientOptions';\n            /**\n                     * The DAppClient has to be used in decentralized applications. It handles all the logic related to connecting to beacon-compatible\n                     * wallets and sending requests.\n                     */\n            export class DAppClient extends Client {\n                            /**\n                                     * The block explorer used by the SDK\n                                     */\n                            readonly blockExplorer: BlockExplorer;\n                            preferredNetwork: NetworkType;\n                            protected postMessageTransport: DappPostMessageTransport | undefined;\n                            protected p2pTransport: DappP2PTransport | undefined;\n                            constructor(config: DAppClientOptions);\n                            initInternalTransports(): Promise<void>;\n                            init(transport?: Transport<any>): Promise<TransportType>;\n                            /**\n                                     * Returns the active account\n                                     */\n                            getActiveAccount(): Promise<AccountInfo | undefined>;\n                            /**\n                                     * Sets the active account\n                                     *\n                                     * @param account The account that will be set as the active account\n                                     */\n                            setActiveAccount(account?: AccountInfo): Promise<void>;\n                            /**\n                                     * Clear the active account\n                                     */\n                            clearActiveAccount(): Promise<void>;\n                            setColorMode(colorMode: ColorMode): Promise<void>;\n                            getColorMode(): Promise<ColorMode>;\n                            /**\n                                     * @deprecated\n                                     *\n                                     * Use getOwnAppMetadata instead\n                                     */\n                            getAppMetadata(): Promise<AppMetadata>;\n                            /**\n                                     * Will remove the account from the local storage and set a new active account if necessary.\n                                     *\n                                     * @param accountIdentifier ID of the account\n                                     */\n                            removeAccount(accountIdentifier: string): Promise<void>;\n                            /**\n                                     * Remove all accounts and set active account to undefined\n                                     */\n                            removeAllAccounts(): Promise<void>;\n                            /**\n                                     * Removes a peer and all the accounts that have been connected through that peer\n                                     *\n                                     * @param peer Peer to be removed\n                                     */\n                            removePeer(peer: ExtendedPeerInfo, sendDisconnectToPeer?: boolean): Promise<void>;\n                            /**\n                                     * Remove all peers and all accounts that have been connected through those peers\n                                     */\n                            removeAllPeers(sendDisconnectToPeers?: boolean): Promise<void>;\n                            /**\n                                     * Allows the user to subscribe to specific events that are fired in the SDK\n                                     *\n                                     * @param internalEvent The event to subscribe to\n                                     * @param eventCallback The callback that will be called when the event occurs\n                                     */\n                            subscribeToEvent<K extends BeaconEvent>(internalEvent: K, eventCallback: BeaconEventHandlerFunction<BeaconEventType[K]>): Promise<void>;\n                            /**\n                                     * Check if we have permissions to send the specific message type to the active account.\n                                     * If no active account is set, only permission requests are allowed.\n                                     *\n                                     * @param type The type of the message\n                                     */\n                            checkPermissions(type: BeaconMessageType): Promise<boolean>;\n                            /**\n                                     * Send a permission request to the DApp. This should be done as the first step. The wallet will respond\n                                     * with an publicKey and permissions that were given. The account returned will be set as the \"activeAccount\"\n                                     * and will be used for the following requests.\n                                     *\n                                     * @param input The message details we need to prepare the PermissionRequest message.\n                                     */\n                            requestPermissions(input?: RequestPermissionInput): Promise<PermissionResponseOutput>;\n                            /**\n                                     * This method will send a \"SignPayloadRequest\" to the wallet. This method is meant to be used to sign\n                                     * arbitrary data (eg. a string). It will return the signature in the format of \"edsig...\"\n                                     *\n                                     * @param input The message details we need to prepare the SignPayloadRequest message.\n                                     */\n                            requestSignPayload(input: RequestSignPayloadInput): Promise<SignPayloadResponseOutput>;\n                            /**\n                                     * This method sends an OperationRequest to the wallet. This method should be used for all kinds of operations,\n                                     * eg. transaction or delegation. Not all properties have to be provided. Data like \"counter\" and fees will be\n                                     * fetched and calculated by the wallet (but they can still be provided if required).\n                                     *\n                                     * @param input The message details we need to prepare the OperationRequest message.\n                                     */\n                            requestOperation(input: RequestOperationInput): Promise<OperationResponseOutput>;\n                            /**\n                                     * Sends a \"BroadcastRequest\" to the wallet. This method can be used to inject an already signed transaction\n                                     * to the network.\n                                     *\n                                     * @param input The message details we need to prepare the BroadcastRequest message.\n                                     */\n                            requestBroadcast(input: RequestBroadcastInput): Promise<BroadcastResponseOutput>;\n                            protected setActivePeer(peer?: ExtendedPostMessagePairingResponse | ExtendedP2PPairingResponse): Promise<void>;\n                            /**\n                                     * A \"setter\" for when the transport needs to be changed.\n                                     */\n                            protected setTransport(transport?: Transport<any>): Promise<void>;\n            }\n    }\n    \n    declare module 'test/clients/dapp-client/DAppClientOptions' {\n            import { NetworkType, Storage } from 'test/';\n            import { BeaconEvent, BeaconEventType, BeaconEventHandlerFunction } from 'test/events';\n            import { ColorMode } from 'test/types/ColorMode';\n            import { BlockExplorer } from 'test/utils/block-explorer';\n            export interface DAppClientOptions {\n                            /**\n                                     * Name of the application\n                                     */\n                            name: string;\n                            /**\n                                     * A URL to the icon of the application\n                                     */\n                            iconUrl?: string;\n                            /**\n                                     * A URL to the website of the application\n                                     */\n                            appUrl?: string;\n                            /**\n                                     * The storage that will be used by the SDK\n                                     */\n                            storage?: Storage;\n                            /**\n                                     * An object that will be used to overwrite default event handler behaviour.\n                                     *\n                                     * If you plan to overwrite all default events, use \"disableDefaultEvents\" instead.\n                                     *\n                                     * This will overwrite the default event handler, so this can lead to unexpected behavior in some cases.\n                                     * We recommend that you overwrite all handlers if you want to use your own UI.\n                                     *\n                                     * If you simply want to be notified of events happening, but do not want to overwrite the default behavior,\n                                     * please use `subscribeToEvent()` on the DAppClient instead.\n                                     */\n                            eventHandlers?: {\n                                            [key in BeaconEvent]?: {\n                                                            handler: BeaconEventHandlerFunction<BeaconEventType[key]>;\n                                            };\n                            };\n                            /**\n                                     * Disable all default Events and UI elements. If passed together with \"eventHandlers\",\n                                     * the default eventHandlers will be removed, and the ones passed by the user will be added.\n                                     */\n                            disableDefaultEvents?: boolean;\n                            /**\n                                     * A list of matrix nodes to connect to. If a non-empty array is passed, the default options will be overwritten.\n                                     * One node will be randomly selected based on the local keypair and the other nodes will be used as a fallback in case the primary node goes down.\n                                     *\n                                     * Only provide the hostname, no https:// prefix. Eg. ['matrix.example.com']\n                                     */\n                            matrixNodes?: string[];\n                            /**\n                                     * The block explorer used by the SDK\n                                     */\n                            blockExplorer?: BlockExplorer;\n                            /**\n                                     * Indicates on which network the DApp is planning to run. This is currently used to adjust the URLs of web-wallets in the pairing alert if they use different URLs for testnets.\n                                     * You will still have to define the network you intend to use during the permission request.\n                                     */\n                            preferredNetwork?: NetworkType;\n                            /**\n                                     * Set the color mode for the UI elements (alerts and toasts)\n                                     */\n                            colorMode?: ColorMode;\n            }\n    }\n    \n    declare module 'test/clients/wallet-client/WalletClient' {\n            import { Client, WalletClientOptions, TransportType, BeaconRequestOutputMessage, BeaconResponseInputMessage, AppMetadata, PermissionInfo } from 'test/';\n            import { ConnectionContext } from 'test/types/ConnectionContext';\n            import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n            import { ExposedPromise } from 'test/utils/exposed-promise';\n            import { PeerInfo } from 'test/types/PeerInfo';\n            /**\n                     * The WalletClient has to be used in the wallet. It handles all the logic related to connecting to beacon-compatible\n                     * dapps and handling/responding to requests.\n                     */\n            export class WalletClient extends Client {\n                            /**\n                                     * Returns whether or not the transport is connected\n                                     */\n                            protected readonly _isConnected: ExposedPromise<boolean>;\n                            get isConnected(): Promise<boolean>;\n                            constructor(config: WalletClientOptions);\n                            init(): Promise<TransportType>;\n                            /**\n                                     * This method initiates a connection to the P2P network and registers a callback that will be called\n                                     * whenever a message is received.\n                                     *\n                                     * @param newMessageCallback The callback that will be invoked for every message the transport receives.\n                                     */\n                            connect(newMessageCallback: (message: BeaconRequestOutputMessage, connectionContext: ConnectionContext) => void): Promise<void>;\n                            /**\n                                     * The method will attempt to initiate a connection using the active transport.\n                                     */\n                            _connect(): Promise<void>;\n                            /**\n                                     * This method sends a response for a specific request back to the DApp\n                                     *\n                                     * @param message The BeaconResponseMessage that will be sent back to the DApp\n                                     */\n                            respond(message: BeaconResponseInputMessage): Promise<void>;\n                            getAppMetadataList(): Promise<AppMetadata[]>;\n                            getAppMetadata(senderId: string): Promise<AppMetadata | undefined>;\n                            removeAppMetadata(senderId: string): Promise<void>;\n                            removeAllAppMetadata(): Promise<void>;\n                            getPermissions(): Promise<PermissionInfo[]>;\n                            getPermission(accountIdentifier: string): Promise<PermissionInfo | undefined>;\n                            removePermission(accountIdentifier: string): Promise<void>;\n                            removeAllPermissions(): Promise<void>;\n                            /**\n                                     * Add a new peer to the known peers\n                                     * @param peer The new peer to add\n                                     */\n                            addPeer(peer: PeerInfo): Promise<void>;\n                            removePeer(peer: ExtendedP2PPairingResponse, sendDisconnectToPeer?: boolean): Promise<void>;\n                            removeAllPeers(sendDisconnectToPeers?: boolean): Promise<void>;\n            }\n    }\n    \n    declare module 'test/clients/wallet-client/WalletClientOptions' {\n            import { Storage } from 'test/';\n            export interface WalletClientOptions {\n                            /**\n                                     * Name of the application\n                                     */\n                            name: string;\n                            /**\n                                     * A URL to the icon of the application\n                                     */\n                            iconUrl?: string;\n                            /**\n                                     * A URL to the website of the application\n                                     */\n                            appUrl?: string;\n                            /**\n                                     * The storage that will be used by the SDK\n                                     */\n                            storage?: Storage;\n                            /**\n                                     * A list of matrix nodes to connect to. If a non-empty array is passed, the default options will be overwritten.\n                                     * One node will be randomly selected based on the local keypair and the other nodes will be used as a fallback in case the primary node goes down.\n                                     *\n                                     * Only provide the hostname, no https:// prefix. Eg. ['matrix.example.com']\n                                     */\n                            matrixNodes?: string[];\n            }\n    }\n    \n    declare module 'test/colorMode' {\n            import { ColorMode } from 'test/types/ColorMode';\n            export const setColorMode: (mode: ColorMode) => void;\n            export const getColorMode: () => ColorMode;\n    }\n    \n    declare module 'test/constants' {\n            export const SDK_VERSION: string;\n            export const BEACON_VERSION: string;\n    }\n    \n    declare module 'test/debug' {\n            export const setDebugEnabled: (enabled: boolean) => void;\n            export const getDebugEnabled: () => boolean;\n    }\n    \n    declare module 'test/errors/AbortedBeaconError' {\n            import { BeaconError } from 'test/';\n            export class AbortedBeaconError extends BeaconError {\n                    name: string;\n                    title: string;\n                    constructor();\n            }\n    }\n    \n    declare module 'test/errors/BeaconError' {\n            import { BeaconErrorType } from 'test/';\n            export abstract class BeaconError implements Error {\n                    name: string;\n                    message: string;\n                    title: string;\n                    description: string;\n                    get fullDescription(): string;\n                    constructor(errorType: BeaconErrorType, message: string);\n                    static getError(errorType: BeaconErrorType, errorData: any): BeaconError;\n            }\n    }\n    \n    declare module 'test/errors/BroadcastBeaconError' {\n            import { BeaconError } from 'test/';\n            export class BroadcastBeaconError extends BeaconError {\n                    name: string;\n                    title: string;\n                    constructor();\n            }\n    }\n    \n    declare module 'test/errors/NetworkNotSupportedBeaconError' {\n            import { BeaconError } from 'test/';\n            export class NetworkNotSupportedBeaconError extends BeaconError {\n                    name: string;\n                    title: string;\n                    constructor();\n            }\n    }\n    \n    declare module 'test/errors/NoAddressBeaconError' {\n            import { BeaconError } from 'test/';\n            export class NoAddressBeaconError extends BeaconError {\n                    name: string;\n                    title: string;\n                    constructor();\n            }\n    }\n    \n    declare module 'test/errors/NoPrivateKeyBeaconError' {\n            import { BeaconError } from 'test/';\n            export class NoPrivateKeyBeaconError extends BeaconError {\n                    name: string;\n                    title: string;\n                    constructor();\n            }\n    }\n    \n    declare module 'test/errors/NotGrantedBeaconError' {\n            import { BeaconError } from 'test/';\n            export class NotGrantedBeaconError extends BeaconError {\n                    name: string;\n                    title: string;\n                    constructor();\n            }\n    }\n    \n    declare module 'test/errors/ParametersInvalidBeaconError' {\n            import { BeaconError } from 'test/';\n            export class ParametersInvalidBeaconError extends BeaconError {\n                    name: string;\n                    title: string;\n                    constructor();\n            }\n    }\n    \n    declare module 'test/errors/SignatureTypeNotSupportedBeaconError' {\n            import { BeaconError } from 'test/';\n            export class SignatureTypeNotSupportedBeaconError extends BeaconError {\n                    name: string;\n                    title: string;\n                    constructor();\n            }\n    }\n    \n    declare module 'test/errors/TooManyOperationsBeaconError' {\n            import { BeaconError } from 'test/';\n            export class TooManyOperationsBeaconError extends BeaconError {\n                    name: string;\n                    title: string;\n                    constructor();\n            }\n    }\n    \n    declare module 'test/errors/TransactionInvalidBeaconError' {\n            import { BeaconError } from 'test/';\n            export class TransactionInvalidBeaconError extends BeaconError {\n                    readonly data: any;\n                    name: string;\n                    title: string;\n                    get fullDescription(): string;\n                    constructor(data: any);\n            }\n    }\n    \n    declare module 'test/errors/UnknownBeaconError' {\n            import { BeaconError } from 'test/';\n            export class UnknownBeaconError extends BeaconError {\n                    name: string;\n                    title: string;\n                    constructor();\n            }\n    }\n    \n    declare module 'test/events' {\n            import { AlertButton } from 'test/ui/alert/Alert';\n            import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n            import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n            import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n            import { BlockExplorer } from 'test/utils/block-explorer';\n            import { P2PPairingRequest, AccountInfo, ErrorResponse, PermissionResponseOutput, OperationResponseOutput, BroadcastResponseOutput, SignPayloadResponseOutput, Network, ConnectionContext, Transport, NetworkType, AcknowledgeResponse } from 'test/';\n            /**\n                     * The different events that can be emitted by the beacon-sdk\n                     */\n            export enum BeaconEvent {\n                            PERMISSION_REQUEST_SENT = \"PERMISSION_REQUEST_SENT\",\n                            PERMISSION_REQUEST_SUCCESS = \"PERMISSION_REQUEST_SUCCESS\",\n                            PERMISSION_REQUEST_ERROR = \"PERMISSION_REQUEST_ERROR\",\n                            OPERATION_REQUEST_SENT = \"OPERATION_REQUEST_SENT\",\n                            OPERATION_REQUEST_SUCCESS = \"OPERATION_REQUEST_SUCCESS\",\n                            OPERATION_REQUEST_ERROR = \"OPERATION_REQUEST_ERROR\",\n                            SIGN_REQUEST_SENT = \"SIGN_REQUEST_SENT\",\n                            SIGN_REQUEST_SUCCESS = \"SIGN_REQUEST_SUCCESS\",\n                            SIGN_REQUEST_ERROR = \"SIGN_REQUEST_ERROR\",\n                            BROADCAST_REQUEST_SENT = \"BROADCAST_REQUEST_SENT\",\n                            BROADCAST_REQUEST_SUCCESS = \"BROADCAST_REQUEST_SUCCESS\",\n                            BROADCAST_REQUEST_ERROR = \"BROADCAST_REQUEST_ERROR\",\n                            ACKNOWLEDGE_RECEIVED = \"ACKNOWLEDGE_RECEIVED\",\n                            LOCAL_RATE_LIMIT_REACHED = \"LOCAL_RATE_LIMIT_REACHED\",\n                            NO_PERMISSIONS = \"NO_PERMISSIONS\",\n                            ACTIVE_ACCOUNT_SET = \"ACTIVE_ACCOUNT_SET\",\n                            ACTIVE_TRANSPORT_SET = \"ACTIVE_TRANSPORT_SET\",\n                            PAIR_INIT = \"PAIR_INIT\",\n                            PAIR_SUCCESS = \"PAIR_SUCCESS\",\n                            CHANNEL_CLOSED = \"CHANNEL_CLOSED\",\n                            INTERNAL_ERROR = \"INTERNAL_ERROR\",\n                            UNKNOWN = \"UNKNOWN\"\n            }\n            export interface WalletInfo {\n                            name: string;\n                            icon?: string;\n            }\n            export interface ExtraInfo {\n                            resetCallback?(): Promise<void>;\n            }\n            interface RequestSentInfo {\n                            extraInfo: ExtraInfo;\n                            walletInfo: WalletInfo;\n            }\n            /**\n                     * The type of the payload of the different BeaconEvents\n                     */\n            export interface BeaconEventType {\n                            [BeaconEvent.PERMISSION_REQUEST_SENT]: RequestSentInfo;\n                            [BeaconEvent.PERMISSION_REQUEST_SUCCESS]: {\n                                            account: AccountInfo;\n                                            output: PermissionResponseOutput;\n                                            blockExplorer: BlockExplorer;\n                                            connectionContext: ConnectionContext;\n                                            walletInfo: WalletInfo;\n                            };\n                            [BeaconEvent.PERMISSION_REQUEST_ERROR]: {\n                                            errorResponse: ErrorResponse;\n                                            walletInfo: WalletInfo;\n                            };\n                            [BeaconEvent.OPERATION_REQUEST_SENT]: RequestSentInfo;\n                            [BeaconEvent.OPERATION_REQUEST_SUCCESS]: {\n                                            account: AccountInfo;\n                                            output: OperationResponseOutput;\n                                            blockExplorer: BlockExplorer;\n                                            connectionContext: ConnectionContext;\n                                            walletInfo: WalletInfo;\n                            };\n                            [BeaconEvent.OPERATION_REQUEST_ERROR]: {\n                                            errorResponse: ErrorResponse;\n                                            walletInfo: WalletInfo;\n                            };\n                            [BeaconEvent.SIGN_REQUEST_SENT]: RequestSentInfo;\n                            [BeaconEvent.SIGN_REQUEST_SUCCESS]: {\n                                            output: SignPayloadResponseOutput;\n                                            connectionContext: ConnectionContext;\n                                            walletInfo: WalletInfo;\n                            };\n                            [BeaconEvent.SIGN_REQUEST_ERROR]: {\n                                            errorResponse: ErrorResponse;\n                                            walletInfo: WalletInfo;\n                            };\n                            [BeaconEvent.BROADCAST_REQUEST_SENT]: RequestSentInfo;\n                            [BeaconEvent.BROADCAST_REQUEST_SUCCESS]: {\n                                            network: Network;\n                                            output: BroadcastResponseOutput;\n                                            blockExplorer: BlockExplorer;\n                                            connectionContext: ConnectionContext;\n                                            walletInfo: WalletInfo;\n                            };\n                            [BeaconEvent.BROADCAST_REQUEST_ERROR]: {\n                                            errorResponse: ErrorResponse;\n                                            walletInfo: WalletInfo;\n                            };\n                            [BeaconEvent.ACKNOWLEDGE_RECEIVED]: {\n                                            message: AcknowledgeResponse;\n                                            extraInfo: ExtraInfo;\n                                            walletInfo: WalletInfo;\n                            };\n                            [BeaconEvent.LOCAL_RATE_LIMIT_REACHED]: undefined;\n                            [BeaconEvent.NO_PERMISSIONS]: undefined;\n                            [BeaconEvent.ACTIVE_ACCOUNT_SET]: AccountInfo;\n                            [BeaconEvent.ACTIVE_TRANSPORT_SET]: Transport;\n                            [BeaconEvent.PAIR_INIT]: {\n                                            p2pPeerInfo: P2PPairingRequest;\n                                            postmessagePeerInfo: PostMessagePairingRequest;\n                                            preferredNetwork: NetworkType;\n                                            abortedHandler?(): void;\n                            };\n                            [BeaconEvent.PAIR_SUCCESS]: ExtendedPostMessagePairingResponse | ExtendedP2PPairingResponse;\n                            [BeaconEvent.CHANNEL_CLOSED]: string;\n                            [BeaconEvent.INTERNAL_ERROR]: string;\n                            [BeaconEvent.UNKNOWN]: undefined;\n            }\n            export type BeaconEventHandlerFunction<T = unknown> = (data: T, eventCallback?: AlertButton[]) => void | Promise<void>;\n            /**\n                     * The default event handlers\n                     */\n            export const defaultEventCallbacks: {\n                            [key in BeaconEvent]: BeaconEventHandlerFunction<BeaconEventType[key]>;\n            };\n            /**\n                     * Handles beacon events\n                     */\n            export class BeaconEventHandler {\n                            constructor(eventsToOverride?: {\n                                            [key in BeaconEvent]?: {\n                                                            handler: BeaconEventHandlerFunction<BeaconEventType[key]>;\n                                            };\n                            }, overrideAll?: boolean);\n                            /**\n                                     * A method to subscribe to a specific beacon event and register a callback\n                                     *\n                                     * @param event The event being emitted\n                                     * @param eventCallback The callback that will be invoked\n                                     */\n                            on<K extends BeaconEvent>(event: K, eventCallback: BeaconEventHandlerFunction<BeaconEventType[K]>): Promise<void>;\n                            /**\n                                     * Emit a beacon event\n                                     *\n                                     * @param event The event being emitted\n                                     * @param data The data to be emit\n                                     */\n                            emit<K extends BeaconEvent>(event: K, data?: BeaconEventType[K], eventCallback?: AlertButton[]): Promise<void>;\n            }\n            export {};\n    }\n    \n    declare module 'test/examples/broadcast-request' {\n            export {};\n    }\n    \n    declare module 'test/examples/custom-block-explorer' {\n            export {};\n    }\n    \n    declare module 'test/examples/disable-all-ui' {\n            export {};\n    }\n    \n    declare module 'test/examples/operation-request' {\n            export {};\n    }\n    \n    declare module 'test/examples/override-default-events' {\n            export {};\n    }\n    \n    declare module 'test/examples/permission-request' {\n            export {};\n    }\n    \n    declare module 'test/examples/sign-payload-request' {\n            export {};\n    }\n    \n    declare module 'test/examples/using-custom-network' {\n            export {};\n    }\n    \n    declare module 'test/examples/wallet-example' {\n            export {};\n    }\n    \n    declare module 'test/index' {\n            import { P2PCommunicationClient } from 'test/transports/clients/P2PCommunicationClient';\n            import { AppMetadata } from 'test/types/beacon/AppMetadata';\n            import { PermissionRequest } from 'test/types/beacon/messages/PermissionRequest';\n            import { Network } from 'test/types/beacon/Network';\n            import { BeaconBaseMessage } from 'test/types/beacon/BeaconBaseMessage';\n            import { BeaconMessageType } from 'test/types/beacon/BeaconMessageType';\n            import { PermissionScope } from 'test/types/beacon/PermissionScope';\n            import { PermissionResponse } from 'test/types/beacon/messages/PermissionResponse';\n            import { OperationRequest } from 'test/types/beacon/messages/OperationRequest';\n            import { OperationResponse } from 'test/types/beacon/messages/OperationResponse';\n            import { SignPayloadRequest } from 'test/types/beacon/messages/SignPayloadRequest';\n            import { SignPayloadResponse } from 'test/types/beacon/messages/SignPayloadResponse';\n            import { BroadcastRequest } from 'test/types/beacon/messages/BroadcastRequest';\n            import { BroadcastResponse } from 'test/types/beacon/messages/BroadcastResponse';\n            import { NetworkType } from 'test/types/beacon/NetworkType';\n            import { TezosBaseOperation } from 'test/types/tezos/TezosBaseOperation';\n            import { TezosOperationType } from 'test/types/tezos/OperationTypes';\n            import { TezosActivateAccountOperation } from 'test/types/tezos/operations/ActivateAccount';\n            import { TezosBallotOperation } from 'test/types/tezos/operations/Ballot';\n            import { TezosDelegationOperation } from 'test/types/tezos/operations/Delegation';\n            import { TezosDoubleBakingEvidenceOperation } from 'test/types/tezos/operations/DoubleBakingEvidence';\n            import { TezosBlockHeader } from 'test/types/tezos/TezosBlockHeader';\n            import { TezosDoubleEndorsementEvidenceOperation } from 'test/types/tezos/operations/DoubleEndorsementEvidence';\n            import { TezosEndorsementOperation } from 'test/types/tezos/operations/Endorsement';\n            import { TezosOriginationOperation } from 'test/types/tezos/operations/Origination';\n            import { TezosProposalOperation } from 'test/types/tezos/operations/Proposal';\n            import { TezosRevealOperation } from 'test/types/tezos/operations/Reveal';\n            import { TezosSeedNonceRevelationOperation } from 'test/types/tezos/operations/SeedNonceRevelation';\n            import { TezosTransactionOperation } from 'test/types/tezos/operations/Transaction';\n            import { MichelsonPrimitives } from 'test/types/tezos/MichelsonPrimitives';\n            import { TezosTransactionParameters } from 'test/types/tezos/TezosTransactionParameters';\n            import { Origin } from 'test/types/Origin';\n            import { AccountInfo, AccountIdentifier } from 'test/types/AccountInfo';\n            import { EncryptedExtensionMessage, ExtensionMessage } from 'test/types/ExtensionMessage';\n            import { ExtensionMessageTarget } from 'test/types/ExtensionMessageTarget';\n            import { TezosOperation } from 'test/types/tezos/TezosOperation';\n            import { Client } from 'test/clients/client/Client';\n            import { WalletClient } from 'test/clients/wallet-client/WalletClient';\n            import { DAppClient } from 'test/clients/dapp-client/DAppClient';\n            import { BeaconError } from 'test/errors/BeaconError';\n            import { BeaconErrorType } from 'test/types/BeaconErrorType';\n            import { BroadcastBeaconError } from 'test/errors/BroadcastBeaconError';\n            import { NetworkNotSupportedBeaconError } from 'test/errors/NetworkNotSupportedBeaconError';\n            import { NoAddressBeaconError } from 'test/errors/NoAddressBeaconError';\n            import { NoPrivateKeyBeaconError } from 'test/errors/NoPrivateKeyBeaconError';\n            import { NotGrantedBeaconError } from 'test/errors/NotGrantedBeaconError';\n            import { ParametersInvalidBeaconError } from 'test/errors/ParametersInvalidBeaconError';\n            import { TooManyOperationsBeaconError } from 'test/errors/TooManyOperationsBeaconError';\n            import { TransactionInvalidBeaconError } from 'test/errors/TransactionInvalidBeaconError';\n            import { UnknownBeaconError } from 'test/errors/UnknownBeaconError';\n            import { ErrorResponse } from 'test/types/beacon/messages/ErrorResponse';\n            import { TransportStatus } from 'test/types/transport/TransportStatus';\n            import { TransportType } from 'test/types/transport/TransportType';\n            import { PostMessageTransport } from 'test/transports/PostMessageTransport';\n            import { Transport } from 'test/transports/Transport';\n            import { P2PTransport } from 'test/transports/P2PTransport';\n            import { Storage } from 'test/storage/Storage';\n            import { StorageKey } from 'test/types/storage/StorageKey';\n            import { StorageKeyReturnDefaults } from 'test/types/storage/StorageKeyReturnDefaults';\n            import { StorageKeyReturnType } from 'test/types/storage/StorageKeyReturnType';\n            import { ExtendedP2PPairingRequest, P2PPairingRequest } from 'test/types/P2PPairingRequest';\n            import { ChromeStorage } from 'test/storage/ChromeStorage';\n            import { LocalStorage } from 'test/storage/LocalStorage';\n            import { getStorage } from 'test/storage/getStorage';\n            import { BeaconMessage } from 'test/types/beacon/BeaconMessage';\n            import { Serializer } from 'test/Serializer';\n            import { RequestPermissionInput } from 'test/types/RequestPermissionInput';\n            import { RequestSignPayloadInput } from 'test/types/RequestSignPayloadInput';\n            import { RequestOperationInput } from 'test/types/RequestOperationInput';\n            import { RequestBroadcastInput } from 'test/types/RequestBroadcastInput';\n            import { PermissionResponseInput, SignPayloadResponseInput, OperationResponseInput, BroadcastResponseInput, BeaconResponseInputMessage, AcknowledgeResponseInput, ErrorResponseInput } from 'test/types/beacon/messages/BeaconResponseInputMessage';\n            import { PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, BeaconResponseOutputMessage } from 'test/types/beacon/messages/BeaconResponseOutputMessage';\n            import { PermissionRequestInput, SignPayloadRequestInput, OperationRequestInput, BroadcastRequestInput, BeaconRequestInputMessage } from 'test/types/beacon/messages/BeaconRequestInputMessage';\n            import { PermissionRequestOutput, SignPayloadRequestOutput, OperationRequestOutput, BroadcastRequestOutput, BeaconRequestOutputMessage } from 'test/types/beacon/messages/BeaconRequestOutputMessage';\n            import { ClientOptions } from 'test/clients/client/ClientOptions';\n            import { DAppClientOptions } from 'test/clients/dapp-client/DAppClientOptions';\n            import { WalletClientOptions } from 'test/clients/wallet-client/WalletClientOptions';\n            import { PermissionInfo } from 'test/types/PermissionInfo';\n            import { SDK_VERSION, BEACON_VERSION } from 'test/constants';\n            import { AccountManager } from 'test/managers/AccountManager';\n            import { AppMetadataManager } from 'test/managers/AppMetadataManager';\n            import { PermissionManager } from 'test/managers/PermissionManager';\n            import { BeaconEvent, BeaconEventHandler, defaultEventCallbacks } from 'test/events';\n            import { getAddressFromPublicKey } from 'test/utils/crypto';\n            import { BeaconClient } from 'test/clients/beacon-client/BeaconClient';\n            import { BeaconClientOptions } from 'test/clients/beacon-client/BeaconClientOptions';\n            import { getAccountIdentifier } from 'test/utils/get-account-identifier';\n            import { ConnectionContext } from 'test/types/ConnectionContext';\n            import { Threshold } from 'test/types/beacon/Threshold';\n            import { PartialTezosTransactionOperation, PartialTezosOperation, PartialTezosDelegationOperation, PartialTezosOriginationOperation, PartialTezosRevealOperation } from 'test/types/tezos/PartialTezosOperation';\n            import { AbortedBeaconError } from 'test/errors/AbortedBeaconError';\n            import { ExtendedPeerInfo, PeerInfo } from 'test/types/PeerInfo';\n            import { availableTransports } from 'test/utils/available-transports';\n            import { AcknowledgeResponse } from 'test/types/beacon/messages/AcknowledgeResponse';\n            import { DisconnectMessage } from 'test/types/beacon/messages/DisconnectMessage';\n            import { DappP2PTransport } from 'test/transports/DappP2PTransport';\n            import { DappPostMessageTransport } from 'test/transports/DappPostMessageTransport';\n            import { WalletP2PTransport } from 'test/transports/WalletP2PTransport';\n            import { WalletPostMessageTransport } from 'test/transports/WalletPostMessageTransport';\n            import { getSenderId } from 'test/utils/get-sender-id';\n            import { SigningType } from 'test/types/beacon/SigningType';\n            import { SignatureTypeNotSupportedBeaconError } from 'test/errors/SignatureTypeNotSupportedBeaconError';\n            import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n            import { ExtendedPostMessagePairingRequest, PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n            import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n            import { PeerManager } from 'test/managers/PeerManager';\n            import { MessageBasedClient } from 'test/transports/clients/MessageBasedClient';\n            import { BeaconRequestMessage } from 'test/types/beacon/BeaconRequestMessage';\n            import { BeaconResponseMessage } from 'test/types/beacon/BeaconResponseMessage';\n            import { Pairing } from 'test/ui/alert/Pairing';\n            import { BlockExplorer } from 'test/utils/block-explorer';\n            import { TezblockBlockExplorer } from 'test/utils/tezblock-blockexplorer';\n            import { setDebugEnabled, getDebugEnabled } from 'test/debug';\n            import { ColorMode } from 'test/types/ColorMode';\n            export { TezosBaseOperation, TezosOperationType, TezosBlockHeader, MichelsonPrimitives, TezosTransactionParameters, TezosOperation };\n            export { TezosActivateAccountOperation, TezosBallotOperation, TezosDelegationOperation, TezosDoubleBakingEvidenceOperation, TezosDoubleEndorsementEvidenceOperation, TezosEndorsementOperation, TezosOriginationOperation, TezosProposalOperation, TezosRevealOperation, TezosSeedNonceRevelationOperation, TezosTransactionOperation, PartialTezosOperation, PartialTezosTransactionOperation, PartialTezosDelegationOperation, PartialTezosOriginationOperation, PartialTezosRevealOperation };\n            export { BeaconClient, BeaconClientOptions, Client, ClientOptions, DAppClient, DAppClientOptions, WalletClient, WalletClientOptions, P2PCommunicationClient };\n            export { AccountIdentifier, AppMetadata, Network, NetworkType, BeaconMessage, PermissionRequest, PermissionResponse, OperationRequest, OperationResponse, SignPayloadRequest, SignPayloadResponse, BroadcastRequest, BroadcastResponse, AcknowledgeResponse, DisconnectMessage, BeaconBaseMessage, BeaconMessageType, PermissionScope, Origin, AccountInfo, Threshold, SigningType, ExtensionMessageTarget, ExtensionMessage, EncryptedExtensionMessage, RequestPermissionInput, RequestSignPayloadInput, RequestOperationInput, RequestBroadcastInput, PermissionInfo };\n            export { PermissionResponseInput, SignPayloadResponseInput, OperationResponseInput, BroadcastResponseInput, AcknowledgeResponseInput, ErrorResponseInput, PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, PermissionRequestInput, SignPayloadRequestInput, OperationRequestInput, BroadcastRequestInput, PermissionRequestOutput, SignPayloadRequestOutput, OperationRequestOutput, BroadcastRequestOutput, BeaconRequestInputMessage, BeaconRequestOutputMessage, BeaconResponseInputMessage, BeaconResponseOutputMessage, BeaconRequestMessage, BeaconResponseMessage };\n            export { BeaconError, BeaconErrorType, ErrorResponse, AbortedBeaconError, BroadcastBeaconError, NetworkNotSupportedBeaconError, NoAddressBeaconError, NoPrivateKeyBeaconError, NotGrantedBeaconError, ParametersInvalidBeaconError, TooManyOperationsBeaconError, TransactionInvalidBeaconError, SignatureTypeNotSupportedBeaconError, UnknownBeaconError };\n            export { TransportStatus, TransportType, Transport, PostMessageTransport, P2PTransport, WalletP2PTransport, WalletPostMessageTransport, DappP2PTransport, DappPostMessageTransport, MessageBasedClient, Pairing };\n            export { BeaconEvent, BeaconEventHandler, defaultEventCallbacks };\n            export { Storage, StorageKey, StorageKeyReturnDefaults, StorageKeyReturnType, ChromeStorage, LocalStorage, getStorage };\n            export { PeerManager, AccountManager, AppMetadataManager, PermissionManager };\n            export { SDK_VERSION, BEACON_VERSION };\n            export { getSenderId, getAccountIdentifier, getAddressFromPublicKey };\n            export { PeerInfo, ExtendedPeerInfo, PostMessagePairingRequest, ExtendedPostMessagePairingRequest, ExtendedPostMessagePairingResponse, P2PPairingRequest, ExtendedP2PPairingRequest, ExtendedP2PPairingResponse };\n            export { BlockExplorer, TezblockBlockExplorer };\n            export { ConnectionContext, Serializer, availableTransports, ColorMode };\n            export { setDebugEnabled, getDebugEnabled };\n    }\n    \n    declare module 'test/interceptors/IncomingRequestInterceptor' {\n            import { BeaconRequestOutputMessage } from 'test/';\n            import { ConnectionContext } from 'test/types/ConnectionContext';\n            import { AppMetadataManager } from 'test/managers/AppMetadataManager';\n            import { BeaconRequestMessage } from 'test/types/beacon/BeaconRequestMessage';\n            interface IncomingRequestInterceptorOptions {\n                            message: BeaconRequestMessage;\n                            connectionInfo: ConnectionContext;\n                            appMetadataManager: AppMetadataManager;\n                            interceptorCallback(message: BeaconRequestOutputMessage, connectionInfo: ConnectionContext): void;\n            }\n            /**\n                     * The IncomingRequestInterceptor is used in the WalletClient to intercept an incoming request and enrich it with data, like app metadata.\n                     */\n            export class IncomingRequestInterceptor {\n                            /**\n                                     * The method that is called during the interception\n                                     *\n                                     * @param config\n                                     */\n                            static intercept(config: IncomingRequestInterceptorOptions): Promise<void>;\n            }\n            export {};\n    }\n    \n    declare module 'test/interceptors/OutgoingResponseInterceptor' {\n            import { BeaconMessage, BeaconResponseInputMessage, AppMetadata } from 'test/';\n            import { PermissionManager } from 'test/managers/PermissionManager';\n            import { AppMetadataManager } from 'test/managers/AppMetadataManager';\n            import { BeaconRequestMessage } from 'test/types/beacon/BeaconRequestMessage';\n            interface OutgoingResponseInterceptorOptions {\n                    senderId: string;\n                    request: BeaconRequestMessage;\n                    message: BeaconResponseInputMessage;\n                    ownAppMetadata: AppMetadata;\n                    permissionManager: PermissionManager;\n                    appMetadataManager: AppMetadataManager;\n                    interceptorCallback(message: BeaconMessage): void;\n            }\n            /**\n                 * The OutgoingResponseInterceptor is used in the WalletClient to intercept an outgoing response and enrich it with data.\n                 */\n            export class OutgoingResponseInterceptor {\n                    static intercept(config: OutgoingResponseInterceptorOptions): Promise<void>;\n            }\n            export {};\n    }\n    \n    declare module 'test/managers/AccountManager' {\n            import { Storage, AccountInfo, BeaconMessage } from 'test/';\n            /**\n                 * The AccountManager provides CRUD functionality for account entities and persists them to the provided storage.\n                 */\n            export class AccountManager {\n                    constructor(storage: Storage);\n                    getAccounts(): Promise<AccountInfo[]>;\n                    getAccount(accountIdentifier: string): Promise<AccountInfo | undefined>;\n                    addAccount(accountInfo: AccountInfo): Promise<void>;\n                    removeAccount(accountIdentifier: string): Promise<void>;\n                    removeAccounts(accountIdentifiers: string[]): Promise<void>;\n                    removeAllAccounts(): Promise<void>;\n                    hasPermission(message: BeaconMessage): Promise<boolean>;\n            }\n    }\n    \n    declare module 'test/managers/AppMetadataManager' {\n            import { Storage, AppMetadata } from 'test/';\n            /**\n                 * The AppMetadataManager provides CRUD functionality for app-metadata entities and persists them to the provided storage.\n                 */\n            export class AppMetadataManager {\n                    constructor(storage: Storage);\n                    getAppMetadataList(): Promise<AppMetadata[]>;\n                    getAppMetadata(senderId: string): Promise<AppMetadata | undefined>;\n                    addAppMetadata(appMetadata: AppMetadata): Promise<void>;\n                    removeAppMetadata(senderId: string): Promise<void>;\n                    removeAppMetadatas(senderIds: string[]): Promise<void>;\n                    removeAllAppMetadata(): Promise<void>;\n            }\n    }\n    \n    declare module 'test/managers/PeerManager' {\n            import { Storage, StorageKey, StorageKeyReturnType } from 'test/';\n            import { ArrayElem } from 'test/managers/StorageManager';\n            /**\n                 * The PeerManager provides CRUD functionality for peer entities and persists them to the provided storage.\n                 */\n            export class PeerManager<T extends StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET> {\n                    constructor(storage: Storage, key: T);\n                    hasPeer(publicKey: string): Promise<boolean>;\n                    getPeers(): Promise<StorageKeyReturnType[T]>;\n                    getPeer(publicKey: string): Promise<ArrayElem<StorageKeyReturnType[T]> | undefined>;\n                    addPeer(peerInfo: ArrayElem<StorageKeyReturnType[T]>): Promise<void>;\n                    removePeer(publicKey: string): Promise<void>;\n                    removePeers(publicKeys: string[]): Promise<void>;\n                    removeAllPeers(): Promise<void>;\n            }\n    }\n    \n    declare module 'test/managers/PermissionManager' {\n            import { BeaconMessage, Storage } from 'test/';\n            import { PermissionInfo } from 'test/types/PermissionInfo';\n            /**\n                 * The PermissionManager provides CRUD functionality for permission entities and persists them to the provided storage.\n                 */\n            export class PermissionManager {\n                    constructor(storage: Storage);\n                    getPermissions(): Promise<PermissionInfo[]>;\n                    getPermission(accountIdentifier: string): Promise<PermissionInfo | undefined>;\n                    addPermission(permissionInfo: PermissionInfo): Promise<void>;\n                    removePermission(accountIdentifier: string): Promise<void>;\n                    removePermissions(accountIdentifiers: string[]): Promise<void>;\n                    removeAllPermissions(): Promise<void>;\n                    hasPermission(message: BeaconMessage): Promise<boolean>;\n            }\n    }\n    \n    declare module 'test/managers/PermissionValidator' {\n            import { BeaconMessage } from 'test/';\n            import { PermissionEntity } from 'test/types/PermissionEntity';\n            /**\n                     * The PermissionValidator is used to check if permissions for a certain message type have been given\n                     */\n            export class PermissionValidator {\n                            /**\n                                     * Check if permissions were given for a certain message type.\n                                     *\n                                     * PermissionRequest and BroadcastRequest will always return true.\n                                     *\n                                     * @param message Beacon Message\n                                     */\n                            static hasPermission(message: BeaconMessage, getOne: (id: string) => Promise<PermissionEntity | undefined>, getAll: () => Promise<PermissionEntity[]>): Promise<boolean>;\n            }\n    }\n    \n    declare module 'test/managers/StorageManager' {\n            import { StorageKey, Storage, StorageKeyReturnType } from 'test/';\n            /** Type workaround for https://github.com/Microsoft/TypeScript/issues/7294#issuecomment-465794460 */\n            export type ArrayElem<A> = A extends (infer Elem)[] ? Elem : never;\n            /**\n                     * The StorageManager provides CRUD functionality for specific entities and persists them to the provided storage.\n                     */\n            export class StorageManager<T extends StorageKey.ACCOUNTS | StorageKey.APP_METADATA_LIST | StorageKey.PERMISSION_LIST | StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET> {\n                            constructor(storage: Storage, storageKey: T);\n                            getAll(): Promise<StorageKeyReturnType[T]>;\n                            getOne(predicate: (element: ArrayElem<StorageKeyReturnType[T]>) => boolean): Promise<ArrayElem<StorageKeyReturnType[T]> | undefined>;\n                            addOne(element: ArrayElem<StorageKeyReturnType[T]>, predicate: (element: ArrayElem<StorageKeyReturnType[T]>) => boolean, overwrite?: boolean): Promise<void>;\n                            remove(predicate: (element: ArrayElem<StorageKeyReturnType[T]>) => boolean): Promise<void>;\n                            removeAll(): Promise<void>;\n            }\n    }\n    \n    declare module 'test/matrix-client/MatrixClient' {\n            import { Storage } from 'test/storage/Storage';\n            import { MatrixClientStore } from 'test/matrix-client/MatrixClientStore';\n            import { MatrixRoom } from 'test/matrix-client/models/MatrixRoom';\n            import { MatrixRoomService } from 'test/matrix-client/services/MatrixRoomService';\n            import { MatrixUserService } from 'test/matrix-client/services/MatrixUserService';\n            import { MatrixEventService } from 'test/matrix-client/services/MatrixEventService';\n            import { MatrixClientEventEmitter } from 'test/matrix-client/MatrixClientEventEmitter';\n            import { MatrixClientEventType, MatrixClientEvent } from 'test/matrix-client/models/MatrixClientEvent';\n            interface MatrixClientOptions {\n                            baseUrl: string;\n                            storage: Storage;\n            }\n            interface MatrixLoginConfig {\n                            id: string;\n                            password: string;\n                            deviceId: string;\n            }\n            /**\n                     * The matrix client used to connect to the matrix network\n                     */\n            export class MatrixClient {\n                            /**\n                                     * Create a matrix client based on the options provided\n                                     *\n                                     * @param config\n                                     */\n                            static create(config: MatrixClientOptions): MatrixClient;\n                            /**\n                                     * Return all the rooms we are currently part of\n                                     */\n                            get joinedRooms(): MatrixRoom[];\n                            /**\n                                     * Return all the rooms to which we have received invitations\n                                     */\n                            get invitedRooms(): MatrixRoom[];\n                            /**\n                                     * Return all the rooms that we left\n                                     */\n                            get leftRooms(): MatrixRoom[];\n                            constructor(store: MatrixClientStore, eventEmitter: MatrixClientEventEmitter, userService: MatrixUserService, roomService: MatrixRoomService, eventService: MatrixEventService);\n                            /**\n                                     * Initiate the connection to the matrix node and log in\n                                     *\n                                     * @param user\n                                     */\n                            start(user: MatrixLoginConfig): Promise<void>;\n                            /**\n                                     * Subscribe to new matrix events\n                                     *\n                                     * @param event\n                                     * @param listener\n                                     */\n                            subscribe<T extends MatrixClientEventType>(event: T, listener: (event: MatrixClientEvent<T>) => void): void;\n                            /**\n                                     * Unsubscribe from matrix events\n                                     *\n                                     * @param event\n                                     * @param listener\n                                     */\n                            unsubscribe(event: MatrixClientEventType, listener?: (event: MatrixClientEvent<any>) => void): void;\n                            getRoomById(id: string): MatrixRoom;\n                            /**\n                                     * Create a private room with the supplied members\n                                     *\n                                     * @param members Members that will be in the room\n                                     */\n                            createTrustedPrivateRoom(...members: string[]): Promise<string>;\n                            /**\n                                     * Invite user to rooms\n                                     *\n                                     * @param user The user to be invited\n                                     * @param roomsOrIds The rooms the user will be invited to\n                                     */\n                            inviteToRooms(user: string, ...roomsOrIds: string[] | MatrixRoom[]): Promise<void>;\n                            /**\n                                     * Join rooms\n                                     *\n                                     * @param roomsOrIds\n                                     */\n                            joinRooms(...roomsOrIds: string[] | MatrixRoom[]): Promise<void>;\n                            /**\n                                     * Send a text message\n                                     *\n                                     * @param roomOrId\n                                     * @param message\n                                     */\n                            sendTextMessage(roomId: string, message: string): Promise<void>;\n            }\n            export {};\n    }\n    \n    declare module 'test/matrix-client/MatrixClientEventEmitter' {\n            import { EventEmitter } from 'events';\n            import { MatrixStateStore, MatrixStateUpdate } from 'test/matrix-client/MatrixClientStore';\n            export class MatrixClientEventEmitter extends EventEmitter {\n                            /**\n                                     * This method is called every time the state is changed\n                                     *\n                                     * @param _oldState\n                                     * @param _newState\n                                     * @param stateChange\n                                     */\n                            onStateChanged(_oldState: MatrixStateStore, _newState: MatrixStateStore, stateChange: Partial<MatrixStateUpdate>): void;\n            }\n    }\n    \n    declare module 'test/matrix-client/MatrixClientStore' {\n            import { MatrixRoom } from 'test/matrix-client/models/MatrixRoom';\n            import { Storage } from 'test/storage/Storage';\n            type OnStateChangedListener = (oldState: MatrixStateStore, newState: MatrixStateStore, stateChange: Partial<MatrixStateUpdate>) => void;\n            export interface MatrixState {\n                            isRunning: boolean;\n                            userId: string | undefined;\n                            deviceId: string | undefined;\n                            txnNo: number;\n                            accessToken: string | undefined;\n                            syncToken: string | undefined;\n                            pollingTimeout: number | undefined;\n                            pollingRetries: number;\n                            rooms: MatrixRoom[] | Record<string, MatrixRoom>;\n            }\n            export interface MatrixStateStore extends MatrixState {\n                            rooms: Record<string, MatrixRoom>;\n            }\n            export interface MatrixStateUpdate extends MatrixState {\n                            rooms: MatrixRoom[];\n            }\n            /**\n                     * The class managing the local state of matrix\n                     */\n            export class MatrixClientStore {\n                            constructor(storage: Storage);\n                            /**\n                                     * Get an item from the state\n                                     *\n                                     * @param key\n                                     */\n                            get<T extends keyof MatrixStateStore>(key: T): MatrixStateStore[T];\n                            /**\n                                     * Get the room from an ID or room instance\n                                     *\n                                     * @param roomOrId\n                                     */\n                            getRoom(roomOrId: string | MatrixRoom): MatrixRoom;\n                            /**\n                                     * Update the state with a partial state\n                                     *\n                                     * @param stateUpdate\n                                     */\n                            update(stateUpdate: Partial<MatrixStateUpdate>): Promise<void>;\n                            /**\n                                     * Register listeners that are called once the state has changed\n                                     *\n                                     * @param listener\n                                     * @param subscribed\n                                     */\n                            onStateChanged(listener: OnStateChangedListener, ...subscribed: (keyof MatrixState)[]): void;\n            }\n            export {};\n    }\n    \n    declare module 'test/matrix-client/MatrixHttpClient' {\n            import { MatrixRequest, MatrixRequestParams } from 'test/matrix-client/models/api/MatrixRequest';\n            interface HttpOptions {\n                            accessToken?: string;\n            }\n            /**\n                     * Handling the HTTP connection to the matrix synapse node\n                     */\n            export class MatrixHttpClient {\n                            constructor(baseUrl: string);\n                            /**\n                                     * Get data from the synapse node\n                                     *\n                                     * @param endpoint\n                                     * @param options\n                                     */\n                            get<T>(endpoint: string, params?: MatrixRequestParams<T>, options?: HttpOptions): Promise<T>;\n                            /**\n                                     * Post data to the synapse node\n                                     *\n                                     * @param endpoint\n                                     * @param body\n                                     * @param options\n                                     * @param params\n                                     */\n                            post<T>(endpoint: string, body: MatrixRequest<T>, options?: HttpOptions, params?: MatrixRequestParams<T>): Promise<T>;\n                            /**\n                                     * Put data to the synapse node\n                                     *\n                                     * @param endpoint\n                                     * @param body\n                                     * @param options\n                                     * @param params\n                                     */\n                            put<T>(endpoint: string, body: MatrixRequest<T>, options?: HttpOptions, params?: MatrixRequestParams<T>): Promise<T>;\n            }\n            export {};\n    }\n    \n    declare module 'test/matrix-client/models/api/MatrixEventSend' {\n            export interface MatrixEventSendRequest {\n                    content: any;\n            }\n            export interface MatrixEventSendResponse {\n                    type?: 'event_send';\n                    event_id: string;\n            }\n    }\n    \n    declare module 'test/matrix-client/models/api/MatrixLogin' {\n            export interface MatrixLoginRequest {\n                    type: 'm.login.password';\n                    identifier: {\n                            type: 'm.id.user';\n                            user: string;\n                    };\n                    password: string;\n                    device_id?: string;\n            }\n            export interface MatrixLoginResponse {\n                    type?: 'login';\n                    user_id: string;\n                    device_id: string;\n                    access_token: string;\n            }\n    }\n    \n    declare module 'test/matrix-client/models/api/MatrixRequest' {\n            import { MatrixLoginRequest, MatrixLoginResponse } from 'test/matrix-client/models/api/MatrixLogin';\n            import { MatrixRoomCreateRequest, MatrixRoomCreateResponse } from 'test/matrix-client/models/api/MatrixRoomCreate';\n            import { MatrixRoomInviteRequest, MatrixRoomInviteResponse } from 'test/matrix-client/models/api/MatrixRoomInvite';\n            import { MatrixRoomJoinRequest, MatrixRoomJoinResponse } from 'test/matrix-client/models/api/MatrixRoomJoin';\n            import { MatrixEventSendRequest, MatrixEventSendResponse } from 'test/matrix-client/models/api/MatrixEventSend';\n            import { MatrixSyncResponse, MatrixSyncRequestParams } from 'test/matrix-client/models/api/MatrixSync';\n            export type MatrixRequest<T> = T extends MatrixLoginResponse ? MatrixLoginRequest : T extends MatrixRoomCreateResponse ? MatrixRoomCreateRequest : T extends MatrixRoomInviteResponse ? MatrixRoomInviteRequest : T extends MatrixRoomJoinResponse ? MatrixRoomJoinRequest : T extends MatrixEventSendResponse ? MatrixEventSendRequest : never;\n            export type MatrixRequestParams<T> = T extends MatrixSyncResponse ? MatrixSyncRequestParams : never;\n    }\n    \n    declare module 'test/matrix-client/models/api/MatrixRoomCreate' {\n            export interface MatrixRoomCreateRequest {\n                    visibility?: 'public' | 'private';\n                    room_alias_name?: string;\n                    name?: string;\n                    topic?: string;\n                    invite?: string[];\n                    preset?: 'private_chat' | 'public_chat' | 'trusted_private_chat';\n                    is_direct?: boolean;\n            }\n            export interface MatrixRoomCreateResponse {\n                    type?: 'room_create';\n                    room_id: string;\n            }\n    }\n    \n    declare module 'test/matrix-client/models/api/MatrixRoomInvite' {\n            export interface MatrixRoomInviteRequest {\n                    user_id: string;\n            }\n            export interface MatrixRoomInviteResponse {\n                    type?: 'room_invite';\n            }\n    }\n    \n    declare module 'test/matrix-client/models/api/MatrixRoomJoin' {\n            export interface MatrixRoomJoinRequest {\n            }\n            export interface MatrixRoomJoinResponse {\n                    type?: 'room_join';\n                    room_id: string;\n            }\n    }\n    \n    declare module 'test/matrix-client/models/api/MatrixSync' {\n            import { MatrixStateEvent } from 'test/matrix-client/models/MatrixStateEvent';\n            export interface MatrixSyncJoinedRoom {\n                    state: {\n                            events: MatrixStateEvent[];\n                    };\n                    timeline: {\n                            events: MatrixStateEvent[];\n                    };\n            }\n            export interface MatrixSyncInvitedRoom {\n                    invite_state: {\n                            events: MatrixStateEvent[];\n                    };\n            }\n            export interface MatrixSyncLeftRoom {\n                    state: {\n                            events: MatrixStateEvent[];\n                    };\n                    timeline: {\n                            events: MatrixStateEvent[];\n                    };\n            }\n            export interface MatrixSyncRooms {\n                    join: {\n                            [key: string]: MatrixSyncJoinedRoom;\n                    };\n                    invite: {\n                            [key: string]: MatrixSyncInvitedRoom;\n                    };\n                    leave: {\n                            [key: string]: MatrixSyncLeftRoom;\n                    };\n            }\n            export interface MatrixSyncRequestParams {\n                    timeout?: number;\n                    since?: string;\n            }\n            export interface MatrixSyncResponse {\n                    type?: 'sync';\n                    next_batch: string;\n                    rooms: MatrixSyncRooms;\n            }\n    }\n    \n    declare module 'test/matrix-client/models/MatrixClientEvent' {\n            import { MatrixMessage } from 'test/matrix-client/models/MatrixMessage';\n            export enum MatrixClientEventType {\n                    INVITE = \"invite\",\n                    MESSAGE = \"message\"\n            }\n            export type MatrixClientEventContent<T> = T extends MatrixClientEventType.INVITE ? MatrixClientEventInviteContent : T extends MatrixClientEventType.MESSAGE ? MatrixClientEventMessageContent<any> : never;\n            export interface MatrixClientEventInviteContent {\n                    roomId: string;\n            }\n            export interface MatrixClientEventMessageContent<T> {\n                    roomId: string;\n                    message: MatrixMessage<T>;\n            }\n            export interface MatrixClientEvent<T extends MatrixClientEventType> {\n                    type: T;\n                    content: MatrixClientEventContent<T>;\n            }\n    }\n    \n    declare module 'test/matrix-client/models/MatrixMessage' {\n            import { MatrixStateEvent } from 'test/matrix-client/models/MatrixStateEvent';\n            export enum MatrixMessageType {\n                    TEXT = \"m.text\"\n            }\n            export class MatrixMessage<T> {\n                    readonly type: MatrixMessageType;\n                    readonly sender: string;\n                    readonly content: T;\n                    /**\n                         * Construct a message from a message event\n                         *\n                         * @param event\n                         */\n                    static from(event: MatrixStateEvent): MatrixMessage<any> | undefined;\n            }\n    }\n    \n    declare module 'test/matrix-client/models/MatrixRoom' {\n            import { MatrixSyncRooms } from 'test/matrix-client/models/api/MatrixSync';\n            import { MatrixMessage } from 'test/matrix-client/models/MatrixMessage';\n            export enum MatrixRoomStatus {\n                            UNKNOWN = 0,\n                            JOINED = 1,\n                            INVITED = 2,\n                            LEFT = 3\n            }\n            export class MatrixRoom {\n                            readonly id: string;\n                            readonly status: MatrixRoomStatus;\n                            readonly members: string[];\n                            messages: MatrixMessage<any>[];\n                            /**\n                                     * Reconstruct rooms from a sync response\n                                     *\n                                     * @param roomSync\n                                     */\n                            static fromSync(roomSync: MatrixSyncRooms): MatrixRoom[];\n                            /**\n                                     * Reconstruct a room from an ID or object\n                                     *\n                                     * @param roomOrId\n                                     * @param status\n                                     */\n                            static from(roomOrId: string | MatrixRoom, status?: MatrixRoomStatus): MatrixRoom;\n                            /**\n                                     * Merge new and old state and remove duplicates\n                                     *\n                                     * @param newState\n                                     * @param previousState\n                                     */\n                            static merge(newState: MatrixRoom, previousState?: MatrixRoom): MatrixRoom;\n            }\n    }\n    \n    declare module 'test/matrix-client/models/MatrixStateEvent' {\n            import { MatrixMessageType } from 'test/matrix-client/models/MatrixMessage';\n            export interface MatrixStateEventMessageText extends MatrixStateEventMessage {\n                    type: 'm.room.message';\n                    content: {\n                            msgtype: MatrixMessageType.TEXT;\n                            body: string;\n                    };\n            }\n            export interface MatrixStateEventMessageContent {\n                    msgtype: string;\n                    body: any;\n                    [key: string]: any;\n            }\n            export interface MatrixStateEventMessage extends MatrixStateEvent {\n                    type: 'm.room.message';\n                    content: MatrixStateEventMessageContent;\n            }\n            export interface MatrixStateEvent {\n                    type: string;\n                    sender: string;\n                    content: unknown;\n                    event_id?: string;\n            }\n    }\n    \n    declare module 'test/matrix-client/services/MatrixEventService' {\n            import { MatrixHttpClient } from 'test/matrix-client/MatrixHttpClient';\n            import { MatrixEventSendResponse } from 'test/matrix-client/models/api/MatrixEventSend';\n            import { MatrixSyncResponse } from 'test/matrix-client/models/api/MatrixSync';\n            import { MatrixStateEventMessageContent } from 'test/matrix-client/models/MatrixStateEvent';\n            interface MatrixScheduledEvent<T> {\n                            accessToken: string;\n                            roomId: string;\n                            type: MatrixEventType;\n                            content: any;\n                            txnId: string;\n                            onSuccess(response: T): void;\n                            onError(error: unknown): void;\n            }\n            type MatrixEventType = 'm.room.message';\n            export interface MatrixSyncOptions {\n                            syncToken?: string;\n                            pollingTimeout?: number;\n            }\n            /**\n                     * A service to help with matrix event management\n                     */\n            export class MatrixEventService {\n                            constructor(httpClient: MatrixHttpClient);\n                            /**\n                                     * Get the latest state from the matrix node\n                                     *\n                                     * @param accessToken\n                                     * @param options\n                                     */\n                            sync(accessToken: string, options?: MatrixSyncOptions): Promise<MatrixSyncResponse>;\n                            /**\n                                     * Send a message to a room\n                                     *\n                                     * @param accessToken\n                                     * @param room\n                                     * @param content\n                                     * @param txnId\n                                     */\n                            sendMessage(accessToken: string, roomId: string, content: MatrixStateEventMessageContent, txnId: string): Promise<MatrixEventSendResponse>;\n                            /**\n                                     * Schedules an event to be sent to the node\n                                     *\n                                     * @param event\n                                     */\n                            scheduleEvent(event: MatrixScheduledEvent<any>): void;\n                            /**\n                                     * Send an event to the matrix node\n                                     *\n                                     * @param scheduledEvent\n                                     */\n                            sendEvent(scheduledEvent: MatrixScheduledEvent<any>): Promise<void>;\n            }\n            export {};\n    }\n    \n    declare module 'test/matrix-client/services/MatrixRoomService' {\n            import { MatrixHttpClient } from 'test/matrix-client/MatrixHttpClient';\n            import { MatrixRoom } from 'test/matrix-client/models/MatrixRoom';\n            import { MatrixRoomCreateRequest, MatrixRoomCreateResponse } from 'test/matrix-client/models/api/MatrixRoomCreate';\n            import { MatrixRoomInviteResponse } from 'test/matrix-client/models/api/MatrixRoomInvite';\n            import { MatrixRoomJoinResponse } from 'test/matrix-client/models/api/MatrixRoomJoin';\n            /**\n                     * A service to help with matrix room management\n                     */\n            export class MatrixRoomService {\n                            constructor(httpClient: MatrixHttpClient);\n                            /**\n                                     * Create a room\n                                     *\n                                     * @param accessToken\n                                     * @param config\n                                     */\n                            createRoom(accessToken: string, config?: MatrixRoomCreateRequest): Promise<MatrixRoomCreateResponse>;\n                            /**\n                                     * Invite a user to a room\n                                     *\n                                     * @param accessToken\n                                     * @param user\n                                     * @param room\n                                     */\n                            inviteToRoom(accessToken: string, user: string, room: MatrixRoom): Promise<MatrixRoomInviteResponse>;\n                            /**\n                                     * Join a specific room\n                                     *\n                                     * @param accessToken\n                                     * @param room\n                                     */\n                            joinRoom(accessToken: string, room: MatrixRoom): Promise<MatrixRoomJoinResponse>;\n                            /**\n                                     * Get all joined rooms\n                                     *\n                                     * @param accessToken\n                                     */\n                            getJoinedRooms(accessToken: string): Promise<MatrixRoomJoinResponse>;\n            }\n    }\n    \n    declare module 'test/matrix-client/services/MatrixUserService' {\n            import { MatrixHttpClient } from 'test/matrix-client/MatrixHttpClient';\n            import { MatrixLoginResponse } from 'test/matrix-client/models/api/MatrixLogin';\n            export class MatrixUserService {\n                    constructor(httpClient: MatrixHttpClient);\n                    /**\n                         * Log in to the matrix node with username and password\n                         *\n                         * @param user\n                         * @param password\n                         * @param deviceId\n                         */\n                    login(user: string, password: string, deviceId: string): Promise<MatrixLoginResponse>;\n            }\n    }\n    \n    declare module 'test/matrix-client/utils/events' {\n            import { MatrixStateEvent, MatrixStateEventMessageText } from 'test/matrix-client/models/MatrixStateEvent';\n            /**\n                     * Check if an event is a create event\n                     *\n                     * @param event MatrixStateEvent\n                     */\n            export const isCreateEvent: (event: MatrixStateEvent) => boolean;\n            /**\n                     * Check if an event is a join event\n                     *\n                     * @param event MatrixStateEvent\n                     */\n            export const isJoinEvent: (event: MatrixStateEvent) => boolean;\n            /**\n                     * Check if an event is a message event\n                     *\n                     * @param event MatrixStateEvent\n                     */\n            export const isMessageEvent: (event: MatrixStateEvent) => boolean;\n            /**\n                     * Check if an event is a text message event\n                     *\n                     * @param event MatrixStateEvent\n                     */\n            export const isTextMessageEvent: (event: MatrixStateEvent) => event is MatrixStateEventMessageText;\n    }\n    \n    declare module 'test/migrations/migrate-0.7.0' {\n            import { PermissionScope, AccountIdentifier, Origin, Network } from 'test/';\n            export interface AccountInfoOld {\n                    accountIdentifier: AccountIdentifier;\n                    beaconId: string;\n                    origin: {\n                            type: Origin;\n                            id: string;\n                    };\n                    address: string;\n                    pubkey: string;\n                    network: Network;\n                    scopes: PermissionScope[];\n                    connectedAt: Date;\n            }\n            export interface P2PPairingRequestOld {\n                    name: string;\n                    pubKey: string;\n                    relayServer: string;\n            }\n            export const migrate_0_7_0: (storage: Storage) => Promise<void>;\n    }\n    \n    declare module 'test/migrations/migrations' {\n            import { Storage } from 'test/';\n            export const migrate: (storage: Storage) => Promise<void>;\n    }\n    \n    declare module 'test/MockWindow' {\n            type Callback = (message: unknown) => void;\n            /**\n                 * A mock for postmessage if run in node.js environment\n                 */\n            let windowRef: {\n                    postMessage: (message: string | Record<string, unknown>, _target?: string | undefined) => void;\n                    addEventListener: (_name: string, eventCallback: Callback) => void;\n                    removeEventListener: (_name: string, eventCallback: Callback) => void;\n                    location: {\n                            origin: string;\n                    };\n            };\n            const clearMockWindowState: () => void;\n            export { windowRef, clearMockWindowState };\n    }\n    \n    declare module 'test/Serializer' {\n            /**\n                     * The Serializer is used to serialize / deserialize JSON objects and encode them with bs58check\n                     */\n            export class Serializer {\n                            /**\n                                     * Serialize and bs58check encode an object\n                                     *\n                                     * @param message JSON object to serialize\n                                     */\n                            serialize(message: unknown): Promise<string>;\n                            /**\n                                     * Deserialize a bs58check encoded string\n                                     *\n                                     * @param encoded String to be deserialized\n                                     */\n                            deserialize(encoded: string): Promise<unknown>;\n            }\n    }\n    \n    declare module 'test/storage/ChromeStorage' {\n            import { Storage, StorageKey, StorageKeyReturnType } from 'test/';\n            export class ChromeStorage implements Storage {\n                    static isSupported(): Promise<boolean>;\n                    get<K extends StorageKey>(key: K): Promise<StorageKeyReturnType[K]>;\n                    set<K extends StorageKey>(key: K, value: StorageKeyReturnType[K]): Promise<void>;\n                    delete<K extends StorageKey>(key: K): Promise<void>;\n            }\n    }\n    \n    declare module 'test/storage/getStorage' {\n            import { Storage } from 'test/';\n            /**\n                 * Get a supported storage on this platform\n                 */\n            export const getStorage: () => Promise<Storage>;\n    }\n    \n    declare module 'test/storage/LocalStorage' {\n            import { Storage, StorageKey, StorageKeyReturnType } from 'test/';\n            export class LocalStorage implements Storage {\n                    constructor(prefix?: string | undefined);\n                    static isSupported(): Promise<boolean>;\n                    get<K extends StorageKey>(key: K): Promise<StorageKeyReturnType[K]>;\n                    set<K extends StorageKey>(key: K, value: StorageKeyReturnType[K]): Promise<void>;\n                    delete<K extends StorageKey>(key: K): Promise<void>;\n            }\n    }\n    \n    declare module 'test/storage/Storage' {\n            import { StorageKey } from 'test/types/storage/StorageKey';\n            import { StorageKeyReturnType } from 'test/types/storage/StorageKeyReturnType';\n            /**\n                     * The storage used in the SDK\n                     */\n            export abstract class Storage {\n                            /**\n                                     * Returns a promise that resolves to true if the storage option is available on this platform.\n                                     */\n                            static isSupported(): Promise<boolean>;\n                            /**\n                                     * Gets a value from storage and returns it\n                                     *\n                                     * @param key The storage key\n                                     */\n                            abstract get<K extends StorageKey>(key: K): Promise<StorageKeyReturnType[K]>;\n                            /**\n                                     * Sets a value in the storage and persist it\n                                     *\n                                     * @param key The storage key\n                                     * @param value The value to be persisted\n                                     */\n                            abstract set<K extends StorageKey>(key: K, value: StorageKeyReturnType[K]): Promise<void>;\n                            /**\n                                     * Delete a key from storage\n                                     *\n                                     * @param key The storage key\n                                     */\n                            abstract delete<K extends StorageKey>(key: K): Promise<void>;\n            }\n    }\n    \n    declare module 'test/transports/clients/CommunicationClient' {\n            import * as sodium from 'libsodium-wrappers';\n            import { P2PPairingRequest } from 'test/';\n            import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n            import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n            import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n            export abstract class CommunicationClient {\n                            protected readonly keyPair: sodium.KeyPair;\n                            constructor(keyPair: sodium.KeyPair);\n                            /**\n                                     * Get the public key\n                                     */\n                            getPublicKey(): Promise<string>;\n                            /**\n                                     * get the public key hash\n                                     */\n                            getPublicKeyHash(): Promise<string>;\n                            /**\n                                     * Create a cryptobox shared key\n                                     *\n                                     * @param otherPublicKey\n                                     * @param selfPrivateKey\n                                     */\n                            protected createCryptoBox(otherPublicKey: string, selfPrivateKey: Uint8Array): Promise<[Uint8Array, Uint8Array, Uint8Array]>;\n                            /**\n                                     * Create a cryptobox server\n                                     *\n                                     * @param otherPublicKey\n                                     * @param selfPrivateKey\n                                     */\n                            protected createCryptoBoxServer(otherPublicKey: string, selfPrivateKey: Uint8Array): Promise<sodium.CryptoKX>;\n                            /**\n                                     * Create a cryptobox client\n                                     *\n                                     * @param otherPublicKey\n                                     * @param selfPrivateKey\n                                     */\n                            protected createCryptoBoxClient(otherPublicKey: string, selfPrivateKey: Uint8Array): Promise<sodium.CryptoKX>;\n                            /**\n                                     * Encrypt a message for a specific publicKey (receiver, asymmetric)\n                                     *\n                                     * @param recipientPublicKey\n                                     * @param message\n                                     */\n                            protected encryptMessageAsymmetric(recipientPublicKey: string, message: string): Promise<string>;\n                            abstract unsubscribeFromEncryptedMessages(): Promise<void>;\n                            abstract unsubscribeFromEncryptedMessage(senderPublicKey: string): Promise<void>;\n                            abstract sendMessage(message: string, peer?: P2PPairingRequest | ExtendedP2PPairingResponse | PostMessagePairingRequest | ExtendedPostMessagePairingResponse): Promise<void>;\n            }\n    }\n    \n    declare module 'test/transports/clients/MessageBasedClient' {\n            import * as sodium from 'libsodium-wrappers';\n            import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n            import { PostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n            import { CommunicationClient } from 'test/transports/clients/CommunicationClient';\n            export abstract class MessageBasedClient extends CommunicationClient {\n                            protected readonly name: string;\n                            /**\n                                     * The listeners that will be notified of new messages\n                                     */\n                            protected abstract readonly activeListeners: Map<string, unknown>;\n                            constructor(name: string, keyPair: sodium.KeyPair);\n                            /**\n                                     * start the client and make sure all dependencies are ready\n                                     */\n                            start(): Promise<void>;\n                            /**\n                                     * Get the pairing request information. This will be shared with the peer during the connection setup\n                                     */\n                            getPairingRequestInfo(): Promise<PostMessagePairingRequest>;\n                            /**\n                                     * Get the pairing response information. This will be shared with the peer during the connection setup\n                                     */\n                            getPairingResponseInfo(request: PostMessagePairingRequest): Promise<PostMessagePairingResponse>;\n                            /**\n                                     * Unsubscribe from encrypted messages from a specific peer\n                                     *\n                                     * @param senderPublicKey\n                                     */\n                            unsubscribeFromEncryptedMessage(senderPublicKey: string): Promise<void>;\n                            /**\n                                     * Unsubscribe from all encrypted messages\n                                     */\n                            unsubscribeFromEncryptedMessages(): Promise<void>;\n                            /**\n                                     * Decrypt a message from a specific peer\n                                     *\n                                     * @param senderPublicKey\n                                     * @param payload\n                                     */\n                            protected decryptMessage(senderPublicKey: string, payload: string): Promise<string>;\n                            /**\n                                     * Encrypt a message for a specific publicKey (receiver)\n                                     *\n                                     * @param recipientPublicKey\n                                     * @param message\n                                     */\n                            protected encryptMessage(recipientPublicKey: string, message: string): Promise<string>;\n                            /**\n                                     * Initialize the connection\n                                     */\n                            abstract init(): Promise<void>;\n            }\n    }\n    \n    declare module 'test/transports/clients/P2PCommunicationClient' {\n            import * as sodium from 'libsodium-wrappers';\n            import { MatrixClientEvent, MatrixClientEventType, MatrixClientEventMessageContent } from 'test/matrix-client/models/MatrixClientEvent';\n            import { Storage } from 'test/storage/Storage';\n            import { P2PPairingRequest } from 'test/';\n            import { ExtendedP2PPairingResponse, P2PPairingResponse } from 'test/types/P2PPairingResponse';\n            import { CommunicationClient } from 'test/transports/clients/CommunicationClient';\n            export class P2PCommunicationClient extends CommunicationClient {\n                    readonly replicationCount: number;\n                    constructor(name: string, keyPair: sodium.KeyPair, replicationCount: number, storage: Storage, matrixNodes: string[], iconUrl?: string | undefined, appUrl?: string | undefined);\n                    getPairingRequestInfo(): Promise<P2PPairingRequest>;\n                    getPairingResponseInfo(request: P2PPairingRequest): Promise<P2PPairingResponse>;\n                    getRelayServer(publicKeyHash?: string, nonce?: string): Promise<string>;\n                    start(): Promise<void>;\n                    listenForEncryptedMessage(senderPublicKey: string, messageCallback: (message: string) => void): Promise<void>;\n                    unsubscribeFromEncryptedMessage(senderPublicKey: string): Promise<void>;\n                    unsubscribeFromEncryptedMessages(): Promise<void>;\n                    sendMessage(message: string, peer: P2PPairingRequest | ExtendedP2PPairingResponse): Promise<void>;\n                    deleteRoomIdFromRooms(roomId: string): Promise<void>;\n                    listenForChannelOpening(messageCallback: (pairingResponse: ExtendedP2PPairingResponse) => void): Promise<void>;\n                    sendPairingResponse(pairingRequest: P2PPairingRequest): Promise<void>;\n                    isTextMessage(content: MatrixClientEventMessageContent<any>): content is MatrixClientEventMessageContent<string>;\n                    isChannelOpenMessage(content: MatrixClientEventMessageContent<string>): Promise<boolean>;\n                    isSender(event: MatrixClientEvent<MatrixClientEventType.MESSAGE>, senderPublicKey: string): Promise<boolean>;\n            }\n    }\n    \n    declare module 'test/transports/clients/PostMessageClient' {\n            import { ConnectionContext } from 'test/';\n            import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n            import { EncryptedExtensionMessage } from 'test/types/ExtensionMessage';\n            import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n            import { MessageBasedClient } from 'test/transports/clients/MessageBasedClient';\n            export class PostMessageClient extends MessageBasedClient {\n                    protected readonly activeListeners: Map<string, (message: EncryptedExtensionMessage, context: ConnectionContext) => void>;\n                    init(): Promise<void>;\n                    listenForEncryptedMessage(senderPublicKey: string, messageCallback: (message: string, context: ConnectionContext) => void): Promise<void>;\n                    sendMessage(message: string, peer: PostMessagePairingRequest | ExtendedPostMessagePairingResponse): Promise<void>;\n                    listenForChannelOpening(messageCallback: (pairingResponse: ExtendedPostMessagePairingResponse) => void): Promise<void>;\n                    sendPairingRequest(id: string): Promise<void>;\n                    isChannelOpenMessage(message: any): Promise<boolean>;\n            }\n    }\n    \n    declare module 'test/transports/DappP2PTransport' {\n            import * as sodium from 'libsodium-wrappers';\n            import { Storage, StorageKey, P2PTransport } from 'test/';\n            import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n            export class DappP2PTransport extends P2PTransport<ExtendedP2PPairingResponse, StorageKey.TRANSPORT_P2P_PEERS_DAPP> {\n                    constructor(name: string, keyPair: sodium.KeyPair, storage: Storage, matrixNodes: string[], iconUrl?: string, appUrl?: string);\n                    startOpenChannelListener(): Promise<void>;\n                    listenForNewPeer(newPeerListener: (peer: ExtendedP2PPairingResponse) => void): Promise<void>;\n                    stopListeningForNewPeers(): Promise<void>;\n            }\n    }\n    \n    declare module 'test/transports/DappPostMessageTransport' {\n            import * as sodium from 'libsodium-wrappers';\n            import { StorageKey, PostMessageTransport, Storage } from 'test/';\n            import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n            export class DappPostMessageTransport extends PostMessageTransport<ExtendedPostMessagePairingResponse, StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP> {\n                    constructor(name: string, keyPair: sodium.KeyPair, storage: Storage);\n                    startOpenChannelListener(): Promise<void>;\n                    listenForNewPeer(newPeerListener: (peer: ExtendedPostMessagePairingResponse) => void): Promise<void>;\n                    stopListeningForNewPeers(): Promise<void>;\n            }\n    }\n    \n    declare module 'test/transports/P2PTransport' {\n            import * as sodium from 'libsodium-wrappers';\n            import { Storage, StorageKey, Transport, TransportType, P2PCommunicationClient, P2PPairingRequest } from 'test/';\n            import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n            export class P2PTransport<T extends P2PPairingRequest | ExtendedP2PPairingResponse, K extends StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET> extends Transport<T, K, P2PCommunicationClient> {\n                    readonly type: TransportType;\n                    constructor(name: string, keyPair: sodium.KeyPair, storage: Storage, matrixNodes: string[], storageKey: K, iconUrl?: string, appUrl?: string);\n                    static isAvailable(): Promise<boolean>;\n                    connect(): Promise<void>;\n                    startOpenChannelListener(): Promise<void>;\n                    getPairingRequestInfo(): Promise<P2PPairingRequest>;\n                    listen(publicKey: string): Promise<void>;\n            }\n    }\n    \n    declare module 'test/transports/PostMessageTransport' {\n            import * as sodium from 'libsodium-wrappers';\n            import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n            import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n            import { Extension } from 'test/types/Extension';\n            import { StorageKey } from 'test/types/storage/StorageKey';\n            import { TransportType } from 'test/types/transport/TransportType';\n            import { Storage } from 'test/storage/Storage';\n            import { PostMessageClient } from 'test/transports/clients/PostMessageClient';\n            import { Transport } from 'test/transports/Transport';\n            export class PostMessageTransport<T extends PostMessagePairingRequest | ExtendedPostMessagePairingResponse, K extends StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET> extends Transport<T, K, PostMessageClient> {\n                    readonly type: TransportType;\n                    constructor(name: string, keyPair: sodium.KeyPair, storage: Storage, storageKey: K);\n                    static isAvailable(): Promise<boolean>;\n                    static getAvailableExtensions(): Promise<Extension[]>;\n                    connect(): Promise<void>;\n                    startOpenChannelListener(): Promise<void>;\n                    getPairingRequestInfo(): Promise<PostMessagePairingRequest>;\n                    listen(publicKey: string): Promise<void>;\n            }\n    }\n    \n    declare module 'test/transports/Transport' {\n            import { ConnectionContext } from 'test/types/ConnectionContext';\n            import { TransportType, TransportStatus, PeerInfo, StorageKey } from 'test/';\n            import { PeerManager } from 'test/managers/PeerManager';\n            import { CommunicationClient } from 'test/transports/clients/CommunicationClient';\n            export abstract class Transport<T extends PeerInfo = PeerInfo, K extends StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET = any, S extends CommunicationClient = any> {\n                            /**\n                                     * The type of the transport\n                                     */\n                            readonly type: TransportType;\n                            /**\n                                     * The name of the app\n                                     */\n                            protected readonly name: string;\n                            /**\n                                     * The status of the transport\n                                     */\n                            protected _isConnected: TransportStatus;\n                            protected readonly peerManager: PeerManager<K>;\n                            /**\n                                     * The client handling the encryption/decryption of messages\n                                     */\n                            protected client: S;\n                            /**\n                                     * The listener that will be invoked when a new peer is connected\n                                     */\n                            protected newPeerListener?: (peer: T) => void;\n                            /**\n                                     * Return the status of the connection\n                                     */\n                            get connectionStatus(): TransportStatus;\n                            constructor(name: string, client: S, peerManager: PeerManager<K>);\n                            /**\n                                     * Returns a promise that resolves to true if the transport is available, false if it is not\n                                     */\n                            static isAvailable(): Promise<boolean>;\n                            /**\n                                     * Connect the transport\n                                     */\n                            connect(): Promise<void>;\n                            /**\n                                     * Send a message through the transport\n                                     *\n                                     * @param message The message to send\n                                     * @param recipient The recipient of the message\n                                     */\n                            send(message: string, peer?: PeerInfo): Promise<void>;\n                            /**\n                                     * Add a listener to be called when a new message is received\n                                     *\n                                     * @param listener The listener that will be registered\n                                     */\n                            addListener(listener: (message: unknown, connectionInfo: ConnectionContext) => void): Promise<void>;\n                            /**\n                                     * Remove a listener\n                                     *\n                                     * @param listener\n                                     */\n                            removeListener(listener: (message: string, connectionInfo: ConnectionContext) => void): Promise<void>;\n                            getPeers(): Promise<T[]>;\n                            addPeer(newPeer: T): Promise<void>;\n                            removePeer(peerToBeRemoved: T): Promise<void>;\n                            removeAllPeers(): Promise<void>;\n                            /**\n                                     * Notify the listeners when a new message comes in\n                                     *\n                                     * @param message Message\n                                     * @param connectionInfo Context info about the connection\n                                     */\n                            protected notifyListeners(message: unknown, connectionInfo: ConnectionContext): Promise<void>;\n                            abstract listen(publicKey: string): Promise<void>;\n            }\n    }\n    \n    declare module 'test/transports/WalletP2PTransport' {\n            import * as sodium from 'libsodium-wrappers';\n            import { Storage, StorageKey, P2PTransport, P2PPairingRequest } from 'test/';\n            export class WalletP2PTransport extends P2PTransport<P2PPairingRequest, StorageKey.TRANSPORT_P2P_PEERS_WALLET> {\n                    constructor(name: string, keyPair: sodium.KeyPair, storage: Storage, matrixNodes: string[], iconUrl?: string, appUrl?: string);\n                    addPeer(newPeer: P2PPairingRequest): Promise<void>;\n            }\n    }\n    \n    declare module 'test/transports/WalletPostMessageTransport' {\n            import * as sodium from 'libsodium-wrappers';\n            import { StorageKey, PostMessageTransport, Storage } from 'test/';\n            import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n            export class WalletPostMessageTransport extends PostMessageTransport<PostMessagePairingRequest, StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET> {\n                    constructor(name: string, keyPair: sodium.KeyPair, storage: Storage);\n            }\n    }\n    \n    declare module 'test/types/AccountInfo' {\n            import { Origin } from 'test/';\n            import { PermissionEntity } from 'test/types/PermissionEntity';\n            export type AccountIdentifier = string;\n            export interface AccountInfo extends PermissionEntity {\n                    accountIdentifier: AccountIdentifier;\n                    senderId: string;\n                    origin: {\n                            type: Origin;\n                            id: string;\n                    };\n                    publicKey: string;\n                    connectedAt: number;\n            }\n    }\n    \n    declare module 'test/types/beacon/AppMetadata' {\n            export interface AppMetadata {\n                    senderId: string;\n                    name: string;\n                    icon?: string;\n            }\n    }\n    \n    declare module 'test/types/beacon/BeaconBaseMessage' {\n            import { BeaconMessageType } from 'test/';\n            export interface BeaconBaseMessage {\n                    type: BeaconMessageType;\n                    version: string;\n                    id: string;\n                    senderId: string;\n            }\n    }\n    \n    declare module 'test/types/beacon/BeaconMessage' {\n            import { PermissionResponse, PermissionRequest, OperationRequest, OperationResponse, SignPayloadRequest, SignPayloadResponse, BroadcastRequest, BroadcastResponse, AcknowledgeResponse, DisconnectMessage, ErrorResponse } from 'test/';\n            export type BeaconMessage = PermissionRequest | PermissionResponse | OperationRequest | OperationResponse | SignPayloadRequest | SignPayloadResponse | BroadcastRequest | BroadcastResponse | AcknowledgeResponse | DisconnectMessage | ErrorResponse;\n    }\n    \n    declare module 'test/types/beacon/BeaconMessageType' {\n            export enum BeaconMessageType {\n                    PermissionRequest = \"permission_request\",\n                    SignPayloadRequest = \"sign_payload_request\",\n                    OperationRequest = \"operation_request\",\n                    BroadcastRequest = \"broadcast_request\",\n                    PermissionResponse = \"permission_response\",\n                    SignPayloadResponse = \"sign_payload_response\",\n                    OperationResponse = \"operation_response\",\n                    BroadcastResponse = \"broadcast_response\",\n                    Acknowledge = \"acknowledge\",\n                    Disconnect = \"disconnect\",\n                    Error = \"error\"\n            }\n    }\n    \n    declare module 'test/types/beacon/BeaconRequestMessage' {\n            import { PermissionRequest, OperationRequest, SignPayloadRequest, BroadcastRequest } from 'test/';\n            export type BeaconRequestMessage = PermissionRequest | OperationRequest | SignPayloadRequest | BroadcastRequest;\n    }\n    \n    declare module 'test/types/beacon/BeaconResponseMessage' {\n            import { PermissionResponse, OperationResponse, SignPayloadResponse, BroadcastResponse } from 'test/';\n            import { ErrorResponse } from 'test/types/beacon/messages/ErrorResponse';\n            export type BeaconResponseMessage = PermissionResponse | OperationResponse | SignPayloadResponse | BroadcastResponse | ErrorResponse;\n    }\n    \n    declare module 'test/types/beacon/messages/AcknowledgeResponse' {\n            import { BeaconBaseMessage, BeaconMessageType } from 'test/';\n            export interface AcknowledgeResponse extends BeaconBaseMessage {\n                    type: BeaconMessageType.Acknowledge;\n            }\n    }\n    \n    declare module 'test/types/beacon/messages/BeaconRequestInputMessage' {\n            import { PermissionRequest, OperationRequest, SignPayloadRequest, BroadcastRequest } from 'test/';\n            export type IgnoredRequestInputProperties = 'id' | 'senderId' | 'version';\n            export type PermissionRequestInput = Omit<PermissionRequest, IgnoredRequestInputProperties>;\n            export type OperationRequestInput = Omit<OperationRequest, IgnoredRequestInputProperties>;\n            export type SignPayloadRequestInput = Omit<SignPayloadRequest, IgnoredRequestInputProperties>;\n            export type BroadcastRequestInput = Omit<BroadcastRequest, IgnoredRequestInputProperties>;\n            export type BeaconRequestInputMessage = PermissionRequestInput | OperationRequestInput | SignPayloadRequestInput | BroadcastRequestInput;\n    }\n    \n    declare module 'test/types/beacon/messages/BeaconRequestOutputMessage' {\n            import { AppMetadata, PermissionRequest, OperationRequest, SignPayloadRequest, BroadcastRequest } from 'test/';\n            export type IgnoredRequestOutputProperties = 'version';\n            export interface ExtraResponseOutputProperties {\n                    appMetadata: AppMetadata;\n            }\n            export type PermissionRequestOutput = Omit<PermissionRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n            export type OperationRequestOutput = Omit<OperationRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n            export type SignPayloadRequestOutput = Omit<SignPayloadRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n            export type BroadcastRequestOutput = Omit<BroadcastRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n            export type BeaconRequestOutputMessage = PermissionRequestOutput | OperationRequestOutput | SignPayloadRequestOutput | BroadcastRequestOutput;\n    }\n    \n    declare module 'test/types/beacon/messages/BeaconResponseInputMessage' {\n            import { PermissionResponse, OperationResponse, SignPayloadResponse, BroadcastResponse, AcknowledgeResponse, ErrorResponse } from 'test/';\n            export type IgnoredResponseInputProperties = 'senderId' | 'version' | 'appMetadata';\n            export type PermissionResponseInput = Omit<PermissionResponse, IgnoredResponseInputProperties>;\n            export type OperationResponseInput = Omit<OperationResponse, IgnoredResponseInputProperties>;\n            export type SignPayloadResponseInput = Omit<SignPayloadResponse, IgnoredResponseInputProperties>;\n            export type BroadcastResponseInput = Omit<BroadcastResponse, IgnoredResponseInputProperties>;\n            export type AcknowledgeResponseInput = Omit<AcknowledgeResponse, IgnoredResponseInputProperties>;\n            export type ErrorResponseInput = Omit<ErrorResponse, IgnoredResponseInputProperties>;\n            export type BeaconResponseInputMessage = PermissionResponseInput | OperationResponseInput | SignPayloadResponseInput | BroadcastResponseInput | AcknowledgeResponseInput | ErrorResponseInput;\n    }\n    \n    declare module 'test/types/beacon/messages/BeaconResponseOutputMessage' {\n            import { PermissionResponse, OperationResponse, SignPayloadResponse, BroadcastResponse, AccountInfo } from 'test/';\n            export type IgnoredResponseOutputProperties = 'id' | 'version' | 'type';\n            export type PermissionResponseOutput = PermissionResponse & {\n                    address: string;\n                    accountInfo: AccountInfo;\n            };\n            export type OperationResponseOutput = OperationResponse;\n            export type SignPayloadResponseOutput = SignPayloadResponse;\n            export type BroadcastResponseOutput = BroadcastResponse;\n            export type BeaconResponseOutputMessage = PermissionResponseOutput | OperationResponseOutput | SignPayloadResponseOutput | BroadcastResponseOutput;\n    }\n    \n    declare module 'test/types/beacon/messages/BroadcastRequest' {\n            import { BeaconBaseMessage, BeaconMessageType, Network } from 'test/';\n            export interface BroadcastRequest extends BeaconBaseMessage {\n                    type: BeaconMessageType.BroadcastRequest;\n                    network: Network;\n                    signedTransaction: string;\n            }\n    }\n    \n    declare module 'test/types/beacon/messages/BroadcastResponse' {\n            import { BeaconBaseMessage, BeaconMessageType } from 'test/';\n            export interface BroadcastResponse extends BeaconBaseMessage {\n                    type: BeaconMessageType.BroadcastResponse;\n                    transactionHash: string;\n            }\n    }\n    \n    declare module 'test/types/beacon/messages/DisconnectMessage' {\n            import { BeaconBaseMessage, BeaconMessageType } from 'test/';\n            export interface DisconnectMessage extends BeaconBaseMessage {\n                    type: BeaconMessageType.Disconnect;\n            }\n    }\n    \n    declare module 'test/types/beacon/messages/ErrorResponse' {\n            import { BeaconBaseMessage, BeaconErrorType, BeaconMessageType } from 'test/';\n            export interface ErrorResponse extends BeaconBaseMessage {\n                    type: BeaconMessageType.Error;\n                    errorType: BeaconErrorType;\n                    errorData?: any;\n            }\n    }\n    \n    declare module 'test/types/beacon/messages/OperationRequest' {\n            import { BeaconBaseMessage, BeaconMessageType, Network } from 'test/';\n            import { PartialTezosOperation } from 'test/types/tezos/PartialTezosOperation';\n            export interface OperationRequest extends BeaconBaseMessage {\n                    type: BeaconMessageType.OperationRequest;\n                    network: Network;\n                    operationDetails: PartialTezosOperation[];\n                    sourceAddress: string;\n            }\n    }\n    \n    declare module 'test/types/beacon/messages/OperationResponse' {\n            import { BeaconBaseMessage, BeaconMessageType } from 'test/';\n            export interface OperationResponse extends BeaconBaseMessage {\n                    type: BeaconMessageType.OperationResponse;\n                    transactionHash: string;\n            }\n    }\n    \n    declare module 'test/types/beacon/messages/PermissionRequest' {\n            import { BeaconBaseMessage, BeaconMessageType, PermissionScope, AppMetadata, Network } from 'test/';\n            export interface PermissionRequest extends BeaconBaseMessage {\n                    type: BeaconMessageType.PermissionRequest;\n                    appMetadata: AppMetadata;\n                    network: Network;\n                    scopes: PermissionScope[];\n            }\n    }\n    \n    declare module 'test/types/beacon/messages/PermissionResponse' {\n            import { AppMetadata, BeaconBaseMessage, BeaconMessageType, Network, PermissionScope, Threshold } from 'test/';\n            export interface PermissionResponse extends BeaconBaseMessage {\n                    type: BeaconMessageType.PermissionResponse;\n                    appMetadata: AppMetadata;\n                    publicKey: string;\n                    network: Network;\n                    scopes: PermissionScope[];\n                    threshold?: Threshold;\n            }\n    }\n    \n    declare module 'test/types/beacon/messages/SignPayloadRequest' {\n            import { BeaconBaseMessage, BeaconMessageType, SigningType } from 'test/';\n            export interface SignPayloadRequest extends BeaconBaseMessage {\n                    type: BeaconMessageType.SignPayloadRequest;\n                    signingType: SigningType;\n                    payload: string;\n                    sourceAddress: string;\n            }\n    }\n    \n    declare module 'test/types/beacon/messages/SignPayloadResponse' {\n            import { BeaconBaseMessage, BeaconMessageType, SigningType } from 'test/';\n            export interface SignPayloadResponse extends BeaconBaseMessage {\n                    type: BeaconMessageType.SignPayloadResponse;\n                    signingType: SigningType;\n                    signature: string;\n            }\n    }\n    \n    declare module 'test/types/beacon/Network' {\n            import { NetworkType } from 'test/';\n            export interface Network {\n                    type: NetworkType;\n                    name?: string;\n                    rpcUrl?: string;\n            }\n    }\n    \n    declare module 'test/types/beacon/NetworkType' {\n            export enum NetworkType {\n                    MAINNET = \"mainnet\",\n                    DELPHINET = \"delphinet\",\n                    EDONET = \"edonet\",\n                    CUSTOM = \"custom\"\n            }\n    }\n    \n    declare module 'test/types/beacon/PermissionScope' {\n            export enum PermissionScope {\n                    SIGN = \"sign\",\n                    OPERATION_REQUEST = \"operation_request\",\n                    THRESHOLD = \"threshold\"\n            }\n    }\n    \n    declare module 'test/types/beacon/SigningType' {\n            export enum SigningType {\n                    RAW = \"raw\",\n                    OPERATION = \"operation\",\n                    MICHELINE = \"micheline\"\n            }\n    }\n    \n    declare module 'test/types/beacon/Threshold' {\n            export interface Threshold {\n                    amount: string;\n                    timeframe: string;\n            }\n    }\n    \n    declare module 'test/types/BeaconErrorType' {\n            export enum BeaconErrorType {\n                    BROADCAST_ERROR = \"BROADCAST_ERROR\",\n                    NETWORK_NOT_SUPPORTED = \"NETWORK_NOT_SUPPORTED\",\n                    NO_ADDRESS_ERROR = \"NO_ADDRESS_ERROR\",\n                    NO_PRIVATE_KEY_FOUND_ERROR = \"NO_PRIVATE_KEY_FOUND_ERROR\",\n                    NOT_GRANTED_ERROR = \"NOT_GRANTED_ERROR\",\n                    PARAMETERS_INVALID_ERROR = \"PARAMETERS_INVALID_ERROR\",\n                    TOO_MANY_OPERATIONS = \"TOO_MANY_OPERATIONS\",\n                    TRANSACTION_INVALID_ERROR = \"TRANSACTION_INVALID_ERROR\",\n                    SIGNATURE_TYPE_NOT_SUPPORTED = \"SIGNATURE_TYPE_NOT_SUPPORTED\",\n                    ABORTED_ERROR = \"ABORTED_ERROR\",\n                    UNKNOWN_ERROR = \"UNKNOWN_ERROR\"\n            }\n    }\n    \n    declare module 'test/types/ColorMode' {\n            export enum ColorMode {\n                    LIGHT = \"light\",\n                    DARK = \"dark\"\n            }\n    }\n    \n    declare module 'test/types/ConnectionContext' {\n            import { Origin } from 'test/';\n            export interface ConnectionContext {\n                    origin: Origin;\n                    id: string;\n                    extras?: {\n                            sender: chrome.runtime.MessageSender;\n                            sendResponse(response?: unknown): void;\n                    };\n            }\n    }\n    \n    declare module 'test/types/Extension' {\n            export interface Extension {\n                    id: string;\n                    name: string;\n                    shortName?: string;\n                    iconUrl?: string;\n                    color?: string;\n            }\n    }\n    \n    declare module 'test/types/ExtensionMessage' {\n            import { ExtensionMessageTarget } from 'test/';\n            export interface ExtensionMessage<T, U = unknown> {\n                    target: ExtensionMessageTarget;\n                    targetId?: string;\n                    sender?: U;\n                    payload: T;\n            }\n            export interface EncryptedExtensionMessage<U = unknown> {\n                    target: ExtensionMessageTarget;\n                    targetId?: string;\n                    sender?: U;\n                    encryptedPayload: string;\n            }\n    }\n    \n    declare module 'test/types/ExtensionMessageTarget' {\n            export enum ExtensionMessageTarget {\n                    BACKGROUND = \"toBackground\",\n                    PAGE = \"toPage\",\n                    EXTENSION = \"toExtension\"\n            }\n    }\n    \n    declare module 'test/types/Origin' {\n            export enum Origin {\n                    WEBSITE = \"website\",\n                    EXTENSION = \"extension\",\n                    P2P = \"p2p\"\n            }\n    }\n    \n    declare module 'test/types/P2PPairingRequest' {\n            import { PeerInfo } from 'test/types/PeerInfo';\n            export interface P2PPairingRequest extends PeerInfo {\n                    id: string;\n                    type: 'p2p-pairing-request';\n                    name: string;\n                    publicKey: string;\n                    relayServer: string;\n                    icon?: string;\n                    appUrl?: string;\n            }\n            export type ExtendedP2PPairingRequest = P2PPairingRequest & {\n                    senderId: string;\n            };\n    }\n    \n    declare module 'test/types/P2PPairingResponse' {\n            import { PeerInfo } from 'test/types/PeerInfo';\n            export interface P2PPairingResponse extends PeerInfo {\n                    id: string;\n                    type: 'p2p-pairing-response';\n                    name: string;\n                    publicKey: string;\n                    relayServer: string;\n                    icon?: string;\n                    appUrl?: string;\n            }\n            export type ExtendedP2PPairingResponse = P2PPairingResponse & {\n                    senderId: string;\n            };\n    }\n    \n    declare module 'test/types/PeerInfo' {\n            export interface PeerInfo {\n                    name: string;\n                    publicKey: string;\n                    version: string;\n            }\n            export type ExtendedPeerInfo = PeerInfo & {\n                    senderId: string;\n            };\n    }\n    \n    declare module 'test/types/PermissionEntity' {\n            import { Network, PermissionScope, Threshold } from 'test/';\n            export interface PermissionEntity {\n                    address: string;\n                    network: Network;\n                    scopes: PermissionScope[];\n                    threshold?: Threshold;\n            }\n    }\n    \n    declare module 'test/types/PermissionInfo' {\n            import { AppMetadata } from 'test/';\n            import { PermissionEntity } from 'test/types/PermissionEntity';\n            export interface PermissionInfo extends PermissionEntity {\n                    accountIdentifier: string;\n                    senderId: string;\n                    appMetadata: AppMetadata;\n                    website: string;\n                    publicKey: string;\n                    connectedAt: number;\n            }\n    }\n    \n    declare module 'test/types/PostMessagePairingRequest' {\n            import { PeerInfo } from 'test/types/PeerInfo';\n            export interface PostMessagePairingRequest extends PeerInfo {\n                    id: string;\n                    type: 'postmessage-pairing-request';\n                    name: string;\n                    publicKey: string;\n                    icon?: string;\n                    appUrl?: string;\n            }\n            export type ExtendedPostMessagePairingRequest = PostMessagePairingRequest & {\n                    senderId: string;\n            };\n    }\n    \n    declare module 'test/types/PostMessagePairingResponse' {\n            import { PeerInfo } from 'test/types/PeerInfo';\n            export interface PostMessagePairingResponse extends PeerInfo {\n                    id: string;\n                    type: 'postmessage-pairing-response';\n                    name: string;\n                    publicKey: string;\n                    icon?: string;\n                    appUrl?: string;\n            }\n            export type ExtendedPostMessagePairingResponse = PostMessagePairingResponse & {\n                    senderId: string;\n                    extensionId: string;\n            };\n    }\n    \n    declare module 'test/types/RequestBroadcastInput' {\n            import { Network } from 'test/';\n            export interface RequestBroadcastInput {\n                    network?: Network;\n                    signedTransaction: string;\n            }\n    }\n    \n    declare module 'test/types/RequestOperationInput' {\n            import { PartialTezosOperation } from 'test/types/tezos/PartialTezosOperation';\n            export interface RequestOperationInput {\n                    operationDetails: PartialTezosOperation[];\n            }\n    }\n    \n    declare module 'test/types/RequestPermissionInput' {\n            import { Network, PermissionScope } from 'test/';\n            export interface RequestPermissionInput {\n                    network?: Network;\n                    scopes?: PermissionScope[];\n            }\n    }\n    \n    declare module 'test/types/RequestSignPayloadInput' {\n            import { SigningType } from 'test/';\n            export interface RequestSignPayloadInput {\n                    signingType?: SigningType;\n                    payload: string;\n                    sourceAddress?: string;\n            }\n    }\n    \n    declare module 'test/types/storage/StorageKey' {\n            export enum StorageKey {\n                    TRANSPORT_P2P_PEERS_DAPP = \"beacon:communication-peers-dapp\",\n                    TRANSPORT_P2P_PEERS_WALLET = \"beacon:communication-peers-wallet\",\n                    TRANSPORT_POSTMESSAGE_PEERS_DAPP = \"beacon:postmessage-peers-dapp\",\n                    TRANSPORT_POSTMESSAGE_PEERS_WALLET = \"beacon:postmessage-peers-wallet\",\n                    ACCOUNTS = \"beacon:accounts\",\n                    ACTIVE_ACCOUNT = \"beacon:active-account\",\n                    ACTIVE_PEER = \"beacon:active-peer\",\n                    BEACON_SDK_SECRET_SEED = \"beacon:sdk-secret-seed\",\n                    APP_METADATA_LIST = \"beacon:app-metadata-list\",\n                    PERMISSION_LIST = \"beacon:permissions\",\n                    BEACON_SDK_VERSION = \"beacon:sdk_version\",\n                    MATRIX_PRESERVED_STATE = \"beacon:sdk-matrix-preserved-state\",\n                    MATRIX_PEER_ROOM_IDS = \"beacon:matrix-peer-rooms\"\n            }\n    }\n    \n    declare module 'test/types/storage/StorageKeyReturnDefaults' {\n            import { StorageKey, StorageKeyReturnType } from 'test/';\n            export type StorageKeyReturnDefaults = {\n                    [key in StorageKey]: StorageKeyReturnType[key];\n            };\n            export const defaultValues: StorageKeyReturnDefaults;\n    }\n    \n    declare module 'test/types/storage/StorageKeyReturnType' {\n            import { StorageKey, AccountInfo, AccountIdentifier, P2PPairingRequest, AppMetadata, PermissionInfo } from 'test/';\n            import { MatrixState } from 'test/matrix-client/MatrixClientStore';\n            import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n            import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n            import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n            export interface StorageKeyReturnType {\n                    [StorageKey.TRANSPORT_P2P_PEERS_DAPP]: P2PPairingRequest[];\n                    [StorageKey.TRANSPORT_P2P_PEERS_WALLET]: ExtendedP2PPairingResponse[];\n                    [StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP]: PostMessagePairingRequest[];\n                    [StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET]: ExtendedPostMessagePairingResponse[];\n                    [StorageKey.ACCOUNTS]: AccountInfo[];\n                    [StorageKey.ACTIVE_ACCOUNT]: AccountIdentifier | undefined;\n                    [StorageKey.ACTIVE_PEER]: string | undefined;\n                    [StorageKey.BEACON_SDK_SECRET_SEED]: string | undefined;\n                    [StorageKey.APP_METADATA_LIST]: AppMetadata[];\n                    [StorageKey.PERMISSION_LIST]: PermissionInfo[];\n                    [StorageKey.BEACON_SDK_VERSION]: string | undefined;\n                    [StorageKey.MATRIX_PRESERVED_STATE]: Partial<MatrixState>;\n                    [StorageKey.MATRIX_PEER_ROOM_IDS]: {\n                            [key: string]: string | undefined;\n                    };\n            }\n    }\n    \n    declare module 'test/types/tezos/MichelineMichelsonV1Expression' {\n            import { MichelsonPrimitives } from 'test/';\n            export type MichelineMichelsonV1Expression = {\n                    int: string;\n            } | {\n                    string: string;\n            } | {\n                    bytes: string;\n            } | MichelineMichelsonV1Expression[] | {\n                    prim: MichelsonPrimitives;\n                    args?: MichelineMichelsonV1Expression[];\n                    annots?: string[];\n            };\n    }\n    \n    declare module 'test/types/tezos/MichelsonPrimitives' {\n            export type MichelsonPrimitives = 'ADD' | 'IF_NONE' | 'SWAP' | 'set' | 'nat' | 'CHECK_SIGNATURE' | 'IF_LEFT' | 'LAMBDA' | 'Elt' | 'CREATE_CONTRACT' | 'NEG' | 'big_map' | 'map' | 'or' | 'BLAKE2B' | 'bytes' | 'SHA256' | 'SET_DELEGATE' | 'CONTRACT' | 'LSL' | 'SUB' | 'IMPLICIT_ACCOUNT' | 'PACK' | 'list' | 'PAIR' | 'Right' | 'contract' | 'GT' | 'LEFT' | 'STEPS_TO_QUOTA' | 'storage' | 'TRANSFER_TOKENS' | 'CDR' | 'SLICE' | 'PUSH' | 'False' | 'SHA512' | 'CHAIN_ID' | 'BALANCE' | 'signature' | 'DUG' | 'SELF' | 'EMPTY_BIG_MAP' | 'LSR' | 'OR' | 'XOR' | 'lambda' | 'COMPARE' | 'key' | 'option' | 'Unit' | 'Some' | 'UNPACK' | 'NEQ' | 'INT' | 'pair' | 'AMOUNT' | 'DIP' | 'ABS' | 'ISNAT' | 'EXEC' | 'NOW' | 'LOOP' | 'chain_id' | 'string' | 'MEM' | 'MAP' | 'None' | 'address' | 'CONCAT' | 'EMPTY_SET' | 'MUL' | 'LOOP_LEFT' | 'timestamp' | 'LT' | 'UPDATE' | 'DUP' | 'SOURCE' | 'mutez' | 'SENDER' | 'IF_CONS' | 'RIGHT' | 'CAR' | 'CONS' | 'LE' | 'NONE' | 'IF' | 'SOME' | 'GET' | 'Left' | 'CAST' | 'int' | 'SIZE' | 'key_hash' | 'unit' | 'DROP' | 'EMPTY_MAP' | 'NIL' | 'DIG' | 'APPLY' | 'bool' | 'RENAME' | 'operation' | 'True' | 'FAILWITH' | 'parameter' | 'HASH_KEY' | 'EQ' | 'NOT' | 'UNIT' | 'Pair' | 'ADDRESS' | 'EDIV' | 'CREATE_ACCOUNT' | 'GE' | 'ITER' | 'code' | 'AND';\n    }\n    \n    declare module 'test/types/tezos/operations/ActivateAccount' {\n            import { TezosBaseOperation, TezosOperationType } from 'test/';\n            export interface TezosActivateAccountOperation extends TezosBaseOperation {\n                    kind: TezosOperationType.ACTIVATE_ACCOUNT;\n                    pkh: string;\n                    secret: string;\n            }\n    }\n    \n    declare module 'test/types/tezos/operations/Ballot' {\n            import { TezosBaseOperation, TezosOperationType } from 'test/';\n            export interface TezosBallotOperation extends TezosBaseOperation {\n                    kind: TezosOperationType.BALLOT;\n                    source: string;\n                    period: string;\n                    proposal: string;\n                    ballot: 'nay' | 'yay' | 'pass';\n            }\n    }\n    \n    declare module 'test/types/tezos/operations/Delegation' {\n            import { TezosBaseOperation, TezosOperationType } from 'test/';\n            export interface TezosDelegationOperation extends TezosBaseOperation {\n                    kind: TezosOperationType.DELEGATION;\n                    source: string;\n                    fee: string;\n                    counter: string;\n                    gas_limit: string;\n                    storage_limit: string;\n                    delegate?: string;\n            }\n    }\n    \n    declare module 'test/types/tezos/operations/DoubleBakingEvidence' {\n            import { TezosBaseOperation, TezosOperationType, TezosBlockHeader } from 'test/';\n            export interface InlinedEndorsement {\n                    branch: string;\n                    operations: InlinedEndorsementContents;\n                    signature?: string;\n            }\n            export interface InlinedEndorsementContents {\n                    kind: 'endorsement';\n                    level: string;\n            }\n            export interface TezosDoubleBakingEvidenceOperation extends TezosBaseOperation {\n                    kind: TezosOperationType.DOUBLE_BAKING_EVIDENCE;\n                    bh1: TezosBlockHeader;\n                    bh2: TezosBlockHeader;\n            }\n    }\n    \n    declare module 'test/types/tezos/operations/DoubleEndorsementEvidence' {\n            import { TezosBaseOperation, TezosOperationType } from 'test/';\n            export interface InlinedEndorsement {\n                    branch: string;\n                    operations: InlinedEndorsementContents;\n                    signature?: string;\n            }\n            export interface InlinedEndorsementContents {\n                    kind: 'endorsement';\n                    level: string;\n            }\n            export interface TezosDoubleEndorsementEvidenceOperation extends TezosBaseOperation {\n                    kind: TezosOperationType.DOUBLE_ENDORSEMENT_EVIDENCE;\n                    op1: InlinedEndorsement;\n                    op2: InlinedEndorsement;\n            }\n    }\n    \n    declare module 'test/types/tezos/operations/Endorsement' {\n            import { TezosBaseOperation, TezosOperationType } from 'test/';\n            export interface TezosEndorsementOperation extends TezosBaseOperation {\n                    kind: TezosOperationType.ENDORSEMENT;\n                    level: string;\n            }\n    }\n    \n    declare module 'test/types/tezos/operations/Origination' {\n            import { TezosBaseOperation, TezosOperationType } from 'test/';\n            export interface TezosOriginationOperation extends TezosBaseOperation {\n                    kind: TezosOperationType.ORIGINATION;\n                    source: string;\n                    fee: string;\n                    counter: string;\n                    gas_limit: string;\n                    storage_limit: string;\n                    balance: string;\n                    delegate?: string;\n                    script: string;\n            }\n    }\n    \n    declare module 'test/types/tezos/operations/Proposal' {\n            import { TezosBaseOperation, TezosOperationType } from 'test/';\n            export interface TezosProposalOperation extends TezosBaseOperation {\n                    kind: TezosOperationType.PROPOSALS;\n                    period: string;\n                    proposals: string[];\n            }\n    }\n    \n    declare module 'test/types/tezos/operations/Reveal' {\n            import { TezosBaseOperation, TezosOperationType } from 'test/';\n            export interface TezosRevealOperation extends TezosBaseOperation {\n                    kind: TezosOperationType.REVEAL;\n                    source: string;\n                    fee: string;\n                    counter: string;\n                    gas_limit: string;\n                    storage_limit: string;\n                    public_key: string;\n            }\n    }\n    \n    declare module 'test/types/tezos/operations/SeedNonceRevelation' {\n            import { TezosBaseOperation, TezosOperationType } from 'test/';\n            export interface TezosSeedNonceRevelationOperation extends TezosBaseOperation {\n                    kind: TezosOperationType.SEED_NONCE_REVELATION;\n                    level: string;\n                    nonce: string;\n            }\n    }\n    \n    declare module 'test/types/tezos/operations/Transaction' {\n            import { TezosBaseOperation, TezosOperationType, TezosTransactionParameters } from 'test/';\n            export interface TezosTransactionOperation extends TezosBaseOperation {\n                    kind: TezosOperationType.TRANSACTION;\n                    source: string;\n                    fee: string;\n                    counter: string;\n                    gas_limit: string;\n                    storage_limit: string;\n                    amount: string;\n                    destination: string;\n                    parameters?: TezosTransactionParameters;\n            }\n    }\n    \n    declare module 'test/types/tezos/OperationTypes' {\n            export enum TezosOperationType {\n                    ENDORSEMENT = \"endorsement\",\n                    SEED_NONCE_REVELATION = \"seed_nonce_revelation\",\n                    DOUBLE_ENDORSEMENT_EVIDENCE = \"double_endorsement_evidence\",\n                    DOUBLE_BAKING_EVIDENCE = \"double_baking_evidence\",\n                    ACTIVATE_ACCOUNT = \"activate_account\",\n                    PROPOSALS = \"proposals\",\n                    BALLOT = \"ballot\",\n                    REVEAL = \"reveal\",\n                    TRANSACTION = \"transaction\",\n                    ORIGINATION = \"origination\",\n                    DELEGATION = \"delegation\"\n            }\n    }\n    \n    declare module 'test/types/tezos/PartialTezosOperation' {\n            import { TezosActivateAccountOperation } from 'test/types/tezos/operations/ActivateAccount';\n            import { TezosBallotOperation } from 'test/types/tezos/operations/Ballot';\n            import { TezosDelegationOperation } from 'test/types/tezos/operations/Delegation';\n            import { TezosDoubleBakingEvidenceOperation } from 'test/types/tezos/operations/DoubleBakingEvidence';\n            import { TezosEndorsementOperation } from 'test/types/tezos/operations/Endorsement';\n            import { TezosOriginationOperation } from 'test/types/tezos/operations/Origination';\n            import { TezosProposalOperation } from 'test/types/tezos/operations/Proposal';\n            import { TezosRevealOperation } from 'test/types/tezos/operations/Reveal';\n            import { TezosSeedNonceRevelationOperation } from 'test/types/tezos/operations/SeedNonceRevelation';\n            import { TezosTransactionOperation } from 'test/types/tezos/operations/Transaction';\n            type omittedProperties = 'source' | 'fee' | 'counter' | 'gas_limit' | 'storage_limit';\n            export type PartialTezosDelegationOperation = Omit<TezosDelegationOperation, omittedProperties>;\n            export type PartialTezosOriginationOperation = Omit<TezosOriginationOperation, omittedProperties>;\n            export type PartialTezosRevealOperation = Omit<TezosRevealOperation, omittedProperties>;\n            export type PartialTezosTransactionOperation = Omit<TezosTransactionOperation, omittedProperties>;\n            export type PartialTezosOperation = TezosActivateAccountOperation | TezosBallotOperation | PartialTezosDelegationOperation | TezosDoubleBakingEvidenceOperation | TezosEndorsementOperation | PartialTezosOriginationOperation | TezosProposalOperation | PartialTezosRevealOperation | TezosSeedNonceRevelationOperation | PartialTezosTransactionOperation;\n            export {};\n    }\n    \n    declare module 'test/types/tezos/TezosBaseOperation' {\n            import { TezosOperationType } from 'test/';\n            export interface TezosBaseOperation {\n                    kind: TezosOperationType;\n            }\n    }\n    \n    declare module 'test/types/tezos/TezosBlockHeader' {\n            export interface TezosBlockHeader {\n                    level: number;\n                    proto: number;\n                    predecessor: string;\n                    timestamp: string;\n                    validation_pass: number;\n                    operations_hash: string;\n                    fitness: string[];\n                    context: string;\n                    priority: number;\n                    proof_of_work_nonce: string;\n                    signature: string;\n            }\n    }\n    \n    declare module 'test/types/tezos/TezosOperation' {\n            import { TezosActivateAccountOperation, TezosBallotOperation, TezosDelegationOperation, TezosDoubleBakingEvidenceOperation, TezosEndorsementOperation, TezosOriginationOperation, TezosProposalOperation, TezosRevealOperation, TezosSeedNonceRevelationOperation, TezosTransactionOperation } from 'test/';\n            export type TezosOperation = TezosActivateAccountOperation | TezosBallotOperation | TezosDelegationOperation | TezosDoubleBakingEvidenceOperation | TezosEndorsementOperation | TezosOriginationOperation | TezosProposalOperation | TezosRevealOperation | TezosSeedNonceRevelationOperation | TezosTransactionOperation;\n    }\n    \n    declare module 'test/types/tezos/TezosTransactionParameters' {\n            import { MichelineMichelsonV1Expression } from 'test/types/tezos/MichelineMichelsonV1Expression';\n            export interface TezosTransactionParameters {\n                    entrypoint: 'default' | 'root' | 'do' | 'set_delegate' | 'remove_delegate' | string;\n                    value: MichelineMichelsonV1Expression;\n            }\n    }\n    \n    declare module 'test/types/transport/TransportStatus' {\n            export enum TransportStatus {\n                    NOT_CONNECTED = \"NOT_CONNECTED\",\n                    CONNECTING = \"CONNECTING\",\n                    CONNECTED = \"CONNECTED\"\n            }\n    }\n    \n    declare module 'test/types/transport/TransportType' {\n            export enum TransportType {\n                    CHROME_MESSAGE = \"chrome_message\",\n                    POST_MESSAGE = \"post_message\",\n                    LEDGER = \"ledger\",\n                    P2P = \"p2p\"\n            }\n    }\n    \n    declare module 'test/ui/alert/alert-templates' {\n            export const alertTemplates: {\n                    container: string;\n                    default: {\n                            html: string;\n                            css: string;\n                    };\n                    pair: {\n                            html: string;\n                            css: string;\n                    };\n            };\n    }\n    \n    declare module 'test/ui/alert/Alert' {\n            import { NetworkType } from 'test/';\n            export interface AlertButton {\n                            text: string;\n                            style?: 'solid' | 'outline';\n                            actionCallback?(): Promise<void>;\n            }\n            export interface AlertConfig {\n                            title: string;\n                            body?: string;\n                            timer?: number;\n                            buttons?: AlertButton[];\n                            pairingPayload?: {\n                                            p2pSyncCode: string;\n                                            postmessageSyncCode: string;\n                                            preferredNetwork: NetworkType;\n                            };\n                            closeButtonCallback?(): void;\n            }\n            /**\n                     * Close an alert by ID\n                     *\n                     * @param id ID of alert\n                     */\n            const closeAlert: (id: string) => Promise<void>;\n            /**\n                     * Close all alerts\n                     */\n            const closeAlerts: () => Promise<void>;\n            /**\n                     * Show an alert\n                     *\n                     * @param alertConfig The configuration of the alert\n                     */\n            const openAlert: (alertConfig: AlertConfig) => Promise<string>;\n            export { closeAlert, closeAlerts, openAlert };\n    }\n    \n    declare module 'test/ui/alert/Pairing' {\n            import { NetworkType } from 'test/';\n            export enum Platform {\n                    DESKTOP = 0,\n                    IOS = 1,\n                    ANDROID = 2\n            }\n            export enum WalletType {\n                    IOS = \"ios\",\n                    ANDROID = \"android\",\n                    EXTENSION = \"extension\",\n                    DESKTOP = \"desktop\",\n                    WEB = \"web\"\n            }\n            export interface AppBase {\n                    name: string;\n                    shortName: string;\n                    color: string;\n                    logo: string;\n            }\n            export interface ExtensionApp extends AppBase {\n                    id: string;\n                    link: string;\n            }\n            export interface WebApp extends AppBase {\n                    links: {\n                            [NetworkType.MAINNET]: string;\n                            [NetworkType.DELPHINET]?: string;\n                            [NetworkType.EDONET]?: string;\n                            [NetworkType.CUSTOM]?: string;\n                    };\n            }\n            export interface DesktopApp extends AppBase {\n                    deepLink: string;\n            }\n            export interface App extends AppBase {\n                    universalLink: string;\n                    deepLink?: string;\n            }\n            export interface PairingAlertWallet {\n                    name: string;\n                    shortName?: string;\n                    color?: string;\n                    logo?: string;\n                    enabled: boolean;\n                    clickHandler(): void;\n            }\n            export interface PairingAlertButton {\n                    title: string;\n                    text: string;\n                    clickHandler(): void;\n            }\n            export interface PairingAlertList {\n                    title: string;\n                    type: WalletType;\n                    wallets: PairingAlertWallet[];\n            }\n            export interface PairingAlertInfo {\n                    walletLists: PairingAlertList[];\n                    buttons: PairingAlertButton[];\n                    qrData: string;\n            }\n            export type StatusUpdateHandler = (walletType: WalletType, app?: PairingAlertWallet) => void;\n            export class Pairing {\n                    static getPlatfrom(): Promise<Platform>;\n                    static getPairingInfo(pairingPayload: {\n                            p2pSyncCode: string;\n                            postmessageSyncCode: string;\n                            preferredNetwork: NetworkType;\n                    }, statusUpdateHandler: StatusUpdateHandler, platform?: Platform): Promise<PairingAlertInfo>;\n            }\n    }\n    \n    declare module 'test/ui/alert/PairingAlert' {\n            import { NetworkType } from 'test/';\n            export const preparePairingAlert: (shadowRoot: ShadowRoot, pairingPayload: {\n                    p2pSyncCode: string;\n                    postmessageSyncCode: string;\n                    preferredNetwork: NetworkType;\n            }) => Promise<void>;\n    }\n    \n    declare module 'test/ui/alert/wallet-lists' {\n            import { App, DesktopApp, ExtensionApp, WebApp } from 'test/ui/alert/Pairing';\n            export const extensionList: ExtensionApp[];\n            export const desktopList: DesktopApp[];\n            export const webList: WebApp[];\n            export const iOSList: App[];\n    }\n    \n    declare module 'test/ui/toast/toast-templates' {\n            export const toastTemplates: {\n                    default: {\n                            html: string;\n                            css: string;\n                            poweredByBeacon: string;\n                    };\n            };\n    }\n    \n    declare module 'test/ui/toast/Toast' {\n            import { WalletInfo } from 'test/events';\n            export interface ToastAction {\n                            text: string;\n                            actionText?: string;\n                            actionCallback?(): Promise<void>;\n            }\n            export interface ToastConfig {\n                            body: string;\n                            timer?: number;\n                            forceNew?: boolean;\n                            state: 'loading' | 'acknowledge' | 'finished';\n                            actions?: ToastAction[];\n                            walletInfo?: WalletInfo;\n            }\n            /**\n                     * Close a toast\n                     */\n            const closeToast: () => Promise<void>;\n            /**\n                     * Create a new toast\n                     *\n                     * @param toastConfig Configuration of the toast\n                     */\n            const openToast: (toastConfig: ToastConfig) => Promise<void>;\n            export { closeToast, openToast };\n    }\n    \n    declare module 'test/utils/assert-never' {\n            /**\n                 * A helper function to make sure if/elses and switch/cases are exhaustive\n                 *\n                 * @param empty The data that has to be empty\n                 */\n            export function assertNever(empty: never): never;\n    }\n    \n    declare module 'test/utils/available-transports' {\n            /**\n                 * An object with promises to indicate whether or not that transport is available.\n                 */\n            export const availableTransports: {\n                    extension: Promise<boolean>;\n                    availableExtensions: Promise<import(\"../types/Extension\").Extension[]>;\n            };\n    }\n    \n    declare module 'test/utils/block-explorer' {\n            import { Network, NetworkType } from 'test/';\n            export abstract class BlockExplorer {\n                            readonly rpcUrls: {\n                                            [key in NetworkType]: string;\n                            };\n                            constructor(rpcUrls: {\n                                            [key in NetworkType]: string;\n                            });\n                            protected getLinkForNetwork(network: Network): Promise<string>;\n                            /**\n                                     * Return a blockexplorer link for an address\n                                     *\n                                     * @param address The address to be opened\n                                     * @param network The network that was used\n                                     */\n                            abstract getAddressLink(address: string, network: Network): Promise<string>;\n                            /**\n                                     * Return a blockexplorer link for a transaction hash\n                                     *\n                                     * @param transactionId The hash of the transaction\n                                     * @param network The network that was used\n                                     */\n                            abstract getTransactionLink(transactionId: string, network: Network): Promise<string>;\n            }\n    }\n    \n    declare module 'test/utils/crypto' {\n            import * as sodium from 'libsodium-wrappers';\n            /**\n                     * Convert a value to hex\n                     *\n                     * @param value\n                     */\n            export function toHex(value: any): string;\n            /**\n                     * Get the hex hash of a value\n                     *\n                     * @param key\n                     */\n            export function getHexHash(key: string | Buffer | Uint8Array): Promise<string>;\n            /**\n                     * Get a keypair from a seed\n                     *\n                     * @param seed\n                     */\n            export function getKeypairFromSeed(seed: string): Promise<sodium.KeyPair>;\n            /**\n                     * Encrypt a message with a shared key\n                     *\n                     * @param message\n                     * @param sharedKey\n                     */\n            export function encryptCryptoboxPayload(message: string, sharedKey: Uint8Array): Promise<string>;\n            /**\n                     * Decrypt a message with a shared key\n                     *\n                     * @param payload\n                     * @param sharedKey\n                     */\n            export function decryptCryptoboxPayload(payload: Uint8Array, sharedKey: Uint8Array): Promise<string>;\n            /**\n                     * Encrypt a message with a public key\n                     *\n                     * @param payload\n                     * @param publicKey\n                     */\n            export function sealCryptobox(payload: string | Buffer, publicKey: Uint8Array): Promise<string>;\n            /**\n                     * Decrypt a message with public + private key\n                     *\n                     * @param encryptedPayload\n                     * @param publicKey\n                     * @param privateKey\n                     */\n            export function openCryptobox(encryptedPayload: string | Buffer, publicKey: Uint8Array, privateKey: Uint8Array): Promise<string>;\n            /**\n                     * Get an address from the public key\n                     *\n                     * @param publicKey\n                     */\n            export function getAddressFromPublicKey(publicKey: string): Promise<string>;\n            /**\n                     * Get the recipient string used in the matrix message\n                     *\n                     * @param recipientHash\n                     * @param relayServer\n                     */\n            export function recipientString(recipientHash: string, relayServer: string): string;\n    }\n    \n    declare module 'test/utils/exposed-promise' {\n            export enum ExposedPromiseStatus {\n                    PENDING = \"pending\",\n                    RESOLVED = \"resolved\",\n                    REJECTED = \"rejected\"\n            }\n            type Resolve<T> = (value?: T) => void;\n            type Reject<U> = (reason?: U) => void;\n            /**\n                 * Exposed promise allow you to create a promise and then resolve it later, from the outside\n                 */\n            export class ExposedPromise<T = unknown, U = unknown> {\n                    get promise(): Promise<T>;\n                    get resolve(): Resolve<T>;\n                    get reject(): Reject<U>;\n                    get status(): ExposedPromiseStatus;\n                    get promiseResult(): T | undefined;\n                    get promiseError(): U | undefined;\n                    constructor();\n                    static resolve<T>(value?: T): ExposedPromise<T>;\n                    static reject<T = never, U = unknown>(reason?: U): ExposedPromise<T, U>;\n                    isPending(): boolean;\n                    isResolved(): boolean;\n                    isRejected(): boolean;\n                    isSettled(): boolean;\n            }\n            export {};\n    }\n    \n    declare module 'test/utils/generate-uuid' {\n            /**\n                 * Generate a random GUID\n                 */\n            export function generateGUID(): Promise<string>;\n    }\n    \n    declare module 'test/utils/get-account-identifier' {\n            import { Network } from 'test/';\n            /**\n                 * Generate a deterministic account identifier based on an address and a network\n                 *\n                 * @param address\n                 * @param network\n                 */\n            export const getAccountIdentifier: (address: string, network: Network) => Promise<string>;\n    }\n    \n    declare module 'test/utils/get-sender-id' {\n            /**\n                 * Generate a deterministic sender identifier based on a public key\n                 *\n                 * @param publicKey\n                 */\n            export const getSenderId: (publicKey: string) => Promise<string>;\n    }\n    \n    declare module 'test/utils/get-tzip10-link' {\n            export const getTzip10Link: (url: string, payload: string) => string;\n    }\n    \n    declare module 'test/utils/Logger' {\n            /**\n                 * The logger that is used internally\n                 */\n            export class Logger {\n                    constructor(service: string);\n                    debug(method: string, ...args: any[]): void;\n                    log(method: string, ...args: any[]): void;\n                    warn(method: string, ...args: any[]): void;\n                    error(method: string, ...args: any[]): void;\n            }\n    }\n    \n    declare module 'test/utils/platform' {\n            export const testUserAgent: (win: Window, expr: RegExp) => boolean;\n            export const isMobile: (win: Window) => boolean;\n            export const isIOS: (win: Window) => boolean;\n            export const isAndroid: (win: Window) => boolean;\n            export const isDesktop: (win: Window) => boolean;\n    }\n    \n    declare module 'test/utils/qr' {\n            /**\n                 * Convert data to a QR code\n                 *\n                 * @param payload The data to be encoded as a QR code\n                 * @param type How the QR code will be encoded\n                 */\n            export const getQrData: (payload: string, type?: \"data\" | \"svg\" | \"ascii\" | undefined) => string;\n    }\n    \n    declare module 'test/utils/replace-in-template' {\n            export const replaceInTemplate: (text: string, placeholder: string, value: string) => string;\n    }\n    \n    declare module 'test/utils/shorten-string' {\n            export const shortenString: (text: string) => string;\n    }\n    \n    declare module 'test/utils/tezblock-blockexplorer' {\n            import { Network, NetworkType } from 'test/';\n            import { BlockExplorer } from 'test/utils/block-explorer';\n            export class TezblockBlockExplorer extends BlockExplorer {\n                    readonly rpcUrls: {\n                            [key in NetworkType]: string;\n                    };\n                    constructor(rpcUrls?: {\n                            [key in NetworkType]: string;\n                    });\n                    getAddressLink(address: string, network: Network): Promise<string>;\n                    getTransactionLink(transactionId: string, network: Network): Promise<string>;\n            }\n    }\n    \n    declare module 'test/utils/utils' {\n            /**\n                 * A helper function to improve typings of object keys\n                 *\n                 * @param obj Object\n                 */\n            export function keys<O extends object>(obj: O): (keyof O)[];\n    }\n    \n    declare module 'test/' {\n            import { P2PCommunicationClient } from 'test/transports/clients/P2PCommunicationClient';\n            import { AppMetadata } from 'test/types/beacon/AppMetadata';\n            import { PermissionRequest } from 'test/types/beacon/messages/PermissionRequest';\n            import { Network } from 'test/types/beacon/Network';\n            import { BeaconBaseMessage } from 'test/types/beacon/BeaconBaseMessage';\n            import { BeaconMessageType } from 'test/types/beacon/BeaconMessageType';\n            import { PermissionScope } from 'test/types/beacon/PermissionScope';\n            import { PermissionResponse } from 'test/types/beacon/messages/PermissionResponse';\n            import { OperationRequest } from 'test/types/beacon/messages/OperationRequest';\n            import { OperationResponse } from 'test/types/beacon/messages/OperationResponse';\n            import { SignPayloadRequest } from 'test/types/beacon/messages/SignPayloadRequest';\n            import { SignPayloadResponse } from 'test/types/beacon/messages/SignPayloadResponse';\n            import { BroadcastRequest } from 'test/types/beacon/messages/BroadcastRequest';\n            import { BroadcastResponse } from 'test/types/beacon/messages/BroadcastResponse';\n            import { NetworkType } from 'test/types/beacon/NetworkType';\n            import { TezosBaseOperation } from 'test/types/tezos/TezosBaseOperation';\n            import { TezosOperationType } from 'test/types/tezos/OperationTypes';\n            import { TezosActivateAccountOperation } from 'test/types/tezos/operations/ActivateAccount';\n            import { TezosBallotOperation } from 'test/types/tezos/operations/Ballot';\n            import { TezosDelegationOperation } from 'test/types/tezos/operations/Delegation';\n            import { TezosDoubleBakingEvidenceOperation } from 'test/types/tezos/operations/DoubleBakingEvidence';\n            import { TezosBlockHeader } from 'test/types/tezos/TezosBlockHeader';\n            import { TezosDoubleEndorsementEvidenceOperation } from 'test/types/tezos/operations/DoubleEndorsementEvidence';\n            import { TezosEndorsementOperation } from 'test/types/tezos/operations/Endorsement';\n            import { TezosOriginationOperation } from 'test/types/tezos/operations/Origination';\n            import { TezosProposalOperation } from 'test/types/tezos/operations/Proposal';\n            import { TezosRevealOperation } from 'test/types/tezos/operations/Reveal';\n            import { TezosSeedNonceRevelationOperation } from 'test/types/tezos/operations/SeedNonceRevelation';\n            import { TezosTransactionOperation } from 'test/types/tezos/operations/Transaction';\n            import { MichelsonPrimitives } from 'test/types/tezos/MichelsonPrimitives';\n            import { TezosTransactionParameters } from 'test/types/tezos/TezosTransactionParameters';\n            import { Origin } from 'test/types/Origin';\n            import { AccountInfo, AccountIdentifier } from 'test/types/AccountInfo';\n            import { EncryptedExtensionMessage, ExtensionMessage } from 'test/types/ExtensionMessage';\n            import { ExtensionMessageTarget } from 'test/types/ExtensionMessageTarget';\n            import { TezosOperation } from 'test/types/tezos/TezosOperation';\n            import { Client } from 'test/clients/client/Client';\n            import { WalletClient } from 'test/clients/wallet-client/WalletClient';\n            import { DAppClient } from 'test/clients/dapp-client/DAppClient';\n            import { BeaconError } from 'test/errors/BeaconError';\n            import { BeaconErrorType } from 'test/types/BeaconErrorType';\n            import { BroadcastBeaconError } from 'test/errors/BroadcastBeaconError';\n            import { NetworkNotSupportedBeaconError } from 'test/errors/NetworkNotSupportedBeaconError';\n            import { NoAddressBeaconError } from 'test/errors/NoAddressBeaconError';\n            import { NoPrivateKeyBeaconError } from 'test/errors/NoPrivateKeyBeaconError';\n            import { NotGrantedBeaconError } from 'test/errors/NotGrantedBeaconError';\n            import { ParametersInvalidBeaconError } from 'test/errors/ParametersInvalidBeaconError';\n            import { TooManyOperationsBeaconError } from 'test/errors/TooManyOperationsBeaconError';\n            import { TransactionInvalidBeaconError } from 'test/errors/TransactionInvalidBeaconError';\n            import { UnknownBeaconError } from 'test/errors/UnknownBeaconError';\n            import { ErrorResponse } from 'test/types/beacon/messages/ErrorResponse';\n            import { TransportStatus } from 'test/types/transport/TransportStatus';\n            import { TransportType } from 'test/types/transport/TransportType';\n            import { PostMessageTransport } from 'test/transports/PostMessageTransport';\n            import { Transport } from 'test/transports/Transport';\n            import { P2PTransport } from 'test/transports/P2PTransport';\n            import { Storage } from 'test/storage/Storage';\n            import { StorageKey } from 'test/types/storage/StorageKey';\n            import { StorageKeyReturnDefaults } from 'test/types/storage/StorageKeyReturnDefaults';\n            import { StorageKeyReturnType } from 'test/types/storage/StorageKeyReturnType';\n            import { ExtendedP2PPairingRequest, P2PPairingRequest } from 'test/types/P2PPairingRequest';\n            import { ChromeStorage } from 'test/storage/ChromeStorage';\n            import { LocalStorage } from 'test/storage/LocalStorage';\n            import { getStorage } from 'test/storage/getStorage';\n            import { BeaconMessage } from 'test/types/beacon/BeaconMessage';\n            import { Serializer } from 'test/Serializer';\n            import { RequestPermissionInput } from 'test/types/RequestPermissionInput';\n            import { RequestSignPayloadInput } from 'test/types/RequestSignPayloadInput';\n            import { RequestOperationInput } from 'test/types/RequestOperationInput';\n            import { RequestBroadcastInput } from 'test/types/RequestBroadcastInput';\n            import { PermissionResponseInput, SignPayloadResponseInput, OperationResponseInput, BroadcastResponseInput, BeaconResponseInputMessage, AcknowledgeResponseInput, ErrorResponseInput } from 'test/types/beacon/messages/BeaconResponseInputMessage';\n            import { PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, BeaconResponseOutputMessage } from 'test/types/beacon/messages/BeaconResponseOutputMessage';\n            import { PermissionRequestInput, SignPayloadRequestInput, OperationRequestInput, BroadcastRequestInput, BeaconRequestInputMessage } from 'test/types/beacon/messages/BeaconRequestInputMessage';\n            import { PermissionRequestOutput, SignPayloadRequestOutput, OperationRequestOutput, BroadcastRequestOutput, BeaconRequestOutputMessage } from 'test/types/beacon/messages/BeaconRequestOutputMessage';\n            import { ClientOptions } from 'test/clients/client/ClientOptions';\n            import { DAppClientOptions } from 'test/clients/dapp-client/DAppClientOptions';\n            import { WalletClientOptions } from 'test/clients/wallet-client/WalletClientOptions';\n            import { PermissionInfo } from 'test/types/PermissionInfo';\n            import { SDK_VERSION, BEACON_VERSION } from 'test/constants';\n            import { AccountManager } from 'test/managers/AccountManager';\n            import { AppMetadataManager } from 'test/managers/AppMetadataManager';\n            import { PermissionManager } from 'test/managers/PermissionManager';\n            import { BeaconEvent, BeaconEventHandler, defaultEventCallbacks } from 'test/events';\n            import { getAddressFromPublicKey } from 'test/utils/crypto';\n            import { BeaconClient } from 'test/clients/beacon-client/BeaconClient';\n            import { BeaconClientOptions } from 'test/clients/beacon-client/BeaconClientOptions';\n            import { getAccountIdentifier } from 'test/utils/get-account-identifier';\n            import { ConnectionContext } from 'test/types/ConnectionContext';\n            import { Threshold } from 'test/types/beacon/Threshold';\n            import { PartialTezosTransactionOperation, PartialTezosOperation, PartialTezosDelegationOperation, PartialTezosOriginationOperation, PartialTezosRevealOperation } from 'test/types/tezos/PartialTezosOperation';\n            import { AbortedBeaconError } from 'test/errors/AbortedBeaconError';\n            import { ExtendedPeerInfo, PeerInfo } from 'test/types/PeerInfo';\n            import { availableTransports } from 'test/utils/available-transports';\n            import { AcknowledgeResponse } from 'test/types/beacon/messages/AcknowledgeResponse';\n            import { DisconnectMessage } from 'test/types/beacon/messages/DisconnectMessage';\n            import { DappP2PTransport } from 'test/transports/DappP2PTransport';\n            import { DappPostMessageTransport } from 'test/transports/DappPostMessageTransport';\n            import { WalletP2PTransport } from 'test/transports/WalletP2PTransport';\n            import { WalletPostMessageTransport } from 'test/transports/WalletPostMessageTransport';\n            import { getSenderId } from 'test/utils/get-sender-id';\n            import { SigningType } from 'test/types/beacon/SigningType';\n            import { SignatureTypeNotSupportedBeaconError } from 'test/errors/SignatureTypeNotSupportedBeaconError';\n            import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n            import { ExtendedPostMessagePairingRequest, PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n            import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n            import { PeerManager } from 'test/managers/PeerManager';\n            import { MessageBasedClient } from 'test/transports/clients/MessageBasedClient';\n            import { BeaconRequestMessage } from 'test/types/beacon/BeaconRequestMessage';\n            import { BeaconResponseMessage } from 'test/types/beacon/BeaconResponseMessage';\n            import { Pairing } from 'test/ui/alert/Pairing';\n            import { BlockExplorer } from 'test/utils/block-explorer';\n            import { TezblockBlockExplorer } from 'test/utils/tezblock-blockexplorer';\n            import { setDebugEnabled, getDebugEnabled } from 'test/debug';\n            import { ColorMode } from 'test/types/ColorMode';\n            export { TezosBaseOperation, TezosOperationType, TezosBlockHeader, MichelsonPrimitives, TezosTransactionParameters, TezosOperation };\n            export { TezosActivateAccountOperation, TezosBallotOperation, TezosDelegationOperation, TezosDoubleBakingEvidenceOperation, TezosDoubleEndorsementEvidenceOperation, TezosEndorsementOperation, TezosOriginationOperation, TezosProposalOperation, TezosRevealOperation, TezosSeedNonceRevelationOperation, TezosTransactionOperation, PartialTezosOperation, PartialTezosTransactionOperation, PartialTezosDelegationOperation, PartialTezosOriginationOperation, PartialTezosRevealOperation };\n            export { BeaconClient, BeaconClientOptions, Client, ClientOptions, DAppClient, DAppClientOptions, WalletClient, WalletClientOptions, P2PCommunicationClient };\n            export { AccountIdentifier, AppMetadata, Network, NetworkType, BeaconMessage, PermissionRequest, PermissionResponse, OperationRequest, OperationResponse, SignPayloadRequest, SignPayloadResponse, BroadcastRequest, BroadcastResponse, AcknowledgeResponse, DisconnectMessage, BeaconBaseMessage, BeaconMessageType, PermissionScope, Origin, AccountInfo, Threshold, SigningType, ExtensionMessageTarget, ExtensionMessage, EncryptedExtensionMessage, RequestPermissionInput, RequestSignPayloadInput, RequestOperationInput, RequestBroadcastInput, PermissionInfo };\n            export { PermissionResponseInput, SignPayloadResponseInput, OperationResponseInput, BroadcastResponseInput, AcknowledgeResponseInput, ErrorResponseInput, PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, PermissionRequestInput, SignPayloadRequestInput, OperationRequestInput, BroadcastRequestInput, PermissionRequestOutput, SignPayloadRequestOutput, OperationRequestOutput, BroadcastRequestOutput, BeaconRequestInputMessage, BeaconRequestOutputMessage, BeaconResponseInputMessage, BeaconResponseOutputMessage, BeaconRequestMessage, BeaconResponseMessage };\n            export { BeaconError, BeaconErrorType, ErrorResponse, AbortedBeaconError, BroadcastBeaconError, NetworkNotSupportedBeaconError, NoAddressBeaconError, NoPrivateKeyBeaconError, NotGrantedBeaconError, ParametersInvalidBeaconError, TooManyOperationsBeaconError, TransactionInvalidBeaconError, SignatureTypeNotSupportedBeaconError, UnknownBeaconError };\n            export { TransportStatus, TransportType, Transport, PostMessageTransport, P2PTransport, WalletP2PTransport, WalletPostMessageTransport, DappP2PTransport, DappPostMessageTransport, MessageBasedClient, Pairing };\n            export { BeaconEvent, BeaconEventHandler, defaultEventCallbacks };\n            export { Storage, StorageKey, StorageKeyReturnDefaults, StorageKeyReturnType, ChromeStorage, LocalStorage, getStorage };\n            export { PeerManager, AccountManager, AppMetadataManager, PermissionManager };\n            export { SDK_VERSION, BEACON_VERSION };\n            export { getSenderId, getAccountIdentifier, getAddressFromPublicKey };\n            export { PeerInfo, ExtendedPeerInfo, PostMessagePairingRequest, ExtendedPostMessagePairingRequest, ExtendedPostMessagePairingResponse, P2PPairingRequest, ExtendedP2PPairingRequest, ExtendedP2PPairingResponse };\n            export { BlockExplorer, TezblockBlockExplorer };\n            export { ConnectionContext, Serializer, availableTransports, ColorMode };\n            export { setDebugEnabled, getDebugEnabled };\n    }\n}\n\ndeclare module 'test/transports/clients/CommunicationClient' {\n    import * as sodium from 'libsodium-wrappers';\n    import { P2PPairingRequest } from 'test/';\n    import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n    import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n    import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n    export abstract class CommunicationClient {\n            protected readonly keyPair: sodium.KeyPair;\n            constructor(keyPair: sodium.KeyPair);\n            /**\n                * Get the public key\n                */\n            getPublicKey(): Promise<string>;\n            /**\n                * get the public key hash\n                */\n            getPublicKeyHash(): Promise<string>;\n            /**\n                * Create a cryptobox shared key\n                *\n                * @param otherPublicKey\n                * @param selfPrivateKey\n                */\n            protected createCryptoBox(otherPublicKey: string, selfPrivateKey: Uint8Array): Promise<[Uint8Array, Uint8Array, Uint8Array]>;\n            /**\n                * Create a cryptobox server\n                *\n                * @param otherPublicKey\n                * @param selfPrivateKey\n                */\n            protected createCryptoBoxServer(otherPublicKey: string, selfPrivateKey: Uint8Array): Promise<sodium.CryptoKX>;\n            /**\n                * Create a cryptobox client\n                *\n                * @param otherPublicKey\n                * @param selfPrivateKey\n                */\n            protected createCryptoBoxClient(otherPublicKey: string, selfPrivateKey: Uint8Array): Promise<sodium.CryptoKX>;\n            /**\n                * Encrypt a message for a specific publicKey (receiver, asymmetric)\n                *\n                * @param recipientPublicKey\n                * @param message\n                */\n            protected encryptMessageAsymmetric(recipientPublicKey: string, message: string): Promise<string>;\n            abstract unsubscribeFromEncryptedMessages(): Promise<void>;\n            abstract unsubscribeFromEncryptedMessage(senderPublicKey: string): Promise<void>;\n            abstract sendMessage(message: string, peer?: P2PPairingRequest | ExtendedP2PPairingResponse | PostMessagePairingRequest | ExtendedPostMessagePairingResponse): Promise<void>;\n    }\n}\n\ndeclare module 'test/transports/clients/MessageBasedClient' {\n    import * as sodium from 'libsodium-wrappers';\n    import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n    import { PostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n    import { CommunicationClient } from 'test/transports/clients/CommunicationClient';\n    export abstract class MessageBasedClient extends CommunicationClient {\n            protected readonly name: string;\n            /**\n                * The listeners that will be notified of new messages\n                */\n            protected abstract readonly activeListeners: Map<string, unknown>;\n            constructor(name: string, keyPair: sodium.KeyPair);\n            /**\n                * start the client and make sure all dependencies are ready\n                */\n            start(): Promise<void>;\n            /**\n                * Get the pairing request information. This will be shared with the peer during the connection setup\n                */\n            getPairingRequestInfo(): Promise<PostMessagePairingRequest>;\n            /**\n                * Get the pairing response information. This will be shared with the peer during the connection setup\n                */\n            getPairingResponseInfo(request: PostMessagePairingRequest): Promise<PostMessagePairingResponse>;\n            /**\n                * Unsubscribe from encrypted messages from a specific peer\n                *\n                * @param senderPublicKey\n                */\n            unsubscribeFromEncryptedMessage(senderPublicKey: string): Promise<void>;\n            /**\n                * Unsubscribe from all encrypted messages\n                */\n            unsubscribeFromEncryptedMessages(): Promise<void>;\n            /**\n                * Decrypt a message from a specific peer\n                *\n                * @param senderPublicKey\n                * @param payload\n                */\n            protected decryptMessage(senderPublicKey: string, payload: string): Promise<string>;\n            /**\n                * Encrypt a message for a specific publicKey (receiver)\n                *\n                * @param recipientPublicKey\n                * @param message\n                */\n            protected encryptMessage(recipientPublicKey: string, message: string): Promise<string>;\n            /**\n                * Initialize the connection\n                */\n            abstract init(): Promise<void>;\n    }\n}\n\ndeclare module 'test/transports/clients/P2PCommunicationClient' {\n    import * as sodium from 'libsodium-wrappers';\n    import { MatrixClientEvent, MatrixClientEventType, MatrixClientEventMessageContent } from 'test/matrix-client/models/MatrixClientEvent';\n    import { Storage } from 'test/storage/Storage';\n    import { P2PPairingRequest } from 'test/';\n    import { ExtendedP2PPairingResponse, P2PPairingResponse } from 'test/types/P2PPairingResponse';\n    import { CommunicationClient } from 'test/transports/clients/CommunicationClient';\n    export class P2PCommunicationClient extends CommunicationClient {\n        readonly replicationCount: number;\n        constructor(name: string, keyPair: sodium.KeyPair, replicationCount: number, storage: Storage, matrixNodes: string[], iconUrl?: string | undefined, appUrl?: string | undefined);\n        getPairingRequestInfo(): Promise<P2PPairingRequest>;\n        getPairingResponseInfo(request: P2PPairingRequest): Promise<P2PPairingResponse>;\n        getRelayServer(publicKeyHash?: string, nonce?: string): Promise<string>;\n        start(): Promise<void>;\n        listenForEncryptedMessage(senderPublicKey: string, messageCallback: (message: string) => void): Promise<void>;\n        unsubscribeFromEncryptedMessage(senderPublicKey: string): Promise<void>;\n        unsubscribeFromEncryptedMessages(): Promise<void>;\n        sendMessage(message: string, peer: P2PPairingRequest | ExtendedP2PPairingResponse): Promise<void>;\n        deleteRoomIdFromRooms(roomId: string): Promise<void>;\n        listenForChannelOpening(messageCallback: (pairingResponse: ExtendedP2PPairingResponse) => void): Promise<void>;\n        sendPairingResponse(pairingRequest: P2PPairingRequest): Promise<void>;\n        isTextMessage(content: MatrixClientEventMessageContent<any>): content is MatrixClientEventMessageContent<string>;\n        isChannelOpenMessage(content: MatrixClientEventMessageContent<string>): Promise<boolean>;\n        isSender(event: MatrixClientEvent<MatrixClientEventType.MESSAGE>, senderPublicKey: string): Promise<boolean>;\n    }\n}\n\ndeclare module 'test/transports/clients/PostMessageClient' {\n    import { ConnectionContext } from 'test/';\n    import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n    import { EncryptedExtensionMessage } from 'test/types/ExtensionMessage';\n    import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n    import { MessageBasedClient } from 'test/transports/clients/MessageBasedClient';\n    export class PostMessageClient extends MessageBasedClient {\n        protected readonly activeListeners: Map<string, (message: EncryptedExtensionMessage, context: ConnectionContext) => void>;\n        init(): Promise<void>;\n        listenForEncryptedMessage(senderPublicKey: string, messageCallback: (message: string, context: ConnectionContext) => void): Promise<void>;\n        sendMessage(message: string, peer: PostMessagePairingRequest | ExtendedPostMessagePairingResponse): Promise<void>;\n        listenForChannelOpening(messageCallback: (pairingResponse: ExtendedPostMessagePairingResponse) => void): Promise<void>;\n        sendPairingRequest(id: string): Promise<void>;\n        isChannelOpenMessage(message: any): Promise<boolean>;\n    }\n}\n\ndeclare module 'test/transports/DappP2PTransport' {\n    import * as sodium from 'libsodium-wrappers';\n    import { Storage, StorageKey, P2PTransport } from 'test/';\n    import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n    export class DappP2PTransport extends P2PTransport<ExtendedP2PPairingResponse, StorageKey.TRANSPORT_P2P_PEERS_DAPP> {\n        constructor(name: string, keyPair: sodium.KeyPair, storage: Storage, matrixNodes: string[], iconUrl?: string, appUrl?: string);\n        startOpenChannelListener(): Promise<void>;\n        listenForNewPeer(newPeerListener: (peer: ExtendedP2PPairingResponse) => void): Promise<void>;\n        stopListeningForNewPeers(): Promise<void>;\n    }\n}\n\ndeclare module 'test/transports/DappPostMessageTransport' {\n    import * as sodium from 'libsodium-wrappers';\n    import { StorageKey, PostMessageTransport, Storage } from 'test/';\n    import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n    export class DappPostMessageTransport extends PostMessageTransport<ExtendedPostMessagePairingResponse, StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP> {\n        constructor(name: string, keyPair: sodium.KeyPair, storage: Storage);\n        startOpenChannelListener(): Promise<void>;\n        listenForNewPeer(newPeerListener: (peer: ExtendedPostMessagePairingResponse) => void): Promise<void>;\n        stopListeningForNewPeers(): Promise<void>;\n    }\n}\n\ndeclare module 'test/transports/P2PTransport' {\n    import * as sodium from 'libsodium-wrappers';\n    import { Storage, StorageKey, Transport, TransportType, P2PCommunicationClient, P2PPairingRequest } from 'test/';\n    import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n    export class P2PTransport<T extends P2PPairingRequest | ExtendedP2PPairingResponse, K extends StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET> extends Transport<T, K, P2PCommunicationClient> {\n        readonly type: TransportType;\n        constructor(name: string, keyPair: sodium.KeyPair, storage: Storage, matrixNodes: string[], storageKey: K, iconUrl?: string, appUrl?: string);\n        static isAvailable(): Promise<boolean>;\n        connect(): Promise<void>;\n        startOpenChannelListener(): Promise<void>;\n        getPairingRequestInfo(): Promise<P2PPairingRequest>;\n        listen(publicKey: string): Promise<void>;\n    }\n}\n\ndeclare module 'test/transports/PostMessageTransport' {\n    import * as sodium from 'libsodium-wrappers';\n    import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n    import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n    import { Extension } from 'test/types/Extension';\n    import { StorageKey } from 'test/types/storage/StorageKey';\n    import { TransportType } from 'test/types/transport/TransportType';\n    import { Storage } from 'test/storage/Storage';\n    import { PostMessageClient } from 'test/transports/clients/PostMessageClient';\n    import { Transport } from 'test/transports/Transport';\n    export class PostMessageTransport<T extends PostMessagePairingRequest | ExtendedPostMessagePairingResponse, K extends StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET> extends Transport<T, K, PostMessageClient> {\n        readonly type: TransportType;\n        constructor(name: string, keyPair: sodium.KeyPair, storage: Storage, storageKey: K);\n        static isAvailable(): Promise<boolean>;\n        static getAvailableExtensions(): Promise<Extension[]>;\n        connect(): Promise<void>;\n        startOpenChannelListener(): Promise<void>;\n        getPairingRequestInfo(): Promise<PostMessagePairingRequest>;\n        listen(publicKey: string): Promise<void>;\n    }\n}\n\ndeclare module 'test/transports/Transport' {\n    import { ConnectionContext } from 'test/types/ConnectionContext';\n    import { TransportType, TransportStatus, PeerInfo, StorageKey } from 'test/';\n    import { PeerManager } from 'test/managers/PeerManager';\n    import { CommunicationClient } from 'test/transports/clients/CommunicationClient';\n    export abstract class Transport<T extends PeerInfo = PeerInfo, K extends StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET = any, S extends CommunicationClient = any> {\n            /**\n                * The type of the transport\n                */\n            readonly type: TransportType;\n            /**\n                * The name of the app\n                */\n            protected readonly name: string;\n            /**\n                * The status of the transport\n                */\n            protected _isConnected: TransportStatus;\n            protected readonly peerManager: PeerManager<K>;\n            /**\n                * The client handling the encryption/decryption of messages\n                */\n            protected client: S;\n            /**\n                * The listener that will be invoked when a new peer is connected\n                */\n            protected newPeerListener?: (peer: T) => void;\n            /**\n                * Return the status of the connection\n                */\n            get connectionStatus(): TransportStatus;\n            constructor(name: string, client: S, peerManager: PeerManager<K>);\n            /**\n                * Returns a promise that resolves to true if the transport is available, false if it is not\n                */\n            static isAvailable(): Promise<boolean>;\n            /**\n                * Connect the transport\n                */\n            connect(): Promise<void>;\n            /**\n                * Send a message through the transport\n                *\n                * @param message The message to send\n                * @param recipient The recipient of the message\n                */\n            send(message: string, peer?: PeerInfo): Promise<void>;\n            /**\n                * Add a listener to be called when a new message is received\n                *\n                * @param listener The listener that will be registered\n                */\n            addListener(listener: (message: unknown, connectionInfo: ConnectionContext) => void): Promise<void>;\n            /**\n                * Remove a listener\n                *\n                * @param listener\n                */\n            removeListener(listener: (message: string, connectionInfo: ConnectionContext) => void): Promise<void>;\n            getPeers(): Promise<T[]>;\n            addPeer(newPeer: T): Promise<void>;\n            removePeer(peerToBeRemoved: T): Promise<void>;\n            removeAllPeers(): Promise<void>;\n            /**\n                * Notify the listeners when a new message comes in\n                *\n                * @param message Message\n                * @param connectionInfo Context info about the connection\n                */\n            protected notifyListeners(message: unknown, connectionInfo: ConnectionContext): Promise<void>;\n            abstract listen(publicKey: string): Promise<void>;\n    }\n}\n\ndeclare module 'test/transports/WalletP2PTransport' {\n    import * as sodium from 'libsodium-wrappers';\n    import { Storage, StorageKey, P2PTransport, P2PPairingRequest } from 'test/';\n    export class WalletP2PTransport extends P2PTransport<P2PPairingRequest, StorageKey.TRANSPORT_P2P_PEERS_WALLET> {\n        constructor(name: string, keyPair: sodium.KeyPair, storage: Storage, matrixNodes: string[], iconUrl?: string, appUrl?: string);\n        addPeer(newPeer: P2PPairingRequest): Promise<void>;\n    }\n}\n\ndeclare module 'test/transports/WalletPostMessageTransport' {\n    import * as sodium from 'libsodium-wrappers';\n    import { StorageKey, PostMessageTransport, Storage } from 'test/';\n    import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n    export class WalletPostMessageTransport extends PostMessageTransport<PostMessagePairingRequest, StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET> {\n        constructor(name: string, keyPair: sodium.KeyPair, storage: Storage);\n    }\n}\n\ndeclare module 'test/types/AccountInfo' {\n    import { Origin } from 'test/';\n    import { PermissionEntity } from 'test/types/PermissionEntity';\n    export type AccountIdentifier = string;\n    export interface AccountInfo extends PermissionEntity {\n        accountIdentifier: AccountIdentifier;\n        senderId: string;\n        origin: {\n            type: Origin;\n            id: string;\n        };\n        publicKey: string;\n        connectedAt: number;\n    }\n}\n\ndeclare module 'test/types/beacon/AppMetadata' {\n    export interface AppMetadata {\n        senderId: string;\n        name: string;\n        icon?: string;\n    }\n}\n\ndeclare module 'test/types/beacon/BeaconBaseMessage' {\n    import { BeaconMessageType } from 'test/';\n    export interface BeaconBaseMessage {\n        type: BeaconMessageType;\n        version: string;\n        id: string;\n        senderId: string;\n    }\n}\n\ndeclare module 'test/types/beacon/BeaconMessage' {\n    import { PermissionResponse, PermissionRequest, OperationRequest, OperationResponse, SignPayloadRequest, SignPayloadResponse, BroadcastRequest, BroadcastResponse, AcknowledgeResponse, DisconnectMessage, ErrorResponse } from 'test/';\n    export type BeaconMessage = PermissionRequest | PermissionResponse | OperationRequest | OperationResponse | SignPayloadRequest | SignPayloadResponse | BroadcastRequest | BroadcastResponse | AcknowledgeResponse | DisconnectMessage | ErrorResponse;\n}\n\ndeclare module 'test/types/beacon/BeaconMessageType' {\n    export enum BeaconMessageType {\n        PermissionRequest = \"permission_request\",\n        SignPayloadRequest = \"sign_payload_request\",\n        OperationRequest = \"operation_request\",\n        BroadcastRequest = \"broadcast_request\",\n        PermissionResponse = \"permission_response\",\n        SignPayloadResponse = \"sign_payload_response\",\n        OperationResponse = \"operation_response\",\n        BroadcastResponse = \"broadcast_response\",\n        Acknowledge = \"acknowledge\",\n        Disconnect = \"disconnect\",\n        Error = \"error\"\n    }\n}\n\ndeclare module 'test/types/beacon/BeaconRequestMessage' {\n    import { PermissionRequest, OperationRequest, SignPayloadRequest, BroadcastRequest } from 'test/';\n    export type BeaconRequestMessage = PermissionRequest | OperationRequest | SignPayloadRequest | BroadcastRequest;\n}\n\ndeclare module 'test/types/beacon/BeaconResponseMessage' {\n    import { PermissionResponse, OperationResponse, SignPayloadResponse, BroadcastResponse } from 'test/';\n    import { ErrorResponse } from 'test/types/beacon/messages/ErrorResponse';\n    export type BeaconResponseMessage = PermissionResponse | OperationResponse | SignPayloadResponse | BroadcastResponse | ErrorResponse;\n}\n\ndeclare module 'test/types/beacon/messages/AcknowledgeResponse' {\n    import { BeaconBaseMessage, BeaconMessageType } from 'test/';\n    export interface AcknowledgeResponse extends BeaconBaseMessage {\n        type: BeaconMessageType.Acknowledge;\n    }\n}\n\ndeclare module 'test/types/beacon/messages/BeaconRequestInputMessage' {\n    import { PermissionRequest, OperationRequest, SignPayloadRequest, BroadcastRequest } from 'test/';\n    export type IgnoredRequestInputProperties = 'id' | 'senderId' | 'version';\n    export type PermissionRequestInput = Omit<PermissionRequest, IgnoredRequestInputProperties>;\n    export type OperationRequestInput = Omit<OperationRequest, IgnoredRequestInputProperties>;\n    export type SignPayloadRequestInput = Omit<SignPayloadRequest, IgnoredRequestInputProperties>;\n    export type BroadcastRequestInput = Omit<BroadcastRequest, IgnoredRequestInputProperties>;\n    export type BeaconRequestInputMessage = PermissionRequestInput | OperationRequestInput | SignPayloadRequestInput | BroadcastRequestInput;\n}\n\ndeclare module 'test/types/beacon/messages/BeaconRequestOutputMessage' {\n    import { AppMetadata, PermissionRequest, OperationRequest, SignPayloadRequest, BroadcastRequest } from 'test/';\n    export type IgnoredRequestOutputProperties = 'version';\n    export interface ExtraResponseOutputProperties {\n        appMetadata: AppMetadata;\n    }\n    export type PermissionRequestOutput = Omit<PermissionRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n    export type OperationRequestOutput = Omit<OperationRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n    export type SignPayloadRequestOutput = Omit<SignPayloadRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n    export type BroadcastRequestOutput = Omit<BroadcastRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n    export type BeaconRequestOutputMessage = PermissionRequestOutput | OperationRequestOutput | SignPayloadRequestOutput | BroadcastRequestOutput;\n}\n\ndeclare module 'test/types/beacon/messages/BeaconResponseInputMessage' {\n    import { PermissionResponse, OperationResponse, SignPayloadResponse, BroadcastResponse, AcknowledgeResponse, ErrorResponse } from 'test/';\n    export type IgnoredResponseInputProperties = 'senderId' | 'version' | 'appMetadata';\n    export type PermissionResponseInput = Omit<PermissionResponse, IgnoredResponseInputProperties>;\n    export type OperationResponseInput = Omit<OperationResponse, IgnoredResponseInputProperties>;\n    export type SignPayloadResponseInput = Omit<SignPayloadResponse, IgnoredResponseInputProperties>;\n    export type BroadcastResponseInput = Omit<BroadcastResponse, IgnoredResponseInputProperties>;\n    export type AcknowledgeResponseInput = Omit<AcknowledgeResponse, IgnoredResponseInputProperties>;\n    export type ErrorResponseInput = Omit<ErrorResponse, IgnoredResponseInputProperties>;\n    export type BeaconResponseInputMessage = PermissionResponseInput | OperationResponseInput | SignPayloadResponseInput | BroadcastResponseInput | AcknowledgeResponseInput | ErrorResponseInput;\n}\n\ndeclare module 'test/types/beacon/messages/BeaconResponseOutputMessage' {\n    import { PermissionResponse, OperationResponse, SignPayloadResponse, BroadcastResponse, AccountInfo } from 'test/';\n    export type IgnoredResponseOutputProperties = 'id' | 'version' | 'type';\n    export type PermissionResponseOutput = PermissionResponse & {\n        address: string;\n        accountInfo: AccountInfo;\n    };\n    export type OperationResponseOutput = OperationResponse;\n    export type SignPayloadResponseOutput = SignPayloadResponse;\n    export type BroadcastResponseOutput = BroadcastResponse;\n    export type BeaconResponseOutputMessage = PermissionResponseOutput | OperationResponseOutput | SignPayloadResponseOutput | BroadcastResponseOutput;\n}\n\ndeclare module 'test/types/beacon/messages/BroadcastRequest' {\n    import { BeaconBaseMessage, BeaconMessageType, Network } from 'test/';\n    export interface BroadcastRequest extends BeaconBaseMessage {\n        type: BeaconMessageType.BroadcastRequest;\n        network: Network;\n        signedTransaction: string;\n    }\n}\n\ndeclare module 'test/types/beacon/messages/BroadcastResponse' {\n    import { BeaconBaseMessage, BeaconMessageType } from 'test/';\n    export interface BroadcastResponse extends BeaconBaseMessage {\n        type: BeaconMessageType.BroadcastResponse;\n        transactionHash: string;\n    }\n}\n\ndeclare module 'test/types/beacon/messages/DisconnectMessage' {\n    import { BeaconBaseMessage, BeaconMessageType } from 'test/';\n    export interface DisconnectMessage extends BeaconBaseMessage {\n        type: BeaconMessageType.Disconnect;\n    }\n}\n\ndeclare module 'test/types/beacon/messages/ErrorResponse' {\n    import { BeaconBaseMessage, BeaconErrorType, BeaconMessageType } from 'test/';\n    export interface ErrorResponse extends BeaconBaseMessage {\n        type: BeaconMessageType.Error;\n        errorType: BeaconErrorType;\n        errorData?: any;\n    }\n}\n\ndeclare module 'test/types/beacon/messages/OperationRequest' {\n    import { BeaconBaseMessage, BeaconMessageType, Network } from 'test/';\n    import { PartialTezosOperation } from 'test/types/tezos/PartialTezosOperation';\n    export interface OperationRequest extends BeaconBaseMessage {\n        type: BeaconMessageType.OperationRequest;\n        network: Network;\n        operationDetails: PartialTezosOperation[];\n        sourceAddress: string;\n    }\n}\n\ndeclare module 'test/types/beacon/messages/OperationResponse' {\n    import { BeaconBaseMessage, BeaconMessageType } from 'test/';\n    export interface OperationResponse extends BeaconBaseMessage {\n        type: BeaconMessageType.OperationResponse;\n        transactionHash: string;\n    }\n}\n\ndeclare module 'test/types/beacon/messages/PermissionRequest' {\n    import { BeaconBaseMessage, BeaconMessageType, PermissionScope, AppMetadata, Network } from 'test/';\n    export interface PermissionRequest extends BeaconBaseMessage {\n        type: BeaconMessageType.PermissionRequest;\n        appMetadata: AppMetadata;\n        network: Network;\n        scopes: PermissionScope[];\n    }\n}\n\ndeclare module 'test/types/beacon/messages/PermissionResponse' {\n    import { AppMetadata, BeaconBaseMessage, BeaconMessageType, Network, PermissionScope, Threshold } from 'test/';\n    export interface PermissionResponse extends BeaconBaseMessage {\n        type: BeaconMessageType.PermissionResponse;\n        appMetadata: AppMetadata;\n        publicKey: string;\n        network: Network;\n        scopes: PermissionScope[];\n        threshold?: Threshold;\n    }\n}\n\ndeclare module 'test/types/beacon/messages/SignPayloadRequest' {\n    import { BeaconBaseMessage, BeaconMessageType, SigningType } from 'test/';\n    export interface SignPayloadRequest extends BeaconBaseMessage {\n        type: BeaconMessageType.SignPayloadRequest;\n        signingType: SigningType;\n        payload: string;\n        sourceAddress: string;\n    }\n}\n\ndeclare module 'test/types/beacon/messages/SignPayloadResponse' {\n    import { BeaconBaseMessage, BeaconMessageType, SigningType } from 'test/';\n    export interface SignPayloadResponse extends BeaconBaseMessage {\n        type: BeaconMessageType.SignPayloadResponse;\n        signingType: SigningType;\n        signature: string;\n    }\n}\n\ndeclare module 'test/types/beacon/Network' {\n    import { NetworkType } from 'test/';\n    export interface Network {\n        type: NetworkType;\n        name?: string;\n        rpcUrl?: string;\n    }\n}\n\ndeclare module 'test/types/beacon/NetworkType' {\n    export enum NetworkType {\n        MAINNET = \"mainnet\",\n        DELPHINET = \"delphinet\",\n        EDONET = \"edonet\",\n        CUSTOM = \"custom\"\n    }\n}\n\ndeclare module 'test/types/beacon/PermissionScope' {\n    export enum PermissionScope {\n        SIGN = \"sign\",\n        OPERATION_REQUEST = \"operation_request\",\n        THRESHOLD = \"threshold\"\n    }\n}\n\ndeclare module 'test/types/beacon/SigningType' {\n    export enum SigningType {\n        RAW = \"raw\",\n        OPERATION = \"operation\",\n        MICHELINE = \"micheline\"\n    }\n}\n\ndeclare module 'test/types/beacon/Threshold' {\n    export interface Threshold {\n        amount: string;\n        timeframe: string;\n    }\n}\n\ndeclare module 'test/types/BeaconErrorType' {\n    export enum BeaconErrorType {\n        BROADCAST_ERROR = \"BROADCAST_ERROR\",\n        NETWORK_NOT_SUPPORTED = \"NETWORK_NOT_SUPPORTED\",\n        NO_ADDRESS_ERROR = \"NO_ADDRESS_ERROR\",\n        NO_PRIVATE_KEY_FOUND_ERROR = \"NO_PRIVATE_KEY_FOUND_ERROR\",\n        NOT_GRANTED_ERROR = \"NOT_GRANTED_ERROR\",\n        PARAMETERS_INVALID_ERROR = \"PARAMETERS_INVALID_ERROR\",\n        TOO_MANY_OPERATIONS = \"TOO_MANY_OPERATIONS\",\n        TRANSACTION_INVALID_ERROR = \"TRANSACTION_INVALID_ERROR\",\n        SIGNATURE_TYPE_NOT_SUPPORTED = \"SIGNATURE_TYPE_NOT_SUPPORTED\",\n        ABORTED_ERROR = \"ABORTED_ERROR\",\n        UNKNOWN_ERROR = \"UNKNOWN_ERROR\"\n    }\n}\n\ndeclare module 'test/types/ColorMode' {\n    export enum ColorMode {\n        LIGHT = \"light\",\n        DARK = \"dark\"\n    }\n}\n\ndeclare module 'test/types/ConnectionContext' {\n    import { Origin } from 'test/';\n    export interface ConnectionContext {\n        origin: Origin;\n        id: string;\n        extras?: {\n            sender: chrome.runtime.MessageSender;\n            sendResponse(response?: unknown): void;\n        };\n    }\n}\n\ndeclare module 'test/types/Extension' {\n    export interface Extension {\n        id: string;\n        name: string;\n        shortName?: string;\n        iconUrl?: string;\n        color?: string;\n    }\n}\n\ndeclare module 'test/types/ExtensionMessage' {\n    import { ExtensionMessageTarget } from 'test/';\n    export interface ExtensionMessage<T, U = unknown> {\n        target: ExtensionMessageTarget;\n        targetId?: string;\n        sender?: U;\n        payload: T;\n    }\n    export interface EncryptedExtensionMessage<U = unknown> {\n        target: ExtensionMessageTarget;\n        targetId?: string;\n        sender?: U;\n        encryptedPayload: string;\n    }\n}\n\ndeclare module 'test/types/ExtensionMessageTarget' {\n    export enum ExtensionMessageTarget {\n        BACKGROUND = \"toBackground\",\n        PAGE = \"toPage\",\n        EXTENSION = \"toExtension\"\n    }\n}\n\ndeclare module 'test/types/Origin' {\n    export enum Origin {\n        WEBSITE = \"website\",\n        EXTENSION = \"extension\",\n        P2P = \"p2p\"\n    }\n}\n\ndeclare module 'test/types/P2PPairingRequest' {\n    import { PeerInfo } from 'test/types/PeerInfo';\n    export interface P2PPairingRequest extends PeerInfo {\n        id: string;\n        type: 'p2p-pairing-request';\n        name: string;\n        publicKey: string;\n        relayServer: string;\n        icon?: string;\n        appUrl?: string;\n    }\n    export type ExtendedP2PPairingRequest = P2PPairingRequest & {\n        senderId: string;\n    };\n}\n\ndeclare module 'test/types/P2PPairingResponse' {\n    import { PeerInfo } from 'test/types/PeerInfo';\n    export interface P2PPairingResponse extends PeerInfo {\n        id: string;\n        type: 'p2p-pairing-response';\n        name: string;\n        publicKey: string;\n        relayServer: string;\n        icon?: string;\n        appUrl?: string;\n    }\n    export type ExtendedP2PPairingResponse = P2PPairingResponse & {\n        senderId: string;\n    };\n}\n\ndeclare module 'test/types/PeerInfo' {\n    export interface PeerInfo {\n        name: string;\n        publicKey: string;\n        version: string;\n    }\n    export type ExtendedPeerInfo = PeerInfo & {\n        senderId: string;\n    };\n}\n\ndeclare module 'test/types/PermissionEntity' {\n    import { Network, PermissionScope, Threshold } from 'test/';\n    export interface PermissionEntity {\n        address: string;\n        network: Network;\n        scopes: PermissionScope[];\n        threshold?: Threshold;\n    }\n}\n\ndeclare module 'test/types/PermissionInfo' {\n    import { AppMetadata } from 'test/';\n    import { PermissionEntity } from 'test/types/PermissionEntity';\n    export interface PermissionInfo extends PermissionEntity {\n        accountIdentifier: string;\n        senderId: string;\n        appMetadata: AppMetadata;\n        website: string;\n        publicKey: string;\n        connectedAt: number;\n    }\n}\n\ndeclare module 'test/types/PostMessagePairingRequest' {\n    import { PeerInfo } from 'test/types/PeerInfo';\n    export interface PostMessagePairingRequest extends PeerInfo {\n        id: string;\n        type: 'postmessage-pairing-request';\n        name: string;\n        publicKey: string;\n        icon?: string;\n        appUrl?: string;\n    }\n    export type ExtendedPostMessagePairingRequest = PostMessagePairingRequest & {\n        senderId: string;\n    };\n}\n\ndeclare module 'test/types/PostMessagePairingResponse' {\n    import { PeerInfo } from 'test/types/PeerInfo';\n    export interface PostMessagePairingResponse extends PeerInfo {\n        id: string;\n        type: 'postmessage-pairing-response';\n        name: string;\n        publicKey: string;\n        icon?: string;\n        appUrl?: string;\n    }\n    export type ExtendedPostMessagePairingResponse = PostMessagePairingResponse & {\n        senderId: string;\n        extensionId: string;\n    };\n}\n\ndeclare module 'test/types/RequestBroadcastInput' {\n    import { Network } from 'test/';\n    export interface RequestBroadcastInput {\n        network?: Network;\n        signedTransaction: string;\n    }\n}\n\ndeclare module 'test/types/RequestOperationInput' {\n    import { PartialTezosOperation } from 'test/types/tezos/PartialTezosOperation';\n    export interface RequestOperationInput {\n        operationDetails: PartialTezosOperation[];\n    }\n}\n\ndeclare module 'test/types/RequestPermissionInput' {\n    import { Network, PermissionScope } from 'test/';\n    export interface RequestPermissionInput {\n        network?: Network;\n        scopes?: PermissionScope[];\n    }\n}\n\ndeclare module 'test/types/RequestSignPayloadInput' {\n    import { SigningType } from 'test/';\n    export interface RequestSignPayloadInput {\n        signingType?: SigningType;\n        payload: string;\n        sourceAddress?: string;\n    }\n}\n\ndeclare module 'test/types/storage/StorageKey' {\n    export enum StorageKey {\n        TRANSPORT_P2P_PEERS_DAPP = \"beacon:communication-peers-dapp\",\n        TRANSPORT_P2P_PEERS_WALLET = \"beacon:communication-peers-wallet\",\n        TRANSPORT_POSTMESSAGE_PEERS_DAPP = \"beacon:postmessage-peers-dapp\",\n        TRANSPORT_POSTMESSAGE_PEERS_WALLET = \"beacon:postmessage-peers-wallet\",\n        ACCOUNTS = \"beacon:accounts\",\n        ACTIVE_ACCOUNT = \"beacon:active-account\",\n        ACTIVE_PEER = \"beacon:active-peer\",\n        BEACON_SDK_SECRET_SEED = \"beacon:sdk-secret-seed\",\n        APP_METADATA_LIST = \"beacon:app-metadata-list\",\n        PERMISSION_LIST = \"beacon:permissions\",\n        BEACON_SDK_VERSION = \"beacon:sdk_version\",\n        MATRIX_PRESERVED_STATE = \"beacon:sdk-matrix-preserved-state\",\n        MATRIX_PEER_ROOM_IDS = \"beacon:matrix-peer-rooms\"\n    }\n}\n\ndeclare module 'test/types/storage/StorageKeyReturnDefaults' {\n    import { StorageKey, StorageKeyReturnType } from 'test/';\n    export type StorageKeyReturnDefaults = {\n        [key in StorageKey]: StorageKeyReturnType[key];\n    };\n    export const defaultValues: StorageKeyReturnDefaults;\n}\n\ndeclare module 'test/types/storage/StorageKeyReturnType' {\n    import { StorageKey, AccountInfo, AccountIdentifier, P2PPairingRequest, AppMetadata, PermissionInfo } from 'test/';\n    import { MatrixState } from 'test/matrix-client/MatrixClientStore';\n    import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n    import { PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n    import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n    export interface StorageKeyReturnType {\n        [StorageKey.TRANSPORT_P2P_PEERS_DAPP]: P2PPairingRequest[];\n        [StorageKey.TRANSPORT_P2P_PEERS_WALLET]: ExtendedP2PPairingResponse[];\n        [StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP]: PostMessagePairingRequest[];\n        [StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET]: ExtendedPostMessagePairingResponse[];\n        [StorageKey.ACCOUNTS]: AccountInfo[];\n        [StorageKey.ACTIVE_ACCOUNT]: AccountIdentifier | undefined;\n        [StorageKey.ACTIVE_PEER]: string | undefined;\n        [StorageKey.BEACON_SDK_SECRET_SEED]: string | undefined;\n        [StorageKey.APP_METADATA_LIST]: AppMetadata[];\n        [StorageKey.PERMISSION_LIST]: PermissionInfo[];\n        [StorageKey.BEACON_SDK_VERSION]: string | undefined;\n        [StorageKey.MATRIX_PRESERVED_STATE]: Partial<MatrixState>;\n        [StorageKey.MATRIX_PEER_ROOM_IDS]: {\n            [key: string]: string | undefined;\n        };\n    }\n}\n\ndeclare module 'test/types/tezos/MichelineMichelsonV1Expression' {\n    import { MichelsonPrimitives } from 'test/';\n    export type MichelineMichelsonV1Expression = {\n        int: string;\n    } | {\n        string: string;\n    } | {\n        bytes: string;\n    } | MichelineMichelsonV1Expression[] | {\n        prim: MichelsonPrimitives;\n        args?: MichelineMichelsonV1Expression[];\n        annots?: string[];\n    };\n}\n\ndeclare module 'test/types/tezos/MichelsonPrimitives' {\n    export type MichelsonPrimitives = 'ADD' | 'IF_NONE' | 'SWAP' | 'set' | 'nat' | 'CHECK_SIGNATURE' | 'IF_LEFT' | 'LAMBDA' | 'Elt' | 'CREATE_CONTRACT' | 'NEG' | 'big_map' | 'map' | 'or' | 'BLAKE2B' | 'bytes' | 'SHA256' | 'SET_DELEGATE' | 'CONTRACT' | 'LSL' | 'SUB' | 'IMPLICIT_ACCOUNT' | 'PACK' | 'list' | 'PAIR' | 'Right' | 'contract' | 'GT' | 'LEFT' | 'STEPS_TO_QUOTA' | 'storage' | 'TRANSFER_TOKENS' | 'CDR' | 'SLICE' | 'PUSH' | 'False' | 'SHA512' | 'CHAIN_ID' | 'BALANCE' | 'signature' | 'DUG' | 'SELF' | 'EMPTY_BIG_MAP' | 'LSR' | 'OR' | 'XOR' | 'lambda' | 'COMPARE' | 'key' | 'option' | 'Unit' | 'Some' | 'UNPACK' | 'NEQ' | 'INT' | 'pair' | 'AMOUNT' | 'DIP' | 'ABS' | 'ISNAT' | 'EXEC' | 'NOW' | 'LOOP' | 'chain_id' | 'string' | 'MEM' | 'MAP' | 'None' | 'address' | 'CONCAT' | 'EMPTY_SET' | 'MUL' | 'LOOP_LEFT' | 'timestamp' | 'LT' | 'UPDATE' | 'DUP' | 'SOURCE' | 'mutez' | 'SENDER' | 'IF_CONS' | 'RIGHT' | 'CAR' | 'CONS' | 'LE' | 'NONE' | 'IF' | 'SOME' | 'GET' | 'Left' | 'CAST' | 'int' | 'SIZE' | 'key_hash' | 'unit' | 'DROP' | 'EMPTY_MAP' | 'NIL' | 'DIG' | 'APPLY' | 'bool' | 'RENAME' | 'operation' | 'True' | 'FAILWITH' | 'parameter' | 'HASH_KEY' | 'EQ' | 'NOT' | 'UNIT' | 'Pair' | 'ADDRESS' | 'EDIV' | 'CREATE_ACCOUNT' | 'GE' | 'ITER' | 'code' | 'AND';\n}\n\ndeclare module 'test/types/tezos/operations/ActivateAccount' {\n    import { TezosBaseOperation, TezosOperationType } from 'test/';\n    export interface TezosActivateAccountOperation extends TezosBaseOperation {\n        kind: TezosOperationType.ACTIVATE_ACCOUNT;\n        pkh: string;\n        secret: string;\n    }\n}\n\ndeclare module 'test/types/tezos/operations/Ballot' {\n    import { TezosBaseOperation, TezosOperationType } from 'test/';\n    export interface TezosBallotOperation extends TezosBaseOperation {\n        kind: TezosOperationType.BALLOT;\n        source: string;\n        period: string;\n        proposal: string;\n        ballot: 'nay' | 'yay' | 'pass';\n    }\n}\n\ndeclare module 'test/types/tezos/operations/Delegation' {\n    import { TezosBaseOperation, TezosOperationType } from 'test/';\n    export interface TezosDelegationOperation extends TezosBaseOperation {\n        kind: TezosOperationType.DELEGATION;\n        source: string;\n        fee: string;\n        counter: string;\n        gas_limit: string;\n        storage_limit: string;\n        delegate?: string;\n    }\n}\n\ndeclare module 'test/types/tezos/operations/DoubleBakingEvidence' {\n    import { TezosBaseOperation, TezosOperationType, TezosBlockHeader } from 'test/';\n    export interface InlinedEndorsement {\n        branch: string;\n        operations: InlinedEndorsementContents;\n        signature?: string;\n    }\n    export interface InlinedEndorsementContents {\n        kind: 'endorsement';\n        level: string;\n    }\n    export interface TezosDoubleBakingEvidenceOperation extends TezosBaseOperation {\n        kind: TezosOperationType.DOUBLE_BAKING_EVIDENCE;\n        bh1: TezosBlockHeader;\n        bh2: TezosBlockHeader;\n    }\n}\n\ndeclare module 'test/types/tezos/operations/DoubleEndorsementEvidence' {\n    import { TezosBaseOperation, TezosOperationType } from 'test/';\n    export interface InlinedEndorsement {\n        branch: string;\n        operations: InlinedEndorsementContents;\n        signature?: string;\n    }\n    export interface InlinedEndorsementContents {\n        kind: 'endorsement';\n        level: string;\n    }\n    export interface TezosDoubleEndorsementEvidenceOperation extends TezosBaseOperation {\n        kind: TezosOperationType.DOUBLE_ENDORSEMENT_EVIDENCE;\n        op1: InlinedEndorsement;\n        op2: InlinedEndorsement;\n    }\n}\n\ndeclare module 'test/types/tezos/operations/Endorsement' {\n    import { TezosBaseOperation, TezosOperationType } from 'test/';\n    export interface TezosEndorsementOperation extends TezosBaseOperation {\n        kind: TezosOperationType.ENDORSEMENT;\n        level: string;\n    }\n}\n\ndeclare module 'test/types/tezos/operations/Origination' {\n    import { TezosBaseOperation, TezosOperationType } from 'test/';\n    export interface TezosOriginationOperation extends TezosBaseOperation {\n        kind: TezosOperationType.ORIGINATION;\n        source: string;\n        fee: string;\n        counter: string;\n        gas_limit: string;\n        storage_limit: string;\n        balance: string;\n        delegate?: string;\n        script: string;\n    }\n}\n\ndeclare module 'test/types/tezos/operations/Proposal' {\n    import { TezosBaseOperation, TezosOperationType } from 'test/';\n    export interface TezosProposalOperation extends TezosBaseOperation {\n        kind: TezosOperationType.PROPOSALS;\n        period: string;\n        proposals: string[];\n    }\n}\n\ndeclare module 'test/types/tezos/operations/Reveal' {\n    import { TezosBaseOperation, TezosOperationType } from 'test/';\n    export interface TezosRevealOperation extends TezosBaseOperation {\n        kind: TezosOperationType.REVEAL;\n        source: string;\n        fee: string;\n        counter: string;\n        gas_limit: string;\n        storage_limit: string;\n        public_key: string;\n    }\n}\n\ndeclare module 'test/types/tezos/operations/SeedNonceRevelation' {\n    import { TezosBaseOperation, TezosOperationType } from 'test/';\n    export interface TezosSeedNonceRevelationOperation extends TezosBaseOperation {\n        kind: TezosOperationType.SEED_NONCE_REVELATION;\n        level: string;\n        nonce: string;\n    }\n}\n\ndeclare module 'test/types/tezos/operations/Transaction' {\n    import { TezosBaseOperation, TezosOperationType, TezosTransactionParameters } from 'test/';\n    export interface TezosTransactionOperation extends TezosBaseOperation {\n        kind: TezosOperationType.TRANSACTION;\n        source: string;\n        fee: string;\n        counter: string;\n        gas_limit: string;\n        storage_limit: string;\n        amount: string;\n        destination: string;\n        parameters?: TezosTransactionParameters;\n    }\n}\n\ndeclare module 'test/types/tezos/OperationTypes' {\n    export enum TezosOperationType {\n        ENDORSEMENT = \"endorsement\",\n        SEED_NONCE_REVELATION = \"seed_nonce_revelation\",\n        DOUBLE_ENDORSEMENT_EVIDENCE = \"double_endorsement_evidence\",\n        DOUBLE_BAKING_EVIDENCE = \"double_baking_evidence\",\n        ACTIVATE_ACCOUNT = \"activate_account\",\n        PROPOSALS = \"proposals\",\n        BALLOT = \"ballot\",\n        REVEAL = \"reveal\",\n        TRANSACTION = \"transaction\",\n        ORIGINATION = \"origination\",\n        DELEGATION = \"delegation\"\n    }\n}\n\ndeclare module 'test/types/tezos/PartialTezosOperation' {\n    import { TezosActivateAccountOperation } from 'test/types/tezos/operations/ActivateAccount';\n    import { TezosBallotOperation } from 'test/types/tezos/operations/Ballot';\n    import { TezosDelegationOperation } from 'test/types/tezos/operations/Delegation';\n    import { TezosDoubleBakingEvidenceOperation } from 'test/types/tezos/operations/DoubleBakingEvidence';\n    import { TezosEndorsementOperation } from 'test/types/tezos/operations/Endorsement';\n    import { TezosOriginationOperation } from 'test/types/tezos/operations/Origination';\n    import { TezosProposalOperation } from 'test/types/tezos/operations/Proposal';\n    import { TezosRevealOperation } from 'test/types/tezos/operations/Reveal';\n    import { TezosSeedNonceRevelationOperation } from 'test/types/tezos/operations/SeedNonceRevelation';\n    import { TezosTransactionOperation } from 'test/types/tezos/operations/Transaction';\n    type omittedProperties = 'source' | 'fee' | 'counter' | 'gas_limit' | 'storage_limit';\n    export type PartialTezosDelegationOperation = Omit<TezosDelegationOperation, omittedProperties>;\n    export type PartialTezosOriginationOperation = Omit<TezosOriginationOperation, omittedProperties>;\n    export type PartialTezosRevealOperation = Omit<TezosRevealOperation, omittedProperties>;\n    export type PartialTezosTransactionOperation = Omit<TezosTransactionOperation, omittedProperties>;\n    export type PartialTezosOperation = TezosActivateAccountOperation | TezosBallotOperation | PartialTezosDelegationOperation | TezosDoubleBakingEvidenceOperation | TezosEndorsementOperation | PartialTezosOriginationOperation | TezosProposalOperation | PartialTezosRevealOperation | TezosSeedNonceRevelationOperation | PartialTezosTransactionOperation;\n    export {};\n}\n\ndeclare module 'test/types/tezos/TezosBaseOperation' {\n    import { TezosOperationType } from 'test/';\n    export interface TezosBaseOperation {\n        kind: TezosOperationType;\n    }\n}\n\ndeclare module 'test/types/tezos/TezosBlockHeader' {\n    export interface TezosBlockHeader {\n        level: number;\n        proto: number;\n        predecessor: string;\n        timestamp: string;\n        validation_pass: number;\n        operations_hash: string;\n        fitness: string[];\n        context: string;\n        priority: number;\n        proof_of_work_nonce: string;\n        signature: string;\n    }\n}\n\ndeclare module 'test/types/tezos/TezosOperation' {\n    import { TezosActivateAccountOperation, TezosBallotOperation, TezosDelegationOperation, TezosDoubleBakingEvidenceOperation, TezosEndorsementOperation, TezosOriginationOperation, TezosProposalOperation, TezosRevealOperation, TezosSeedNonceRevelationOperation, TezosTransactionOperation } from 'test/';\n    export type TezosOperation = TezosActivateAccountOperation | TezosBallotOperation | TezosDelegationOperation | TezosDoubleBakingEvidenceOperation | TezosEndorsementOperation | TezosOriginationOperation | TezosProposalOperation | TezosRevealOperation | TezosSeedNonceRevelationOperation | TezosTransactionOperation;\n}\n\ndeclare module 'test/types/tezos/TezosTransactionParameters' {\n    import { MichelineMichelsonV1Expression } from 'test/types/tezos/MichelineMichelsonV1Expression';\n    export interface TezosTransactionParameters {\n        entrypoint: 'default' | 'root' | 'do' | 'set_delegate' | 'remove_delegate' | string;\n        value: MichelineMichelsonV1Expression;\n    }\n}\n\ndeclare module 'test/types/transport/TransportStatus' {\n    export enum TransportStatus {\n        NOT_CONNECTED = \"NOT_CONNECTED\",\n        CONNECTING = \"CONNECTING\",\n        CONNECTED = \"CONNECTED\"\n    }\n}\n\ndeclare module 'test/types/transport/TransportType' {\n    export enum TransportType {\n        CHROME_MESSAGE = \"chrome_message\",\n        POST_MESSAGE = \"post_message\",\n        LEDGER = \"ledger\",\n        P2P = \"p2p\"\n    }\n}\n\ndeclare module 'test/ui/alert/alert-templates' {\n    export const alertTemplates: {\n        container: string;\n        default: {\n            html: string;\n            css: string;\n        };\n        pair: {\n            html: string;\n            css: string;\n        };\n    };\n}\n\ndeclare module 'test/ui/alert/Alert' {\n    import { NetworkType } from 'test/';\n    export interface AlertButton {\n            text: string;\n            style?: 'solid' | 'outline';\n            actionCallback?(): Promise<void>;\n    }\n    export interface AlertConfig {\n            title: string;\n            body?: string;\n            timer?: number;\n            buttons?: AlertButton[];\n            pairingPayload?: {\n                    p2pSyncCode: string;\n                    postmessageSyncCode: string;\n                    preferredNetwork: NetworkType;\n            };\n            closeButtonCallback?(): void;\n    }\n    /**\n        * Close an alert by ID\n        *\n        * @param id ID of alert\n        */\n    const closeAlert: (id: string) => Promise<void>;\n    /**\n        * Close all alerts\n        */\n    const closeAlerts: () => Promise<void>;\n    /**\n        * Show an alert\n        *\n        * @param alertConfig The configuration of the alert\n        */\n    const openAlert: (alertConfig: AlertConfig) => Promise<string>;\n    export { closeAlert, closeAlerts, openAlert };\n}\n\ndeclare module 'test/ui/alert/Pairing' {\n    import { NetworkType } from 'test/';\n    export enum Platform {\n        DESKTOP = 0,\n        IOS = 1,\n        ANDROID = 2\n    }\n    export enum WalletType {\n        IOS = \"ios\",\n        ANDROID = \"android\",\n        EXTENSION = \"extension\",\n        DESKTOP = \"desktop\",\n        WEB = \"web\"\n    }\n    export interface AppBase {\n        name: string;\n        shortName: string;\n        color: string;\n        logo: string;\n    }\n    export interface ExtensionApp extends AppBase {\n        id: string;\n        link: string;\n    }\n    export interface WebApp extends AppBase {\n        links: {\n            [NetworkType.MAINNET]: string;\n            [NetworkType.DELPHINET]?: string;\n            [NetworkType.EDONET]?: string;\n            [NetworkType.CUSTOM]?: string;\n        };\n    }\n    export interface DesktopApp extends AppBase {\n        deepLink: string;\n    }\n    export interface App extends AppBase {\n        universalLink: string;\n        deepLink?: string;\n    }\n    export interface PairingAlertWallet {\n        name: string;\n        shortName?: string;\n        color?: string;\n        logo?: string;\n        enabled: boolean;\n        clickHandler(): void;\n    }\n    export interface PairingAlertButton {\n        title: string;\n        text: string;\n        clickHandler(): void;\n    }\n    export interface PairingAlertList {\n        title: string;\n        type: WalletType;\n        wallets: PairingAlertWallet[];\n    }\n    export interface PairingAlertInfo {\n        walletLists: PairingAlertList[];\n        buttons: PairingAlertButton[];\n        qrData: string;\n    }\n    export type StatusUpdateHandler = (walletType: WalletType, app?: PairingAlertWallet) => void;\n    export class Pairing {\n        static getPlatfrom(): Promise<Platform>;\n        static getPairingInfo(pairingPayload: {\n            p2pSyncCode: string;\n            postmessageSyncCode: string;\n            preferredNetwork: NetworkType;\n        }, statusUpdateHandler: StatusUpdateHandler, platform?: Platform): Promise<PairingAlertInfo>;\n    }\n}\n\ndeclare module 'test/ui/alert/PairingAlert' {\n    import { NetworkType } from 'test/';\n    export const preparePairingAlert: (shadowRoot: ShadowRoot, pairingPayload: {\n        p2pSyncCode: string;\n        postmessageSyncCode: string;\n        preferredNetwork: NetworkType;\n    }) => Promise<void>;\n}\n\ndeclare module 'test/ui/alert/wallet-lists' {\n    import { App, DesktopApp, ExtensionApp, WebApp } from 'test/ui/alert/Pairing';\n    export const extensionList: ExtensionApp[];\n    export const desktopList: DesktopApp[];\n    export const webList: WebApp[];\n    export const iOSList: App[];\n}\n\ndeclare module 'test/ui/toast/toast-templates' {\n    export const toastTemplates: {\n        default: {\n            html: string;\n            css: string;\n            poweredByBeacon: string;\n        };\n    };\n}\n\ndeclare module 'test/ui/toast/Toast' {\n    import { WalletInfo } from 'test/events';\n    export interface ToastAction {\n            text: string;\n            actionText?: string;\n            actionCallback?(): Promise<void>;\n    }\n    export interface ToastConfig {\n            body: string;\n            timer?: number;\n            forceNew?: boolean;\n            state: 'loading' | 'acknowledge' | 'finished';\n            actions?: ToastAction[];\n            walletInfo?: WalletInfo;\n    }\n    /**\n        * Close a toast\n        */\n    const closeToast: () => Promise<void>;\n    /**\n        * Create a new toast\n        *\n        * @param toastConfig Configuration of the toast\n        */\n    const openToast: (toastConfig: ToastConfig) => Promise<void>;\n    export { closeToast, openToast };\n}\n\ndeclare module 'test/utils/assert-never' {\n    /**\n      * A helper function to make sure if/elses and switch/cases are exhaustive\n      *\n      * @param empty The data that has to be empty\n      */\n    export function assertNever(empty: never): never;\n}\n\ndeclare module 'test/utils/available-transports' {\n    /**\n      * An object with promises to indicate whether or not that transport is available.\n      */\n    export const availableTransports: {\n        extension: Promise<boolean>;\n        availableExtensions: Promise<import(\"../types/Extension\").Extension[]>;\n    };\n}\n\ndeclare module 'test/utils/block-explorer' {\n    import { Network, NetworkType } from 'test/';\n    export abstract class BlockExplorer {\n            readonly rpcUrls: {\n                    [key in NetworkType]: string;\n            };\n            constructor(rpcUrls: {\n                    [key in NetworkType]: string;\n            });\n            protected getLinkForNetwork(network: Network): Promise<string>;\n            /**\n                * Return a blockexplorer link for an address\n                *\n                * @param address The address to be opened\n                * @param network The network that was used\n                */\n            abstract getAddressLink(address: string, network: Network): Promise<string>;\n            /**\n                * Return a blockexplorer link for a transaction hash\n                *\n                * @param transactionId The hash of the transaction\n                * @param network The network that was used\n                */\n            abstract getTransactionLink(transactionId: string, network: Network): Promise<string>;\n    }\n}\n\ndeclare module 'test/utils/crypto' {\n    import * as sodium from 'libsodium-wrappers';\n    /**\n        * Convert a value to hex\n        *\n        * @param value\n        */\n    export function toHex(value: any): string;\n    /**\n        * Get the hex hash of a value\n        *\n        * @param key\n        */\n    export function getHexHash(key: string | Buffer | Uint8Array): Promise<string>;\n    /**\n        * Get a keypair from a seed\n        *\n        * @param seed\n        */\n    export function getKeypairFromSeed(seed: string): Promise<sodium.KeyPair>;\n    /**\n        * Encrypt a message with a shared key\n        *\n        * @param message\n        * @param sharedKey\n        */\n    export function encryptCryptoboxPayload(message: string, sharedKey: Uint8Array): Promise<string>;\n    /**\n        * Decrypt a message with a shared key\n        *\n        * @param payload\n        * @param sharedKey\n        */\n    export function decryptCryptoboxPayload(payload: Uint8Array, sharedKey: Uint8Array): Promise<string>;\n    /**\n        * Encrypt a message with a public key\n        *\n        * @param payload\n        * @param publicKey\n        */\n    export function sealCryptobox(payload: string | Buffer, publicKey: Uint8Array): Promise<string>;\n    /**\n        * Decrypt a message with public + private key\n        *\n        * @param encryptedPayload\n        * @param publicKey\n        * @param privateKey\n        */\n    export function openCryptobox(encryptedPayload: string | Buffer, publicKey: Uint8Array, privateKey: Uint8Array): Promise<string>;\n    /**\n        * Get an address from the public key\n        *\n        * @param publicKey\n        */\n    export function getAddressFromPublicKey(publicKey: string): Promise<string>;\n    /**\n        * Get the recipient string used in the matrix message\n        *\n        * @param recipientHash\n        * @param relayServer\n        */\n    export function recipientString(recipientHash: string, relayServer: string): string;\n}\n\ndeclare module 'test/utils/exposed-promise' {\n    export enum ExposedPromiseStatus {\n        PENDING = \"pending\",\n        RESOLVED = \"resolved\",\n        REJECTED = \"rejected\"\n    }\n    type Resolve<T> = (value?: T) => void;\n    type Reject<U> = (reason?: U) => void;\n    /**\n      * Exposed promise allow you to create a promise and then resolve it later, from the outside\n      */\n    export class ExposedPromise<T = unknown, U = unknown> {\n        get promise(): Promise<T>;\n        get resolve(): Resolve<T>;\n        get reject(): Reject<U>;\n        get status(): ExposedPromiseStatus;\n        get promiseResult(): T | undefined;\n        get promiseError(): U | undefined;\n        constructor();\n        static resolve<T>(value?: T): ExposedPromise<T>;\n        static reject<T = never, U = unknown>(reason?: U): ExposedPromise<T, U>;\n        isPending(): boolean;\n        isResolved(): boolean;\n        isRejected(): boolean;\n        isSettled(): boolean;\n    }\n    export {};\n}\n\ndeclare module 'test/utils/generate-uuid' {\n    /**\n      * Generate a random GUID\n      */\n    export function generateGUID(): Promise<string>;\n}\n\ndeclare module 'test/utils/get-account-identifier' {\n    import { Network } from 'test/';\n    /**\n      * Generate a deterministic account identifier based on an address and a network\n      *\n      * @param address\n      * @param network\n      */\n    export const getAccountIdentifier: (address: string, network: Network) => Promise<string>;\n}\n\ndeclare module 'test/utils/get-sender-id' {\n    /**\n      * Generate a deterministic sender identifier based on a public key\n      *\n      * @param publicKey\n      */\n    export const getSenderId: (publicKey: string) => Promise<string>;\n}\n\ndeclare module 'test/utils/get-tzip10-link' {\n    export const getTzip10Link: (url: string, payload: string) => string;\n}\n\ndeclare module 'test/utils/Logger' {\n    /**\n      * The logger that is used internally\n      */\n    export class Logger {\n        constructor(service: string);\n        debug(method: string, ...args: any[]): void;\n        log(method: string, ...args: any[]): void;\n        warn(method: string, ...args: any[]): void;\n        error(method: string, ...args: any[]): void;\n    }\n}\n\ndeclare module 'test/utils/platform' {\n    export const testUserAgent: (win: Window, expr: RegExp) => boolean;\n    export const isMobile: (win: Window) => boolean;\n    export const isIOS: (win: Window) => boolean;\n    export const isAndroid: (win: Window) => boolean;\n    export const isDesktop: (win: Window) => boolean;\n}\n\ndeclare module 'test/utils/qr' {\n    /**\n      * Convert data to a QR code\n      *\n      * @param payload The data to be encoded as a QR code\n      * @param type How the QR code will be encoded\n      */\n    export const getQrData: (payload: string, type?: \"data\" | \"svg\" | \"ascii\" | undefined) => string;\n}\n\ndeclare module 'test/utils/replace-in-template' {\n    export const replaceInTemplate: (text: string, placeholder: string, value: string) => string;\n}\n\ndeclare module 'test/utils/shorten-string' {\n    export const shortenString: (text: string) => string;\n}\n\ndeclare module 'test/utils/tezblock-blockexplorer' {\n    import { Network, NetworkType } from 'test/';\n    import { BlockExplorer } from 'test/utils/block-explorer';\n    export class TezblockBlockExplorer extends BlockExplorer {\n        readonly rpcUrls: {\n            [key in NetworkType]: string;\n        };\n        constructor(rpcUrls?: {\n            [key in NetworkType]: string;\n        });\n        getAddressLink(address: string, network: Network): Promise<string>;\n        getTransactionLink(transactionId: string, network: Network): Promise<string>;\n    }\n}\n\ndeclare module 'test/utils/utils' {\n    /**\n      * A helper function to improve typings of object keys\n      *\n      * @param obj Object\n      */\n    export function keys<O extends object>(obj: O): (keyof O)[];\n}\n\ndeclare module 'test/' {\n    import { P2PCommunicationClient } from 'test/transports/clients/P2PCommunicationClient';\n    import { AppMetadata } from 'test/types/beacon/AppMetadata';\n    import { PermissionRequest } from 'test/types/beacon/messages/PermissionRequest';\n    import { Network } from 'test/types/beacon/Network';\n    import { BeaconBaseMessage } from 'test/types/beacon/BeaconBaseMessage';\n    import { BeaconMessageType } from 'test/types/beacon/BeaconMessageType';\n    import { PermissionScope } from 'test/types/beacon/PermissionScope';\n    import { PermissionResponse } from 'test/types/beacon/messages/PermissionResponse';\n    import { OperationRequest } from 'test/types/beacon/messages/OperationRequest';\n    import { OperationResponse } from 'test/types/beacon/messages/OperationResponse';\n    import { SignPayloadRequest } from 'test/types/beacon/messages/SignPayloadRequest';\n    import { SignPayloadResponse } from 'test/types/beacon/messages/SignPayloadResponse';\n    import { BroadcastRequest } from 'test/types/beacon/messages/BroadcastRequest';\n    import { BroadcastResponse } from 'test/types/beacon/messages/BroadcastResponse';\n    import { NetworkType } from 'test/types/beacon/NetworkType';\n    import { TezosBaseOperation } from 'test/types/tezos/TezosBaseOperation';\n    import { TezosOperationType } from 'test/types/tezos/OperationTypes';\n    import { TezosActivateAccountOperation } from 'test/types/tezos/operations/ActivateAccount';\n    import { TezosBallotOperation } from 'test/types/tezos/operations/Ballot';\n    import { TezosDelegationOperation } from 'test/types/tezos/operations/Delegation';\n    import { TezosDoubleBakingEvidenceOperation } from 'test/types/tezos/operations/DoubleBakingEvidence';\n    import { TezosBlockHeader } from 'test/types/tezos/TezosBlockHeader';\n    import { TezosDoubleEndorsementEvidenceOperation } from 'test/types/tezos/operations/DoubleEndorsementEvidence';\n    import { TezosEndorsementOperation } from 'test/types/tezos/operations/Endorsement';\n    import { TezosOriginationOperation } from 'test/types/tezos/operations/Origination';\n    import { TezosProposalOperation } from 'test/types/tezos/operations/Proposal';\n    import { TezosRevealOperation } from 'test/types/tezos/operations/Reveal';\n    import { TezosSeedNonceRevelationOperation } from 'test/types/tezos/operations/SeedNonceRevelation';\n    import { TezosTransactionOperation } from 'test/types/tezos/operations/Transaction';\n    import { MichelsonPrimitives } from 'test/types/tezos/MichelsonPrimitives';\n    import { TezosTransactionParameters } from 'test/types/tezos/TezosTransactionParameters';\n    import { Origin } from 'test/types/Origin';\n    import { AccountInfo, AccountIdentifier } from 'test/types/AccountInfo';\n    import { EncryptedExtensionMessage, ExtensionMessage } from 'test/types/ExtensionMessage';\n    import { ExtensionMessageTarget } from 'test/types/ExtensionMessageTarget';\n    import { TezosOperation } from 'test/types/tezos/TezosOperation';\n    import { Client } from 'test/clients/client/Client';\n    import { WalletClient } from 'test/clients/wallet-client/WalletClient';\n    import { DAppClient } from 'test/clients/dapp-client/DAppClient';\n    import { BeaconError } from 'test/errors/BeaconError';\n    import { BeaconErrorType } from 'test/types/BeaconErrorType';\n    import { BroadcastBeaconError } from 'test/errors/BroadcastBeaconError';\n    import { NetworkNotSupportedBeaconError } from 'test/errors/NetworkNotSupportedBeaconError';\n    import { NoAddressBeaconError } from 'test/errors/NoAddressBeaconError';\n    import { NoPrivateKeyBeaconError } from 'test/errors/NoPrivateKeyBeaconError';\n    import { NotGrantedBeaconError } from 'test/errors/NotGrantedBeaconError';\n    import { ParametersInvalidBeaconError } from 'test/errors/ParametersInvalidBeaconError';\n    import { TooManyOperationsBeaconError } from 'test/errors/TooManyOperationsBeaconError';\n    import { TransactionInvalidBeaconError } from 'test/errors/TransactionInvalidBeaconError';\n    import { UnknownBeaconError } from 'test/errors/UnknownBeaconError';\n    import { ErrorResponse } from 'test/types/beacon/messages/ErrorResponse';\n    import { TransportStatus } from 'test/types/transport/TransportStatus';\n    import { TransportType } from 'test/types/transport/TransportType';\n    import { PostMessageTransport } from 'test/transports/PostMessageTransport';\n    import { Transport } from 'test/transports/Transport';\n    import { P2PTransport } from 'test/transports/P2PTransport';\n    import { Storage } from 'test/storage/Storage';\n    import { StorageKey } from 'test/types/storage/StorageKey';\n    import { StorageKeyReturnDefaults } from 'test/types/storage/StorageKeyReturnDefaults';\n    import { StorageKeyReturnType } from 'test/types/storage/StorageKeyReturnType';\n    import { ExtendedP2PPairingRequest, P2PPairingRequest } from 'test/types/P2PPairingRequest';\n    import { ChromeStorage } from 'test/storage/ChromeStorage';\n    import { LocalStorage } from 'test/storage/LocalStorage';\n    import { getStorage } from 'test/storage/getStorage';\n    import { BeaconMessage } from 'test/types/beacon/BeaconMessage';\n    import { Serializer } from 'test/Serializer';\n    import { RequestPermissionInput } from 'test/types/RequestPermissionInput';\n    import { RequestSignPayloadInput } from 'test/types/RequestSignPayloadInput';\n    import { RequestOperationInput } from 'test/types/RequestOperationInput';\n    import { RequestBroadcastInput } from 'test/types/RequestBroadcastInput';\n    import { PermissionResponseInput, SignPayloadResponseInput, OperationResponseInput, BroadcastResponseInput, BeaconResponseInputMessage, AcknowledgeResponseInput, ErrorResponseInput } from 'test/types/beacon/messages/BeaconResponseInputMessage';\n    import { PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, BeaconResponseOutputMessage } from 'test/types/beacon/messages/BeaconResponseOutputMessage';\n    import { PermissionRequestInput, SignPayloadRequestInput, OperationRequestInput, BroadcastRequestInput, BeaconRequestInputMessage } from 'test/types/beacon/messages/BeaconRequestInputMessage';\n    import { PermissionRequestOutput, SignPayloadRequestOutput, OperationRequestOutput, BroadcastRequestOutput, BeaconRequestOutputMessage } from 'test/types/beacon/messages/BeaconRequestOutputMessage';\n    import { ClientOptions } from 'test/clients/client/ClientOptions';\n    import { DAppClientOptions } from 'test/clients/dapp-client/DAppClientOptions';\n    import { WalletClientOptions } from 'test/clients/wallet-client/WalletClientOptions';\n    import { PermissionInfo } from 'test/types/PermissionInfo';\n    import { SDK_VERSION, BEACON_VERSION } from 'test/constants';\n    import { AccountManager } from 'test/managers/AccountManager';\n    import { AppMetadataManager } from 'test/managers/AppMetadataManager';\n    import { PermissionManager } from 'test/managers/PermissionManager';\n    import { BeaconEvent, BeaconEventHandler, defaultEventCallbacks } from 'test/events';\n    import { getAddressFromPublicKey } from 'test/utils/crypto';\n    import { BeaconClient } from 'test/clients/beacon-client/BeaconClient';\n    import { BeaconClientOptions } from 'test/clients/beacon-client/BeaconClientOptions';\n    import { getAccountIdentifier } from 'test/utils/get-account-identifier';\n    import { ConnectionContext } from 'test/types/ConnectionContext';\n    import { Threshold } from 'test/types/beacon/Threshold';\n    import { PartialTezosTransactionOperation, PartialTezosOperation, PartialTezosDelegationOperation, PartialTezosOriginationOperation, PartialTezosRevealOperation } from 'test/types/tezos/PartialTezosOperation';\n    import { AbortedBeaconError } from 'test/errors/AbortedBeaconError';\n    import { ExtendedPeerInfo, PeerInfo } from 'test/types/PeerInfo';\n    import { availableTransports } from 'test/utils/available-transports';\n    import { AcknowledgeResponse } from 'test/types/beacon/messages/AcknowledgeResponse';\n    import { DisconnectMessage } from 'test/types/beacon/messages/DisconnectMessage';\n    import { DappP2PTransport } from 'test/transports/DappP2PTransport';\n    import { DappPostMessageTransport } from 'test/transports/DappPostMessageTransport';\n    import { WalletP2PTransport } from 'test/transports/WalletP2PTransport';\n    import { WalletPostMessageTransport } from 'test/transports/WalletPostMessageTransport';\n    import { getSenderId } from 'test/utils/get-sender-id';\n    import { SigningType } from 'test/types/beacon/SigningType';\n    import { SignatureTypeNotSupportedBeaconError } from 'test/errors/SignatureTypeNotSupportedBeaconError';\n    import { ExtendedP2PPairingResponse } from 'test/types/P2PPairingResponse';\n    import { ExtendedPostMessagePairingRequest, PostMessagePairingRequest } from 'test/types/PostMessagePairingRequest';\n    import { ExtendedPostMessagePairingResponse } from 'test/types/PostMessagePairingResponse';\n    import { PeerManager } from 'test/managers/PeerManager';\n    import { MessageBasedClient } from 'test/transports/clients/MessageBasedClient';\n    import { BeaconRequestMessage } from 'test/types/beacon/BeaconRequestMessage';\n    import { BeaconResponseMessage } from 'test/types/beacon/BeaconResponseMessage';\n    import { Pairing } from 'test/ui/alert/Pairing';\n    import { BlockExplorer } from 'test/utils/block-explorer';\n    import { TezblockBlockExplorer } from 'test/utils/tezblock-blockexplorer';\n    import { setDebugEnabled, getDebugEnabled } from 'test/debug';\n    import { ColorMode } from 'test/types/ColorMode';\n    export { TezosBaseOperation, TezosOperationType, TezosBlockHeader, MichelsonPrimitives, TezosTransactionParameters, TezosOperation };\n    export { TezosActivateAccountOperation, TezosBallotOperation, TezosDelegationOperation, TezosDoubleBakingEvidenceOperation, TezosDoubleEndorsementEvidenceOperation, TezosEndorsementOperation, TezosOriginationOperation, TezosProposalOperation, TezosRevealOperation, TezosSeedNonceRevelationOperation, TezosTransactionOperation, PartialTezosOperation, PartialTezosTransactionOperation, PartialTezosDelegationOperation, PartialTezosOriginationOperation, PartialTezosRevealOperation };\n    export { BeaconClient, BeaconClientOptions, Client, ClientOptions, DAppClient, DAppClientOptions, WalletClient, WalletClientOptions, P2PCommunicationClient };\n    export { AccountIdentifier, AppMetadata, Network, NetworkType, BeaconMessage, PermissionRequest, PermissionResponse, OperationRequest, OperationResponse, SignPayloadRequest, SignPayloadResponse, BroadcastRequest, BroadcastResponse, AcknowledgeResponse, DisconnectMessage, BeaconBaseMessage, BeaconMessageType, PermissionScope, Origin, AccountInfo, Threshold, SigningType, ExtensionMessageTarget, ExtensionMessage, EncryptedExtensionMessage, RequestPermissionInput, RequestSignPayloadInput, RequestOperationInput, RequestBroadcastInput, PermissionInfo };\n    export { PermissionResponseInput, SignPayloadResponseInput, OperationResponseInput, BroadcastResponseInput, AcknowledgeResponseInput, ErrorResponseInput, PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, PermissionRequestInput, SignPayloadRequestInput, OperationRequestInput, BroadcastRequestInput, PermissionRequestOutput, SignPayloadRequestOutput, OperationRequestOutput, BroadcastRequestOutput, BeaconRequestInputMessage, BeaconRequestOutputMessage, BeaconResponseInputMessage, BeaconResponseOutputMessage, BeaconRequestMessage, BeaconResponseMessage };\n    export { BeaconError, BeaconErrorType, ErrorResponse, AbortedBeaconError, BroadcastBeaconError, NetworkNotSupportedBeaconError, NoAddressBeaconError, NoPrivateKeyBeaconError, NotGrantedBeaconError, ParametersInvalidBeaconError, TooManyOperationsBeaconError, TransactionInvalidBeaconError, SignatureTypeNotSupportedBeaconError, UnknownBeaconError };\n    export { TransportStatus, TransportType, Transport, PostMessageTransport, P2PTransport, WalletP2PTransport, WalletPostMessageTransport, DappP2PTransport, DappPostMessageTransport, MessageBasedClient, Pairing };\n    export { BeaconEvent, BeaconEventHandler, defaultEventCallbacks };\n    export { Storage, StorageKey, StorageKeyReturnDefaults, StorageKeyReturnType, ChromeStorage, LocalStorage, getStorage };\n    export { PeerManager, AccountManager, AppMetadataManager, PermissionManager };\n    export { SDK_VERSION, BEACON_VERSION };\n    export { getSenderId, getAccountIdentifier, getAddressFromPublicKey };\n    export { PeerInfo, ExtendedPeerInfo, PostMessagePairingRequest, ExtendedPostMessagePairingRequest, ExtendedPostMessagePairingResponse, P2PPairingRequest, ExtendedP2PPairingRequest, ExtendedP2PPairingResponse };\n    export { BlockExplorer, TezblockBlockExplorer };\n    export { ConnectionContext, Serializer, availableTransports, ColorMode };\n    export { setDebugEnabled, getDebugEnabled };\n}\n\n"},{"name":"@taquito/beacon-wallet/dist/types/taquito-beacon-wallet.d.ts","dts":"/**\r\n * @packageDocumentation\r\n * @module @taquito/beacon-wallet\r\n */\r\nimport { DAppClient, DAppClientOptions, RequestPermissionInput, PermissionScope } from '@airgap/beacon-sdk';\r\nimport { WalletDelegateParams, WalletOriginateParams, WalletProvider, WalletTransferParams } from '@taquito/taquito';\r\nexport declare class BeaconWalletNotInitialized implements Error {\r\n    name: string;\r\n    message: string;\r\n}\r\nexport declare class MissingRequiredScopes implements Error {\r\n    requiredScopes: PermissionScope[];\r\n    name: string;\r\n    message: string;\r\n    constructor(requiredScopes: PermissionScope[]);\r\n}\r\nexport declare class BeaconWallet implements WalletProvider {\r\n    client: DAppClient;\r\n    constructor(options: DAppClientOptions);\r\n    private validateRequiredScopesOrFail;\r\n    requestPermissions(request?: RequestPermissionInput): Promise<void>;\r\n    private removeFeeAndLimit;\r\n    getPKH(): Promise<string>;\r\n    mapTransferParamsToWalletParams(params: WalletTransferParams): Promise<import(\"@taquito/taquito/dist/types/operations/types\").RPCTransferOperation>;\r\n    mapOriginateParamsToWalletParams(params: WalletOriginateParams): Promise<import(\"@taquito/taquito/dist/types/operations/types\").RPCOriginationOperation>;\r\n    mapDelegateParamsToWalletParams(params: WalletDelegateParams): Promise<import(\"@taquito/taquito/dist/types/operations/types\").RPCDelegateOperation>;\r\n    sendOperations(params: any[]): Promise<string>;\r\n    /**\r\n     *\r\n     * @description Removes all beacon values from the storage. After using this method, this instance is no longer usable.\r\n     * You will have to instanciate a new BeaconWallet.\r\n     */\r\n    disconnect(): Promise<void>;\r\n    /**\r\n     *\r\n     * @description This method removes the active account from local storage by setting it to undefined.\r\n     */\r\n    clearActiveAccount(): Promise<void>;\r\n}\r\n"},{"name":"@taquito/http-utils/dist/types/status_code.d.ts","dts":"/**\r\n * Hypertext Transfer Protocol (HTTP) response status codes.\r\n * @see {@link https://en.wikipedia.org/wiki/List_of_HTTP_status_codes}\r\n */\r\nexport declare enum STATUS_CODE {\r\n    /**\r\n     * The server has received the request headers and the client should proceed to send the request body\r\n     * (in the case of a request for which a body needs to be sent; for example, a POST request).\r\n     * Sending a large request body to a server after a request has been rejected for inappropriate headers would be inefficient.\r\n     * To have a server check the request's headers, a client must send Expect: 100-continue as a header in its initial request\r\n     * and receive a 100 Continue status code in response before sending the body. The response 417 Expectation Failed indicates the request should not be continued.\r\n     */\r\n    CONTINUE = 100,\r\n    /**\r\n     * The requester has asked the server to switch protocols and the server has agreed to do so.\r\n     */\r\n    SWITCHING_PROTOCOLS = 101,\r\n    /**\r\n     * A WebDAV request may contain many sub-requests involving file operations, requiring a long time to complete the request.\r\n     * This code indicates that the server has received and is processing the request, but no response is available yet.\r\n     * This prevents the client from timing out and assuming the request was lost.\r\n     */\r\n    PROCESSING = 102,\r\n    /**\r\n     * Standard response for successful HTTP requests.\r\n     * The actual response will depend on the request method used.\r\n     * In a GET request, the response will contain an entity corresponding to the requested resource.\r\n     * In a POST request, the response will contain an entity describing or containing the result of the action.\r\n     */\r\n    OK = 200,\r\n    /**\r\n     * The request has been fulfilled, resulting in the creation of a new resource.\r\n     */\r\n    CREATED = 201,\r\n    /**\r\n     * The request has been accepted for processing, but the processing has not been completed.\r\n     * The request might or might not be eventually acted upon, and may be disallowed when processing occurs.\r\n     */\r\n    ACCEPTED = 202,\r\n    /**\r\n     * SINCE HTTP/1.1\r\n     * The server is a transforming proxy that received a 200 OK from its origin,\r\n     * but is returning a modified version of the origin's response.\r\n     */\r\n    NON_AUTHORITATIVE_INFORMATION = 203,\r\n    /**\r\n     * The server successfully processed the request and is not returning any content.\r\n     */\r\n    NO_CONTENT = 204,\r\n    /**\r\n     * The server successfully processed the request, but is not returning any content.\r\n     * Unlike a 204 response, this response requires that the requester reset the document view.\r\n     */\r\n    RESET_CONTENT = 205,\r\n    /**\r\n     * The server is delivering only part of the resource (byte serving) due to a range header sent by the client.\r\n     * The range header is used by HTTP clients to enable resuming of interrupted downloads,\r\n     * or split a download into multiple simultaneous streams.\r\n     */\r\n    PARTIAL_CONTENT = 206,\r\n    /**\r\n     * The message body that follows is an XML message and can contain a number of separate response codes,\r\n     * depending on how many sub-requests were made.\r\n     */\r\n    MULTI_STATUS = 207,\r\n    /**\r\n     * The members of a DAV binding have already been enumerated in a preceding part of the (multistatus) response,\r\n     * and are not being included again.\r\n     */\r\n    ALREADY_REPORTED = 208,\r\n    /**\r\n     * The server has fulfilled a request for the resource,\r\n     * and the response is a representation of the result of one or more instance-manipulations applied to the current instance.\r\n     */\r\n    IM_USED = 226,\r\n    /**\r\n     * Indicates multiple options for the resource from which the client may choose (via agent-driven content negotiation).\r\n     * For example, this code could be used to present multiple video format options,\r\n     * to list files with different filename extensions, or to suggest word-sense disambiguation.\r\n     */\r\n    MULTIPLE_CHOICES = 300,\r\n    /**\r\n     * This and all future requests should be directed to the given URI.\r\n     */\r\n    MOVED_PERMANENTLY = 301,\r\n    /**\r\n     * This is an example of industry practice contradicting the standard.\r\n     * The HTTP/1.0 specification (RFC 1945) required the client to perform a temporary redirect\r\n     * (the original describing phrase was \"Moved Temporarily\"), but popular browsers implemented 302\r\n     * with the functionality of a 303 See Other. Therefore, HTTP/1.1 added status codes 303 and 307\r\n     * to distinguish between the two behaviours. However, some Web applications and frameworks\r\n     * use the 302 status code as if it were the 303.\r\n     */\r\n    FOUND = 302,\r\n    /**\r\n     * SINCE HTTP/1.1\r\n     * The response to the request can be found under another URI using a GET method.\r\n     * When received in response to a POST (or PUT/DELETE), the client should presume that\r\n     * the server has received the data and should issue a redirect with a separate GET message.\r\n     */\r\n    SEE_OTHER = 303,\r\n    /**\r\n     * Indicates that the resource has not been modified since the version specified by the request headers If-Modified-Since or If-None-Match.\r\n     * In such case, there is no need to retransmit the resource since the client still has a previously-downloaded copy.\r\n     */\r\n    NOT_MODIFIED = 304,\r\n    /**\r\n     * SINCE HTTP/1.1\r\n     * The requested resource is available only through a proxy, the address for which is provided in the response.\r\n     * Many HTTP clients (such as Mozilla and Internet Explorer) do not correctly handle responses with this status code, primarily for security reasons.\r\n     */\r\n    USE_PROXY = 305,\r\n    /**\r\n     * No longer used. Originally meant \"Subsequent requests should use the specified proxy.\"\r\n     */\r\n    SWITCH_PROXY = 306,\r\n    /**\r\n     * SINCE HTTP/1.1\r\n     * In this case, the request should be repeated with another URI; however, future requests should still use the original URI.\r\n     * In contrast to how 302 was historically implemented, the request method is not allowed to be changed when reissuing the original request.\r\n     * For example, a POST request should be repeated using another POST request.\r\n     */\r\n    TEMPORARY_REDIRECT = 307,\r\n    /**\r\n     * The request and all future requests should be repeated using another URI.\r\n     * 307 and 308 parallel the behaviors of 302 and 301, but do not allow the HTTP method to change.\r\n     * So, for example, submitting a form to a permanently redirected resource may continue smoothly.\r\n     */\r\n    PERMANENT_REDIRECT = 308,\r\n    /**\r\n     * The server cannot or will not process the request due to an apparent client error\r\n     * (e.g., malformed request syntax, too large size, invalid request message framing, or deceptive request routing).\r\n     */\r\n    BAD_REQUEST = 400,\r\n    /**\r\n     * Similar to 403 Forbidden, but specifically for use when authentication is required and has failed or has not yet\r\n     * been provided. The response must include a WWW-Authenticate header field containing a challenge applicable to the\r\n     * requested resource. See Basic access authentication and Digest access authentication. 401 semantically means\r\n     * \"unauthenticated\",i.e. the user does not have the necessary credentials.\r\n     */\r\n    UNAUTHORIZED = 401,\r\n    /**\r\n     * Reserved for future use. The original intention was that this code might be used as part of some form of digital\r\n     * cash or micro payment scheme, but that has not happened, and this code is not usually used.\r\n     * Google Developers API uses this status if a particular developer has exceeded the daily limit on requests.\r\n     */\r\n    PAYMENT_REQUIRED = 402,\r\n    /**\r\n     * The request was valid, but the server is refusing action.\r\n     * The user might not have the necessary permissions for a resource.\r\n     */\r\n    FORBIDDEN = 403,\r\n    /**\r\n     * The requested resource could not be found but may be available in the future.\r\n     * Subsequent requests by the client are permissible.\r\n     */\r\n    NOT_FOUND = 404,\r\n    /**\r\n     * A request method is not supported for the requested resource;\r\n     * for example, a GET request on a form that requires data to be presented via POST, or a PUT request on a read-only resource.\r\n     */\r\n    METHOD_NOT_ALLOWED = 405,\r\n    /**\r\n     * The requested resource is capable of generating only content not acceptable according to the Accept headers sent in the request.\r\n     */\r\n    NOT_ACCEPTABLE = 406,\r\n    /**\r\n     * The client must first authenticate itself with the proxy.\r\n     */\r\n    PROXY_AUTHENTICATION_REQUIRED = 407,\r\n    /**\r\n     * The server timed out waiting for the request.\r\n     * According to HTTP specifications:\r\n     * \"The client did not produce a request within the time that the server was prepared to wait. The client MAY repeat the request without modifications at any later time.\"\r\n     */\r\n    REQUEST_TIMEOUT = 408,\r\n    /**\r\n     * Indicates that the request could not be processed because of conflict in the request,\r\n     * such as an edit conflict between multiple simultaneous updates.\r\n     */\r\n    CONFLICT = 409,\r\n    /**\r\n     * Indicates that the resource requested is no longer available and will not be available again.\r\n     * This should be used when a resource has been intentionally removed and the resource should be purged.\r\n     * Upon receiving a 410 status code, the client should not request the resource in the future.\r\n     * Clients such as search engines should remove the resource from their indices.\r\n     * Most use cases do not require clients and search engines to purge the resource, and a \"404 Not Found\" may be used instead.\r\n     */\r\n    GONE = 410,\r\n    /**\r\n     * The request did not specify the length of its content, which is required by the requested resource.\r\n     */\r\n    LENGTH_REQUIRED = 411,\r\n    /**\r\n     * The server does not meet one of the preconditions that the requester put on the request.\r\n     */\r\n    PRECONDITION_FAILED = 412,\r\n    /**\r\n     * The request is larger than the server is willing or able to process. Previously called \"Request Entity Too Large\".\r\n     */\r\n    PAYLOAD_TOO_LARGE = 413,\r\n    /**\r\n     * The URI provided was too long for the server to process. Often the result of too much data being encoded as a query-string of a GET request,\r\n     * in which case it should be converted to a POST request.\r\n     * Called \"Request-URI Too Long\" previously.\r\n     */\r\n    URI_TOO_LONG = 414,\r\n    /**\r\n     * The request entity has a media type which the server or resource does not support.\r\n     * For example, the client uploads an image as image/svg+xml, but the server requires that images use a different format.\r\n     */\r\n    UNSUPPORTED_MEDIA_TYPE = 415,\r\n    /**\r\n     * The client has asked for a portion of the file (byte serving), but the server cannot supply that portion.\r\n     * For example, if the client asked for a part of the file that lies beyond the end of the file.\r\n     * Called \"Requested Range Not Satisfiable\" previously.\r\n     */\r\n    RANGE_NOT_SATISFIABLE = 416,\r\n    /**\r\n     * The server cannot meet the requirements of the Expect request-header field.\r\n     */\r\n    EXPECTATION_FAILED = 417,\r\n    /**\r\n     * This code was defined in 1998 as one of the traditional IETF April Fools' jokes, in RFC 2324, Hyper Text Coffee Pot Control Protocol,\r\n     * and is not expected to be implemented by actual HTTP servers. The RFC specifies this code should be returned by\r\n     * teapots requested to brew coffee. This HTTP status is used as an Easter egg in some websites, including Google.com.\r\n     */\r\n    I_AM_A_TEAPOT = 418,\r\n    /**\r\n     * The request was directed at a server that is not able to produce a response (for example because a connection reuse).\r\n     */\r\n    MISDIRECTED_REQUEST = 421,\r\n    /**\r\n     * The request was well-formed but was unable to be followed due to semantic errors.\r\n     */\r\n    UNPROCESSABLE_ENTITY = 422,\r\n    /**\r\n     * The resource that is being accessed is locked.\r\n     */\r\n    LOCKED = 423,\r\n    /**\r\n     * The request failed due to failure of a previous request (e.g., a PROPPATCH).\r\n     */\r\n    FAILED_DEPENDENCY = 424,\r\n    /**\r\n     * The client should switch to a different protocol such as TLS/1.0, given in the Upgrade header field.\r\n     */\r\n    UPGRADE_REQUIRED = 426,\r\n    /**\r\n     * The origin server requires the request to be conditional.\r\n     * Intended to prevent \"the 'lost update' problem, where a client\r\n     * GETs a resource's state, modifies it, and PUTs it back to the server,\r\n     * when meanwhile a third party has modified the state on the server, leading to a conflict.\"\r\n     */\r\n    PRECONDITION_REQUIRED = 428,\r\n    /**\r\n     * The user has sent too many requests in a given amount of time. Intended for use with rate-limiting schemes.\r\n     */\r\n    TOO_MANY_REQUESTS = 429,\r\n    /**\r\n     * The server is unwilling to process the request because either an individual header field,\r\n     * or all the header fields collectively, are too large.\r\n     */\r\n    REQUEST_HEADER_FIELDS_TOO_LARGE = 431,\r\n    /**\r\n     * A server operator has received a legal demand to deny access to a resource or to a set of resources\r\n     * that includes the requested resource. The code 451 was chosen as a reference to the novel Fahrenheit 451.\r\n     */\r\n    UNAVAILABLE_FOR_LEGAL_REASONS = 451,\r\n    /**\r\n     * A generic error message, given when an unexpected condition was encountered and no more specific message is suitable.\r\n     */\r\n    INTERNAL_SERVER_ERROR = 500,\r\n    /**\r\n     * The server either does not recognize the request method, or it lacks the ability to fulfill the request.\r\n     * Usually this implies future availability (e.g., a new feature of a web-service API).\r\n     */\r\n    NOT_IMPLEMENTED = 501,\r\n    /**\r\n     * The server was acting as a gateway or proxy and received an invalid response from the upstream server.\r\n     */\r\n    BAD_GATEWAY = 502,\r\n    /**\r\n     * The server is currently unavailable (because it is overloaded or down for maintenance).\r\n     * Generally, this is a temporary state.\r\n     */\r\n    SERVICE_UNAVAILABLE = 503,\r\n    /**\r\n     * The server was acting as a gateway or proxy and did not receive a timely response from the upstream server.\r\n     */\r\n    GATEWAY_TIMEOUT = 504,\r\n    /**\r\n     * The server does not support the HTTP protocol version used in the request\r\n     */\r\n    HTTP_VERSION_NOT_SUPPORTED = 505,\r\n    /**\r\n     * Transparent content negotiation for the request results in a circular reference.\r\n     */\r\n    VARIANT_ALSO_NEGOTIATES = 506,\r\n    /**\r\n     * The server is unable to store the representation needed to complete the request.\r\n     */\r\n    INSUFFICIENT_STORAGE = 507,\r\n    /**\r\n     * The server detected an infinite loop while processing the request.\r\n     */\r\n    LOOP_DETECTED = 508,\r\n    /**\r\n     * Further extensions to the request are required for the server to fulfill it.\r\n     */\r\n    NOT_EXTENDED = 510,\r\n    /**\r\n     * The client needs to authenticate to gain network access.\r\n     * Intended for use by intercepting proxies used to control access to the network (e.g., \"captive portals\" used\r\n     * to require agreement to Terms of Service before granting full Internet access via a Wi-Fi hotspot).\r\n     */\r\n    NETWORK_AUTHENTICATION_REQUIRED = 511\r\n}\r\n"},{"name":"@taquito/http-utils/dist/types/taquito-http-utils.d.ts","dts":"/**\r\n * @packageDocumentation\r\n * @module @taquito/http-utils\r\n */\r\nimport { STATUS_CODE } from './status_code';\r\nexport * from './status_code';\r\ninterface HttpRequestOptions {\r\n    url: string;\r\n    method?: 'GET' | 'POST';\r\n    timeout?: number;\r\n    json?: boolean;\r\n    query?: {\r\n        [key: string]: any;\r\n    };\r\n    headers?: {\r\n        [key: string]: string;\r\n    };\r\n    mimeType?: string;\r\n}\r\nexport declare class HttpResponseError implements Error {\r\n    message: string;\r\n    status: STATUS_CODE;\r\n    statusText: string;\r\n    body: string;\r\n    url: string;\r\n    name: string;\r\n    constructor(message: string, status: STATUS_CODE, statusText: string, body: string, url: string);\r\n}\r\nexport declare class HttpRequestFailed implements Error {\r\n    url: string;\r\n    innerEvent: any;\r\n    name: string;\r\n    message: string;\r\n    constructor(url: string, innerEvent: any);\r\n}\r\nexport declare class HttpBackend {\r\n    private serialize;\r\n    private createXHR;\r\n    /**\r\n     *\r\n     * @param options contains options to be passed for the HTTP request (url, method and timeout)\r\n     */\r\n    createRequest<T>({ url, method, timeout, query, headers, json, mimeType }: HttpRequestOptions, data?: {}): Promise<T>;\r\n}\r\n"},{"name":"@taquito/michel-codec/dist/types/base58.d.ts","dts":"export declare function decodeBase58(src: string): number[];\r\nexport declare function decodeBase58Check(src: string): number[];\r\n"},{"name":"@taquito/michel-codec/dist/types/formatters.d.ts","dts":"import { InstructionTrace } from \"./michelson-typecheck\";\r\nimport { MichelsonError } from \"./utils\";\r\nimport { MichelsonReturnType } from \"./michelson-types\";\r\nexport declare function formatStack(s: MichelsonReturnType): string;\r\nexport declare function traceDumpFunc(blocks: boolean, cb: (s: string) => void): (v: InstructionTrace) => void;\r\nexport declare function formatError(err: MichelsonError): string;\r\n"},{"name":"@taquito/michel-codec/dist/types/macros.d.ts","dts":"import { Prim, Expr } from \"./micheline\";\r\nimport { ProtocolOptions } from \"./michelson-types\";\r\nexport declare class MacroError extends Error {\r\n    prim: Prim;\r\n    constructor(prim: Prim, message?: string);\r\n}\r\nexport declare function expandMacros(ex: Prim, opt?: ProtocolOptions): Expr;\r\n"},{"name":"@taquito/michel-codec/dist/types/micheline-emitter.d.ts","dts":"import { Expr } from \"./micheline\";\r\nexport interface FormatOptions {\r\n    /**\r\n     * A string used for code indentation if desired. Usually a tab character or a number of spaces.\r\n     */\r\n    indent?: string;\r\n    /**\r\n     * A string used for line separation. Usually a newline character (\"\\n\");\r\n     */\r\n    newline?: string;\r\n}\r\n/**\r\n * Formats Micheline expression\r\n * @param expr An AST node\r\n * @param opt Options\r\n */\r\nexport declare function emitMicheline(expr: Expr, opt?: FormatOptions, foldMacros?: boolean): string;\r\n"},{"name":"@taquito/michel-codec/dist/types/micheline-parser.d.ts","dts":"import { Token } from './scan';\r\nimport { Expr } from './micheline';\r\nimport { ProtocolOptions } from './michelson-types';\r\nexport declare class MichelineParseError extends Error {\r\n    token: Token | null;\r\n    /**\r\n     * @param token A token caused the error\r\n     * @param message An error message\r\n     */\r\n    constructor(token: Token | null, message?: string);\r\n}\r\nexport declare class JSONParseError extends Error {\r\n    node: any;\r\n    /**\r\n     * @param node A node caused the error\r\n     * @param message An error message\r\n     */\r\n    constructor(node: any, message?: string);\r\n}\r\nexport interface ParserOptions extends ProtocolOptions {\r\n    /**\r\n     * Expand [Michelson macros](https://tezos.gitlab.io/whitedoc/michelson.html#macros) during parsing.\r\n     */\r\n    expandMacros?: boolean;\r\n}\r\n/**\r\n * Converts and validates Michelson expressions between JSON-based Michelson and Micheline\r\n *\r\n * Pretty Print a Michelson Smart Contract:\r\n * ```\r\n * const contract = await Tezos.contract.at(\"KT1Vsw3kh9638gqWoHTjvHCoHLPKvCbMVbCg\");\r\n * const p = new Parser();\r\n *\r\n * const michelsonCode = p.parseJSON(contract.script.code);\r\n * const storage = p.parseJSON(contract.script.storage);\r\n *\r\n * console.log(\"Pretty print Michelson smart contract:\");\r\n * console.log(emitMicheline(michelsonCode, {indent:\"    \", newline: \"\\n\",}));\r\n *\r\n * console.log(\"Pretty print Storage:\");\r\n * console.log(emitMicheline(storage, {indent:\"    \", newline: \"\\n\",}));\r\n * ```\r\n *\r\n * Encode a Michelson expression for inital storage of a smart contract\r\n * ```\r\n * const src = `(Pair (Pair { Elt 1\r\n *                (Pair (Pair \"tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN\" \"tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx\")\r\n *                      0x0501000000026869) }\r\n *          10000000)\r\n *    (Pair 2 333))`;\r\n *\r\n * const p = new Parser();\r\n *\r\n * const exp = p.parseMichelineExpression(src);\r\n * console.log(JSON.stringify(exp));\r\n * ```\r\n */\r\nexport declare class Parser {\r\n    private opt?;\r\n    constructor(opt?: ParserOptions | undefined);\r\n    private expand;\r\n    private parseList;\r\n    private parseArgs;\r\n    private parseSequence;\r\n    private parseExpr;\r\n    /**\r\n     * Parses a Micheline sequence expression, such as smart contract source. Enclosing curly brackets may be omitted.\r\n     * @param src A Micheline sequence `{parameter ...; storage int; code { DUP ; ...};}` or `parameter ...; storage int; code { DUP ; ...};`\r\n     */\r\n    parseScript(src: string): Expr[] | null;\r\n    /**\r\n     * Parse any Michelson expression\r\n     * @param src A Michelson expression such as `(Pair {Elt \"0\" 0} 0)` or `{parameter ...; storage int; code { DUP ; ...};}`\r\n     * @returns An AST node or null for empty document.\r\n     */\r\n    parseMichelineExpression(src: string): Expr | null;\r\n    /**\r\n     * Takes a JSON-encoded Michelson, validates it, strips away unneeded properties and optionally expands macros (See {@link ParserOptions}).\r\n     * @param src An object containing JSON-encoded Michelson, usually returned by `JSON.parse()`\r\n     */\r\n    parseJSON(src: object): Expr;\r\n}\r\n"},{"name":"@taquito/michel-codec/dist/types/micheline.d.ts","dts":"export declare type SourceReference = {\r\n    first: number;\r\n    last: number;\r\n    macro?: Expr;\r\n};\r\nexport declare const sourceReference: unique symbol;\r\nexport interface Node {\r\n    [sourceReference]?: SourceReference;\r\n}\r\n/**\r\n * An AST node representing Michelson string literal.\r\n */\r\nexport interface StringLiteral extends Node {\r\n    string: string;\r\n}\r\n/**\r\n * An AST node representing Michelson int literal.\r\n */\r\nexport interface IntLiteral<T extends string = string> extends Node {\r\n    int: T;\r\n}\r\n/**\r\n * An AST node representing Michelson bytes literal.\r\n */\r\nexport interface BytesLiteral extends Node {\r\n    bytes: string;\r\n}\r\n/**\r\n * An AST node representing Michelson primitive.\r\n */\r\nexport interface Prim<PT extends string = string, AT extends Expr[] = Expr[]> extends Node {\r\n    prim: PT;\r\n    args?: AT;\r\n    annots?: string[];\r\n}\r\nexport declare type List<T extends Expr> = T[] & Node;\r\ninterface ExprList extends List<Expr> {\r\n}\r\n/**\r\n * An AST node representing valid Michelson expression. Directly corresponds to JSON-encoded Michelson node\r\n */\r\nexport declare type Expr = Prim | StringLiteral | IntLiteral | BytesLiteral | ExprList;\r\nexport {};\r\n"},{"name":"@taquito/michel-codec/dist/types/michelson-contract.d.ts","dts":"import { MichelsonContract, MichelsonContractSection, MichelsonType, MichelsonData, MichelsonCode, MichelsonReturnType, ProtocolOptions } from \"./michelson-types\";\r\nimport { InstructionTrace } from \"./michelson-typecheck\";\r\nexport interface ContractOptions extends ProtocolOptions {\r\n    traceCallback?: (t: InstructionTrace) => void;\r\n}\r\nexport declare class Contract {\r\n    readonly contract: MichelsonContract;\r\n    private ctx;\r\n    readonly output: MichelsonReturnType;\r\n    constructor(contract: MichelsonContract, opt?: ContractOptions);\r\n    static parse(src: string | object, opt?: ContractOptions): Contract;\r\n    static parseTypeExpression(src: string | object): MichelsonType;\r\n    static parseDataExpression(src: string | object): MichelsonData;\r\n    section<T extends \"parameter\" | \"storage\" | \"code\">(section: T): MichelsonContractSection<T>;\r\n    entryPoints(): [string, MichelsonType][];\r\n    entryPoint(ep?: string): MichelsonType | null;\r\n    assertDataValid(d: MichelsonData, t: MichelsonType): void;\r\n    isDataValid(d: MichelsonData, t: MichelsonType): boolean;\r\n    assertParameterValid(ep: string | null, d: MichelsonData): void;\r\n    isParameterValid(ep: string | null, d: MichelsonData): boolean;\r\n    functionType(inst: MichelsonCode, stack: MichelsonType[]): MichelsonReturnType;\r\n}\r\nexport declare const dummyContract: Contract;\r\n"},{"name":"@taquito/michel-codec/dist/types/michelson-typecheck.d.ts","dts":"import { Expr } from \"./micheline\";\r\nimport { MichelsonType, MichelsonData, MichelsonCode, MichelsonContract, MichelsonContractSection, MichelsonReturnType, ProtocolOptions } from \"./michelson-types\";\r\nimport { MichelsonError } from \"./utils\";\r\nexport interface Context extends ProtocolOptions {\r\n    contract?: MichelsonContract;\r\n    traceCallback?: (t: InstructionTrace) => void;\r\n}\r\nexport declare class MichelsonTypeError extends MichelsonError<MichelsonType | MichelsonType[]> {\r\n    data?: Expr;\r\n    /**\r\n     * @param val Value of a type node caused the error\r\n     * @param data Value of a data node caused the error\r\n     * @param message An error message\r\n     */\r\n    constructor(val: MichelsonType | MichelsonType[], data?: Expr, message?: string);\r\n}\r\nexport declare class MichelsonInstructionError extends MichelsonError<MichelsonCode> {\r\n    stackState: MichelsonReturnType;\r\n    /**\r\n     * @param val Value of a type node caused the error\r\n     * @param stackState Current stack state\r\n     * @param message An error message\r\n     */\r\n    constructor(val: MichelsonCode, stackState: MichelsonReturnType, message?: string);\r\n}\r\nexport declare function assertTypeAnnotationsValid(t: MichelsonType, field?: boolean): void;\r\nexport interface InstructionTrace {\r\n    op: MichelsonCode;\r\n    in: MichelsonType[];\r\n    out: MichelsonReturnType;\r\n}\r\nexport declare function contractSection<T extends \"parameter\" | \"storage\" | \"code\">(contract: MichelsonContract, section: T): MichelsonContractSection<T>;\r\nexport declare function contractEntryPoint(src: MichelsonContract | MichelsonType, ep?: string): MichelsonType | null;\r\nexport declare function contractEntryPoints(src: MichelsonContract | MichelsonType): [string, MichelsonType][];\r\nexport declare function assertContractValid(contract: MichelsonContract, ctx?: Context): MichelsonReturnType;\r\nexport declare function assertDataValid(d: MichelsonData, t: MichelsonType, ctx?: Context): void;\r\nexport declare function functionType(inst: MichelsonCode, stack: MichelsonType[], ctx?: Context): MichelsonReturnType;\r\nexport declare function assertTypesEqual<T1 extends MichelsonType | MichelsonType[], T2 extends T1>(a: T1, b: T2, field?: boolean): void;\r\nexport declare function isTypeAnnotationsValid(t: MichelsonType, field?: boolean): boolean;\r\nexport declare function isContractValid(contract: MichelsonContract, ctx?: Context): MichelsonReturnType | null;\r\nexport declare function isDataValid(d: MichelsonData, t: MichelsonType, ctx?: Context): boolean;\r\nexport declare function isTypeEqual<T1 extends MichelsonType | MichelsonType[], T2 extends T1>(a: T1, b: T2, field?: boolean): boolean;\r\n"},{"name":"@taquito/michel-codec/dist/types/michelson-types.d.ts","dts":"import { Prim, Expr, IntLiteral, StringLiteral, BytesLiteral, List, Node } from \"./micheline\";\r\ninterface Prim0<PT extends string = string> extends Prim<PT> {\r\n    args?: never;\r\n}\r\ninterface PrimX<PT extends string = string, AT extends Expr[] = Expr[]> extends Prim<PT, AT> {\r\n    args: AT;\r\n}\r\ndeclare type MichelsonNoArgInstructionID = \"ABS\" | \"ADD\" | \"ADDRESS\" | \"AMOUNT\" | \"AND\" | \"APPLY\" | \"BALANCE\" | \"BLAKE2B\" | \"CAR\" | \"CDR\" | \"CHAIN_ID\" | \"CHECK_SIGNATURE\" | \"COMPARE\" | \"CONCAT\" | \"CONS\" | \"EDIV\" | \"EQ\" | \"EXEC\" | \"FAILWITH\" | \"GE\" | \"GET_AND_UPDATE\" | \"GT\" | \"HASH_KEY\" | \"IMPLICIT_ACCOUNT\" | \"INT\" | \"ISNAT\" | \"JOIN_TICKETS\" | \"KECCAK\" | \"LE\" | \"LEVEL\" | \"LSL\" | \"LSR\" | \"LT\" | \"MEM\" | \"MUL\" | \"NEG\" | \"NEQ\" | \"NEVER\" | \"NOT\" | \"NOW\" | \"OR\" | \"PACK\" | \"PAIRING_CHECK\" | \"READ_TICKET\" | \"SAPLING_VERIFY_UPDATE\" | \"SELF\" | \"SELF_ADDRESS\" | \"SENDER\" | \"SET_DELEGATE\" | \"SHA256\" | \"SHA3\" | \"SHA512\" | \"SIZE\" | \"SLICE\" | \"SOME\" | \"SOURCE\" | \"SPLIT_TICKET\" | \"SUB\" | \"SWAP\" | \"TICKET\" | \"TOTAL_VOTING_POWER\" | \"TRANSFER_TOKENS\" | \"UNIT\" | \"VOTING_POWER\" | \"XOR\" | \"RENAME\";\r\ndeclare type MichelsonRegularInstructionID = \"CONTRACT\" | \"CREATE_CONTRACT\" | \"DIG\" | \"DIP\" | \"DROP\" | \"DUG\" | \"DUP\" | \"EMPTY_BIG_MAP\" | \"EMPTY_MAP\" | \"EMPTY_SET\" | \"GET\" | \"IF\" | \"IF_CONS\" | \"IF_LEFT\" | \"IF_NONE\" | \"ITER\" | \"LAMBDA\" | \"LEFT\" | \"LOOP\" | \"LOOP_LEFT\" | \"MAP\" | \"NIL\" | \"NONE\" | \"PAIR\" | \"PUSH\" | \"RIGHT\" | \"SAPLING_EMPTY_STATE\" | \"UNPACK\" | \"UNPAIR\" | \"UPDATE\" | \"CAST\";\r\ndeclare type MichelsonInstructionID = MichelsonNoArgInstructionID | MichelsonRegularInstructionID;\r\ndeclare type InstrPrim<PT extends MichelsonInstructionID, AT extends Expr[]> = Prim<PT, AT>;\r\ndeclare type Instr0<PT extends MichelsonNoArgInstructionID> = Prim0<PT>;\r\ndeclare type InstrX<PT extends MichelsonRegularInstructionID, AT extends Expr[]> = PrimX<PT, AT>;\r\nexport declare type MichelsonCode = InstructionList | MichelsonInstruction;\r\nexport interface InstructionList extends List<MichelsonCode> {\r\n}\r\nexport declare type MichelsonNoArgInstruction = Instr0<MichelsonNoArgInstructionID>;\r\nexport declare type MichelsonInstruction = MichelsonNoArgInstruction | InstrX<\"DIG\" | \"DUG\" | \"SAPLING_EMPTY_STATE\", [IntLiteral]> | InstrX<\"NONE\" | \"LEFT\" | \"RIGHT\" | \"NIL\" | \"CAST\", [MichelsonType]> | InstrX<\"IF_NONE\" | \"IF_LEFT\" | \"IF_CONS\" | \"IF\", [InstructionList, InstructionList]> | InstrX<\"MAP\" | \"ITER\" | \"LOOP\" | \"LOOP_LEFT\" | \"DIP\", [InstructionList]> | InstrX<\"UNPACK\", [MichelsonType]> | InstrX<\"CONTRACT\", [MichelsonType]> | InstrX<\"CREATE_CONTRACT\", [MichelsonContract]> | InstrX<\"PUSH\", [MichelsonType, MichelsonData]> | InstrX<\"EMPTY_SET\", [MichelsonType]> | InstrX<\"EMPTY_MAP\", [MichelsonType, MichelsonType]> | InstrX<\"EMPTY_BIG_MAP\", [MichelsonType, MichelsonType]> | InstrX<\"LAMBDA\", [MichelsonType, MichelsonType, InstructionList]> | InstrX<\"DIP\", [IntLiteral, InstructionList] | [InstructionList]> | InstrPrim<\"DROP\" | \"PAIR\" | \"UNPAIR\" | \"DUP\" | \"GET\" | \"UPDATE\", [IntLiteral]>;\r\nexport declare type MichelsonSimpleComparableTypeID = \"string\" | \"nat\" | \"int\" | \"bytes\" | \"bool\" | \"mutez\" | \"key_hash\" | \"address\" | \"timestamp\" | \"never\" | \"key\" | \"unit\" | \"signature\" | \"chain_id\";\r\nexport declare type MichelsonTypeID = MichelsonSimpleComparableTypeID | \"option\" | \"list\" | \"set\" | \"contract\" | \"operation\" | \"pair\" | \"or\" | \"lambda\" | \"map\" | \"big_map\" | \"sapling_transaction\" | \"sapling_state\" | \"ticket\" | \"bls12_381_g1\" | \"bls12_381_g2\" | \"bls12_381_fr\";\r\ndeclare type Type0<PT extends MichelsonTypeID> = Prim0<PT>;\r\ndeclare type TypeX<PT extends MichelsonTypeID, AT extends Expr[]> = PrimX<PT, AT>;\r\nexport declare const refContract: unique symbol;\r\nexport interface MichelsonTypeAddress extends Type0<\"address\"> {\r\n    [refContract]?: MichelsonTypeContract<MichelsonType>;\r\n}\r\nexport declare type MichelsonTypeInt = Type0<\"int\">;\r\nexport declare type MichelsonTypeNat = Type0<\"nat\">;\r\nexport declare type MichelsonTypeString = Type0<\"string\">;\r\nexport declare type MichelsonTypeBytes = Type0<\"bytes\">;\r\nexport declare type MichelsonTypeMutez = Type0<\"mutez\">;\r\nexport declare type MichelsonTypeBool = Type0<\"bool\">;\r\nexport declare type MichelsonTypeKeyHash = Type0<\"key_hash\">;\r\nexport declare type MichelsonTypeTimestamp = Type0<\"timestamp\">;\r\nexport declare type MichelsonTypeKey = Type0<\"key\">;\r\nexport declare type MichelsonTypeUnit = Type0<\"unit\">;\r\nexport declare type MichelsonTypeSignature = Type0<\"signature\">;\r\nexport declare type MichelsonTypeOperation = Type0<\"operation\">;\r\nexport declare type MichelsonTypeChainID = Type0<\"chain_id\">;\r\nexport declare type MichelsonTypeNever = Type0<\"never\">;\r\nexport declare type MichelsonTypeBLS12_381_G1 = Type0<\"bls12_381_g1\">;\r\nexport declare type MichelsonTypeBLS12_381_G2 = Type0<\"bls12_381_g2\">;\r\nexport declare type MichelsonTypeBLS12_381_FR = Type0<\"bls12_381_fr\">;\r\ndeclare type TypeList<T extends MichelsonType[]> = T & Node;\r\nexport declare type MichelsonTypePair<T extends MichelsonType[]> = TypeX<\"pair\", T> | TypeList<T>;\r\nexport interface MichelsonTypeOption<T extends MichelsonType> extends TypeX<\"option\", [T]> {\r\n}\r\nexport interface MichelsonTypeList<T extends MichelsonType> extends TypeX<\"list\", [T]> {\r\n}\r\nexport interface MichelsonTypeContract<T extends MichelsonType> extends TypeX<\"contract\", [T]> {\r\n}\r\nexport interface MichelsonTypeOr<T extends [MichelsonType, MichelsonType]> extends TypeX<\"or\", T> {\r\n}\r\nexport interface MichelsonTypeLambda<Arg extends MichelsonType, Ret extends MichelsonType> extends TypeX<\"lambda\", [Arg, Ret]> {\r\n}\r\nexport interface MichelsonTypeSet<T extends MichelsonType> extends TypeX<\"set\", [T]> {\r\n}\r\nexport interface MichelsonTypeMap<K extends MichelsonType, V extends MichelsonType> extends TypeX<\"map\", [K, V]> {\r\n}\r\nexport interface MichelsonTypeBigMap<K extends MichelsonType, V extends MichelsonType> extends TypeX<\"big_map\", [K, V]> {\r\n}\r\nexport interface MichelsonTypeSaplingState<S extends string = string> extends TypeX<\"sapling_state\", [IntLiteral<S>]> {\r\n}\r\nexport interface MichelsonTypeSaplingTransaction<S extends string = string> extends TypeX<\"sapling_transaction\", [IntLiteral<S>]> {\r\n}\r\nexport interface MichelsonTypeTicket<T extends MichelsonType> extends TypeX<\"ticket\", [T]> {\r\n}\r\nexport declare type MichelsonType<T extends MichelsonTypeID = MichelsonTypeID> = T extends \"int\" ? MichelsonTypeInt : T extends \"nat\" ? MichelsonTypeNat : T extends \"string\" ? MichelsonTypeString : T extends \"bytes\" ? MichelsonTypeBytes : T extends \"mutez\" ? MichelsonTypeMutez : T extends \"bool\" ? MichelsonTypeBool : T extends \"key_hash\" ? MichelsonTypeKeyHash : T extends \"timestamp\" ? MichelsonTypeTimestamp : T extends \"address\" ? MichelsonTypeAddress : T extends \"key\" ? MichelsonTypeKey : T extends \"unit\" ? MichelsonTypeUnit : T extends \"signature\" ? MichelsonTypeSignature : T extends \"operation\" ? MichelsonTypeOperation : T extends \"chain_id\" ? MichelsonTypeChainID : T extends \"option\" ? MichelsonTypeOption<MichelsonType> : T extends \"list\" ? MichelsonTypeList<MichelsonType> : T extends \"contract\" ? MichelsonTypeContract<MichelsonType> : T extends \"ticket\" ? MichelsonTypeTicket<MichelsonType> : T extends \"pair\" ? MichelsonTypePair<MichelsonType[]> : T extends \"or\" ? MichelsonTypeOr<[MichelsonType, MichelsonType]> : T extends \"lambda\" ? MichelsonTypeLambda<MichelsonType, MichelsonType> : T extends \"set\" ? MichelsonTypeSet<MichelsonType> : T extends \"map\" ? MichelsonTypeMap<MichelsonType, MichelsonType> : T extends \"big_map\" ? MichelsonTypeBigMap<MichelsonType, MichelsonType> : T extends \"never\" ? MichelsonTypeNever : T extends \"bls12_381_g1\" ? MichelsonTypeBLS12_381_G1 : T extends \"bls12_381_g2\" ? MichelsonTypeBLS12_381_G2 : T extends \"bls12_381_fr\" ? MichelsonTypeBLS12_381_FR : T extends \"sapling_transaction\" ? MichelsonTypeSaplingTransaction : MichelsonTypeSaplingState;\r\nexport declare type MichelsonDataId = \"Unit\" | \"True\" | \"False\" | \"None\" | \"Pair\" | \"Left\" | \"Right\" | \"Some\";\r\ndeclare type Data0<PT extends MichelsonDataId> = Prim0<PT>;\r\ndeclare type DataX<PT extends MichelsonDataId, AT extends MichelsonData[]> = PrimX<PT, AT>;\r\ndeclare type PartialData = DataX<\"Some\" | \"Left\" | \"Right\", [MichelsonData]>;\r\ndeclare type DataList<T extends MichelsonData[]> = T & Node;\r\nexport declare type MichelsonDataPair<T extends MichelsonData[]> = DataX<\"Pair\", T> | DataList<T>;\r\nexport declare type MichelsonMapElt = PrimX<\"Elt\", [MichelsonData, MichelsonData]>;\r\nexport declare type MichelsonMapEltList = List<MichelsonMapElt>;\r\nexport declare type MichelsonData = IntLiteral | StringLiteral | BytesLiteral | Data0<\"Unit\" | \"True\" | \"False\" | \"None\"> | PartialData | DataList<MichelsonData[]> | MichelsonDataPair<MichelsonData[]> | InstructionList | MichelsonMapEltList;\r\ndeclare type MichelsonSectionId = \"parameter\" | \"storage\" | \"code\";\r\ndeclare type SectionPrim<PT extends MichelsonSectionId, AT extends Expr[]> = PrimX<PT, AT>;\r\nexport declare type MichelsonContractParameter = SectionPrim<\"parameter\", [MichelsonType]>;\r\nexport declare type MichelsonContractStorage = SectionPrim<\"storage\", [MichelsonType]>;\r\nexport declare type MichelsonContractCode = SectionPrim<\"code\", [InstructionList]>;\r\nexport declare type MichelsonContract = [\r\n    MichelsonContractParameter,\r\n    MichelsonContractStorage,\r\n    MichelsonContractCode\r\n] | [\r\n    MichelsonContractParameter,\r\n    MichelsonContractCode,\r\n    MichelsonContractStorage\r\n] | [\r\n    MichelsonContractStorage,\r\n    MichelsonContractParameter,\r\n    MichelsonContractCode\r\n] | [\r\n    MichelsonContractStorage,\r\n    MichelsonContractCode,\r\n    MichelsonContractParameter\r\n] | [\r\n    MichelsonContractCode,\r\n    MichelsonContractStorage,\r\n    MichelsonContractParameter\r\n] | [\r\n    MichelsonContractCode,\r\n    MichelsonContractParameter,\r\n    MichelsonContractStorage\r\n];\r\nexport declare type MichelsonContractSection<T extends MichelsonSectionId> = T extends \"parameter\" ? MichelsonContractParameter : T extends \"storage\" ? MichelsonContractStorage : MichelsonContractCode;\r\nexport interface MichelsonTypeFailed {\r\n    failed: MichelsonType;\r\n}\r\nexport declare type MichelsonReturnType = MichelsonType[] | MichelsonTypeFailed;\r\nexport declare enum Protocol {\r\n    Pt24m4xi = \"Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd\",\r\n    PsBABY5H = \"PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU\",\r\n    PsBabyM1 = \"PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS\",\r\n    PsCARTHA = \"PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb\",\r\n    PsDELPH1 = \"PsDELPH1Kxsxt8f9eWbxQeRxkjfbxoqM52jvs5Y5fBxWWh4ifpo\",\r\n    PtEdo2Zk = \"PtEdo2ZkT9oKpimTah6x2embF25oss54njMuPzkJTEi5RqfdZFA\"\r\n}\r\nexport declare const DefaultProtocol = Protocol.PsDELPH1;\r\nexport declare type ProtocolID = `${Protocol}`;\r\nexport interface ProtocolOptions {\r\n    protocol?: ProtocolID;\r\n}\r\nexport {};\r\n"},{"name":"@taquito/michel-codec/dist/types/michelson-validator.d.ts","dts":"import { Expr } from \"./micheline\";\r\nimport { MichelsonError } from \"./utils\";\r\nimport { MichelsonCode, MichelsonType, MichelsonData, MichelsonContract, MichelsonInstruction, InstructionList } from \"./michelson-types\";\r\nexport declare const instructionIDs: Record<MichelsonInstruction[\"prim\"], true>;\r\nexport declare class MichelsonValidationError extends MichelsonError {\r\n    val: Expr;\r\n    /**\r\n     * @param val Value of a node caused the error\r\n     * @param message An error message\r\n     */\r\n    constructor(val: Expr, message?: string);\r\n}\r\n/**\r\n * Checks if the node is a valid Michelson code (sequence of instructions).\r\n * This is a type guard function which either returns true of throws an exception.\r\n * @param ex An AST node\r\n */\r\nexport declare function assertMichelsonInstruction(ex: Expr): ex is MichelsonCode;\r\nexport declare function assertMichelsonComparableType(ex: Expr): ex is MichelsonType;\r\nexport declare function assertMichelsonPackableType(ex: Expr): ex is MichelsonType;\r\nexport declare function assertMichelsonPushableType(ex: Expr): ex is MichelsonType;\r\nexport declare function assertMichelsonStorableType(ex: Expr): ex is MichelsonType;\r\nexport declare function assertMichelsonPassableType(ex: Expr): ex is MichelsonType;\r\nexport declare function assertMichelsonBigMapStorableType(ex: Expr): ex is MichelsonType;\r\n/**\r\n * Checks if the node is a valid Michelson type expression.\r\n * This is a type guard function which either returns true of throws an exception.\r\n * @param ex An AST node\r\n */\r\nexport declare function assertMichelsonType(ex: Expr): ex is MichelsonType;\r\n/**\r\n * Checks if the node is a valid Michelson data literal such as `(Pair {Elt \"0\" 0} 0)`.\r\n * This is a type guard function which either returns true of throws an exception.\r\n * @param ex An AST node\r\n */\r\nexport declare function assertMichelsonData(ex: Expr): ex is MichelsonData;\r\n/**\r\n * Checks if the node is a valid Michelson smart contract source containing all required and valid properties such as `parameter`, `storage` and `code`.\r\n * This is a type guard function which either returns true of throws an exception.\r\n * @param ex An AST node\r\n */\r\nexport declare function assertMichelsonContract(ex: Expr): ex is MichelsonContract;\r\n/**\r\n * Checks if the node is a valid Michelson smart contract source containing all required and valid properties such as `parameter`, `storage` and `code`.\r\n * @param ex An AST node\r\n */\r\nexport declare function isMichelsonScript(ex: Expr): ex is MichelsonContract;\r\n/**\r\n * Checks if the node is a valid Michelson data literal such as `(Pair {Elt \"0\" 0} 0)`.\r\n * @param ex An AST node\r\n */\r\nexport declare function isMichelsonData(ex: Expr): ex is MichelsonData;\r\n/**\r\n * Checks if the node is a valid Michelson code (sequence of instructions).\r\n * @param ex An AST node\r\n */\r\nexport declare function isMichelsonCode(ex: Expr): ex is InstructionList;\r\n/**\r\n * Checks if the node is a valid Michelson type expression.\r\n * @param ex An AST node\r\n */\r\nexport declare function isMichelsonType(ex: Expr): ex is MichelsonType;\r\n"},{"name":"@taquito/michel-codec/dist/types/scan.d.ts","dts":"export declare class ScanError extends Error {\r\n    src: string;\r\n    idx: number;\r\n    constructor(src: string, idx: number, message?: string);\r\n}\r\nexport declare enum Literal {\r\n    Comment = 0,\r\n    Number = 1,\r\n    String = 2,\r\n    Bytes = 3,\r\n    Ident = 4\r\n}\r\nexport declare type TokenType = \"(\" | \")\" | \"{\" | \"}\" | \";\" | Literal;\r\nexport interface Token {\r\n    t: TokenType;\r\n    v: string;\r\n    first: number;\r\n    last: number;\r\n}\r\nexport declare function scan(src: string, scanComments?: boolean): Generator<Token, void>;\r\n"},{"name":"@taquito/michel-codec/dist/types/taquito-michel-codec.d.ts","dts":"/**\r\n * @packageDocumentation\r\n * @module @taquito/michel-codec\r\n */\r\nexport * from \"./micheline\";\r\nexport * from \"./micheline-parser\";\r\nexport * from \"./micheline-emitter\";\r\nexport * from \"./michelson-validator\";\r\nexport * from \"./michelson-types\";\r\nexport * from \"./michelson-typecheck\";\r\nexport * from \"./michelson-contract\";\r\nexport * from \"./formatters\";\r\nexport { MichelsonError, isMichelsonError } from \"./utils\";\r\nexport { MacroError } from \"./macros\";\r\n"},{"name":"@taquito/michel-codec/dist/types/utils.d.ts","dts":"import { Prim, Expr } from \"./micheline\";\r\nexport declare type Tuple<N extends number, T> = N extends 1 ? [T] : N extends 2 ? [T, T] : N extends 3 ? [T, T, T] : N extends 4 ? [T, T, T, T] : N extends 5 ? [T, T, T, T, T] : N extends 6 ? [T, T, T, T, T, T] : N extends 7 ? [T, T, T, T, T, T, T] : N extends 8 ? [T, T, T, T, T, T, T, T] : T[];\r\ndeclare type RequiredProp<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>;\r\ndeclare type OmitProp<T, K extends keyof T> = Omit<T, K> & {\r\n    [P in K]?: undefined;\r\n};\r\nexport declare type ReqArgs<T extends Prim> = RequiredProp<T, \"args\">;\r\nexport declare type NoArgs<T extends Prim> = OmitProp<T, \"args\">;\r\nexport declare type NoAnnots<T extends Prim> = OmitProp<T, \"annots\">;\r\nexport declare type Nullable<T> = {\r\n    [P in keyof T]: T[P] | null;\r\n};\r\nexport declare class MichelsonError<T extends Expr = Expr> extends Error {\r\n    val: T;\r\n    /**\r\n     * @param val Value of a AST node caused the error\r\n     * @param path Path to a node caused the error\r\n     * @param message An error message\r\n     */\r\n    constructor(val: T, message?: string);\r\n}\r\nexport declare function isMichelsonError<T extends Expr = Expr>(err: any): err is MichelsonError<T>;\r\nexport declare class LongInteger {\r\n    private neg;\r\n    private buf;\r\n    private append;\r\n    constructor(arg?: string | number);\r\n    cmp(arg: LongInteger): number;\r\n    get sign(): number;\r\n}\r\nexport declare function parseBytes(s: string): number[] | null;\r\nexport declare function compareBytes(a: number[] | Uint8Array, b: number[] | Uint8Array): number;\r\nexport declare function isDecimal(x: string): boolean;\r\nexport declare function isNatural(x: string): boolean;\r\nexport interface UnpackedAnnotations {\r\n    f?: string[];\r\n    t?: string[];\r\n    v?: string[];\r\n}\r\nexport interface UnpackAnnotationsOptions {\r\n    specialVar?: boolean;\r\n    emptyVar?: boolean;\r\n    specialFields?: boolean;\r\n    emptyFields?: boolean;\r\n}\r\nexport declare function unpackAnnotations(p: Prim | Expr[], opt?: UnpackAnnotationsOptions): UnpackedAnnotations;\r\nexport declare type TezosIDType = \"BlockHash\" | \"OperationHash\" | \"OperationListHash\" | \"OperationListListHash\" | \"ProtocolHash\" | \"ContextHash\" | \"ED25519PublicKeyHash\" | \"SECP256K1PublicKeyHash\" | \"P256PublicKeyHash\" | \"ContractHash\" | \"CryptoboxPublicKeyHash\" | \"ED25519Seed\" | \"ED25519PublicKey\" | \"SECP256K1SecretKey\" | \"P256SecretKey\" | \"ED25519EncryptedSeed\" | \"SECP256K1EncryptedSecretKey\" | \"P256EncryptedSecretKey\" | \"SECP256K1PublicKey\" | \"P256PublicKey\" | \"SECP256K1Scalar\" | \"SECP256K1Element\" | \"ED25519SecretKey\" | \"ED25519Signature\" | \"SECP256K1Signature\" | \"P256Signature\" | \"GenericSignature\" | \"ChainID\";\r\nexport declare type TezosIDPrefix = [number, number[]];\r\nexport declare const tezosPrefix: Record<TezosIDType, TezosIDPrefix>;\r\nexport declare function checkTezosID(id: string | number[], ...types: TezosIDType[]): [TezosIDType, number[]] | null;\r\nexport {};\r\n"},{"name":"@taquito/michelson-encoder/dist/types/schema/model.d.ts","dts":"export interface RpcTransaction {\r\n    protocol: string;\r\n    chain_id: string;\r\n    hash: string;\r\n    branch: string;\r\n    contents: Content[];\r\n    signature: string;\r\n}\r\ninterface Content {\r\n    kind: string;\r\n    source: string;\r\n    fee: string;\r\n    counter: string;\r\n    gas_limit: string;\r\n    storage_limit: string;\r\n    amount: string;\r\n    destination: string;\r\n    parameters: Params;\r\n    metadata: Metadata;\r\n}\r\ninterface Metadata {\r\n    balance_updates: Balanceupdate[];\r\n    operation_result: Operationresult;\r\n}\r\ninterface Operationresult {\r\n    status: string;\r\n    storage: Storage;\r\n    big_map_diff: Bigmapdiff[];\r\n    consumed_gas: string;\r\n    storage_size: string;\r\n    paid_storage_size_diff: string;\r\n    consumed_milligas?: string;\r\n}\r\ninterface Bigmapdiff {\r\n    key_hash: string;\r\n    key: Key;\r\n    value: Value;\r\n}\r\ninterface Value {\r\n    prim: string;\r\n    args: any[];\r\n}\r\ninterface Key {\r\n    bytes: string;\r\n}\r\ninterface Storage {\r\n    prim: string;\r\n    args: any[];\r\n}\r\ninterface Balanceupdate {\r\n    kind: string;\r\n    contract?: string;\r\n    change: string;\r\n    category?: string;\r\n    delegate?: string;\r\n    level?: number;\r\n}\r\ninterface Params {\r\n    prim: string;\r\n    args: any[];\r\n}\r\nexport {};\r\n"},{"name":"@taquito/michelson-encoder/dist/types/schema/parameter.d.ts","dts":"import { Semantic } from '../tokens/token';\r\nimport { ScriptResponse, MichelsonV1Expression } from '@taquito/rpc';\r\n/**\r\n * @warn Our current smart contract abstraction feature is currently in preview. It's API is not final, and it may not cover every use case (yet). We will greatly appreciate any feedback on this feature.\r\n */\r\nexport declare class ParameterSchema {\r\n    private root;\r\n    static fromRPCResponse(val: {\r\n        script: ScriptResponse;\r\n    }): ParameterSchema;\r\n    get isMultipleEntryPoint(): boolean;\r\n    get hasAnnotation(): boolean;\r\n    constructor(val: MichelsonV1Expression);\r\n    Execute(val: any, semantics?: Semantic): any;\r\n    Encode(...args: any[]): any;\r\n    ExtractSchema(): any;\r\n    ExtractSignatures(): any[][];\r\n}\r\n"},{"name":"@taquito/michelson-encoder/dist/types/schema/storage.d.ts","dts":"import { MichelsonV1Expression, ScriptResponse } from '@taquito/rpc';\r\nimport { Semantic } from '../tokens/token';\r\nimport { RpcTransaction } from './model';\r\ndeclare const schemaTypeSymbol: unique symbol;\r\n/**\r\n * @warn Our current smart contract abstraction feature is currently in preview. It's API is not final, and it may not cover every use case (yet). We will greatly appreciate any feedback on this feature.\r\n */\r\nexport declare class Schema {\r\n    private root;\r\n    [schemaTypeSymbol]: boolean;\r\n    static isSchema(obj: any): obj is Schema;\r\n    private bigMap?;\r\n    static fromRPCResponse(val: {\r\n        script: ScriptResponse;\r\n    }): Schema;\r\n    private isExpressionExtended;\r\n    constructor(val: MichelsonV1Expression);\r\n    private removeTopLevelAnnotation;\r\n    Execute(val: any, semantics?: Semantic): any;\r\n    Typecheck(val: any): boolean;\r\n    ExecuteOnBigMapDiff(diff: any[], semantics?: Semantic): any;\r\n    ExecuteOnBigMapValue(key: any, semantics?: Semantic): any;\r\n    EncodeBigMapKey(key: string): {\r\n        key: {\r\n            [key: string]: string;\r\n        };\r\n        type: {\r\n            prim: string;\r\n        };\r\n    };\r\n    Encode(_value?: any): any;\r\n    ExtractSchema(): any;\r\n    /**\r\n     * @deprecated\r\n     */\r\n    ComputeState(tx: RpcTransaction[], state: any): any;\r\n    /**\r\n     * @description Look up in top-level pairs of the storage to find a value matching the specified type\r\n     *\r\n     * @returns The first value found that match the type or `undefined` if no value is found\r\n     *\r\n     * @param storage storage to parse to find the value\r\n     * @param valueType type of value to look for\r\n     *\r\n     */\r\n    FindFirstInTopLevelPair<T extends MichelsonV1Expression>(storage: any, valueType: any): T | undefined;\r\n    private findValue;\r\n}\r\nexport {};\r\n"},{"name":"@taquito/michelson-encoder/dist/types/schema/types.d.ts","dts":"export declare type Falsy<T> = T | undefined | false;\r\n"},{"name":"@taquito/michelson-encoder/dist/types/tokens/comparable/address.d.ts","dts":"import { TokenFactory, ComparableToken, TokenValidationError } from '../token';\r\nexport declare class AddressValidationError extends TokenValidationError {\r\n    value: any;\r\n    token: AddressToken;\r\n    name: string;\r\n    constructor(value: any, token: AddressToken, message: string);\r\n}\r\nexport declare class AddressToken extends ComparableToken {\r\n    protected val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    };\r\n    protected idx: number;\r\n    protected fac: TokenFactory;\r\n    static prim: string;\r\n    constructor(val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    }, idx: number, fac: TokenFactory);\r\n    ToBigMapKey(val: any): {\r\n        key: {\r\n            bytes: string;\r\n        };\r\n        type: {\r\n            prim: string;\r\n        };\r\n    };\r\n    private isValid;\r\n    Encode(args: any[]): any;\r\n    EncodeObject(val: any): any;\r\n    Execute(val: {\r\n        bytes: string;\r\n        string: string;\r\n    }): string;\r\n    ExtractSchema(): string;\r\n    ToKey({ bytes, string }: any): any;\r\n    compare(address1: string, address2: string): number;\r\n}\r\n"},{"name":"@taquito/michelson-encoder/dist/types/tokens/comparable/bool.d.ts","dts":"import { TokenFactory, ComparableToken } from '../token';\r\nexport declare class BoolToken extends ComparableToken {\r\n    protected val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    };\r\n    protected idx: number;\r\n    protected fac: TokenFactory;\r\n    static prim: string;\r\n    constructor(val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    }, idx: number, fac: TokenFactory);\r\n    Execute(val: any): boolean;\r\n    Encode(args: any[]): any;\r\n    EncodeObject(val: any): {\r\n        prim: string;\r\n    };\r\n    ExtractSchema(): string;\r\n    ToBigMapKey(val: string): {\r\n        key: {\r\n            [key: string]: string;\r\n        };\r\n        type: {\r\n            prim: string;\r\n        };\r\n    };\r\n    ToKey(val: string): {\r\n        prim: string;\r\n    };\r\n    compare(val1: any, val2: any): 0 | 1 | -1;\r\n}\r\n"},{"name":"@taquito/michelson-encoder/dist/types/tokens/comparable/bytes.d.ts","dts":"import { TokenFactory, ComparableToken, TokenValidationError } from '../token';\r\nexport declare class BytesValidationError extends TokenValidationError {\r\n    value: any;\r\n    token: BytesToken;\r\n    name: string;\r\n    constructor(value: any, token: BytesToken, message: string);\r\n}\r\nexport declare class BytesToken extends ComparableToken {\r\n    protected val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    };\r\n    protected idx: number;\r\n    protected fac: TokenFactory;\r\n    static prim: string;\r\n    constructor(val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    }, idx: number, fac: TokenFactory);\r\n    ToBigMapKey(val: string): {\r\n        key: {\r\n            bytes: string;\r\n        };\r\n        type: {\r\n            prim: string;\r\n        };\r\n    };\r\n    private isValid;\r\n    Encode(args: any[]): any;\r\n    EncodeObject(val: any): {\r\n        bytes: string;\r\n    };\r\n    Execute(val: any): string;\r\n    ExtractSchema(): string;\r\n    ToKey({ bytes, string }: any): any;\r\n}\r\n"},{"name":"@taquito/michelson-encoder/dist/types/tokens/comparable/int.d.ts","dts":"import { TokenFactory, ComparableToken, TokenValidationError } from '../token';\r\nexport declare class IntValidationError extends TokenValidationError {\r\n    value: any;\r\n    token: IntToken;\r\n    name: string;\r\n    constructor(value: any, token: IntToken, message: string);\r\n}\r\nexport declare class IntToken extends ComparableToken {\r\n    protected val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    };\r\n    protected idx: number;\r\n    protected fac: TokenFactory;\r\n    static prim: string;\r\n    constructor(val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    }, idx: number, fac: TokenFactory);\r\n    Execute(val: {\r\n        [key: string]: string;\r\n    }): {\r\n        [key: string]: any;\r\n    };\r\n    ExtractSchema(): string;\r\n    private isValid;\r\n    Encode(args: any[]): any;\r\n    EncodeObject(val: any): any;\r\n    ToBigMapKey(val: string): {\r\n        key: {\r\n            int: string;\r\n        };\r\n        type: {\r\n            prim: string;\r\n        };\r\n    };\r\n    ToKey({ int }: any): any;\r\n}\r\n"},{"name":"@taquito/michelson-encoder/dist/types/tokens/comparable/key_hash.d.ts","dts":"import { TokenFactory, ComparableToken, TokenValidationError } from '../token';\r\nexport declare class KeyHashValidationError extends TokenValidationError {\r\n    value: any;\r\n    token: KeyHashToken;\r\n    name: string;\r\n    constructor(value: any, token: KeyHashToken, message: string);\r\n}\r\nexport declare class KeyHashToken extends ComparableToken {\r\n    protected val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    };\r\n    protected idx: number;\r\n    protected fac: TokenFactory;\r\n    static prim: string;\r\n    constructor(val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    }, idx: number, fac: TokenFactory);\r\n    Execute(val: {\r\n        bytes: string;\r\n        string: string;\r\n    }): string;\r\n    private isValid;\r\n    Encode(args: any[]): any;\r\n    EncodeObject(val: any): any;\r\n    ExtractSchema(): string;\r\n    ToKey({ string, bytes }: any): any;\r\n    ToBigMapKey(val: string): {\r\n        key: {\r\n            string: string;\r\n        };\r\n        type: {\r\n            prim: string;\r\n        };\r\n    };\r\n}\r\n"},{"name":"@taquito/michelson-encoder/dist/types/tokens/comparable/mutez.d.ts","dts":"import { TokenFactory, ComparableToken, TokenValidationError } from '../token';\r\nimport BigNumber from 'bignumber.js';\r\nexport declare class MutezValidationError extends TokenValidationError {\r\n    value: any;\r\n    token: MutezToken;\r\n    name: string;\r\n    constructor(value: any, token: MutezToken, message: string);\r\n}\r\nexport declare class MutezToken extends ComparableToken {\r\n    protected val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    };\r\n    protected idx: number;\r\n    protected fac: TokenFactory;\r\n    static prim: string;\r\n    constructor(val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    }, idx: number, fac: TokenFactory);\r\n    Execute(val: any): BigNumber;\r\n    ExtractSchema(): string;\r\n    private isValid;\r\n    Encode(args: any[]): any;\r\n    EncodeObject(val: any): any;\r\n    ToBigMapKey(val: string): {\r\n        key: {\r\n            int: string;\r\n        };\r\n        type: {\r\n            prim: string;\r\n        };\r\n    };\r\n    ToKey({ int }: any): any;\r\n}\r\n"},{"name":"@taquito/michelson-encoder/dist/types/tokens/comparable/nat.d.ts","dts":"import { TokenFactory, ComparableToken, TokenValidationError } from '../token';\r\nexport declare class NatValidationError extends TokenValidationError {\r\n    value: any;\r\n    token: NatToken;\r\n    name: string;\r\n    constructor(value: any, token: NatToken, message: string);\r\n}\r\nexport declare class NatToken extends ComparableToken {\r\n    protected val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    };\r\n    protected idx: number;\r\n    protected fac: TokenFactory;\r\n    static prim: string;\r\n    constructor(val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    }, idx: number, fac: TokenFactory);\r\n    Execute(val: any): {\r\n        [key: string]: any;\r\n    };\r\n    Encode(args: any[]): any;\r\n    private isValid;\r\n    EncodeObject(val: any): any;\r\n    ExtractSchema(): string;\r\n    ToBigMapKey(val: string): {\r\n        key: {\r\n            int: string;\r\n        };\r\n        type: {\r\n            prim: string;\r\n        };\r\n    };\r\n    ToKey({ int }: any): any;\r\n}\r\n"},{"name":"@taquito/michelson-encoder/dist/types/tokens/comparable/string.d.ts","dts":"import { TokenFactory, ComparableToken } from '../token';\r\nexport declare class StringToken extends ComparableToken {\r\n    protected val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    };\r\n    protected idx: number;\r\n    protected fac: TokenFactory;\r\n    static prim: string;\r\n    constructor(val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    }, idx: number, fac: TokenFactory);\r\n    Execute(val: any): string;\r\n    ExtractSchema(): string;\r\n    Encode(args: any[]): any;\r\n    EncodeObject(val: any): any;\r\n    ToKey({ string }: any): any;\r\n    ToBigMapKey(val: string): {\r\n        key: {\r\n            string: string;\r\n        };\r\n        type: {\r\n            prim: string;\r\n        };\r\n    };\r\n}\r\n"},{"name":"@taquito/michelson-encoder/dist/types/tokens/comparable/timestamp.d.ts","dts":"import { TokenFactory, ComparableToken } from '../token';\r\nexport declare class TimestampToken extends ComparableToken {\r\n    protected val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    };\r\n    protected idx: number;\r\n    protected fac: TokenFactory;\r\n    static prim: string;\r\n    constructor(val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    }, idx: number, fac: TokenFactory);\r\n    Execute(val: {\r\n        string?: string;\r\n        int?: string;\r\n    }): string | undefined;\r\n    Encode(args: any[]): any;\r\n    EncodeObject(val: any): any;\r\n    ExtractSchema(): string;\r\n    ToKey({ string }: any): any;\r\n    ToBigMapKey(val: string): {\r\n        key: {\r\n            string: string;\r\n        };\r\n        type: {\r\n            prim: string;\r\n        };\r\n    };\r\n}\r\n"},{"name":"@taquito/michelson-encoder/dist/types/tokens/bigmap.d.ts","dts":"import { ComparableToken, Semantic, Token, TokenFactory, TokenValidationError } from './token';\r\nexport declare class BigMapValidationError extends TokenValidationError {\r\n    value: any;\r\n    token: BigMapToken;\r\n    name: string;\r\n    constructor(value: any, token: BigMapToken, message: string);\r\n}\r\nexport declare class BigMapToken extends Token {\r\n    protected val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots?: any[];\r\n    };\r\n    protected idx: number;\r\n    protected fac: TokenFactory;\r\n    static prim: string;\r\n    constructor(val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots?: any[];\r\n    }, idx: number, fac: TokenFactory);\r\n    get ValueSchema(): Token;\r\n    get KeySchema(): ComparableToken;\r\n    ExtractSchema(): {\r\n        [x: number]: any;\r\n    };\r\n    private isValid;\r\n    Encode(args: any[]): any;\r\n    EncodeObject(args: any): any;\r\n    Execute(val: any[] | {\r\n        int: string;\r\n    }, semantic?: Semantic): any;\r\n}\r\n"},{"name":"@taquito/michelson-encoder/dist/types/tokens/chain-id.d.ts","dts":"import { TokenFactory, ComparableToken, TokenValidationError } from './token';\r\nexport declare class ChainIDValidationError extends TokenValidationError {\r\n    value: any;\r\n    token: ChainIDToken;\r\n    name: string;\r\n    constructor(value: any, token: ChainIDToken, message: string);\r\n}\r\nexport declare class ChainIDToken extends ComparableToken {\r\n    protected val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    };\r\n    protected idx: number;\r\n    protected fac: TokenFactory;\r\n    static prim: string;\r\n    constructor(val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    }, idx: number, fac: TokenFactory);\r\n    private isValid;\r\n    Execute(val: any): string;\r\n    ExtractSchema(): string;\r\n    Encode(args: any[]): any;\r\n    EncodeObject(val: any): any;\r\n    ToKey({ string }: any): any;\r\n    ToBigMapKey(val: string): {\r\n        key: {\r\n            string: string;\r\n        };\r\n        type: {\r\n            prim: string;\r\n        };\r\n    };\r\n}\r\n"},{"name":"@taquito/michelson-encoder/dist/types/tokens/contract.d.ts","dts":"import { Token, TokenFactory, TokenValidationError } from './token';\r\nexport declare class ContractValidationError extends TokenValidationError {\r\n    value: any;\r\n    token: ContractToken;\r\n    name: string;\r\n    constructor(value: any, token: ContractToken, message: string);\r\n}\r\nexport declare class ContractToken extends Token {\r\n    protected val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    };\r\n    protected idx: number;\r\n    protected fac: TokenFactory;\r\n    static prim: string;\r\n    constructor(val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    }, idx: number, fac: TokenFactory);\r\n    private isValid;\r\n    Execute(val: {\r\n        bytes: string;\r\n        string: string;\r\n    }): any;\r\n    Encode(args: any[]): any;\r\n    EncodeObject(val: any): any;\r\n    ExtractSchema(): string;\r\n}\r\n"},{"name":"@taquito/michelson-encoder/dist/types/tokens/createToken.d.ts","dts":"import { Token } from './token';\r\nexport declare class InvalidTokenError implements Error {\r\n    message: string;\r\n    data: any;\r\n    name: string;\r\n    constructor(message: string, data: any);\r\n}\r\nexport declare function createToken(val: any, idx: number): Token;\r\n"},{"name":"@taquito/michelson-encoder/dist/types/tokens/key.d.ts","dts":"import { Token, TokenFactory, TokenValidationError } from './token';\r\nexport declare class KeyValidationError extends TokenValidationError {\r\n    value: any;\r\n    token: KeyToken;\r\n    name: string;\r\n    constructor(value: any, token: KeyToken, message: string);\r\n}\r\nexport declare class KeyToken extends Token {\r\n    protected val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    };\r\n    protected idx: number;\r\n    protected fac: TokenFactory;\r\n    static prim: string;\r\n    constructor(val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    }, idx: number, fac: TokenFactory);\r\n    Execute(val: {\r\n        bytes: string;\r\n        string: string;\r\n    }): string;\r\n    private isValid;\r\n    Encode(args: any[]): any;\r\n    EncodeObject(val: any): any;\r\n    ExtractSchema(): string;\r\n}\r\n"},{"name":"@taquito/michelson-encoder/dist/types/tokens/lambda.d.ts","dts":"import { Token, TokenFactory } from './token';\r\nexport declare class LambdaToken extends Token {\r\n    protected val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    };\r\n    protected idx: number;\r\n    protected fac: TokenFactory;\r\n    static prim: string;\r\n    constructor(val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    }, idx: number, fac: TokenFactory);\r\n    Execute(val: any): {\r\n        [key: string]: any;\r\n    };\r\n    Encode(args: any[]): any;\r\n    EncodeObject(val: any): any;\r\n    ExtractSchema(): {\r\n        [x: string]: {\r\n            parameters: any;\r\n            returns: any;\r\n        };\r\n    };\r\n}\r\n"},{"name":"@taquito/michelson-encoder/dist/types/tokens/list.d.ts","dts":"import { Token, TokenFactory, Semantic, TokenValidationError } from './token';\r\nexport declare class ListValidationError extends TokenValidationError {\r\n    value: any;\r\n    token: ListToken;\r\n    name: string;\r\n    constructor(value: any, token: ListToken, message: string);\r\n}\r\nexport declare class ListToken extends Token {\r\n    protected val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    };\r\n    protected idx: number;\r\n    protected fac: TokenFactory;\r\n    static prim: string;\r\n    constructor(val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    }, idx: number, fac: TokenFactory);\r\n    private isValid;\r\n    Encode(args: any[]): any;\r\n    Execute(val: any, semantics?: Semantic): any;\r\n    EncodeObject(args: any): any;\r\n    ExtractSchema(): string;\r\n}\r\n"},{"name":"@taquito/michelson-encoder/dist/types/tokens/map.d.ts","dts":"import { ComparableToken, Semantic, Token, TokenFactory, TokenValidationError } from './token';\r\nexport declare class MapValidationError extends TokenValidationError {\r\n    value: any;\r\n    token: MapToken;\r\n    name: string;\r\n    constructor(value: any, token: MapToken, message: string);\r\n}\r\nexport declare class MapToken extends Token {\r\n    protected val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    };\r\n    protected idx: number;\r\n    protected fac: TokenFactory;\r\n    static prim: string;\r\n    constructor(val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    }, idx: number, fac: TokenFactory);\r\n    get ValueSchema(): Token;\r\n    get KeySchema(): ComparableToken;\r\n    private isValid;\r\n    Execute(val: any[], semantics?: Semantic): {\r\n        [key: string]: any;\r\n    };\r\n    Encode(args: any[]): any;\r\n    EncodeObject(args: any): any;\r\n    ExtractSchema(): {\r\n        map: {\r\n            key: any;\r\n            value: any;\r\n        };\r\n    };\r\n}\r\n"},{"name":"@taquito/michelson-encoder/dist/types/tokens/operation.d.ts","dts":"import { Token, TokenFactory } from './token';\r\nexport declare class OperationToken extends Token {\r\n    protected val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    };\r\n    protected idx: number;\r\n    protected fac: TokenFactory;\r\n    static prim: string;\r\n    constructor(val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    }, idx: number, fac: TokenFactory);\r\n    Execute(val: any): {\r\n        [key: string]: any;\r\n    };\r\n    Encode(...args: any[]): any;\r\n    EncodeObject(val: any): any;\r\n    ExtractSchema(): string;\r\n}\r\n"},{"name":"@taquito/michelson-encoder/dist/types/tokens/option.d.ts","dts":"import { Token, TokenFactory, Semantic } from './token';\r\nexport declare class OptionToken extends Token {\r\n    protected val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    };\r\n    protected idx: number;\r\n    protected fac: TokenFactory;\r\n    static prim: string;\r\n    constructor(val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    }, idx: number, fac: TokenFactory);\r\n    subToken(): Token;\r\n    annot(): string;\r\n    Encode(args: any): any;\r\n    EncodeObject(args: any): any;\r\n    Execute(val: any, semantics?: Semantic): any;\r\n    ExtractSchema(): any;\r\n    ExtractSignature(): any[][];\r\n}\r\n"},{"name":"@taquito/michelson-encoder/dist/types/tokens/or.d.ts","dts":"import { Token, TokenFactory, Semantic } from './token';\r\nexport declare class OrToken extends Token {\r\n    protected val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    };\r\n    protected idx: number;\r\n    protected fac: TokenFactory;\r\n    static prim: string;\r\n    constructor(val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    }, idx: number, fac: TokenFactory);\r\n    Encode(args: any[]): any;\r\n    ExtractSignature(): any;\r\n    EncodeObject(args: any): any;\r\n    Execute(val: any, semantics?: Semantic): any;\r\n    private traversal;\r\n    ExtractSchema(): any;\r\n}\r\n"},{"name":"@taquito/michelson-encoder/dist/types/tokens/pair.d.ts","dts":"import { TokenFactory, Semantic, ComparableToken } from './token';\r\nexport declare class PairToken extends ComparableToken {\r\n    static prim: string;\r\n    constructor(val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    } | any[], idx: number, fac: TokenFactory);\r\n    private args;\r\n    private tokens;\r\n    Encode(args: any[]): any;\r\n    ExtractSignature(): any;\r\n    ToBigMapKey(val: any): {\r\n        key: any;\r\n        type: {\r\n            prim: string;\r\n            args?: any[] | undefined;\r\n        };\r\n    };\r\n    ToKey(val: any): {\r\n        [key: string]: any;\r\n    };\r\n    EncodeObject(args: any): any;\r\n    private traversal;\r\n    Execute(val: any, semantics?: Semantic): {\r\n        [key: string]: any;\r\n    };\r\n    ExtractSchema(): any;\r\n    compare(val1: any, val2: any): number;\r\n}\r\n"},{"name":"@taquito/michelson-encoder/dist/types/tokens/set.d.ts","dts":"import { Token, TokenFactory, Semantic, TokenValidationError, ComparableToken } from './token';\r\nexport declare class SetValidationError extends TokenValidationError {\r\n    value: any;\r\n    token: SetToken;\r\n    name: string;\r\n    constructor(value: any, token: SetToken, message: string);\r\n}\r\nexport declare class SetToken extends Token {\r\n    protected val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    };\r\n    protected idx: number;\r\n    protected fac: TokenFactory;\r\n    static prim: string;\r\n    constructor(val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    }, idx: number, fac: TokenFactory);\r\n    get KeySchema(): ComparableToken;\r\n    private isValid;\r\n    Encode(args: any[]): any;\r\n    Execute(val: any, semantics?: Semantic): any;\r\n    EncodeObject(args: any): any;\r\n    ExtractSchema(): string;\r\n}\r\n"},{"name":"@taquito/michelson-encoder/dist/types/tokens/signature.d.ts","dts":"import { Token, TokenFactory, TokenValidationError } from './token';\r\nexport declare class SignatureValidationError extends TokenValidationError {\r\n    value: any;\r\n    token: SignatureToken;\r\n    name: string;\r\n    constructor(value: any, token: SignatureToken, message: string);\r\n}\r\nexport declare class SignatureToken extends Token {\r\n    protected val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    };\r\n    protected idx: number;\r\n    protected fac: TokenFactory;\r\n    static prim: string;\r\n    constructor(val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    }, idx: number, fac: TokenFactory);\r\n    Execute(val: any): {\r\n        [key: string]: any;\r\n    };\r\n    private isValid;\r\n    Encode(args: any[]): any;\r\n    EncodeObject(val: any): any;\r\n    ExtractSchema(): string;\r\n}\r\n"},{"name":"@taquito/michelson-encoder/dist/types/tokens/ticket.d.ts","dts":"import { Token, TokenFactory, Semantic } from './token';\r\nexport declare class EncodeTicketError implements Error {\r\n    name: string;\r\n    message: string;\r\n}\r\nexport declare class TicketToken extends Token {\r\n    protected val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    };\r\n    protected idx: number;\r\n    protected fac: TokenFactory;\r\n    static prim: string;\r\n    constructor(val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    }, idx: number, fac: TokenFactory);\r\n    Encode(_args: any[]): any;\r\n    EncodeObject(_args: any): any;\r\n    Execute(val: any, _semantics?: Semantic): {\r\n        ticketer: any;\r\n        value: any;\r\n        amount: any;\r\n    };\r\n    ExtractSchema(): {\r\n        ticketer: string;\r\n        value: string;\r\n        amount: string;\r\n    };\r\n}\r\n"},{"name":"@taquito/michelson-encoder/dist/types/tokens/token.d.ts","dts":"import { MichelsonV1Expression } from '@taquito/rpc';\r\nexport declare abstract class TokenValidationError implements Error {\r\n    value: any;\r\n    token: Token;\r\n    name: string;\r\n    message: string;\r\n    constructor(value: any, token: Token, baseMessage: string);\r\n}\r\nexport declare type TokenFactory = (val: any, idx: number) => Token;\r\nexport interface Semantic {\r\n    [key: string]: (value: MichelsonV1Expression, schema: MichelsonV1Expression) => any;\r\n}\r\nexport declare abstract class Token {\r\n    protected val: {\r\n        prim: string;\r\n        args?: any[];\r\n        annots?: any[];\r\n    };\r\n    protected idx: number;\r\n    protected fac: TokenFactory;\r\n    constructor(val: {\r\n        prim: string;\r\n        args?: any[];\r\n        annots?: any[];\r\n    }, idx: number, fac: TokenFactory);\r\n    protected typeWithoutAnnotations(): {\r\n        prim: string;\r\n        args?: any[] | undefined;\r\n    };\r\n    annot(): any;\r\n    hasAnnotations(): number | false;\r\n    createToken: TokenFactory;\r\n    abstract ExtractSchema(): any;\r\n    abstract Execute(val: any, semantics?: Semantic): any;\r\n    abstract Encode(_args: any[]): any;\r\n    abstract EncodeObject(args: any): any;\r\n    ExtractSignature(): any[][];\r\n}\r\nexport declare abstract class ComparableToken extends Token {\r\n    abstract ToBigMapKey(val: string): {\r\n        key: {\r\n            [key: string]: string;\r\n        };\r\n        type: {\r\n            prim: string;\r\n        };\r\n    };\r\n    abstract ToKey(val: string): any;\r\n    compare(o1: string, o2: string): number;\r\n}\r\n"},{"name":"@taquito/michelson-encoder/dist/types/tokens/tokens.d.ts","dts":"import { PairToken } from './pair';\r\nimport { NatToken } from './comparable/nat';\r\nimport { StringToken } from './comparable/string';\r\nimport { BigMapToken } from './bigmap';\r\nimport { AddressToken } from './comparable/address';\r\nimport { MapToken } from './map';\r\nimport { BoolToken } from './comparable/bool';\r\nimport { OrToken } from './or';\r\nimport { ContractToken } from './contract';\r\nimport { ListToken } from './list';\r\nimport { MutezToken } from './comparable/mutez';\r\nimport { BytesToken } from './comparable/bytes';\r\nimport { OptionToken } from './option';\r\nimport { TimestampToken } from './comparable/timestamp';\r\nimport { IntToken } from './comparable/int';\r\nimport { UnitToken } from './unit';\r\nimport { KeyToken } from './key';\r\nimport { KeyHashToken } from './comparable/key_hash';\r\nimport { SignatureToken } from './signature';\r\nimport { LambdaToken } from './lambda';\r\nimport { OperationToken } from './operation';\r\nimport { SetToken } from './set';\r\nimport { ChainIDToken } from './chain-id';\r\nimport { TicketToken } from './ticket';\r\nexport declare const tokens: (typeof PairToken | typeof NatToken | typeof StringToken | typeof BigMapToken | typeof AddressToken | typeof MapToken | typeof BoolToken | typeof OrToken | typeof ContractToken | typeof ListToken | typeof MutezToken | typeof BytesToken | typeof OptionToken | typeof TimestampToken | typeof IntToken | typeof UnitToken | typeof KeyToken | typeof KeyHashToken | typeof SignatureToken | typeof LambdaToken | typeof OperationToken | typeof SetToken | typeof ChainIDToken | typeof TicketToken)[];\r\n"},{"name":"@taquito/michelson-encoder/dist/types/tokens/unit.d.ts","dts":"import { Token, TokenFactory } from './token';\r\nexport declare class UnitToken extends Token {\r\n    protected val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    };\r\n    protected idx: number;\r\n    protected fac: TokenFactory;\r\n    static prim: string;\r\n    constructor(val: {\r\n        prim: string;\r\n        args: any[];\r\n        annots: any[];\r\n    }, idx: number, fac: TokenFactory);\r\n    Encode(args: any[]): any;\r\n    EncodeObject(_val: any): any;\r\n    Execute(): symbol;\r\n    ExtractSchema(): string;\r\n}\r\n"},{"name":"@taquito/michelson-encoder/dist/types/errors.d.ts","dts":"export { ListValidationError } from './tokens/list';\r\nexport { MapValidationError } from './tokens/map';\r\nexport { SetValidationError } from './tokens/set';\r\nexport { BigMapValidationError } from './tokens/bigmap';\r\nexport { ChainIDValidationError } from './tokens/chain-id';\r\nexport { KeyValidationError } from './tokens/key';\r\nexport { ContractValidationError } from './tokens/contract';\r\nexport { SignatureValidationError } from './tokens/signature';\r\nexport { AddressValidationError } from './tokens/comparable/address';\r\nexport { BytesValidationError } from './tokens/comparable/bytes';\r\nexport { IntValidationError } from './tokens/comparable/int';\r\nexport { KeyHashValidationError } from './tokens/comparable/key_hash';\r\nexport { MutezValidationError } from './tokens/comparable/mutez';\r\nexport { NatValidationError } from './tokens/comparable/nat';\r\nexport { EncodeTicketError } from './tokens/ticket';\r\n"},{"name":"@taquito/michelson-encoder/dist/types/michelson-map.d.ts","dts":"import { MichelsonV1Expression } from '@taquito/rpc';\r\ndeclare const michelsonMapTypeSymbol: unique symbol;\r\nexport declare type MichelsonMapKey = Array<any> | Object | string | boolean | number;\r\nexport declare class MapTypecheckError implements Error {\r\n    readonly value: any;\r\n    readonly type: any;\r\n    name: string;\r\n    message: string;\r\n    constructor(value: any, type: any, errorType: 'key' | 'value');\r\n}\r\n/**\r\n * @description Michelson Map is an abstraction over the michelson native map. It supports complex Pair as key\r\n */\r\nexport declare class MichelsonMap<K extends MichelsonMapKey, T extends any> {\r\n    private valueMap;\r\n    private keyMap;\r\n    [michelsonMapTypeSymbol]: boolean;\r\n    static isMichelsonMap(obj: any): obj is MichelsonMap<any, any>;\r\n    private keySchema?;\r\n    private valueSchema?;\r\n    /**\r\n     * @param mapType If specified key and value will be type-checked before being added to the map\r\n     *\r\n     * @example new MichelsonMap({ prim: \"map\", args: [{prim: \"string\"}, {prim: \"int\"}]})\r\n     */\r\n    constructor(mapType?: MichelsonV1Expression);\r\n    setType(mapType: MichelsonV1Expression): void;\r\n    removeType(): void;\r\n    static fromLiteral(obj: {\r\n        [key: string]: any;\r\n    }, mapType?: MichelsonV1Expression): MichelsonMap<MichelsonMapKey, unknown>;\r\n    private typecheckKey;\r\n    private typecheckValue;\r\n    private assertTypecheckValue;\r\n    private assertTypecheckKey;\r\n    private serializeDeterministically;\r\n    keys(): Generator<K>;\r\n    values(): Generator<T>;\r\n    entries(): Generator<[K, T]>;\r\n    get(key: K): T | undefined;\r\n    /**\r\n     *\r\n     * @description Set a key and a value in the MichelsonMap. If the key already exists, override the current value.\r\n     *\r\n     * @example map.set(\"myKey\", \"myValue\") // Using a string as key\r\n     *\r\n     * @example map.set({0: \"test\", 1: \"test1\"}, \"myValue\") // Using a pair as key\r\n     *\r\n     * @warn The same key can be represented in multiple ways, depending on the type of the key. This duplicate key situation will cause a runtime error (duplicate key) when sending the map data to the Tezos RPC node.\r\n     *\r\n     * For example, consider a contract with a map whose key is of type boolean.  If you set the following values in MichelsonMap: map.set(false, \"myValue\") and map.set(null, \"myValue\").\r\n     *\r\n     * You will get two unique entries in the MichelsonMap. These values will both be evaluated as falsy by the MichelsonEncoder and ultimately rejected by the Tezos RPC.\r\n     */\r\n    set(key: K, value: T): void;\r\n    delete(key: K): void;\r\n    has(key: K): boolean;\r\n    clear(): void;\r\n    get size(): number;\r\n    forEach(cb: (value: T, key: K, map: MichelsonMap<K, T>) => void): void;\r\n}\r\nexport {};\r\n"},{"name":"@taquito/michelson-encoder/dist/types/taquito-michelson-encoder.d.ts","dts":"/**\r\n * @packageDocumentation\r\n * @module @taquito/michelson-encoder\r\n */\r\nexport * from './schema/storage';\r\nexport * from './schema/parameter';\r\nexport { Semantic } from './tokens/token';\r\nexport * from './errors';\r\nexport declare const UnitValue: unique symbol;\r\nexport * from './michelson-map';\r\n"},{"name":"@taquito/michelson-encoder/node_modules/bignumber.js/bignumber.d.ts","dts":"// Type definitions for bignumber.js >=8.1.0\r\n// Project: https://github.com/MikeMcl/bignumber.js\r\n// Definitions by: Michael Mclaughlin <https://github.com/MikeMcl>\r\n// Definitions: https://github.com/MikeMcl/bignumber.js\r\n\r\n// Documentation: http://mikemcl.github.io/bignumber.js/\r\n//\r\n// Exports:\r\n//\r\n//   class     BigNumber (default export)\r\n//   type      BigNumber.Constructor\r\n//   type      BigNumber.ModuloMode\r\n//   type      BigNumber.RoundingMOde\r\n//   type      BigNumber.Value\r\n//   interface BigNumber.Config\r\n//   interface BigNumber.Format\r\n//   interface BigNumber.Instance\r\n//\r\n// Example:\r\n//\r\n//   import {BigNumber} from \"bignumber.js\"\r\n//   //import BigNumber from \"bignumber.js\"\r\n//\r\n//   let rm: BigNumber.RoundingMode = BigNumber.ROUND_UP;\r\n//   let f: BigNumber.Format = { decimalSeparator: ',' };\r\n//   let c: BigNumber.Config = { DECIMAL_PLACES: 4, ROUNDING_MODE: rm, FORMAT: f };\r\n//   BigNumber.config(c);\r\n//\r\n//   let v: BigNumber.Value = '12345.6789';\r\n//   let b: BigNumber = new BigNumber(v);\r\n//\r\n// The use of compiler option `--strictNullChecks` is recommended.\r\n\r\nexport default BigNumber;\r\n\r\nexport namespace BigNumber {\r\n\r\n  /** See `BigNumber.config` (alias `BigNumber.set`) and `BigNumber.clone`. */\r\n  interface Config {\r\n\r\n    /**\r\n     * An integer, 0 to 1e+9. Default value: 20.\r\n     *\r\n     * The maximum number of decimal places of the result of operations involving division, i.e.\r\n     * division, square root and base conversion operations, and exponentiation when the exponent is\r\n     * negative.\r\n     *\r\n     * ```ts\r\n     * BigNumber.config({ DECIMAL_PLACES: 5 })\r\n     * BigNumber.set({ DECIMAL_PLACES: 5 })\r\n     * ```\r\n     */\r\n    DECIMAL_PLACES?: number;\r\n\r\n    /**\r\n     * An integer, 0 to 8. Default value: `BigNumber.ROUND_HALF_UP` (4).\r\n     *\r\n     * The rounding mode used in operations that involve division (see `DECIMAL_PLACES`) and the\r\n     * default rounding mode of the `decimalPlaces`, `precision`, `toExponential`, `toFixed`,\r\n     * `toFormat` and `toPrecision` methods.\r\n     *\r\n     * The modes are available as enumerated properties of the BigNumber constructor.\r\n     *\r\n     * ```ts\r\n     * BigNumber.config({ ROUNDING_MODE: 0 })\r\n     * BigNumber.set({ ROUNDING_MODE: BigNumber.ROUND_UP })\r\n     * ```\r\n     */\r\n    ROUNDING_MODE?: BigNumber.RoundingMode;\r\n\r\n    /**\r\n     * An integer, 0 to 1e+9, or an array, [-1e+9 to 0, 0 to 1e+9].\r\n     * Default value: `[-7, 20]`.\r\n     *\r\n     * The exponent value(s) at which `toString` returns exponential notation.\r\n     *\r\n     * If a single number is assigned, the value is the exponent magnitude.\r\n     *\r\n     * If an array of two numbers is assigned then the first number is the negative exponent value at\r\n     * and beneath which exponential notation is used, and the second number is the positive exponent\r\n     * value at and above which exponential notation is used.\r\n     *\r\n     * For example, to emulate JavaScript numbers in terms of the exponent values at which they begin\r\n     * to use exponential notation, use `[-7, 20]`.\r\n     *\r\n     * ```ts\r\n     * BigNumber.config({ EXPONENTIAL_AT: 2 })\r\n     * new BigNumber(12.3)         // '12.3'        e is only 1\r\n     * new BigNumber(123)          // '1.23e+2'\r\n     * new BigNumber(0.123)        // '0.123'       e is only -1\r\n     * new BigNumber(0.0123)       // '1.23e-2'\r\n     *\r\n     * BigNumber.config({ EXPONENTIAL_AT: [-7, 20] })\r\n     * new BigNumber(123456789)    // '123456789'   e is only 8\r\n     * new BigNumber(0.000000123)  // '1.23e-7'\r\n     *\r\n     * // Almost never return exponential notation:\r\n     * BigNumber.config({ EXPONENTIAL_AT: 1e+9 })\r\n     *\r\n     * // Always return exponential notation:\r\n     * BigNumber.config({ EXPONENTIAL_AT: 0 })\r\n     * ```\r\n     *\r\n     * Regardless of the value of `EXPONENTIAL_AT`, the `toFixed` method will always return a value in\r\n     * normal notation and the `toExponential` method will always return a value in exponential form.\r\n     * Calling `toString` with a base argument, e.g. `toString(10)`, will also always return normal\r\n     * notation.\r\n     */\r\n    EXPONENTIAL_AT?: number | [number, number];\r\n\r\n    /**\r\n     * An integer, magnitude 1 to 1e+9, or an array, [-1e+9 to -1, 1 to 1e+9].\r\n     * Default value: `[-1e+9, 1e+9]`.\r\n     *\r\n     * The exponent value(s) beyond which overflow to Infinity and underflow to zero occurs.\r\n     *\r\n     * If a single number is assigned, it is the maximum exponent magnitude: values wth a positive\r\n     * exponent of greater magnitude become Infinity and those with a negative exponent of greater\r\n     * magnitude become zero.\r\n     *\r\n     * If an array of two numbers is assigned then the first number is the negative exponent limit and\r\n     * the second number is the positive exponent limit.\r\n     *\r\n     * For example, to emulate JavaScript numbers in terms of the exponent values at which they\r\n     * become zero and Infinity, use [-324, 308].\r\n     *\r\n     * ```ts\r\n     * BigNumber.config({ RANGE: 500 })\r\n     * BigNumber.config().RANGE     // [ -500, 500 ]\r\n     * new BigNumber('9.999e499')   // '9.999e+499'\r\n     * new BigNumber('1e500')       // 'Infinity'\r\n     * new BigNumber('1e-499')      // '1e-499'\r\n     * new BigNumber('1e-500')      // '0'\r\n     *\r\n     * BigNumber.config({ RANGE: [-3, 4] })\r\n     * new BigNumber(99999)         // '99999'      e is only 4\r\n     * new BigNumber(100000)        // 'Infinity'   e is 5\r\n     * new BigNumber(0.001)         // '0.01'       e is only -3\r\n     * new BigNumber(0.0001)        // '0'          e is -4\r\n     * ```\r\n     * The largest possible magnitude of a finite BigNumber is 9.999...e+1000000000.\r\n     * The smallest possible magnitude of a non-zero BigNumber is 1e-1000000000.\r\n     */\r\n    RANGE?: number | [number, number];\r\n\r\n    /**\r\n     * A boolean: `true` or `false`. Default value: `false`.\r\n     *\r\n     * The value that determines whether cryptographically-secure pseudo-random number generation is\r\n     * used. If `CRYPTO` is set to true then the random method will generate random digits using\r\n     * `crypto.getRandomValues` in browsers that support it, or `crypto.randomBytes` if using a\r\n     * version of Node.js that supports it.\r\n     *\r\n     * If neither function is supported by the host environment then attempting to set `CRYPTO` to\r\n     * `true` will fail and an exception will be thrown.\r\n     *\r\n     * If `CRYPTO` is `false` then the source of randomness used will be `Math.random` (which is\r\n     * assumed to generate at least 30 bits of randomness).\r\n     *\r\n     * See `BigNumber.random`.\r\n     *\r\n     * ```ts\r\n     * // Node.js\r\n     * global.crypto = require('crypto')\r\n     *\r\n     * BigNumber.config({ CRYPTO: true })\r\n     * BigNumber.config().CRYPTO       // true\r\n     * BigNumber.random()              // 0.54340758610486147524\r\n     * ```\r\n     */\r\n    CRYPTO?: boolean;\r\n\r\n    /**\r\n     * An integer, 0, 1, 3, 6 or 9. Default value: `BigNumber.ROUND_DOWN` (1).\r\n     *\r\n     * The modulo mode used when calculating the modulus: `a mod n`.\r\n     * The quotient, `q = a / n`, is calculated according to the `ROUNDING_MODE` that corresponds to\r\n     * the chosen `MODULO_MODE`.\r\n     * The remainder, `r`, is calculated as: `r = a - n * q`.\r\n     *\r\n     * The modes that are most commonly used for the modulus/remainder operation are shown in the\r\n     * following table. Although the other rounding modes can be used, they may not give useful\r\n     * results.\r\n     *\r\n     * Property           | Value | Description\r\n     * :------------------|:------|:------------------------------------------------------------------\r\n     *  `ROUND_UP`        |   0   | The remainder is positive if the dividend is negative.\r\n     *  `ROUND_DOWN`      |   1   | The remainder has the same sign as the dividend.\r\n     *                    |       | Uses 'truncating division' and matches JavaScript's `%` operator .\r\n     *  `ROUND_FLOOR`     |   3   | The remainder has the same sign as the divisor.\r\n     *                    |       | This matches Python's `%` operator.\r\n     *  `ROUND_HALF_EVEN` |   6   | The IEEE 754 remainder function.\r\n     *  `EUCLID`          |   9   | The remainder is always positive.\r\n     *                    |       | Euclidian division: `q = sign(n) * floor(a / abs(n))`\r\n     *\r\n     * The rounding/modulo modes are available as enumerated properties of the BigNumber constructor.\r\n     *\r\n     * See `modulo`.\r\n     *\r\n     * ```ts\r\n     * BigNumber.config({ MODULO_MODE: BigNumber.EUCLID })\r\n     * BigNumber.set({ MODULO_MODE: 9 })          // equivalent\r\n     * ```\r\n     */\r\n    MODULO_MODE?: BigNumber.ModuloMode;\r\n\r\n    /**\r\n     * An integer, 0 to 1e+9. Default value: 0.\r\n     *\r\n     * The maximum precision, i.e. number of significant digits, of the result of the power operation\r\n     * - unless a modulus is specified.\r\n     *\r\n     * If set to 0, the number of significant digits will not be limited.\r\n     *\r\n     * See `exponentiatedBy`.\r\n     *\r\n     * ```ts\r\n     * BigNumber.config({ POW_PRECISION: 100 })\r\n     * ```\r\n     */\r\n    POW_PRECISION?: number;\r\n\r\n    /**\r\n     * An object including any number of the properties shown below.\r\n     *\r\n     * The object configures the format of the string returned by the `toFormat` method.\r\n     * The example below shows the properties of the object that are recognised, and\r\n     * their default values.\r\n     *\r\n     * Unlike the other configuration properties, the values of the properties of the `FORMAT` object\r\n     * will not be checked for validity - the existing object will simply be replaced by the object\r\n     * that is passed in.\r\n     *\r\n     * See `toFormat`.\r\n     *\r\n     * ```ts\r\n     * BigNumber.config({\r\n     *   FORMAT: {\r\n     *     // string to prepend\r\n     *     prefix: '',\r\n     *     // the decimal separator\r\n     *     decimalSeparator: '.',\r\n     *     // the grouping separator of the integer part\r\n     *     groupSeparator: ',',\r\n     *     // the primary grouping size of the integer part\r\n     *     groupSize: 3,\r\n     *     // the secondary grouping size of the integer part\r\n     *     secondaryGroupSize: 0,\r\n     *     // the grouping separator of the fraction part\r\n     *     fractionGroupSeparator: ' ',\r\n     *     // the grouping size of the fraction part\r\n     *     fractionGroupSize: 0,\r\n     *     // string to append\r\n     *     suffix: ''\r\n     *   }\r\n     * })\r\n     * ```\r\n     */\r\n    FORMAT?: BigNumber.Format;\r\n\r\n    /**\r\n     * The alphabet used for base conversion. The length of the alphabet corresponds to the maximum\r\n     * value of the base argument that can be passed to the BigNumber constructor or `toString`.\r\n     *\r\n     * Default value: `'0123456789abcdefghijklmnopqrstuvwxyz'`.\r\n     *\r\n     * There is no maximum length for the alphabet, but it must be at least 2 characters long,\r\n     * and it must not contain whitespace or a repeated character, or the sign indicators '+' and\r\n     * '-', or the decimal separator '.'.\r\n     *\r\n     * ```ts\r\n     * // duodecimal (base 12)\r\n     * BigNumber.config({ ALPHABET: '0123456789TE' })\r\n     * x = new BigNumber('T', 12)\r\n     * x.toString()                // '10'\r\n     * x.toString(12)              // 'T'\r\n     * ```\r\n     */\r\n    ALPHABET?: string;\r\n  }\r\n\r\n  /** See `FORMAT` and `toFormat`. */\r\n  interface Format {\r\n\r\n    /** The string to prepend. */\r\n    prefix?: string;\r\n\r\n    /** The decimal separator. */\r\n    decimalSeparator?: string;\r\n\r\n    /** The grouping separator of the integer part. */\r\n    groupSeparator?: string;\r\n\r\n    /** The primary grouping size of the integer part. */\r\n    groupSize?: number;\r\n\r\n    /** The secondary grouping size of the integer part. */\r\n    secondaryGroupSize?: number;\r\n\r\n    /** The grouping separator of the fraction part. */\r\n    fractionGroupSeparator?: string;\r\n\r\n    /** The grouping size of the fraction part. */\r\n    fractionGroupSize?: number;\r\n\r\n    /** The string to append. */\r\n    suffix?: string;\r\n  }\r\n\r\n  interface Instance {\r\n\r\n    /** The coefficient of the value of this BigNumber, an array of base 1e14 integer numbers, or null. */\r\n    readonly c: number[] | null;\r\n\r\n    /** The exponent of the value of this BigNumber, an integer number, -1000000000 to 1000000000, or null. */\r\n    readonly e: number | null;\r\n\r\n    /** The sign of the value of this BigNumber, -1, 1, or null. */\r\n    readonly s: number | null;\r\n\r\n    [key: string]: any;\r\n  }\r\n\r\n  type Constructor = typeof BigNumber;\r\n  type ModuloMode = 0 | 1 | 3 | 6 | 9;\r\n  type RoundingMode = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\r\n  type Value = string | number | Instance;\r\n}\r\n\r\nexport declare class BigNumber implements BigNumber.Instance {\r\n\r\n  /** Used internally to identify a BigNumber instance. */\r\n  private readonly _isBigNumber: true;\r\n\r\n  /** The coefficient of the value of this BigNumber, an array of base 1e14 integer numbers, or null. */\r\n  readonly c: number[] | null;\r\n\r\n  /** The exponent of the value of this BigNumber, an integer number, -1000000000 to 1000000000, or null. */\r\n  readonly e: number | null;\r\n\r\n  /** The sign of the value of this BigNumber, -1, 1, or null. */\r\n  readonly s: number | null;\r\n\r\n  /**\r\n   * Returns a new instance of a BigNumber object with value `n`, where `n` is a numeric value in\r\n   * the specified `base`, or base 10 if `base` is omitted or is `null` or `undefined`.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(123.4567)              // '123.4567'\r\n   * // 'new' is optional\r\n   * y = BigNumber(x)                         // '123.4567'\r\n   * ```\r\n   *\r\n   * If `n` is a base 10 value it can be in normal (fixed-point) or exponential notation.\r\n   * Values in other bases must be in normal notation. Values in any base can have fraction digits,\r\n   * i.e. digits after the decimal point.\r\n   *\r\n   * ```ts\r\n   * new BigNumber(43210)                     // '43210'\r\n   * new BigNumber('4.321e+4')                // '43210'\r\n   * new BigNumber('-735.0918e-430')          // '-7.350918e-428'\r\n   * new BigNumber('123412421.234324', 5)     // '607236.557696'\r\n   * ```\r\n   *\r\n   * Signed `0`, signed `Infinity` and `NaN` are supported.\r\n   *\r\n   * ```ts\r\n   * new BigNumber('-Infinity')               // '-Infinity'\r\n   * new BigNumber(NaN)                       // 'NaN'\r\n   * new BigNumber(-0)                        // '0'\r\n   * new BigNumber('.5')                      // '0.5'\r\n   * new BigNumber('+2')                      // '2'\r\n   * ```\r\n   *\r\n   * String values in hexadecimal literal form, e.g. `'0xff'`, are valid, as are string values with\r\n   * the octal and binary prefixs `'0o'` and `'0b'`. String values in octal literal form without the\r\n   * prefix will be interpreted as decimals, e.g. `'011'` is interpreted as 11, not 9.\r\n   *\r\n   * ```ts\r\n   * new BigNumber(-10110100.1, 2)            // '-180.5'\r\n   * new BigNumber('-0b10110100.1')           // '-180.5'\r\n   * new BigNumber('ff.8', 16)                // '255.5'\r\n   * new BigNumber('0xff.8')                  // '255.5'\r\n   * ```\r\n   *\r\n   * If a base is specified, `n` is rounded according to the current `DECIMAL_PLACES` and\r\n   * `ROUNDING_MODE` settings. This includes base 10, so don't include a `base` parameter for decimal\r\n   * values unless this behaviour is desired.\r\n   *\r\n   * ```ts\r\n   * BigNumber.config({ DECIMAL_PLACES: 5 })\r\n   * new BigNumber(1.23456789)                // '1.23456789'\r\n   * new BigNumber(1.23456789, 10)            // '1.23457'\r\n   * ```\r\n   *\r\n   * An error is thrown if `base` is invalid.\r\n   *\r\n   * There is no limit to the number of digits of a value of type string (other than that of\r\n   * JavaScript's maximum array size). See `RANGE` to set the maximum and minimum possible exponent\r\n   * value of a BigNumber.\r\n   *\r\n   * ```ts\r\n   * new BigNumber('5032485723458348569331745.33434346346912144534543')\r\n   * new BigNumber('4.321e10000000')\r\n   * ```\r\n   *\r\n   * BigNumber `NaN` is returned if `n` is invalid (unless `BigNumber.DEBUG` is `true`, see below).\r\n   *\r\n   * ```ts\r\n   * new BigNumber('.1*')                    // 'NaN'\r\n   * new BigNumber('blurgh')                 // 'NaN'\r\n   * new BigNumber(9, 2)                     // 'NaN'\r\n   * ```\r\n   *\r\n   * To aid in debugging, if `BigNumber.DEBUG` is `true` then an error will be thrown on an\r\n   * invalid `n`. An error will also be thrown if `n` is of type number with more than 15\r\n   * significant digits, as calling `toString` or `valueOf` on these numbers may not result in the\r\n   * intended value.\r\n   *\r\n   * ```ts\r\n   * console.log(823456789123456.3)          //  823456789123456.2\r\n   * new BigNumber(823456789123456.3)        // '823456789123456.2'\r\n   * BigNumber.DEBUG = true\r\n   * // 'Error: Number has more than 15 significant digits'\r\n   * new BigNumber(823456789123456.3)\r\n   * // 'Error: Not a base 2 number'\r\n   * new BigNumber(9, 2)\r\n   * ```\r\n   *\r\n   * A BigNumber can also be created from an object literal.\r\n   * Use `isBigNumber` to check that it is well-formed.\r\n   *\r\n   * ```ts\r\n   * new BigNumber({ s: 1, e: 2, c: [ 777, 12300000000000 ], _isBigNumber: true })    // '777.123'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param base The base of `n`, integer, 2 to 36 (or `ALPHABET.length`, see `ALPHABET`).\r\n   */\r\n  constructor(n: BigNumber.Value, base?: number);\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the absolute value, i.e. the magnitude, of the value of this\r\n   * BigNumber.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(-0.8)\r\n   * x.absoluteValue()           // '0.8'\r\n   * ```\r\n   */\r\n  absoluteValue(): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the absolute value, i.e. the magnitude, of the value of this\r\n   * BigNumber.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(-0.8)\r\n   * x.abs()                     // '0.8'\r\n   * ```\r\n   */\r\n  abs(): BigNumber;\r\n\r\n  /**\r\n   *  Returns |                                                               |\r\n   * :-------:|:--------------------------------------------------------------|\r\n   *     1    | If the value of this BigNumber is greater than the value of `n`\r\n   *    -1    | If the value of this BigNumber is less than the value of `n`\r\n   *     0    | If this BigNumber and `n` have the same value\r\n   *  `null`  | If the value of either this BigNumber or `n` is `NaN`\r\n   *\r\n   * ```ts\r\n   *\r\n   * x = new BigNumber(Infinity)\r\n   * y = new BigNumber(5)\r\n   * x.comparedTo(y)                 // 1\r\n   * x.comparedTo(x.minus(1))        // 0\r\n   * y.comparedTo(NaN)               // null\r\n   * y.comparedTo('110', 2)          // -1\r\n   * ```\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  comparedTo(n: BigNumber.Value, base?: number): number;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber rounded by rounding mode\r\n   * `roundingMode` to a maximum of `decimalPlaces` decimal places.\r\n   *\r\n   * If `decimalPlaces` is omitted, or is `null` or `undefined`, the return value is the number of\r\n   * decimal places of the value of this BigNumber, or `null` if the value of this BigNumber is\r\n   * `Infinity` or `NaN`.\r\n   *\r\n   * If `roundingMode` is omitted, or is `null` or `undefined`, `ROUNDING_MODE` is used.\r\n   *\r\n   * Throws if `decimalPlaces` or `roundingMode` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(1234.56)\r\n   * x.decimalPlaces()                      // 2\r\n   * x.decimalPlaces(1)                     // '1234.6'\r\n   * x.decimalPlaces(2)                     // '1234.56'\r\n   * x.decimalPlaces(10)                    // '1234.56'\r\n   * x.decimalPlaces(0, 1)                  // '1234'\r\n   * x.decimalPlaces(0, 6)                  // '1235'\r\n   * x.decimalPlaces(1, 1)                  // '1234.5'\r\n   * x.decimalPlaces(1, BigNumber.ROUND_HALF_EVEN)     // '1234.6'\r\n   * x                                      // '1234.56'\r\n   * y = new BigNumber('9.9e-101')\r\n   * y.decimalPlaces()                      // 102\r\n   * ```\r\n   *\r\n   * @param [decimalPlaces] Decimal places, integer, 0 to 1e+9.\r\n   * @param [roundingMode] Rounding mode, integer, 0 to 8.\r\n   */\r\n  decimalPlaces(): number;\r\n  decimalPlaces(decimalPlaces: number, roundingMode?: BigNumber.RoundingMode): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber rounded by rounding mode\r\n   * `roundingMode` to a maximum of `decimalPlaces` decimal places.\r\n   *\r\n   * If `decimalPlaces` is omitted, or is `null` or `undefined`, the return value is the number of\r\n   * decimal places of the value of this BigNumber, or `null` if the value of this BigNumber is\r\n   * `Infinity` or `NaN`.\r\n   *\r\n   * If `roundingMode` is omitted, or is `null` or `undefined`, `ROUNDING_MODE` is used.\r\n   *\r\n   * Throws if `decimalPlaces` or `roundingMode` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(1234.56)\r\n   * x.dp()                                 // 2\r\n   * x.dp(1)                                // '1234.6'\r\n   * x.dp(2)                                // '1234.56'\r\n   * x.dp(10)                               // '1234.56'\r\n   * x.dp(0, 1)                             // '1234'\r\n   * x.dp(0, 6)                             // '1235'\r\n   * x.dp(1, 1)                             // '1234.5'\r\n   * x.dp(1, BigNumber.ROUND_HALF_EVEN)     // '1234.6'\r\n   * x                                      // '1234.56'\r\n   * y = new BigNumber('9.9e-101')\r\n   * y.dp()                                 // 102\r\n   * ```\r\n   *\r\n   * @param [decimalPlaces] Decimal places, integer, 0 to 1e+9.\r\n   * @param [roundingMode] Rounding mode, integer, 0 to 8.\r\n   */\r\n  dp(): number;\r\n  dp(decimalPlaces: number, roundingMode?: BigNumber.RoundingMode): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber divided by `n`, rounded\r\n   * according to the current `DECIMAL_PLACES` and `ROUNDING_MODE` settings.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(355)\r\n   * y = new BigNumber(113)\r\n   * x.dividedBy(y)                  // '3.14159292035398230088'\r\n   * x.dividedBy(5)                  // '71'\r\n   * x.dividedBy(47, 16)             // '5'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  dividedBy(n: BigNumber.Value, base?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber divided by `n`, rounded\r\n   * according to the current `DECIMAL_PLACES` and `ROUNDING_MODE` settings.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(355)\r\n   * y = new BigNumber(113)\r\n   * x.div(y)                    // '3.14159292035398230088'\r\n   * x.div(5)                    // '71'\r\n   * x.div(47, 16)               // '5'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  div(n: BigNumber.Value, base?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the integer part of dividing the value of this BigNumber by\r\n   * `n`.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(5)\r\n   * y = new BigNumber(3)\r\n   * x.dividedToIntegerBy(y)              // '1'\r\n   * x.dividedToIntegerBy(0.7)            // '7'\r\n   * x.dividedToIntegerBy('0.f', 16)      // '5'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  dividedToIntegerBy(n: BigNumber.Value, base?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the integer part of dividing the value of this BigNumber by\r\n   * `n`.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(5)\r\n   * y = new BigNumber(3)\r\n   * x.idiv(y)                       // '1'\r\n   * x.idiv(0.7)                     // '7'\r\n   * x.idiv('0.f', 16)               // '5'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  idiv(n: BigNumber.Value, base?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber exponentiated by `n`, i.e.\r\n   * raised to the power `n`, and optionally modulo a modulus `m`.\r\n   *\r\n   * If `n` is negative the result is rounded according to the current `DECIMAL_PLACES` and\r\n   * `ROUNDING_MODE` settings.\r\n   *\r\n   * As the number of digits of the result of the power operation can grow so large so quickly,\r\n   * e.g. 123.456**10000 has over 50000 digits, the number of significant digits calculated is\r\n   * limited to the value of the `POW_PRECISION` setting (unless a modulus `m` is specified).\r\n   *\r\n   * By default `POW_PRECISION` is set to 0. This means that an unlimited number of significant\r\n   * digits will be calculated, and that the method's performance will decrease dramatically for\r\n   * larger exponents.\r\n   *\r\n   * If `m` is specified and the value of `m`, `n` and this BigNumber are integers and `n` is\r\n   * positive, then a fast modular exponentiation algorithm is used, otherwise the operation will\r\n   * be performed as `x.exponentiatedBy(n).modulo(m)` with a `POW_PRECISION` of 0.\r\n   *\r\n   * Throws if `n` is not an integer.\r\n   *\r\n   * ```ts\r\n   * Math.pow(0.7, 2)                    // 0.48999999999999994\r\n   * x = new BigNumber(0.7)\r\n   * x.exponentiatedBy(2)                // '0.49'\r\n   * BigNumber(3).exponentiatedBy(-2)    // '0.11111111111111111111'\r\n   * ```\r\n   *\r\n   * @param n The exponent, an integer.\r\n   * @param [m] The modulus.\r\n   */\r\n  exponentiatedBy(n: BigNumber.Value, m?: BigNumber.Value): BigNumber;\r\n  exponentiatedBy(n: number, m?: BigNumber.Value): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber exponentiated by `n`, i.e.\r\n   * raised to the power `n`, and optionally modulo a modulus `m`.\r\n   *\r\n   * If `n` is negative the result is rounded according to the current `DECIMAL_PLACES` and\r\n   * `ROUNDING_MODE` settings.\r\n   *\r\n   * As the number of digits of the result of the power operation can grow so large so quickly,\r\n   * e.g. 123.456**10000 has over 50000 digits, the number of significant digits calculated is\r\n   * limited to the value of the `POW_PRECISION` setting (unless a modulus `m` is specified).\r\n   *\r\n   * By default `POW_PRECISION` is set to 0. This means that an unlimited number of significant\r\n   * digits will be calculated, and that the method's performance will decrease dramatically for\r\n   * larger exponents.\r\n   *\r\n   * If `m` is specified and the value of `m`, `n` and this BigNumber are integers and `n` is\r\n   * positive, then a fast modular exponentiation algorithm is used, otherwise the operation will\r\n   * be performed as `x.pow(n).modulo(m)` with a `POW_PRECISION` of 0.\r\n   *\r\n   * Throws if `n` is not an integer.\r\n   *\r\n   * ```ts\r\n   * Math.pow(0.7, 2)                   // 0.48999999999999994\r\n   * x = new BigNumber(0.7)\r\n   * x.pow(2)                           // '0.49'\r\n   * BigNumber(3).pow(-2)               // '0.11111111111111111111'\r\n   * ```\r\n   *\r\n   * @param n The exponent, an integer.\r\n   * @param [m] The modulus.\r\n   */\r\n  pow(n: BigNumber.Value, m?: BigNumber.Value): BigNumber;\r\n  pow(n: number, m?: BigNumber.Value): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber rounded to an integer using\r\n   * rounding mode `rm`.\r\n   *\r\n   * If `rm` is omitted, or is `null` or `undefined`, `ROUNDING_MODE` is used.\r\n   *\r\n   * Throws if `rm` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(123.456)\r\n   * x.integerValue()                        // '123'\r\n   * x.integerValue(BigNumber.ROUND_CEIL)    // '124'\r\n   * y = new BigNumber(-12.7)\r\n   * y.integerValue()                        // '-13'\r\n   * x.integerValue(BigNumber.ROUND_DOWN)    // '-12'\r\n   * ```\r\n   *\r\n   * @param {BigNumber.RoundingMode} [rm] The roundng mode, an integer, 0 to 8.\r\n   */\r\n  integerValue(rm?: BigNumber.RoundingMode): BigNumber;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is equal to the value of `n`, otherwise returns\r\n   * `false`.\r\n   *\r\n   * As with JavaScript, `NaN` does not equal `NaN`.\r\n   *\r\n   * ```ts\r\n   * 0 === 1e-324                           // true\r\n   * x = new BigNumber(0)\r\n   * x.isEqualTo('1e-324')                  // false\r\n   * BigNumber(-0).isEqualTo(x)             // true  ( -0 === 0 )\r\n   * BigNumber(255).isEqualTo('ff', 16)     // true\r\n   *\r\n   * y = new BigNumber(NaN)\r\n   * y.isEqualTo(NaN)                // false\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  isEqualTo(n: BigNumber.Value, base?: number): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is equal to the value of `n`, otherwise returns\r\n   * `false`.\r\n   *\r\n   * As with JavaScript, `NaN` does not equal `NaN`.\r\n   *\r\n   * ```ts\r\n   * 0 === 1e-324                    // true\r\n   * x = new BigNumber(0)\r\n   * x.eq('1e-324')                  // false\r\n   * BigNumber(-0).eq(x)             // true  ( -0 === 0 )\r\n   * BigNumber(255).eq('ff', 16)     // true\r\n   *\r\n   * y = new BigNumber(NaN)\r\n   * y.eq(NaN)                       // false\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  eq(n: BigNumber.Value, base?: number): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is a finite number, otherwise returns `false`.\r\n   *\r\n   * The only possible non-finite values of a BigNumber are `NaN`, `Infinity` and `-Infinity`.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(1)\r\n   * x.isFinite()                    // true\r\n   * y = new BigNumber(Infinity)\r\n   * y.isFinite()                    // false\r\n   * ```\r\n   */\r\n  isFinite(): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is greater than the value of `n`, otherwise\r\n   * returns `false`.\r\n   *\r\n   * ```ts\r\n   * 0.1 > (0.3 - 0.2)                             // true\r\n   * x = new BigNumber(0.1)\r\n   * x.isGreaterThan(BigNumber(0.3).minus(0.2))    // false\r\n   * BigNumber(0).isGreaterThan(x)                 // false\r\n   * BigNumber(11, 3).isGreaterThan(11.1, 2)       // true\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  isGreaterThan(n: BigNumber.Value, base?: number): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is greater than the value of `n`, otherwise\r\n   * returns `false`.\r\n   *\r\n   * ```ts\r\n   * 0.1 > (0.3 - 0                     // true\r\n   * x = new BigNumber(0.1)\r\n   * x.gt(BigNumber(0.3).minus(0.2))    // false\r\n   * BigNumber(0).gt(x)                 // false\r\n   * BigNumber(11, 3).gt(11.1, 2)       // true\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  gt(n: BigNumber.Value, base?: number): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is greater than or equal to the value of `n`,\r\n   * otherwise returns `false`.\r\n   *\r\n   * ```ts\r\n   * (0.3 - 0.2) >= 0.1                                  // false\r\n   * x = new BigNumber(0.3).minus(0.2)\r\n   * x.isGreaterThanOrEqualTo(0.1)                       // true\r\n   * BigNumber(1).isGreaterThanOrEqualTo(x)              // true\r\n   * BigNumber(10, 18).isGreaterThanOrEqualTo('i', 36)   // true\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  isGreaterThanOrEqualTo(n: BigNumber.Value, base?: number): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is greater than or equal to the value of `n`,\r\n   * otherwise returns `false`.\r\n   *\r\n   * ```ts\r\n   * (0.3 - 0.2) >= 0.1                    // false\r\n   * x = new BigNumber(0.3).minus(0.2)\r\n   * x.gte(0.1)                            // true\r\n   * BigNumber(1).gte(x)                   // true\r\n   * BigNumber(10, 18).gte('i', 36)        // true\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  gte(n: BigNumber.Value, base?: number): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is an integer, otherwise returns `false`.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(1)\r\n   * x.isInteger()                   // true\r\n   * y = new BigNumber(123.456)\r\n   * y.isInteger()                   // false\r\n   * ```\r\n   */\r\n  isInteger(): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is less than the value of `n`, otherwise returns\r\n   * `false`.\r\n   *\r\n   * ```ts\r\n   * (0.3 - 0.2) < 0.1                       // true\r\n   * x = new BigNumber(0.3).minus(0.2)\r\n   * x.isLessThan(0.1)                       // false\r\n   * BigNumber(0).isLessThan(x)              // true\r\n   * BigNumber(11.1, 2).isLessThan(11, 3)    // true\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  isLessThan(n: BigNumber.Value, base?: number): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is less than the value of `n`, otherwise returns\r\n   * `false`.\r\n   *\r\n   * ```ts\r\n   * (0.3 - 0.2) < 0.1                       // true\r\n   * x = new BigNumber(0.3).minus(0.2)\r\n   * x.lt(0.1)                               // false\r\n   * BigNumber(0).lt(x)                      // true\r\n   * BigNumber(11.1, 2).lt(11, 3)            // true\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  lt(n: BigNumber.Value, base?: number): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is less than or equal to the value of `n`,\r\n   * otherwise returns `false`.\r\n   *\r\n   * ```ts\r\n   * 0.1 <= (0.3 - 0.2)                                 // false\r\n   * x = new BigNumber(0.1)\r\n   * x.isLessThanOrEqualTo(BigNumber(0.3).minus(0.2))   // true\r\n   * BigNumber(-1).isLessThanOrEqualTo(x)               // true\r\n   * BigNumber(10, 18).isLessThanOrEqualTo('i', 36)     // true\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  isLessThanOrEqualTo(n: BigNumber.Value, base?: number): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is less than or equal to the value of `n`,\r\n   * otherwise returns `false`.\r\n   *\r\n   * ```ts\r\n   * 0.1 <= (0.3 - 0.2)                  // false\r\n   * x = new BigNumber(0.1)\r\n   * x.lte(BigNumber(0.3).minus(0.2))    // true\r\n   * BigNumber(-1).lte(x)                // true\r\n   * BigNumber(10, 18).lte('i', 36)      // true\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  lte(n: BigNumber.Value, base?: number): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is `NaN`, otherwise returns `false`.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(NaN)\r\n   * x.isNaN()                       // true\r\n   * y = new BigNumber('Infinity')\r\n   * y.isNaN()                       // false\r\n   * ```\r\n   */\r\n  isNaN(): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is negative, otherwise returns `false`.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(-0)\r\n   * x.isNegative()                  // true\r\n   * y = new BigNumber(2)\r\n   * y.isNegative()                  // false\r\n   * ```\r\n   */\r\n  isNegative(): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is positive, otherwise returns `false`.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(-0)\r\n   * x.isPositive()                  // false\r\n   * y = new BigNumber(2)\r\n   * y.isPositive()                  // true\r\n   * ```\r\n   */\r\n  isPositive(): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is zero or minus zero, otherwise returns `false`.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(-0)\r\n   * x.isZero()                 // true\r\n   * ```\r\n   */\r\n  isZero(): boolean;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber minus `n`.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * 0.3 - 0.1                       // 0.19999999999999998\r\n   * x = new BigNumber(0.3)\r\n   * x.minus(0.1)                    // '0.2'\r\n   * x.minus(0.6, 20)                // '0'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  minus(n: BigNumber.Value, base?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber modulo `n`, i.e. the integer\r\n   * remainder of dividing this BigNumber by `n`.\r\n   *\r\n   * The value returned, and in particular its sign, is dependent on the value of the `MODULO_MODE`\r\n   * setting of this BigNumber constructor. If it is 1 (default value), the result will have the\r\n   * same sign as this BigNumber, and it will match that of Javascript's `%` operator (within the\r\n   * limits of double precision) and BigDecimal's `remainder` method.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * See `MODULO_MODE` for a description of the other modulo modes.\r\n   *\r\n   * ```ts\r\n   * 1 % 0.9                         // 0.09999999999999998\r\n   * x = new BigNumber(1)\r\n   * x.modulo(0.9)                   // '0.1'\r\n   * y = new BigNumber(33)\r\n   * y.modulo('a', 33)               // '3'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  modulo(n: BigNumber.Value, base?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber modulo `n`, i.e. the integer\r\n   * remainder of dividing this BigNumber by `n`.\r\n   *\r\n   * The value returned, and in particular its sign, is dependent on the value of the `MODULO_MODE`\r\n   * setting of this BigNumber constructor. If it is 1 (default value), the result will have the\r\n   * same sign as this BigNumber, and it will match that of Javascript's `%` operator (within the\r\n   * limits of double precision) and BigDecimal's `remainder` method.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * See `MODULO_MODE` for a description of the other modulo modes.\r\n   *\r\n   * ```ts\r\n   * 1 % 0.9                      // 0.09999999999999998\r\n   * x = new BigNumber(1)\r\n   * x.mod(0.9)                   // '0.1'\r\n   * y = new BigNumber(33)\r\n   * y.mod('a', 33)               // '3'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  mod(n: BigNumber.Value, base?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber multiplied by `n`.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * 0.6 * 3                                // 1.7999999999999998\r\n   * x = new BigNumber(0.6)\r\n   * y = x.multipliedBy(3)                  // '1.8'\r\n   * BigNumber('7e+500').multipliedBy(y)    // '1.26e+501'\r\n   * x.multipliedBy('-a', 16)               // '-6'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  multipliedBy(n: BigNumber.Value, base?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber multiplied by `n`.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * 0.6 * 3                         // 1.7999999999999998\r\n   * x = new BigNumber(0.6)\r\n   * y = x.times(3)                  // '1.8'\r\n   * BigNumber('7e+500').times(y)    // '1.26e+501'\r\n   * x.times('-a', 16)               // '-6'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  times(n: BigNumber.Value, base?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber negated, i.e. multiplied by -1.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(1.8)\r\n   * x.negated()                     // '-1.8'\r\n   * y = new BigNumber(-1.3)\r\n   * y.negated()                     // '1.3'\r\n   * ```\r\n   */\r\n  negated(): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber plus `n`.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * 0.1 + 0.2                       // 0.30000000000000004\r\n   * x = new BigNumber(0.1)\r\n   * y = x.plus(0.2)                 // '0.3'\r\n   * BigNumber(0.7).plus(x).plus(y)  // '1.1'\r\n   * x.plus('0.1', 8)                // '0.225'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  plus(n: BigNumber.Value, base?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns the number of significant digits of the value of this BigNumber, or `null` if the value\r\n   * of this BigNumber is `Infinity` or `NaN`.\r\n   *\r\n   * If `includeZeros` is true then any trailing zeros of the integer part of the value of this\r\n   * BigNumber are counted as significant digits, otherwise they are not.\r\n   *\r\n   * Throws if `includeZeros` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(9876.54321)\r\n   * x.precision()                         // 9\r\n   * y = new BigNumber(987000)\r\n   * y.precision(false)                    // 3\r\n   * y.precision(true)                     // 6\r\n   * ```\r\n   *\r\n   * @param [includeZeros] Whether to include integer trailing zeros in the significant digit count.\r\n   */\r\n  precision(includeZeros?: boolean): number;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber rounded to a precision of\r\n   * `significantDigits` significant digits using rounding mode `roundingMode`.\r\n   *\r\n   * If `roundingMode` is omitted or is `null` or `undefined`, `ROUNDING_MODE` will be used.\r\n   *\r\n   * Throws if `significantDigits` or `roundingMode` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(9876.54321)\r\n   * x.precision(6)                         // '9876.54'\r\n   * x.precision(6, BigNumber.ROUND_UP)     // '9876.55'\r\n   * x.precision(2)                         // '9900'\r\n   * x.precision(2, 1)                      // '9800'\r\n   * x                                      // '9876.54321'\r\n   * ```\r\n   *\r\n   * @param significantDigits Significant digits, integer, 1 to 1e+9.\r\n   * @param [roundingMode] Rounding mode, integer, 0 to 8.\r\n   */\r\n  precision(significantDigits: number, roundingMode?: BigNumber.RoundingMode): BigNumber;\r\n\r\n  /**\r\n   * Returns the number of significant digits of the value of this BigNumber,\r\n   * or `null` if the value of this BigNumber is `Infinity` or `NaN`.\r\n   *\r\n   * If `includeZeros` is true then any trailing zeros of the integer part of\r\n   * the value of this BigNumber are counted as significant digits, otherwise\r\n   * they are not.\r\n   *\r\n   * Throws if `includeZeros` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(9876.54321)\r\n   * x.sd()                         // 9\r\n   * y = new BigNumber(987000)\r\n   * y.sd(false)                    // 3\r\n   * y.sd(true)                     // 6\r\n   * ```\r\n   *\r\n   * @param [includeZeros] Whether to include integer trailing zeros in the significant digit count.\r\n   */\r\n  sd(includeZeros?: boolean): number;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber rounded to a precision of\r\n   * `significantDigits` significant digits using rounding mode `roundingMode`.\r\n   *\r\n   * If `roundingMode` is omitted or is `null` or `undefined`, `ROUNDING_MODE` will be used.\r\n   *\r\n   * Throws if `significantDigits` or `roundingMode` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(9876.54321)\r\n   * x.sd(6)                           // '9876.54'\r\n   * x.sd(6, BigNumber.ROUND_UP)       // '9876.55'\r\n   * x.sd(2)                           // '9900'\r\n   * x.sd(2, 1)                        // '9800'\r\n   * x                                 // '9876.54321'\r\n   * ```\r\n   *\r\n   * @param significantDigits Significant digits, integer, 1 to 1e+9.\r\n   * @param [roundingMode] Rounding mode, integer, 0 to 8.\r\n   */\r\n  sd(significantDigits: number, roundingMode?: BigNumber.RoundingMode): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber shifted by `n` places.\r\n   *\r\n   * The shift is of the decimal point, i.e. of powers of ten, and is to the left if `n` is negative\r\n   * or to the right if `n` is positive.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * Throws if `n` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(1.23)\r\n   * x.shiftedBy(3)                      // '1230'\r\n   * x.shiftedBy(-3)                     // '0.00123'\r\n   * ```\r\n   *\r\n   * @param n The shift value, integer, -9007199254740991 to 9007199254740991.\r\n   */\r\n  shiftedBy(n: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the square root of the value of this BigNumber, rounded\r\n   * according to the current `DECIMAL_PLACES` and `ROUNDING_MODE` settings.\r\n   *\r\n   * The return value will be correctly rounded, i.e. rounded as if the result was first calculated\r\n   * to an infinite number of correct digits before rounding.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(16)\r\n   * x.squareRoot()                  // '4'\r\n   * y = new BigNumber(3)\r\n   * y.squareRoot()                  // '1.73205080756887729353'\r\n   * ```\r\n   */\r\n  squareRoot(): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the square root of the value of this BigNumber, rounded\r\n   * according to the current `DECIMAL_PLACES` and `ROUNDING_MODE` settings.\r\n   *\r\n   * The return value will be correctly rounded, i.e. rounded as if the result was first calculated\r\n   * to an infinite number of correct digits before rounding.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(16)\r\n   * x.sqrt()                  // '4'\r\n   * y = new BigNumber(3)\r\n   * y.sqrt()                  // '1.73205080756887729353'\r\n   * ```\r\n   */\r\n  sqrt(): BigNumber;\r\n\r\n  /**\r\n   * Returns a string representing the value of this BigNumber in exponential notation rounded using\r\n   * rounding mode `roundingMode` to `decimalPlaces` decimal places, i.e with one digit before the\r\n   * decimal point and `decimalPlaces` digits after it.\r\n   *\r\n   * If the value of this BigNumber in exponential notation has fewer than `decimalPlaces` fraction\r\n   * digits, the return value will be appended with zeros accordingly.\r\n   *\r\n   * If `decimalPlaces` is omitted, or is `null` or `undefined`, the number of digits after the\r\n   * decimal point defaults to the minimum number of digits necessary to represent the value\r\n   * exactly.\r\n   *\r\n   * If `roundingMode` is omitted or is `null` or `undefined`, `ROUNDING_MODE` is used.\r\n   *\r\n   * Throws if `decimalPlaces` or `roundingMode` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = 45.6\r\n   * y = new BigNumber(x)\r\n   * x.toExponential()               // '4.56e+1'\r\n   * y.toExponential()               // '4.56e+1'\r\n   * x.toExponential(0)              // '5e+1'\r\n   * y.toExponential(0)              // '5e+1'\r\n   * x.toExponential(1)              // '4.6e+1'\r\n   * y.toExponential(1)              // '4.6e+1'\r\n   * y.toExponential(1, 1)           // '4.5e+1'  (ROUND_DOWN)\r\n   * x.toExponential(3)              // '4.560e+1'\r\n   * y.toExponential(3)              // '4.560e+1'\r\n   * ```\r\n   *\r\n   * @param [decimalPlaces] Decimal places, integer, 0 to 1e+9.\r\n   * @param [roundingMode] Rounding mode, integer, 0 to 8.\r\n   */\r\n  toExponential(decimalPlaces: number, roundingMode?: BigNumber.RoundingMode): string;\r\n  toExponential(): string;\r\n\r\n  /**\r\n   * Returns a string representing the value of this BigNumber in normal (fixed-point) notation\r\n   * rounded to `decimalPlaces` decimal places using rounding mode `roundingMode`.\r\n   *\r\n   * If the value of this BigNumber in normal notation has fewer than `decimalPlaces` fraction\r\n   * digits, the return value will be appended with zeros accordingly.\r\n   *\r\n   * Unlike `Number.prototype.toFixed`, which returns exponential notation if a number is greater or\r\n   * equal to 10**21, this method will always return normal notation.\r\n   *\r\n   * If `decimalPlaces` is omitted or is `null` or `undefined`, the return value will be unrounded\r\n   * and in normal notation. This is also unlike `Number.prototype.toFixed`, which returns the value\r\n   * to zero decimal places. It is useful when normal notation is required and the current\r\n   * `EXPONENTIAL_AT` setting causes `toString` to return exponential notation.\r\n   *\r\n   * If `roundingMode` is omitted or is `null` or `undefined`, `ROUNDING_MODE` is used.\r\n   *\r\n   * Throws if `decimalPlaces` or `roundingMode` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = 3.456\r\n   * y = new BigNumber(x)\r\n   * x.toFixed()                     // '3'\r\n   * y.toFixed()                     // '3.456'\r\n   * y.toFixed(0)                    // '3'\r\n   * x.toFixed(2)                    // '3.46'\r\n   * y.toFixed(2)                    // '3.46'\r\n   * y.toFixed(2, 1)                 // '3.45'  (ROUND_DOWN)\r\n   * x.toFixed(5)                    // '3.45600'\r\n   * y.toFixed(5)                    // '3.45600'\r\n   * ```\r\n   *\r\n   * @param [decimalPlaces] Decimal places, integer, 0 to 1e+9.\r\n   * @param [roundingMode] Rounding mode, integer, 0 to 8.\r\n   */\r\n  toFixed(decimalPlaces: number, roundingMode?: BigNumber.RoundingMode): string;\r\n  toFixed(): string;\r\n\r\n  /**\r\n   * Returns a string representing the value of this BigNumber in normal (fixed-point) notation\r\n   * rounded to `decimalPlaces` decimal places using rounding mode `roundingMode`, and formatted\r\n   * according to the properties of the `format` or `FORMAT` object.\r\n   *\r\n   * The formatting object may contain some or all of the properties shown in the examples below.\r\n   *\r\n   * If `decimalPlaces` is omitted or is `null` or `undefined`, then the return value is not\r\n   * rounded to a fixed number of decimal places.\r\n   *\r\n   * If `roundingMode` is omitted or is `null` or `undefined`, `ROUNDING_MODE` is used.\r\n   *\r\n   * If `format` is omitted or is `null` or `undefined`, `FORMAT` is used.\r\n   *\r\n   * Throws if `decimalPlaces`, `roundingMode`, or `format` is invalid.\r\n   *\r\n   * ```ts\r\n   * fmt = {\r\n   *   decimalSeparator: '.',\r\n   *   groupSeparator: ',',\r\n   *   groupSize: 3,\r\n   *   secondaryGroupSize: 0,\r\n   *   fractionGroupSeparator: ' ',\r\n   *   fractionGroupSize: 0\r\n   * }\r\n   *\r\n   * x = new BigNumber('123456789.123456789')\r\n   *\r\n   * // Set the global formatting options\r\n   * BigNumber.config({ FORMAT: fmt })\r\n   *\r\n   * x.toFormat()                              // '123,456,789.123456789'\r\n   * x.toFormat(3)                             // '123,456,789.123'\r\n   *\r\n   * // If a reference to the object assigned to FORMAT has been retained,\r\n   * // the format properties can be changed directly\r\n   * fmt.groupSeparator = ' '\r\n   * fmt.fractionGroupSize = 5\r\n   * x.toFormat()                              // '123 456 789.12345 6789'\r\n   *\r\n   * // Alternatively, pass the formatting options as an argument\r\n   * fmt = {\r\n   *   decimalSeparator: ',',\r\n   *   groupSeparator: '.',\r\n   *   groupSize: 3,\r\n   *   secondaryGroupSize: 2\r\n   * }\r\n   *\r\n   * x.toFormat()                              // '123 456 789.12345 6789'\r\n   * x.toFormat(fmt)                           // '12.34.56.789,123456789'\r\n   * x.toFormat(2, fmt)                        // '12.34.56.789,12'\r\n   * x.toFormat(3, BigNumber.ROUND_UP, fmt)    // '12.34.56.789,124'\r\n   * ```\r\n   *\r\n   * @param [decimalPlaces] Decimal places, integer, 0 to 1e+9.\r\n   * @param [roundingMode] Rounding mode, integer, 0 to 8.\r\n   * @param [format] Formatting options object. See `BigNumber.Format`.\r\n   */\r\n  toFormat(decimalPlaces: number, roundingMode: BigNumber.RoundingMode, format?: BigNumber.Format): string;\r\n  toFormat(decimalPlaces: number, roundingMode?: BigNumber.RoundingMode): string;\r\n  toFormat(decimalPlaces?: number): string;\r\n  toFormat(decimalPlaces: number, format: BigNumber.Format): string;\r\n  toFormat(format: BigNumber.Format): string;\r\n\r\n  /**\r\n   * Returns an array of two BigNumbers representing the value of this BigNumber as a simple\r\n   * fraction with an integer numerator and an integer denominator.\r\n   * The denominator will be a positive non-zero value less than or equal to `max_denominator`.\r\n   * If a maximum denominator, `max_denominator`, is not specified, or is `null` or `undefined`, the\r\n   * denominator will be the lowest value necessary to represent the number exactly.\r\n   *\r\n   * Throws if `max_denominator` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(1.75)\r\n   * x.toFraction()                  // '7, 4'\r\n   *\r\n   * pi = new BigNumber('3.14159265358')\r\n   * pi.toFraction()                 // '157079632679,50000000000'\r\n   * pi.toFraction(100000)           // '312689, 99532'\r\n   * pi.toFraction(10000)            // '355, 113'\r\n   * pi.toFraction(100)              // '311, 99'\r\n   * pi.toFraction(10)               // '22, 7'\r\n   * pi.toFraction(1)                // '3, 1'\r\n   * ```\r\n   *\r\n   * @param [max_denominator] The maximum denominator, integer > 0, or Infinity.\r\n   */\r\n  toFraction(max_denominator?: BigNumber.Value): [BigNumber, BigNumber];\r\n\r\n  /** As `valueOf`. */\r\n  toJSON(): string;\r\n\r\n  /**\r\n   * Returns the value of this BigNumber as a JavaScript primitive number.\r\n   *\r\n   * Using the unary plus operator gives the same result.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(456.789)\r\n   * x.toNumber()                    // 456.789\r\n   * +x                              // 456.789\r\n   *\r\n   * y = new BigNumber('45987349857634085409857349856430985')\r\n   * y.toNumber()                    // 4.598734985763409e+34\r\n   *\r\n   * z = new BigNumber(-0)\r\n   * 1 / z.toNumber()                // -Infinity\r\n   * 1 / +z                          // -Infinity\r\n   * ```\r\n   */\r\n  toNumber(): number;\r\n\r\n  /**\r\n   * Returns a string representing the value of this BigNumber rounded to `significantDigits`\r\n   * significant digits using rounding mode `roundingMode`.\r\n   *\r\n   * If `significantDigits` is less than the number of digits necessary to represent the integer\r\n   * part of the value in normal (fixed-point) notation, then exponential notation is used.\r\n   *\r\n   * If `significantDigits` is omitted, or is `null` or `undefined`, then the return value is the\r\n   * same as `n.toString()`.\r\n   *\r\n   * If `roundingMode` is omitted or is `null` or `undefined`, `ROUNDING_MODE` is used.\r\n   *\r\n   * Throws if `significantDigits` or `roundingMode` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = 45.6\r\n   * y = new BigNumber(x)\r\n   * x.toPrecision()                 // '45.6'\r\n   * y.toPrecision()                 // '45.6'\r\n   * x.toPrecision(1)                // '5e+1'\r\n   * y.toPrecision(1)                // '5e+1'\r\n   * y.toPrecision(2, 0)             // '4.6e+1'  (ROUND_UP)\r\n   * y.toPrecision(2, 1)             // '4.5e+1'  (ROUND_DOWN)\r\n   * x.toPrecision(5)                // '45.600'\r\n   * y.toPrecision(5)                // '45.600'\r\n   * ```\r\n   *\r\n   * @param [significantDigits] Significant digits, integer, 1 to 1e+9.\r\n   * @param [roundingMode] Rounding mode, integer 0 to 8.\r\n   */\r\n  toPrecision(significantDigits: number, roundingMode?: BigNumber.RoundingMode): string;\r\n  toPrecision(): string;\r\n\r\n  /**\r\n   * Returns a string representing the value of this BigNumber in base `base`, or base 10 if `base`\r\n   * is omitted or is `null` or `undefined`.\r\n   *\r\n   * For bases above 10, and using the default base conversion alphabet (see `ALPHABET`), values\r\n   * from 10 to 35 are represented by a-z (the same as `Number.prototype.toString`).\r\n   *\r\n   * If a base is specified the value is rounded according to the current `DECIMAL_PLACES` and\r\n   * `ROUNDING_MODE` settings, otherwise it is not.\r\n   *\r\n   * If a base is not specified, and this BigNumber has a positive exponent that is equal to or\r\n   * greater than the positive component of the current `EXPONENTIAL_AT` setting, or a negative\r\n   * exponent equal to or less than the negative component of the setting, then exponential notation\r\n   * is returned.\r\n   *\r\n   * If `base` is `null` or `undefined` it is ignored.\r\n   *\r\n   * Throws if `base` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(750000)\r\n   * x.toString()                    // '750000'\r\n   * BigNumber.config({ EXPONENTIAL_AT: 5 })\r\n   * x.toString()                    // '7.5e+5'\r\n   *\r\n   * y = new BigNumber(362.875)\r\n   * y.toString(2)                   // '101101010.111'\r\n   * y.toString(9)                   // '442.77777777777777777778'\r\n   * y.toString(32)                  // 'ba.s'\r\n   *\r\n   * BigNumber.config({ DECIMAL_PLACES: 4 });\r\n   * z = new BigNumber('1.23456789')\r\n   * z.toString()                    // '1.23456789'\r\n   * z.toString(10)                  // '1.2346'\r\n   * ```\r\n   *\r\n   * @param [base] The base, integer, 2 to 36 (or `ALPHABET.length`, see `ALPHABET`).\r\n   */\r\n  toString(base?: number): string;\r\n\r\n  /**\r\n   * As `toString`, but does not accept a base argument and includes the minus sign for negative\r\n   * zero.\r\n   *\r\n   * ``ts\r\n   * x = new BigNumber('-0')\r\n   * x.toString()                    // '0'\r\n   * x.valueOf()                     // '-0'\r\n   * y = new BigNumber('1.777e+457')\r\n   * y.valueOf()                     // '1.777e+457'\r\n   * ```\r\n   */\r\n  valueOf(): string;\r\n\r\n  /** Helps ES6 import. */\r\n  private static readonly default?: BigNumber.Constructor;\r\n\r\n  /** Helps ES6 import. */\r\n  private static readonly BigNumber?: BigNumber.Constructor;\r\n\r\n  /** Rounds away from zero. */\r\n  static readonly ROUND_UP: 0;\r\n\r\n  /** Rounds towards zero. */\r\n  static readonly ROUND_DOWN: 1;\r\n\r\n  /** Rounds towards Infinity. */\r\n  static readonly ROUND_CEIL: 2;\r\n\r\n  /** Rounds towards -Infinity. */\r\n  static readonly ROUND_FLOOR: 3;\r\n\r\n  /** Rounds towards nearest neighbour. If equidistant, rounds away from zero . */\r\n  static readonly ROUND_HALF_UP: 4;\r\n\r\n  /** Rounds towards nearest neighbour. If equidistant, rounds towards zero. */\r\n  static readonly ROUND_HALF_DOWN: 5;\r\n\r\n  /** Rounds towards nearest neighbour. If equidistant, rounds towards even neighbour. */\r\n  static readonly ROUND_HALF_EVEN: 6;\r\n\r\n  /** Rounds towards nearest neighbour. If equidistant, rounds towards Infinity. */\r\n  static readonly ROUND_HALF_CEIL: 7;\r\n\r\n  /** Rounds towards nearest neighbour. If equidistant, rounds towards -Infinity. */\r\n  static readonly ROUND_HALF_FLOOR: 8;\r\n\r\n  /** See `MODULO_MODE`. */\r\n  static readonly EUCLID: 9;\r\n\r\n  /**\r\n   * To aid in debugging, if a `BigNumber.DEBUG` property is `true` then an error will be thrown\r\n   * if the BigNumber constructor receives an invalid `BigNumber.Value`, or if `BigNumber.isBigNumber`\r\n   * receives a BigNumber instance that is malformed.\r\n   *\r\n   * ```ts\r\n   * // No error, and BigNumber NaN is returned.\r\n   * new BigNumber('blurgh')    // 'NaN'\r\n   * new BigNumber(9, 2)        // 'NaN'\r\n   * BigNumber.DEBUG = true\r\n   * new BigNumber('blurgh')    // '[BigNumber Error] Not a number'\r\n   * new BigNumber(9, 2)        // '[BigNumber Error] Not a base 2 number'\r\n   * ```\r\n   *\r\n   * An error will also be thrown if a `BigNumber.Value` is of type number with more than 15\r\n   * significant digits, as calling `toString` or `valueOf` on such numbers may not result\r\n   * in the intended value.\r\n   *\r\n   * ```ts\r\n   * console.log(823456789123456.3)       //  823456789123456.2\r\n   * // No error, and the returned BigNumber does not have the same value as the number literal.\r\n   * new BigNumber(823456789123456.3)     // '823456789123456.2'\r\n   * BigNumber.DEBUG = true\r\n   * new BigNumber(823456789123456.3)\r\n   * // '[BigNumber Error] Number primitive has more than 15 significant digits'\r\n   * ```\r\n   *\r\n   * Check that a BigNumber instance is well-formed:\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(10)\r\n   *\r\n   * BigNumber.DEBUG = false\r\n   * // Change x.c to an illegitimate value.\r\n   * x.c = NaN\r\n   * // No error, as BigNumber.DEBUG is false.\r\n   * BigNumber.isBigNumber(x)    // true\r\n   *\r\n   * BigNumber.DEBUG = true\r\n   * BigNumber.isBigNumber(x)    // '[BigNumber Error] Invalid BigNumber'\r\n   * ```\r\n   */\r\n  static DEBUG?: boolean;\r\n\r\n  /**\r\n   * Returns a new independent BigNumber constructor with configuration as described by `object`, or\r\n   * with the default configuration if object is `null` or `undefined`.\r\n   *\r\n   * Throws if `object` is not an object.\r\n   *\r\n   * ```ts\r\n   * BigNumber.config({ DECIMAL_PLACES: 5 })\r\n   * BN = BigNumber.clone({ DECIMAL_PLACES: 9 })\r\n   *\r\n   * x = new BigNumber(1)\r\n   * y = new BN(1)\r\n   *\r\n   * x.div(3)                        // 0.33333\r\n   * y.div(3)                        // 0.333333333\r\n   *\r\n   * // BN = BigNumber.clone({ DECIMAL_PLACES: 9 }) is equivalent to:\r\n   * BN = BigNumber.clone()\r\n   * BN.config({ DECIMAL_PLACES: 9 })\r\n   * ```\r\n   *\r\n   * @param [object] The configuration object.\r\n   */\r\n  static clone(object?: BigNumber.Config): BigNumber.Constructor;\r\n\r\n  /**\r\n   * Configures the settings that apply to this BigNumber constructor.\r\n   *\r\n   * The configuration object, `object`, contains any number of the properties shown in the example\r\n   * below.\r\n   *\r\n   * Returns an object with the above properties and their current values.\r\n   *\r\n   * Throws if `object` is not an object, or if an invalid value is assigned to one or more of the\r\n   * properties.\r\n   *\r\n   * ```ts\r\n   * BigNumber.config({\r\n   *     DECIMAL_PLACES: 40,\r\n   *     ROUNDING_MODE: BigNumber.ROUND_HALF_CEIL,\r\n   *     EXPONENTIAL_AT: [-10, 20],\r\n   *     RANGE: [-500, 500],\r\n   *     CRYPTO: true,\r\n   *     MODULO_MODE: BigNumber.ROUND_FLOOR,\r\n   *     POW_PRECISION: 80,\r\n   *     FORMAT: {\r\n   *         groupSize: 3,\r\n   *         groupSeparator: ' ',\r\n   *         decimalSeparator: ','\r\n   *     },\r\n   *     ALPHABET: '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'\r\n   * });\r\n   *\r\n   * BigNumber.config().DECIMAL_PLACES        // 40\r\n   * ```\r\n   *\r\n   * @param object The configuration object.\r\n   */\r\n  static config(object: BigNumber.Config): BigNumber.Config;\r\n\r\n  /**\r\n   * Returns `true` if `value` is a BigNumber instance, otherwise returns `false`.\r\n   *\r\n   * If `BigNumber.DEBUG` is `true`, throws if a BigNumber instance is not well-formed.\r\n   *\r\n   * ```ts\r\n   * x = 42\r\n   * y = new BigNumber(x)\r\n   *\r\n   * BigNumber.isBigNumber(x)             // false\r\n   * y instanceof BigNumber               // true\r\n   * BigNumber.isBigNumber(y)             // true\r\n   *\r\n   * BN = BigNumber.clone();\r\n   * z = new BN(x)\r\n   * z instanceof BigNumber               // false\r\n   * BigNumber.isBigNumber(z)             // true\r\n   * ```\r\n   *\r\n   * @param value The value to test.\r\n   */\r\n  static isBigNumber(value: any): value is BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the maximum of the arguments.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber('3257869345.0378653')\r\n   * BigNumber.maximum(4e9, x, '123456789.9')      // '4000000000'\r\n   *\r\n   * arr = [12, '13', new BigNumber(14)]\r\n   * BigNumber.maximum.apply(null, arr)            // '14'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   */\r\n  static maximum(...n: BigNumber.Value[]): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the maximum of the arguments.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber('3257869345.0378653')\r\n   * BigNumber.max(4e9, x, '123456789.9')      // '4000000000'\r\n   *\r\n   * arr = [12, '13', new BigNumber(14)]\r\n   * BigNumber.max.apply(null, arr)            // '14'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   */\r\n  static max(...n: BigNumber.Value[]): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the minimum of the arguments.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber('3257869345.0378653')\r\n   * BigNumber.minimum(4e9, x, '123456789.9')          // '123456789.9'\r\n   *\r\n   * arr = [2, new BigNumber(-14), '-15.9999', -12]\r\n   * BigNumber.minimum.apply(null, arr)                // '-15.9999'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   */\r\n  static minimum(...n: BigNumber.Value[]): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the minimum of the arguments.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber('3257869345.0378653')\r\n   * BigNumber.min(4e9, x, '123456789.9')             // '123456789.9'\r\n   *\r\n   * arr = [2, new BigNumber(-14), '-15.9999', -12]\r\n   * BigNumber.min.apply(null, arr)                   // '-15.9999'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   */\r\n  static min(...n: BigNumber.Value[]): BigNumber;\r\n\r\n  /**\r\n   * Returns a new BigNumber with a pseudo-random value equal to or greater than 0 and less than 1.\r\n   *\r\n   * The return value will have `decimalPlaces` decimal places, or less if trailing zeros are\r\n   * produced. If `decimalPlaces` is omitted, the current `DECIMAL_PLACES` setting will be used.\r\n   *\r\n   * Depending on the value of this BigNumber constructor's `CRYPTO` setting and the support for the\r\n   * `crypto` object in the host environment, the random digits of the return value are generated by\r\n   * either `Math.random` (fastest), `crypto.getRandomValues` (Web Cryptography API in recent\r\n   * browsers) or `crypto.randomBytes` (Node.js).\r\n   *\r\n   * To be able to set `CRYPTO` to true when using Node.js, the `crypto` object must be available\r\n   * globally:\r\n   *\r\n   * ```ts\r\n   * global.crypto = require('crypto')\r\n   * ```\r\n   *\r\n   * If `CRYPTO` is true, i.e. one of the `crypto` methods is to be used, the value of a returned\r\n   * BigNumber should be cryptographically secure and statistically indistinguishable from a random\r\n   * value.\r\n   *\r\n   * Throws if `decimalPlaces` is invalid.\r\n   *\r\n   * ```ts\r\n   * BigNumber.config({ DECIMAL_PLACES: 10 })\r\n   * BigNumber.random()              // '0.4117936847'\r\n   * BigNumber.random(20)            // '0.78193327636914089009'\r\n   * ```\r\n   *\r\n   * @param [decimalPlaces] Decimal places, integer, 0 to 1e+9.\r\n   */\r\n  static random(decimalPlaces?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the sum of the arguments.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber('3257869345.0378653')\r\n   * BigNumber.sum(4e9, x, '123456789.9')      // '7381326134.9378653'\r\n   *\r\n   * arr = [2, new BigNumber(14), '15.9999', 12]\r\n   * BigNumber.sum.apply(null, arr)            // '43.9999'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   */\r\n  static sum(...n: BigNumber.Value[]): BigNumber;\r\n\r\n  /**\r\n   * Configures the settings that apply to this BigNumber constructor.\r\n   *\r\n   * The configuration object, `object`, contains any number of the properties shown in the example\r\n   * below.\r\n   *\r\n   * Returns an object with the above properties and their current values.\r\n   *\r\n   * Throws if `object` is not an object, or if an invalid value is assigned to one or more of the\r\n   * properties.\r\n   *\r\n   * ```ts\r\n   * BigNumber.set({\r\n   *     DECIMAL_PLACES: 40,\r\n   *     ROUNDING_MODE: BigNumber.ROUND_HALF_CEIL,\r\n   *     EXPONENTIAL_AT: [-10, 20],\r\n   *     RANGE: [-500, 500],\r\n   *     CRYPTO: true,\r\n   *     MODULO_MODE: BigNumber.ROUND_FLOOR,\r\n   *     POW_PRECISION: 80,\r\n   *     FORMAT: {\r\n   *         groupSize: 3,\r\n   *         groupSeparator: ' ',\r\n   *         decimalSeparator: ','\r\n   *     },\r\n   *     ALPHABET: '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'\r\n   * });\r\n   *\r\n   * BigNumber.set().DECIMAL_PLACES        // 40\r\n   * ```\r\n   *\r\n   * @param object The configuration object.\r\n   */\r\n  static set(object: BigNumber.Config): BigNumber.Config;\r\n}\r\n"},{"name":"@taquito/rpc/dist/types/utils/utils.d.ts","dts":"/**\r\n * Casts object/array items to BigNumber\r\n * keys support lodash path notation\r\n * @param data input object or array\r\n * @param keys keys for processing or all items if not defined\r\n *\r\n * @see https://lodash.com/docs/#get\r\n *\r\n */\r\nexport declare function castToBigNumber(data: any, keys?: any): object;\r\n/**\r\n * Casts object/array BigNumber items to strings for readability\r\n * @param data input object or array\r\n * @param keys keys for processing or all items if not defined\r\n *\r\n */\r\nexport declare function castToString(data: any, keys?: any): object;\r\n"},{"name":"@taquito/rpc/dist/types/opkind.d.ts","dts":"export declare enum OpKind {\r\n    ORIGINATION = \"origination\",\r\n    DELEGATION = \"delegation\",\r\n    REVEAL = \"reveal\",\r\n    TRANSACTION = \"transaction\",\r\n    ACTIVATION = \"activate_account\",\r\n    ENDORSEMENT = \"endorsement\",\r\n    SEED_NONCE_REVELATION = \"seed_nonce_revelation\",\r\n    DOUBLE_ENDORSEMENT_EVIDENCE = \"double_endorsement_evidence\",\r\n    DOUBLE_BAKING_EVIDENCE = \"double_baking_evidence\",\r\n    PROPOSALS = \"proposals\",\r\n    BALLOT = \"ballot\"\r\n}\r\n"},{"name":"@taquito/rpc/dist/types/taquito-rpc.d.ts","dts":"/**\r\n * @packageDocumentation\r\n * @module @taquito/rpc\r\n */\r\nimport { HttpBackend } from '@taquito/http-utils';\r\nimport BigNumber from 'bignumber.js';\r\nimport { BakingRightsQueryArguments, BakingRightsResponse, BalanceResponse, BallotListResponse, BallotsResponse, BigMapGetResponse, BigMapKey, BigMapResponse, BlockHeaderResponse, BlockMetadata, BlockResponse, ConstantsResponse, ContractResponse, CurrentProposalResponse, CurrentQuorumResponse, DelegateResponse, DelegatesResponse, EndorsingRightsQueryArguments, EndorsingRightsResponse, EntrypointsResponse, ForgeOperationsParams, ManagerKeyResponse, OperationHash, PackDataParams, PeriodKindResponse, PreapplyParams, PreapplyResponse, ProposalsResponse, RPCRunCodeParam, RPCRunOperationParam, RunCodeResult, ScriptResponse, StorageResponse, VotesListingsResponse } from './types';\r\nexport * from './types';\r\nexport { OpKind } from './opkind';\r\ninterface RPCOptions {\r\n    block: string;\r\n}\r\n/***\r\n * @description RpcClient allows interaction with Tezos network through an rpc node\r\n */\r\nexport declare class RpcClient {\r\n    private url;\r\n    private chain;\r\n    private httpBackend;\r\n    /**\r\n     *\r\n     * @param url rpc root url\r\n     * @param chain chain (default main)\r\n     * @param httpBackend Http backend that issue http request.\r\n     * You can override it by providing your own if you which to hook in the request/response\r\n     *\r\n     * @example new RpcClient('https://api.tez.ie/rpc/mainnet', 'main') this will use https://api.tez.ie/rpc/mainnet/chains/main\r\n     */\r\n    constructor(url: string, chain?: string, httpBackend?: HttpBackend);\r\n    private createURL;\r\n    /**\r\n     *\r\n     * @param options contains generic configuration for rpc calls\r\n     *\r\n     * @description Get the block's hash, its unique identifier.\r\n     *\r\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-hash\r\n     */\r\n    getBlockHash({ block }?: RPCOptions): Promise<string>;\r\n    /**\r\n     *\r\n     * @param options contains generic configuration for rpc calls\r\n     *\r\n     * @description List the ancestors of the given block which, if referred to as the branch in an operation header, are recent enough for that operation to be included in the current block.\r\n     *\r\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-live-blocks\r\n     */\r\n    getLiveBlocks({ block }?: RPCOptions): Promise<string[]>;\r\n    /**\r\n     *\r\n     * @param address address from which we want to retrieve the balance\r\n     * @param options contains generic configuration for rpc calls\r\n     *\r\n     * @description Access the balance of a contract.\r\n     *\r\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-balance\r\n     */\r\n    getBalance(address: string, { block }?: RPCOptions): Promise<BalanceResponse>;\r\n    /**\r\n     *\r\n     * @param address contract address from which we want to retrieve the storage\r\n     * @param options contains generic configuration for rpc calls\r\n     *\r\n     * @description Access the data of the contract.\r\n     *\r\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-storage\r\n     */\r\n    getStorage(address: string, { block }?: {\r\n        block: string;\r\n    }): Promise<StorageResponse>;\r\n    /**\r\n     *\r\n     * @param address contract address from which we want to retrieve the script\r\n     * @param options contains generic configuration for rpc calls\r\n     *\r\n     * @description Access the code and data of the contract.\r\n     *\r\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-script\r\n     */\r\n    getScript(address: string, { block }?: {\r\n        block: string;\r\n    }): Promise<ScriptResponse>;\r\n    /**\r\n     *\r\n     * @param address contract address from which we want to retrieve\r\n     * @param options contains generic configuration for rpc calls\r\n     *\r\n     * @description Access the complete status of a contract.\r\n     *\r\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id\r\n     */\r\n    getContract(address: string, { block }?: {\r\n        block: string;\r\n    }): Promise<ContractResponse>;\r\n    /**\r\n     *\r\n     * @param address contract address from which we want to retrieve the manager\r\n     * @param options contains generic configuration for rpc calls\r\n     *\r\n     * @description Access the manager key of a contract.\r\n     *\r\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-manager-key\r\n     */\r\n    getManagerKey(address: string, { block }?: {\r\n        block: string;\r\n    }): Promise<ManagerKeyResponse>;\r\n    /**\r\n     *\r\n     * @param address contract address from which we want to retrieve the delegate (baker)\r\n     * @param options contains generic configuration for rpc calls\r\n     *\r\n     * @description Access the delegate of a contract, if any.\r\n     *\r\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-delegate\r\n     */\r\n    getDelegate(address: string, { block }?: {\r\n        block: string;\r\n    }): Promise<DelegateResponse>;\r\n    /**\r\n     *\r\n     * @param address contract address from which we want to retrieve the big map key\r\n     * @param options contains generic configuration for rpc calls\r\n     *\r\n     * @description Access the value associated with a key in the big map storage of the contract.\r\n     *\r\n     * @deprecated Deprecated in favor of getBigMapKeyByID\r\n     *\r\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-script\r\n     */\r\n    getBigMapKey(address: string, key: BigMapKey, { block }?: {\r\n        block: string;\r\n    }): Promise<BigMapGetResponse>;\r\n    /**\r\n     *\r\n     * @param id Big Map ID\r\n     * @param expr Expression hash to query (A b58check encoded Blake2b hash of the expression (The expression can be packed using the pack_data method))\r\n     * @param options contains generic configuration for rpc calls\r\n     *\r\n     * @description Access the value associated with a key in a big map.\r\n     *\r\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-big-maps-big-map-id-script-expr\r\n     */\r\n    getBigMapExpr(id: string, expr: string, { block }?: {\r\n        block: string;\r\n    }): Promise<BigMapResponse>;\r\n    /**\r\n     *\r\n     * @param address delegate address which we want to retrieve\r\n     * @param options contains generic configuration for rpc calls\r\n     *\r\n     * @description Fetches information about a delegate from RPC.\r\n     *\r\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-delegates-pkh\r\n     */\r\n    getDelegates(address: string, { block }?: {\r\n        block: string;\r\n    }): Promise<DelegatesResponse>;\r\n    /**\r\n     *\r\n     * @param options contains generic configuration for rpc calls\r\n     *\r\n     * @description All constants\r\n     *\r\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-constants\r\n     */\r\n    getConstants({ block }?: RPCOptions): Promise<ConstantsResponse>;\r\n    /**\r\n     *\r\n     * @param options contains generic configuration for rpc calls. See examples for various available sytaxes.\r\n     *\r\n     * @description All the information about a block\r\n     *\r\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id\r\n     * @example getBlock() will default to /main/chains/block/head.\r\n     * @example getBlock({ block: head~2 }) will return an offset of 2 blocks.\r\n     * @example getBlock({ block: BL8fTiWcSxWCjiMVnDkbh6EuhqVPZzgWheJ2dqwrxYRm9AephXh~2 }) will return an offset of 2 blocks from given block hash..\r\n     */\r\n    getBlock({ block }?: RPCOptions): Promise<BlockResponse>;\r\n    /**\r\n     *\r\n     * @param options contains generic configuration for rpc calls\r\n     *\r\n     * @description The whole block header\r\n     *\r\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-header\r\n     */\r\n    getBlockHeader({ block }?: RPCOptions): Promise<BlockHeaderResponse>;\r\n    /**\r\n     *\r\n     * @param options contains generic configuration for rpc calls\r\n     *\r\n     * @description All the metadata associated to the block\r\n     *\r\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-metadata\r\n     */\r\n    getBlockMetadata({ block }?: RPCOptions): Promise<BlockMetadata>;\r\n    /**\r\n     *\r\n     * @param args contains optional query arguments\r\n     * @param options contains generic configuration for rpc calls\r\n     *\r\n     * @description Retrieves the list of delegates allowed to bake a block.\r\n     *\r\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-helpers-baking-rights\r\n     */\r\n    getBakingRights(args?: BakingRightsQueryArguments, { block }?: RPCOptions): Promise<BakingRightsResponse>;\r\n    /**\r\n     *\r\n     * @param args contains optional query arguments\r\n     * @param options contains generic configuration for rpc calls\r\n     *\r\n     * @description Retrieves the list of delegates allowed to bake a block.\r\n     *\r\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-helpers-endorsing-rights\r\n     */\r\n    getEndorsingRights(args?: EndorsingRightsQueryArguments, { block }?: RPCOptions): Promise<EndorsingRightsResponse>;\r\n    /**\r\n     * @param options contains generic configuration for rpc calls\r\n     *\r\n     * @description Ballots casted so far during a voting period\r\n     *\r\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-ballot-list\r\n     */\r\n    getBallotList({ block }?: RPCOptions): Promise<BallotListResponse>;\r\n    /**\r\n     *\r\n     * @param options contains generic configuration for rpc calls\r\n     *\r\n     * @description Sum of ballots casted so far during a voting period.\r\n     *\r\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-ballots\r\n     */\r\n    getBallots({ block }?: RPCOptions): Promise<BallotsResponse>;\r\n    /**\r\n     *\r\n     * @param options contains generic configuration for rpc calls\r\n     *\r\n     * @description Current period kind.\r\n     *\r\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-current-period-kind\r\n     */\r\n    getCurrentPeriodKind({ block }?: RPCOptions): Promise<PeriodKindResponse>;\r\n    /**\r\n     *\r\n     * @param options contains generic configuration for rpc calls\r\n     *\r\n     * @description Current proposal under evaluation.\r\n     *\r\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-current-proposal\r\n     */\r\n    getCurrentProposal({ block }?: RPCOptions): Promise<CurrentProposalResponse>;\r\n    /**\r\n     *\r\n     * @param options contains generic configuration for rpc calls\r\n     *\r\n     * @description Current expected quorum.\r\n     *\r\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-current-quorum\r\n     */\r\n    getCurrentQuorum({ block }?: RPCOptions): Promise<CurrentQuorumResponse>;\r\n    /**\r\n     *\r\n     * @param options contains generic configuration for rpc calls\r\n     *\r\n     * @description List of delegates with their voting weight, in number of rolls.\r\n     *\r\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-listings\r\n     */\r\n    getVotesListings({ block }?: RPCOptions): Promise<VotesListingsResponse>;\r\n    /**\r\n     *\r\n     * @param options contains generic configuration for rpc calls\r\n     *\r\n     * @description List of proposals with number of supporters.\r\n     *\r\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-proposals\r\n     */\r\n    getProposals({ block }?: RPCOptions): Promise<ProposalsResponse>;\r\n    /**\r\n     *\r\n     * @param data operation contents to forge\r\n     * @param options contains generic configuration for rpc calls\r\n     *\r\n     * @description Forge an operation returning the unsigned bytes\r\n     *\r\n     * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-forge-operations\r\n     */\r\n    forgeOperations(data: ForgeOperationsParams, { block }?: RPCOptions): Promise<string>;\r\n    /**\r\n     *\r\n     * @param signedOpBytes signed bytes to inject\r\n     *\r\n     * @description Inject an operation in node and broadcast it. Returns the ID of the operation. The `signedOperationContents` should be constructed using a contextual RPCs from the latest block and signed by the client. By default, the RPC will wait for the operation to be (pre-)validated before answering. See RPCs under /blocks/prevalidation for more details on the prevalidation context.\r\n     *\r\n     * @see https://tezos.gitlab.io/api/rpc.html#post-injection-operation\r\n     */\r\n    injectOperation(signedOpBytes: string): Promise<OperationHash>;\r\n    /**\r\n     *\r\n     * @param ops Operations to apply\r\n     * @param options contains generic configuration for rpc calls\r\n     *\r\n     * @description Simulate the validation of an operation\r\n     *\r\n     * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-preapply-operations\r\n     */\r\n    preapplyOperations(ops: PreapplyParams, { block }?: RPCOptions): Promise<PreapplyResponse[]>;\r\n    /**\r\n     *\r\n     * @param contract address of the contract we want to get the entrypoints of\r\n     *\r\n     * @description Return the list of entrypoints of the contract\r\n     *\r\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-entrypoints\r\n     *\r\n     * @version 005_PsBABY5H\r\n     */\r\n    getEntrypoints(contract: string, { block }?: RPCOptions): Promise<EntrypointsResponse>;\r\n    /**\r\n     * @param op Operation to run\r\n     * @param options contains generic configuration for rpc calls\r\n     *\r\n     * @description Run an operation without signature checks\r\n     *\r\n     * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-scripts-run-operation\r\n     */\r\n    runOperation(op: RPCRunOperationParam, { block }?: RPCOptions): Promise<PreapplyResponse>;\r\n    /**\r\n     * @param code Code to run\r\n     * @param options contains generic configuration for rpc calls\r\n     *\r\n     * @description Run a piece of code in the current context\r\n     *\r\n     * @see https://tezos.gitlab.io/007/rpc.html#post-block-id-helpers-scripts-run-code\r\n     */\r\n    runCode(code: RPCRunCodeParam, { block }?: RPCOptions): Promise<RunCodeResult>;\r\n    getChainId(): Promise<string>;\r\n    /**\r\n     *\r\n     * @param data Data to pack\r\n     * @param options contains generic configuration for rpc calls\r\n     *\r\n     * @description Computes the serialized version of a data expression using the same algorithm as script instruction PACK\r\n     *\r\n     * @example packData({ data: { string: \"test\" }, type: { prim: \"string\" } })\r\n     *\r\n     * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-scripts-pack-data\r\n     */\r\n    packData(data: PackDataParams, { block }?: RPCOptions): Promise<{\r\n        packed: string;\r\n        gas: BigNumber | \"unaccounted\" | undefined;\r\n    }>;\r\n    /**\r\n     *\r\n     * @description Return rpc root url\r\n     */\r\n    getRpcUrl(): string;\r\n}\r\n"},{"name":"@taquito/rpc/dist/types/types.d.ts","dts":"import BigNumber from 'bignumber.js';\r\nimport { OpKind } from './opkind';\r\nexport declare type BalanceResponse = BigNumber;\r\nexport declare type StorageResponse = ScriptedContracts['storage'];\r\nexport declare type ScriptResponse = ScriptedContracts;\r\nexport declare type BigMapGetResponse = MichelsonV1Expression;\r\nexport declare type ManagerResponse = {\r\n    manager: string;\r\n};\r\nexport declare type ManagerKeyResponse = string | {\r\n    key: string;\r\n};\r\nexport declare type DelegateResponse = string | null;\r\nexport declare type OperationHash = string;\r\nexport interface DelegatesResponse {\r\n    balance: BigNumber;\r\n    frozen_balance: BigNumber;\r\n    frozen_balance_by_cycle: Frozenbalancebycycle[];\r\n    staking_balance: BigNumber;\r\n    delegated_contracts: string[];\r\n    delegated_balance: BigNumber;\r\n    deactivated: boolean;\r\n    grace_period: number;\r\n}\r\ninterface Frozenbalancebycycle {\r\n    cycle: number;\r\n    deposit: BigNumber;\r\n    fees: BigNumber;\r\n    rewards: BigNumber;\r\n}\r\nexport declare type BigMapKey = {\r\n    key: {\r\n        [key: string]: string;\r\n    };\r\n    type: {\r\n        prim: string;\r\n    };\r\n};\r\nexport interface BlockFullHeader {\r\n    level: number;\r\n    proto: number;\r\n    predecessor: string;\r\n    timestamp: TimeStampMixed;\r\n    validation_pass: number;\r\n    operations_hash: string;\r\n    fitness: string[];\r\n    context: string;\r\n    priority: number;\r\n    proof_of_work_nonce: string;\r\n    seed_nonce_hash?: string;\r\n    signature: string;\r\n}\r\nexport declare type InlinedEndorsementKindEnum = OpKind.ENDORSEMENT;\r\nexport interface InlinedEndorsementContents {\r\n    kind: InlinedEndorsementKindEnum;\r\n    level: number;\r\n}\r\nexport interface InlinedEndorsement {\r\n    branch: string;\r\n    operations: InlinedEndorsementContents;\r\n    signature?: string;\r\n}\r\nexport declare type OperationContentsBallotEnum = 'nay' | 'yay' | 'pass';\r\nexport interface OperationContentsEndorsement {\r\n    kind: OpKind.ENDORSEMENT;\r\n    level: number;\r\n}\r\nexport interface OperationContentsRevelation {\r\n    kind: OpKind.SEED_NONCE_REVELATION;\r\n    level: number;\r\n    nonce: string;\r\n}\r\nexport interface OperationContentsDoubleEndorsement {\r\n    kind: OpKind.DOUBLE_ENDORSEMENT_EVIDENCE;\r\n    op1: InlinedEndorsement;\r\n    op2: InlinedEndorsement;\r\n}\r\nexport interface OperationContentsDoubleBaking {\r\n    kind: OpKind.DOUBLE_BAKING_EVIDENCE;\r\n    bh1: BlockFullHeader;\r\n    bh2: BlockFullHeader;\r\n}\r\nexport interface OperationContentsActivateAccount {\r\n    kind: OpKind.ACTIVATION;\r\n    pkh: string;\r\n    secret: string;\r\n}\r\nexport interface OperationContentsProposals {\r\n    kind: OpKind.PROPOSALS;\r\n    source: string;\r\n    period: number;\r\n    proposals: string[];\r\n}\r\nexport interface OperationContentsBallot {\r\n    kind: OpKind.BALLOT;\r\n    source: string;\r\n    period: number;\r\n    proposal: string;\r\n    ballot: OperationContentsBallotEnum;\r\n}\r\nexport interface OperationContentsReveal {\r\n    kind: OpKind.REVEAL;\r\n    source: string;\r\n    fee: string;\r\n    counter: string;\r\n    gas_limit: string;\r\n    storage_limit: string;\r\n    public_key: string;\r\n}\r\nexport interface OperationContentsTransaction {\r\n    kind: OpKind.TRANSACTION;\r\n    source: string;\r\n    fee: string;\r\n    counter: string;\r\n    gas_limit: string;\r\n    storage_limit: string;\r\n    amount: string;\r\n    destination: string;\r\n    parameters?: TransactionOperationParameter;\r\n}\r\nexport interface OperationContentsOrigination {\r\n    kind: OpKind.ORIGINATION;\r\n    source: string;\r\n    fee: string;\r\n    counter: string;\r\n    gas_limit: string;\r\n    storage_limit: string;\r\n    balance: string;\r\n    delegate?: string;\r\n    script?: ScriptedContracts;\r\n}\r\nexport interface OperationContentsDelegation {\r\n    kind: OpKind.DELEGATION;\r\n    source: string;\r\n    fee: string;\r\n    counter: string;\r\n    gas_limit: string;\r\n    storage_limit: string;\r\n    delegate?: string;\r\n}\r\nexport declare type OperationContents = OperationContentsEndorsement | OperationContentsRevelation | OperationContentsDoubleEndorsement | OperationContentsDoubleBaking | OperationContentsActivateAccount | OperationContentsProposals | OperationContentsBallot | OperationContentsReveal | OperationContentsTransaction | OperationContentsOrigination | OperationContentsDelegation;\r\nexport interface OperationContentsAndResultMetadataExtended {\r\n    balance_updates: OperationMetadataBalanceUpdates[];\r\n    delegate: string;\r\n    slots: number[];\r\n}\r\nexport interface OperationContentsAndResultMetadataReveal {\r\n    balance_updates: OperationMetadataBalanceUpdates[];\r\n    operation_result: OperationResultReveal;\r\n    internal_operation_results?: InternalOperationResult[];\r\n}\r\nexport interface OperationContentsAndResultMetadataTransaction {\r\n    balance_updates: OperationMetadataBalanceUpdates[];\r\n    operation_result: OperationResultTransaction;\r\n    internal_operation_results?: InternalOperationResult[];\r\n}\r\nexport interface OperationContentsAndResultMetadataDelegation {\r\n    balance_updates: OperationMetadataBalanceUpdates[];\r\n    operation_result: OperationResultDelegation;\r\n    internal_operation_results?: InternalOperationResult[];\r\n}\r\nexport interface OperationContentsAndResultMetadata {\r\n    balance_updates: OperationMetadataBalanceUpdates[];\r\n}\r\nexport interface OperationContentsAndResultEndorsement {\r\n    kind: OpKind.ENDORSEMENT;\r\n    level: number;\r\n    metadata: OperationContentsAndResultMetadataExtended;\r\n}\r\nexport interface OperationContentsAndResultRevelation {\r\n    kind: OpKind.SEED_NONCE_REVELATION;\r\n    level: number;\r\n    nonce: string;\r\n    metadata: OperationContentsAndResultMetadata;\r\n}\r\nexport interface OperationContentsAndResultDoubleEndorsement {\r\n    kind: OpKind.DOUBLE_ENDORSEMENT_EVIDENCE;\r\n    op1: InlinedEndorsement;\r\n    op2: InlinedEndorsement;\r\n    metadata: OperationContentsAndResultMetadata;\r\n}\r\nexport interface OperationContentsAndResultDoubleBaking {\r\n    kind: OpKind.DOUBLE_BAKING_EVIDENCE;\r\n    bh1: BlockFullHeader;\r\n    bh2: BlockFullHeader;\r\n    metadata: OperationContentsAndResultMetadata;\r\n}\r\nexport interface OperationContentsAndResultActivateAccount {\r\n    kind: OpKind.ACTIVATION;\r\n    pkh: string;\r\n    secret: string;\r\n    metadata: OperationContentsAndResultMetadata;\r\n}\r\nexport interface OperationContentsAndResultProposals {\r\n    kind: OpKind.PROPOSALS;\r\n    source: string;\r\n    period: number;\r\n    proposals: string[];\r\n}\r\nexport interface OperationContentsAndResultBallot {\r\n    kind: OpKind.BALLOT;\r\n    source: string;\r\n    period: number;\r\n    proposal: string;\r\n    ballot: OperationContentsBallotEnum;\r\n}\r\nexport interface OperationContentsAndResultReveal {\r\n    kind: OpKind.REVEAL;\r\n    source: string;\r\n    fee: string;\r\n    counter: string;\r\n    gas_limit: string;\r\n    storage_limit: string;\r\n    public_key: string;\r\n    metadata: OperationContentsAndResultMetadataReveal;\r\n}\r\nexport interface OperationContentsAndResultTransaction {\r\n    kind: OpKind.TRANSACTION;\r\n    source: string;\r\n    fee: string;\r\n    counter: string;\r\n    gas_limit: string;\r\n    storage_limit: string;\r\n    amount: string;\r\n    destination: string;\r\n    parameters?: TransactionOperationParameter;\r\n    metadata: OperationContentsAndResultMetadataTransaction;\r\n}\r\nexport interface OperationContentsAndResultDelegation {\r\n    kind: OpKind.DELEGATION;\r\n    source: string;\r\n    fee: string;\r\n    counter: string;\r\n    gas_limit: string;\r\n    storage_limit: string;\r\n    delegate?: string;\r\n    metadata: OperationContentsAndResultMetadataDelegation;\r\n}\r\nexport declare type OperationContentsAndResult = OperationContentsAndResultEndorsement | OperationContentsAndResultRevelation | OperationContentsAndResultDoubleEndorsement | OperationContentsAndResultDoubleBaking | OperationContentsAndResultActivateAccount | OperationContentsAndResultProposals | OperationContentsAndResultBallot | OperationContentsAndResultReveal | OperationContentsAndResultTransaction | OperationContentsAndResultOrigination | OperationContentsAndResultDelegation;\r\nexport interface OperationEntry {\r\n    protocol: string;\r\n    chain_id: string;\r\n    hash: string;\r\n    branch: string;\r\n    contents: (OperationContents | OperationContentsAndResult)[];\r\n    signature?: string;\r\n}\r\nexport interface BlockResponse {\r\n    protocol: string;\r\n    chain_id: string;\r\n    hash: string;\r\n    header: BlockFullHeader;\r\n    metadata: BlockMetadata;\r\n    operations: OperationEntry[][];\r\n}\r\nexport declare type BakingRightsArgumentsDelegate = string | string[];\r\nexport declare type BakingRightsArgumentsCycle = number | number[];\r\nexport declare type BakingRightsArgumentsLevel = number | number[];\r\nexport interface BakingRightsQueryArguments {\r\n    level?: BakingRightsArgumentsLevel;\r\n    cycle?: BakingRightsArgumentsCycle;\r\n    delegate?: BakingRightsArgumentsDelegate;\r\n    max_priority?: number;\r\n    all?: null;\r\n}\r\nexport interface BakingRightsResponseItem {\r\n    level: number;\r\n    delegate: string;\r\n    priority: number;\r\n    estimated_time?: Date;\r\n}\r\nexport declare type BakingRightsResponse = BakingRightsResponseItem[];\r\nexport declare type EndorsingRightsArgumentsDelegate = string | string[];\r\nexport declare type EndorsingRightsArgumentsCycle = number | number[];\r\nexport declare type EndorsingRightsArgumentsLevel = number | number[];\r\nexport interface EndorsingRightsQueryArguments {\r\n    level?: EndorsingRightsArgumentsLevel;\r\n    cycle?: EndorsingRightsArgumentsCycle;\r\n    delegate?: EndorsingRightsArgumentsDelegate;\r\n}\r\nexport interface EndorsingRightsResponseItem {\r\n    level: number;\r\n    delegate: string;\r\n    slots: number[];\r\n    estimated_time?: Date;\r\n}\r\nexport declare type EndorsingRightsResponse = EndorsingRightsResponseItem[];\r\nexport declare type BallotListResponseEnum = 'nay' | 'yay' | 'pass';\r\nexport interface BallotListResponseItem {\r\n    pkh: string;\r\n    ballot: BallotListResponseEnum;\r\n}\r\nexport declare type BallotListResponse = BallotListResponseItem[];\r\nexport interface BallotsResponse {\r\n    yay: number;\r\n    nay: number;\r\n    pass: number;\r\n}\r\nexport declare type PeriodKindResponse = 'proposal' | 'testing_vote' | 'testing' | 'promotion_vote';\r\nexport declare type CurrentProposalResponse = string | null;\r\nexport declare type CurrentQuorumResponse = number;\r\nexport interface VotesListingsResponseItem {\r\n    pkh: string;\r\n    rolls: number;\r\n}\r\nexport declare type VotesListingsResponse = VotesListingsResponseItem[];\r\nexport declare type ProposalsResponseItem = [string, number];\r\nexport declare type ProposalsResponse = ProposalsResponseItem[];\r\nexport interface RawBlockHeaderResponse {\r\n    protocol: string;\r\n    chain_id: string;\r\n    hash: string;\r\n    level: number;\r\n    proto: number;\r\n    predecessor: string;\r\n    timestamp: string;\r\n    validation_pass: number;\r\n    operations_hash: string;\r\n    fitness: string[];\r\n    context: string;\r\n    priority: number;\r\n    proof_of_work_nonce: string;\r\n    signature: string;\r\n}\r\nexport interface BlockHeaderResponse {\r\n    protocol: string;\r\n    chain_id: string;\r\n    hash: string;\r\n    level: number;\r\n    proto: number;\r\n    predecessor: string;\r\n    timestamp: string;\r\n    validation_pass: number;\r\n    operations_hash: string;\r\n    fitness: string[];\r\n    context: string;\r\n    priority: number;\r\n    proof_of_work_nonce: string;\r\n    signature: string;\r\n}\r\nexport interface PackDataParams {\r\n    data: MichelsonV1Expression;\r\n    type: MichelsonV1Expression;\r\n    gas?: BigNumber;\r\n}\r\nexport declare type HexString = string;\r\nexport interface PackDataResponse {\r\n    packed: HexString;\r\n    gas?: BigNumber | 'unaccounted';\r\n}\r\nexport declare type BigMapResponse = MichelsonV1Expression | MichelsonV1Expression[];\r\nexport declare type PreapplyParams = OperationObject[];\r\nexport declare type PreapplyResponse = {\r\n    contents: OperationContentsAndResult[];\r\n};\r\nexport declare type ForgeOperationsParams = Pick<OperationObject, 'branch' | 'contents'>;\r\nexport declare type TimeStampMixed = Date | string;\r\nexport declare type BalanceUpdateKindEnum = 'contract' | 'freezer';\r\nexport declare type BalanceUpdateCategoryEnum = 'rewards' | 'fees' | 'deposits';\r\nexport interface MichelsonV1ExpressionBase {\r\n    int?: string;\r\n    string?: string;\r\n    bytes?: string;\r\n}\r\nexport interface MichelsonV1ExpressionExtended {\r\n    prim: string;\r\n    args?: MichelsonV1Expression[];\r\n    annots?: string[];\r\n}\r\nexport declare type MichelsonV1Expression = MichelsonV1ExpressionBase | MichelsonV1ExpressionExtended | MichelsonV1Expression[];\r\nexport interface ScriptedContracts {\r\n    code: MichelsonV1Expression[];\r\n    storage: MichelsonV1Expression;\r\n}\r\nexport interface OperationBalanceUpdatesItem {\r\n    kind: BalanceUpdateKindEnum;\r\n    category?: BalanceUpdateCategoryEnum;\r\n    delegate?: string;\r\n    cycle?: number;\r\n    contract?: string;\r\n    change: string;\r\n}\r\nexport declare type OperationBalanceUpdates = OperationBalanceUpdatesItem[];\r\nexport interface OperationObject {\r\n    branch?: string;\r\n    contents?: OperationContents[];\r\n    protocol?: string;\r\n    signature?: string;\r\n}\r\nexport declare type InternalOperationResultKindEnum = OpKind.REVEAL | OpKind.TRANSACTION | OpKind.ORIGINATION | OpKind.DELEGATION;\r\nexport declare type InternalOperationResultEnum = OperationResultReveal | OperationResultTransaction | OperationResultDelegation | OperationResultOrigination;\r\nexport interface OperationResultDelegation {\r\n    status: OperationResultStatusEnum;\r\n    consumed_gas?: string;\r\n    errors?: TezosGenericOperationError[];\r\n    consumed_milligas?: string;\r\n}\r\nexport interface ContractBigMapDiffItem {\r\n    key_hash: string;\r\n    key: MichelsonV1Expression;\r\n    value?: MichelsonV1Expression;\r\n}\r\nexport declare type ContractBigMapDiff = ContractBigMapDiffItem[];\r\nexport interface TezosGenericOperationError {\r\n    kind: string;\r\n    id: string;\r\n}\r\nexport interface OperationResultTransaction {\r\n    status: OperationResultStatusEnum;\r\n    storage?: MichelsonV1Expression;\r\n    big_map_diff?: ContractBigMapDiff;\r\n    balance_updates?: OperationBalanceUpdates;\r\n    originated_contracts?: string[];\r\n    consumed_gas?: string;\r\n    storage_size?: string;\r\n    paid_storage_size_diff?: string;\r\n    allocated_destination_contract?: boolean;\r\n    errors?: TezosGenericOperationError[];\r\n    consumed_milligas?: string;\r\n}\r\nexport interface OperationResultReveal {\r\n    status: OperationResultStatusEnum;\r\n    consumed_gas?: string;\r\n    errors?: TezosGenericOperationError[];\r\n    consumed_milligas?: string;\r\n}\r\nexport interface TransactionOperationParameter {\r\n    entrypoint: string;\r\n    value: MichelsonV1Expression;\r\n}\r\nexport interface InternalOperationResult {\r\n    kind: InternalOperationResultKindEnum;\r\n    source: string;\r\n    nonce: number;\r\n    amount?: string;\r\n    destination?: string;\r\n    parameters?: TransactionOperationParameter;\r\n    public_key?: string;\r\n    balance?: string;\r\n    delegate?: string;\r\n    script?: ScriptedContracts;\r\n    result: InternalOperationResultEnum;\r\n}\r\nexport declare type MetadataBalanceUpdatesKindEnum = 'contract' | 'freezer';\r\nexport declare type MetadataBalanceUpdatesCategoryEnum = 'rewards' | 'fees' | 'deposits';\r\nexport interface OperationMetadataBalanceUpdates {\r\n    kind: MetadataBalanceUpdatesKindEnum;\r\n    category?: MetadataBalanceUpdatesCategoryEnum;\r\n    contract?: string;\r\n    delegate?: string;\r\n    cycle?: number;\r\n    change: string;\r\n}\r\nexport declare type OperationResultStatusEnum = 'applied' | 'failed' | 'skipped' | 'backtracked';\r\nexport interface OperationResultOrigination {\r\n    status: OperationResultStatusEnum;\r\n    balance_updates?: OperationBalanceUpdates;\r\n    originated_contracts?: string[];\r\n    consumed_gas?: string;\r\n    storage_size?: string;\r\n    paid_storage_size_diff?: string;\r\n    errors?: TezosGenericOperationError[];\r\n    consumed_milligas?: string;\r\n}\r\nexport interface OperationContentsAndResultMetadataOrigination {\r\n    balance_updates: OperationMetadataBalanceUpdates[];\r\n    operation_result: OperationResultOrigination;\r\n    internal_operation_results?: InternalOperationResult[];\r\n}\r\nexport declare type ConstantsResponse = ConstantsResponseCommon & ConstantsResponseProto007 & ConstantsResponseProto006 & ConstantsResponseProto005 & ConstantsResponseProto004 & ConstantsResponseProto003 & ConstantsResponseProto001And002;\r\nexport interface ConstantsResponseCommon {\r\n    proof_of_work_nonce_size: number;\r\n    nonce_length: number;\r\n    max_operation_data_length: number;\r\n    preserved_cycles: number;\r\n    blocks_per_cycle: number;\r\n    blocks_per_commitment: number;\r\n    blocks_per_roll_snapshot: number;\r\n    blocks_per_voting_period: number;\r\n    time_between_blocks: BigNumber[];\r\n    endorsers_per_block: number;\r\n    hard_gas_limit_per_operation: BigNumber;\r\n    hard_gas_limit_per_block: BigNumber;\r\n    proof_of_work_threshold: BigNumber;\r\n    tokens_per_roll: BigNumber;\r\n    michelson_maximum_type_size: number;\r\n    seed_nonce_revelation_tip: BigNumber;\r\n    block_security_deposit: BigNumber;\r\n    endorsement_security_deposit: BigNumber;\r\n    endorsement_reward: BigNumber | BigNumber[];\r\n    cost_per_byte: BigNumber;\r\n    hard_storage_limit_per_operation: BigNumber;\r\n}\r\nexport interface ConstantsResponseProto007 extends Omit<ConstantsResponseProto006, 'max_revelations_per_block'> {\r\n    max_anon_ops_per_block?: number;\r\n}\r\nexport interface ConstantsResponseProto006 extends Omit<ConstantsResponseProto005, 'block_reward'> {\r\n    baking_reward_per_endorsement?: BigNumber[];\r\n}\r\nexport interface ConstantsResponseProto005 extends ConstantsResponseProto004 {\r\n    quorum_min?: number;\r\n    quorum_max?: number;\r\n    min_proposal_quorum?: number;\r\n    initial_endorsers?: number;\r\n    delay_per_missing_endorsement?: BigNumber;\r\n}\r\nexport interface ConstantsResponseProto004 extends ConstantsResponseProto003 {\r\n    test_chain_duration?: BigNumber;\r\n}\r\nexport interface ConstantsResponseProto003 extends Omit<ConstantsResponseProto001And002, 'origination_burn'> {\r\n    origination_size?: number;\r\n    max_proposals_per_delegate?: number;\r\n}\r\nexport interface ConstantsResponseProto001And002 {\r\n    max_revelations_per_block?: number;\r\n    origination_burn?: string;\r\n    block_reward?: BigNumber;\r\n}\r\nexport interface ContractResponse {\r\n    balance: BigNumber;\r\n    script: ScriptedContracts;\r\n    counter?: string;\r\n    delegate?: string;\r\n}\r\nexport interface TestChainStatus {\r\n    status: string;\r\n}\r\nexport interface MaxOperationListLength {\r\n    max_size: number;\r\n    max_op: number;\r\n}\r\nexport interface Level {\r\n    level: number;\r\n    level_position: number;\r\n    cycle: number;\r\n    cycle_position: number;\r\n    voting_period: number;\r\n    voting_period_position: number;\r\n    expected_commitment: boolean;\r\n}\r\nexport interface BlockMetadata {\r\n    protocol: string;\r\n    next_protocol: string;\r\n    test_chain_status: TestChainStatus;\r\n    max_operations_ttl: number;\r\n    max_operation_data_length: number;\r\n    max_block_header_length: number;\r\n    max_operation_list_length: MaxOperationListLength[];\r\n    baker: string;\r\n    level: Level;\r\n    voting_period_kind: string;\r\n    nonce_hash?: any;\r\n    consumed_gas: string;\r\n    deactivated: any[];\r\n    balance_updates: OperationBalanceUpdates;\r\n}\r\nexport declare type RPCRunOperationParam = {\r\n    operation: OperationObject;\r\n    chain_id: string;\r\n};\r\nexport declare type RPCRunCodeParam = {\r\n    script: MichelsonV1ExpressionExtended[];\r\n    storage: MichelsonV1Expression;\r\n    input: MichelsonV1Expression;\r\n    amount: string;\r\n    chain_id: string;\r\n    source?: string;\r\n    payer?: string;\r\n    gas?: BigNumber;\r\n    entrypoint?: string;\r\n    balance?: string;\r\n};\r\nexport declare type RunCodeResult = {\r\n    storage: MichelsonV1Expression;\r\n    operations: InternalOperationResult[];\r\n    big_map_diff?: ContractBigMapDiff;\r\n};\r\nexport declare type EntrypointsResponse = {\r\n    entrypoints: {\r\n        [key: string]: Object;\r\n    };\r\n    unreachable?: {\r\n        path: ('Left' | 'Right')[];\r\n    };\r\n};\r\nexport interface OperationContentsAndResultOrigination {\r\n    kind: OpKind.ORIGINATION;\r\n    source: string;\r\n    fee: string;\r\n    counter: string;\r\n    gas_limit: string;\r\n    storage_limit: string;\r\n    balance: string;\r\n    delegate?: string;\r\n    script?: ScriptedContracts;\r\n    metadata: OperationContentsAndResultMetadataOrigination;\r\n}\r\nexport {};\r\n"},{"name":"@taquito/rpc/node_modules/bignumber.js/bignumber.d.ts","dts":"// Type definitions for bignumber.js >=8.1.0\r\n// Project: https://github.com/MikeMcl/bignumber.js\r\n// Definitions by: Michael Mclaughlin <https://github.com/MikeMcl>\r\n// Definitions: https://github.com/MikeMcl/bignumber.js\r\n\r\n// Documentation: http://mikemcl.github.io/bignumber.js/\r\n//\r\n// Exports:\r\n//\r\n//   class     BigNumber (default export)\r\n//   type      BigNumber.Constructor\r\n//   type      BigNumber.ModuloMode\r\n//   type      BigNumber.RoundingMOde\r\n//   type      BigNumber.Value\r\n//   interface BigNumber.Config\r\n//   interface BigNumber.Format\r\n//   interface BigNumber.Instance\r\n//\r\n// Example:\r\n//\r\n//   import {BigNumber} from \"bignumber.js\"\r\n//   //import BigNumber from \"bignumber.js\"\r\n//\r\n//   let rm: BigNumber.RoundingMode = BigNumber.ROUND_UP;\r\n//   let f: BigNumber.Format = { decimalSeparator: ',' };\r\n//   let c: BigNumber.Config = { DECIMAL_PLACES: 4, ROUNDING_MODE: rm, FORMAT: f };\r\n//   BigNumber.config(c);\r\n//\r\n//   let v: BigNumber.Value = '12345.6789';\r\n//   let b: BigNumber = new BigNumber(v);\r\n//\r\n// The use of compiler option `--strictNullChecks` is recommended.\r\n\r\nexport default BigNumber;\r\n\r\nexport namespace BigNumber {\r\n\r\n  /** See `BigNumber.config` (alias `BigNumber.set`) and `BigNumber.clone`. */\r\n  interface Config {\r\n\r\n    /**\r\n     * An integer, 0 to 1e+9. Default value: 20.\r\n     *\r\n     * The maximum number of decimal places of the result of operations involving division, i.e.\r\n     * division, square root and base conversion operations, and exponentiation when the exponent is\r\n     * negative.\r\n     *\r\n     * ```ts\r\n     * BigNumber.config({ DECIMAL_PLACES: 5 })\r\n     * BigNumber.set({ DECIMAL_PLACES: 5 })\r\n     * ```\r\n     */\r\n    DECIMAL_PLACES?: number;\r\n\r\n    /**\r\n     * An integer, 0 to 8. Default value: `BigNumber.ROUND_HALF_UP` (4).\r\n     *\r\n     * The rounding mode used in operations that involve division (see `DECIMAL_PLACES`) and the\r\n     * default rounding mode of the `decimalPlaces`, `precision`, `toExponential`, `toFixed`,\r\n     * `toFormat` and `toPrecision` methods.\r\n     *\r\n     * The modes are available as enumerated properties of the BigNumber constructor.\r\n     *\r\n     * ```ts\r\n     * BigNumber.config({ ROUNDING_MODE: 0 })\r\n     * BigNumber.set({ ROUNDING_MODE: BigNumber.ROUND_UP })\r\n     * ```\r\n     */\r\n    ROUNDING_MODE?: BigNumber.RoundingMode;\r\n\r\n    /**\r\n     * An integer, 0 to 1e+9, or an array, [-1e+9 to 0, 0 to 1e+9].\r\n     * Default value: `[-7, 20]`.\r\n     *\r\n     * The exponent value(s) at which `toString` returns exponential notation.\r\n     *\r\n     * If a single number is assigned, the value is the exponent magnitude.\r\n     *\r\n     * If an array of two numbers is assigned then the first number is the negative exponent value at\r\n     * and beneath which exponential notation is used, and the second number is the positive exponent\r\n     * value at and above which exponential notation is used.\r\n     *\r\n     * For example, to emulate JavaScript numbers in terms of the exponent values at which they begin\r\n     * to use exponential notation, use `[-7, 20]`.\r\n     *\r\n     * ```ts\r\n     * BigNumber.config({ EXPONENTIAL_AT: 2 })\r\n     * new BigNumber(12.3)         // '12.3'        e is only 1\r\n     * new BigNumber(123)          // '1.23e+2'\r\n     * new BigNumber(0.123)        // '0.123'       e is only -1\r\n     * new BigNumber(0.0123)       // '1.23e-2'\r\n     *\r\n     * BigNumber.config({ EXPONENTIAL_AT: [-7, 20] })\r\n     * new BigNumber(123456789)    // '123456789'   e is only 8\r\n     * new BigNumber(0.000000123)  // '1.23e-7'\r\n     *\r\n     * // Almost never return exponential notation:\r\n     * BigNumber.config({ EXPONENTIAL_AT: 1e+9 })\r\n     *\r\n     * // Always return exponential notation:\r\n     * BigNumber.config({ EXPONENTIAL_AT: 0 })\r\n     * ```\r\n     *\r\n     * Regardless of the value of `EXPONENTIAL_AT`, the `toFixed` method will always return a value in\r\n     * normal notation and the `toExponential` method will always return a value in exponential form.\r\n     * Calling `toString` with a base argument, e.g. `toString(10)`, will also always return normal\r\n     * notation.\r\n     */\r\n    EXPONENTIAL_AT?: number | [number, number];\r\n\r\n    /**\r\n     * An integer, magnitude 1 to 1e+9, or an array, [-1e+9 to -1, 1 to 1e+9].\r\n     * Default value: `[-1e+9, 1e+9]`.\r\n     *\r\n     * The exponent value(s) beyond which overflow to Infinity and underflow to zero occurs.\r\n     *\r\n     * If a single number is assigned, it is the maximum exponent magnitude: values wth a positive\r\n     * exponent of greater magnitude become Infinity and those with a negative exponent of greater\r\n     * magnitude become zero.\r\n     *\r\n     * If an array of two numbers is assigned then the first number is the negative exponent limit and\r\n     * the second number is the positive exponent limit.\r\n     *\r\n     * For example, to emulate JavaScript numbers in terms of the exponent values at which they\r\n     * become zero and Infinity, use [-324, 308].\r\n     *\r\n     * ```ts\r\n     * BigNumber.config({ RANGE: 500 })\r\n     * BigNumber.config().RANGE     // [ -500, 500 ]\r\n     * new BigNumber('9.999e499')   // '9.999e+499'\r\n     * new BigNumber('1e500')       // 'Infinity'\r\n     * new BigNumber('1e-499')      // '1e-499'\r\n     * new BigNumber('1e-500')      // '0'\r\n     *\r\n     * BigNumber.config({ RANGE: [-3, 4] })\r\n     * new BigNumber(99999)         // '99999'      e is only 4\r\n     * new BigNumber(100000)        // 'Infinity'   e is 5\r\n     * new BigNumber(0.001)         // '0.01'       e is only -3\r\n     * new BigNumber(0.0001)        // '0'          e is -4\r\n     * ```\r\n     * The largest possible magnitude of a finite BigNumber is 9.999...e+1000000000.\r\n     * The smallest possible magnitude of a non-zero BigNumber is 1e-1000000000.\r\n     */\r\n    RANGE?: number | [number, number];\r\n\r\n    /**\r\n     * A boolean: `true` or `false`. Default value: `false`.\r\n     *\r\n     * The value that determines whether cryptographically-secure pseudo-random number generation is\r\n     * used. If `CRYPTO` is set to true then the random method will generate random digits using\r\n     * `crypto.getRandomValues` in browsers that support it, or `crypto.randomBytes` if using a\r\n     * version of Node.js that supports it.\r\n     *\r\n     * If neither function is supported by the host environment then attempting to set `CRYPTO` to\r\n     * `true` will fail and an exception will be thrown.\r\n     *\r\n     * If `CRYPTO` is `false` then the source of randomness used will be `Math.random` (which is\r\n     * assumed to generate at least 30 bits of randomness).\r\n     *\r\n     * See `BigNumber.random`.\r\n     *\r\n     * ```ts\r\n     * // Node.js\r\n     * global.crypto = require('crypto')\r\n     *\r\n     * BigNumber.config({ CRYPTO: true })\r\n     * BigNumber.config().CRYPTO       // true\r\n     * BigNumber.random()              // 0.54340758610486147524\r\n     * ```\r\n     */\r\n    CRYPTO?: boolean;\r\n\r\n    /**\r\n     * An integer, 0, 1, 3, 6 or 9. Default value: `BigNumber.ROUND_DOWN` (1).\r\n     *\r\n     * The modulo mode used when calculating the modulus: `a mod n`.\r\n     * The quotient, `q = a / n`, is calculated according to the `ROUNDING_MODE` that corresponds to\r\n     * the chosen `MODULO_MODE`.\r\n     * The remainder, `r`, is calculated as: `r = a - n * q`.\r\n     *\r\n     * The modes that are most commonly used for the modulus/remainder operation are shown in the\r\n     * following table. Although the other rounding modes can be used, they may not give useful\r\n     * results.\r\n     *\r\n     * Property           | Value | Description\r\n     * :------------------|:------|:------------------------------------------------------------------\r\n     *  `ROUND_UP`        |   0   | The remainder is positive if the dividend is negative.\r\n     *  `ROUND_DOWN`      |   1   | The remainder has the same sign as the dividend.\r\n     *                    |       | Uses 'truncating division' and matches JavaScript's `%` operator .\r\n     *  `ROUND_FLOOR`     |   3   | The remainder has the same sign as the divisor.\r\n     *                    |       | This matches Python's `%` operator.\r\n     *  `ROUND_HALF_EVEN` |   6   | The IEEE 754 remainder function.\r\n     *  `EUCLID`          |   9   | The remainder is always positive.\r\n     *                    |       | Euclidian division: `q = sign(n) * floor(a / abs(n))`\r\n     *\r\n     * The rounding/modulo modes are available as enumerated properties of the BigNumber constructor.\r\n     *\r\n     * See `modulo`.\r\n     *\r\n     * ```ts\r\n     * BigNumber.config({ MODULO_MODE: BigNumber.EUCLID })\r\n     * BigNumber.set({ MODULO_MODE: 9 })          // equivalent\r\n     * ```\r\n     */\r\n    MODULO_MODE?: BigNumber.ModuloMode;\r\n\r\n    /**\r\n     * An integer, 0 to 1e+9. Default value: 0.\r\n     *\r\n     * The maximum precision, i.e. number of significant digits, of the result of the power operation\r\n     * - unless a modulus is specified.\r\n     *\r\n     * If set to 0, the number of significant digits will not be limited.\r\n     *\r\n     * See `exponentiatedBy`.\r\n     *\r\n     * ```ts\r\n     * BigNumber.config({ POW_PRECISION: 100 })\r\n     * ```\r\n     */\r\n    POW_PRECISION?: number;\r\n\r\n    /**\r\n     * An object including any number of the properties shown below.\r\n     *\r\n     * The object configures the format of the string returned by the `toFormat` method.\r\n     * The example below shows the properties of the object that are recognised, and\r\n     * their default values.\r\n     *\r\n     * Unlike the other configuration properties, the values of the properties of the `FORMAT` object\r\n     * will not be checked for validity - the existing object will simply be replaced by the object\r\n     * that is passed in.\r\n     *\r\n     * See `toFormat`.\r\n     *\r\n     * ```ts\r\n     * BigNumber.config({\r\n     *   FORMAT: {\r\n     *     // string to prepend\r\n     *     prefix: '',\r\n     *     // the decimal separator\r\n     *     decimalSeparator: '.',\r\n     *     // the grouping separator of the integer part\r\n     *     groupSeparator: ',',\r\n     *     // the primary grouping size of the integer part\r\n     *     groupSize: 3,\r\n     *     // the secondary grouping size of the integer part\r\n     *     secondaryGroupSize: 0,\r\n     *     // the grouping separator of the fraction part\r\n     *     fractionGroupSeparator: ' ',\r\n     *     // the grouping size of the fraction part\r\n     *     fractionGroupSize: 0,\r\n     *     // string to append\r\n     *     suffix: ''\r\n     *   }\r\n     * })\r\n     * ```\r\n     */\r\n    FORMAT?: BigNumber.Format;\r\n\r\n    /**\r\n     * The alphabet used for base conversion. The length of the alphabet corresponds to the maximum\r\n     * value of the base argument that can be passed to the BigNumber constructor or `toString`.\r\n     *\r\n     * Default value: `'0123456789abcdefghijklmnopqrstuvwxyz'`.\r\n     *\r\n     * There is no maximum length for the alphabet, but it must be at least 2 characters long,\r\n     * and it must not contain whitespace or a repeated character, or the sign indicators '+' and\r\n     * '-', or the decimal separator '.'.\r\n     *\r\n     * ```ts\r\n     * // duodecimal (base 12)\r\n     * BigNumber.config({ ALPHABET: '0123456789TE' })\r\n     * x = new BigNumber('T', 12)\r\n     * x.toString()                // '10'\r\n     * x.toString(12)              // 'T'\r\n     * ```\r\n     */\r\n    ALPHABET?: string;\r\n  }\r\n\r\n  /** See `FORMAT` and `toFormat`. */\r\n  interface Format {\r\n\r\n    /** The string to prepend. */\r\n    prefix?: string;\r\n\r\n    /** The decimal separator. */\r\n    decimalSeparator?: string;\r\n\r\n    /** The grouping separator of the integer part. */\r\n    groupSeparator?: string;\r\n\r\n    /** The primary grouping size of the integer part. */\r\n    groupSize?: number;\r\n\r\n    /** The secondary grouping size of the integer part. */\r\n    secondaryGroupSize?: number;\r\n\r\n    /** The grouping separator of the fraction part. */\r\n    fractionGroupSeparator?: string;\r\n\r\n    /** The grouping size of the fraction part. */\r\n    fractionGroupSize?: number;\r\n\r\n    /** The string to append. */\r\n    suffix?: string;\r\n  }\r\n\r\n  interface Instance {\r\n\r\n    /** The coefficient of the value of this BigNumber, an array of base 1e14 integer numbers, or null. */\r\n    readonly c: number[] | null;\r\n\r\n    /** The exponent of the value of this BigNumber, an integer number, -1000000000 to 1000000000, or null. */\r\n    readonly e: number | null;\r\n\r\n    /** The sign of the value of this BigNumber, -1, 1, or null. */\r\n    readonly s: number | null;\r\n\r\n    [key: string]: any;\r\n  }\r\n\r\n  type Constructor = typeof BigNumber;\r\n  type ModuloMode = 0 | 1 | 3 | 6 | 9;\r\n  type RoundingMode = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\r\n  type Value = string | number | Instance;\r\n}\r\n\r\nexport declare class BigNumber implements BigNumber.Instance {\r\n\r\n  /** Used internally to identify a BigNumber instance. */\r\n  private readonly _isBigNumber: true;\r\n\r\n  /** The coefficient of the value of this BigNumber, an array of base 1e14 integer numbers, or null. */\r\n  readonly c: number[] | null;\r\n\r\n  /** The exponent of the value of this BigNumber, an integer number, -1000000000 to 1000000000, or null. */\r\n  readonly e: number | null;\r\n\r\n  /** The sign of the value of this BigNumber, -1, 1, or null. */\r\n  readonly s: number | null;\r\n\r\n  /**\r\n   * Returns a new instance of a BigNumber object with value `n`, where `n` is a numeric value in\r\n   * the specified `base`, or base 10 if `base` is omitted or is `null` or `undefined`.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(123.4567)              // '123.4567'\r\n   * // 'new' is optional\r\n   * y = BigNumber(x)                         // '123.4567'\r\n   * ```\r\n   *\r\n   * If `n` is a base 10 value it can be in normal (fixed-point) or exponential notation.\r\n   * Values in other bases must be in normal notation. Values in any base can have fraction digits,\r\n   * i.e. digits after the decimal point.\r\n   *\r\n   * ```ts\r\n   * new BigNumber(43210)                     // '43210'\r\n   * new BigNumber('4.321e+4')                // '43210'\r\n   * new BigNumber('-735.0918e-430')          // '-7.350918e-428'\r\n   * new BigNumber('123412421.234324', 5)     // '607236.557696'\r\n   * ```\r\n   *\r\n   * Signed `0`, signed `Infinity` and `NaN` are supported.\r\n   *\r\n   * ```ts\r\n   * new BigNumber('-Infinity')               // '-Infinity'\r\n   * new BigNumber(NaN)                       // 'NaN'\r\n   * new BigNumber(-0)                        // '0'\r\n   * new BigNumber('.5')                      // '0.5'\r\n   * new BigNumber('+2')                      // '2'\r\n   * ```\r\n   *\r\n   * String values in hexadecimal literal form, e.g. `'0xff'`, are valid, as are string values with\r\n   * the octal and binary prefixs `'0o'` and `'0b'`. String values in octal literal form without the\r\n   * prefix will be interpreted as decimals, e.g. `'011'` is interpreted as 11, not 9.\r\n   *\r\n   * ```ts\r\n   * new BigNumber(-10110100.1, 2)            // '-180.5'\r\n   * new BigNumber('-0b10110100.1')           // '-180.5'\r\n   * new BigNumber('ff.8', 16)                // '255.5'\r\n   * new BigNumber('0xff.8')                  // '255.5'\r\n   * ```\r\n   *\r\n   * If a base is specified, `n` is rounded according to the current `DECIMAL_PLACES` and\r\n   * `ROUNDING_MODE` settings. This includes base 10, so don't include a `base` parameter for decimal\r\n   * values unless this behaviour is desired.\r\n   *\r\n   * ```ts\r\n   * BigNumber.config({ DECIMAL_PLACES: 5 })\r\n   * new BigNumber(1.23456789)                // '1.23456789'\r\n   * new BigNumber(1.23456789, 10)            // '1.23457'\r\n   * ```\r\n   *\r\n   * An error is thrown if `base` is invalid.\r\n   *\r\n   * There is no limit to the number of digits of a value of type string (other than that of\r\n   * JavaScript's maximum array size). See `RANGE` to set the maximum and minimum possible exponent\r\n   * value of a BigNumber.\r\n   *\r\n   * ```ts\r\n   * new BigNumber('5032485723458348569331745.33434346346912144534543')\r\n   * new BigNumber('4.321e10000000')\r\n   * ```\r\n   *\r\n   * BigNumber `NaN` is returned if `n` is invalid (unless `BigNumber.DEBUG` is `true`, see below).\r\n   *\r\n   * ```ts\r\n   * new BigNumber('.1*')                    // 'NaN'\r\n   * new BigNumber('blurgh')                 // 'NaN'\r\n   * new BigNumber(9, 2)                     // 'NaN'\r\n   * ```\r\n   *\r\n   * To aid in debugging, if `BigNumber.DEBUG` is `true` then an error will be thrown on an\r\n   * invalid `n`. An error will also be thrown if `n` is of type number with more than 15\r\n   * significant digits, as calling `toString` or `valueOf` on these numbers may not result in the\r\n   * intended value.\r\n   *\r\n   * ```ts\r\n   * console.log(823456789123456.3)          //  823456789123456.2\r\n   * new BigNumber(823456789123456.3)        // '823456789123456.2'\r\n   * BigNumber.DEBUG = true\r\n   * // 'Error: Number has more than 15 significant digits'\r\n   * new BigNumber(823456789123456.3)\r\n   * // 'Error: Not a base 2 number'\r\n   * new BigNumber(9, 2)\r\n   * ```\r\n   *\r\n   * A BigNumber can also be created from an object literal.\r\n   * Use `isBigNumber` to check that it is well-formed.\r\n   *\r\n   * ```ts\r\n   * new BigNumber({ s: 1, e: 2, c: [ 777, 12300000000000 ], _isBigNumber: true })    // '777.123'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param base The base of `n`, integer, 2 to 36 (or `ALPHABET.length`, see `ALPHABET`).\r\n   */\r\n  constructor(n: BigNumber.Value, base?: number);\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the absolute value, i.e. the magnitude, of the value of this\r\n   * BigNumber.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(-0.8)\r\n   * x.absoluteValue()           // '0.8'\r\n   * ```\r\n   */\r\n  absoluteValue(): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the absolute value, i.e. the magnitude, of the value of this\r\n   * BigNumber.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(-0.8)\r\n   * x.abs()                     // '0.8'\r\n   * ```\r\n   */\r\n  abs(): BigNumber;\r\n\r\n  /**\r\n   *  Returns |                                                               |\r\n   * :-------:|:--------------------------------------------------------------|\r\n   *     1    | If the value of this BigNumber is greater than the value of `n`\r\n   *    -1    | If the value of this BigNumber is less than the value of `n`\r\n   *     0    | If this BigNumber and `n` have the same value\r\n   *  `null`  | If the value of either this BigNumber or `n` is `NaN`\r\n   *\r\n   * ```ts\r\n   *\r\n   * x = new BigNumber(Infinity)\r\n   * y = new BigNumber(5)\r\n   * x.comparedTo(y)                 // 1\r\n   * x.comparedTo(x.minus(1))        // 0\r\n   * y.comparedTo(NaN)               // null\r\n   * y.comparedTo('110', 2)          // -1\r\n   * ```\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  comparedTo(n: BigNumber.Value, base?: number): number;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber rounded by rounding mode\r\n   * `roundingMode` to a maximum of `decimalPlaces` decimal places.\r\n   *\r\n   * If `decimalPlaces` is omitted, or is `null` or `undefined`, the return value is the number of\r\n   * decimal places of the value of this BigNumber, or `null` if the value of this BigNumber is\r\n   * `Infinity` or `NaN`.\r\n   *\r\n   * If `roundingMode` is omitted, or is `null` or `undefined`, `ROUNDING_MODE` is used.\r\n   *\r\n   * Throws if `decimalPlaces` or `roundingMode` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(1234.56)\r\n   * x.decimalPlaces()                      // 2\r\n   * x.decimalPlaces(1)                     // '1234.6'\r\n   * x.decimalPlaces(2)                     // '1234.56'\r\n   * x.decimalPlaces(10)                    // '1234.56'\r\n   * x.decimalPlaces(0, 1)                  // '1234'\r\n   * x.decimalPlaces(0, 6)                  // '1235'\r\n   * x.decimalPlaces(1, 1)                  // '1234.5'\r\n   * x.decimalPlaces(1, BigNumber.ROUND_HALF_EVEN)     // '1234.6'\r\n   * x                                      // '1234.56'\r\n   * y = new BigNumber('9.9e-101')\r\n   * y.decimalPlaces()                      // 102\r\n   * ```\r\n   *\r\n   * @param [decimalPlaces] Decimal places, integer, 0 to 1e+9.\r\n   * @param [roundingMode] Rounding mode, integer, 0 to 8.\r\n   */\r\n  decimalPlaces(): number;\r\n  decimalPlaces(decimalPlaces: number, roundingMode?: BigNumber.RoundingMode): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber rounded by rounding mode\r\n   * `roundingMode` to a maximum of `decimalPlaces` decimal places.\r\n   *\r\n   * If `decimalPlaces` is omitted, or is `null` or `undefined`, the return value is the number of\r\n   * decimal places of the value of this BigNumber, or `null` if the value of this BigNumber is\r\n   * `Infinity` or `NaN`.\r\n   *\r\n   * If `roundingMode` is omitted, or is `null` or `undefined`, `ROUNDING_MODE` is used.\r\n   *\r\n   * Throws if `decimalPlaces` or `roundingMode` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(1234.56)\r\n   * x.dp()                                 // 2\r\n   * x.dp(1)                                // '1234.6'\r\n   * x.dp(2)                                // '1234.56'\r\n   * x.dp(10)                               // '1234.56'\r\n   * x.dp(0, 1)                             // '1234'\r\n   * x.dp(0, 6)                             // '1235'\r\n   * x.dp(1, 1)                             // '1234.5'\r\n   * x.dp(1, BigNumber.ROUND_HALF_EVEN)     // '1234.6'\r\n   * x                                      // '1234.56'\r\n   * y = new BigNumber('9.9e-101')\r\n   * y.dp()                                 // 102\r\n   * ```\r\n   *\r\n   * @param [decimalPlaces] Decimal places, integer, 0 to 1e+9.\r\n   * @param [roundingMode] Rounding mode, integer, 0 to 8.\r\n   */\r\n  dp(): number;\r\n  dp(decimalPlaces: number, roundingMode?: BigNumber.RoundingMode): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber divided by `n`, rounded\r\n   * according to the current `DECIMAL_PLACES` and `ROUNDING_MODE` settings.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(355)\r\n   * y = new BigNumber(113)\r\n   * x.dividedBy(y)                  // '3.14159292035398230088'\r\n   * x.dividedBy(5)                  // '71'\r\n   * x.dividedBy(47, 16)             // '5'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  dividedBy(n: BigNumber.Value, base?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber divided by `n`, rounded\r\n   * according to the current `DECIMAL_PLACES` and `ROUNDING_MODE` settings.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(355)\r\n   * y = new BigNumber(113)\r\n   * x.div(y)                    // '3.14159292035398230088'\r\n   * x.div(5)                    // '71'\r\n   * x.div(47, 16)               // '5'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  div(n: BigNumber.Value, base?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the integer part of dividing the value of this BigNumber by\r\n   * `n`.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(5)\r\n   * y = new BigNumber(3)\r\n   * x.dividedToIntegerBy(y)              // '1'\r\n   * x.dividedToIntegerBy(0.7)            // '7'\r\n   * x.dividedToIntegerBy('0.f', 16)      // '5'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  dividedToIntegerBy(n: BigNumber.Value, base?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the integer part of dividing the value of this BigNumber by\r\n   * `n`.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(5)\r\n   * y = new BigNumber(3)\r\n   * x.idiv(y)                       // '1'\r\n   * x.idiv(0.7)                     // '7'\r\n   * x.idiv('0.f', 16)               // '5'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  idiv(n: BigNumber.Value, base?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber exponentiated by `n`, i.e.\r\n   * raised to the power `n`, and optionally modulo a modulus `m`.\r\n   *\r\n   * If `n` is negative the result is rounded according to the current `DECIMAL_PLACES` and\r\n   * `ROUNDING_MODE` settings.\r\n   *\r\n   * As the number of digits of the result of the power operation can grow so large so quickly,\r\n   * e.g. 123.456**10000 has over 50000 digits, the number of significant digits calculated is\r\n   * limited to the value of the `POW_PRECISION` setting (unless a modulus `m` is specified).\r\n   *\r\n   * By default `POW_PRECISION` is set to 0. This means that an unlimited number of significant\r\n   * digits will be calculated, and that the method's performance will decrease dramatically for\r\n   * larger exponents.\r\n   *\r\n   * If `m` is specified and the value of `m`, `n` and this BigNumber are integers and `n` is\r\n   * positive, then a fast modular exponentiation algorithm is used, otherwise the operation will\r\n   * be performed as `x.exponentiatedBy(n).modulo(m)` with a `POW_PRECISION` of 0.\r\n   *\r\n   * Throws if `n` is not an integer.\r\n   *\r\n   * ```ts\r\n   * Math.pow(0.7, 2)                    // 0.48999999999999994\r\n   * x = new BigNumber(0.7)\r\n   * x.exponentiatedBy(2)                // '0.49'\r\n   * BigNumber(3).exponentiatedBy(-2)    // '0.11111111111111111111'\r\n   * ```\r\n   *\r\n   * @param n The exponent, an integer.\r\n   * @param [m] The modulus.\r\n   */\r\n  exponentiatedBy(n: BigNumber.Value, m?: BigNumber.Value): BigNumber;\r\n  exponentiatedBy(n: number, m?: BigNumber.Value): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber exponentiated by `n`, i.e.\r\n   * raised to the power `n`, and optionally modulo a modulus `m`.\r\n   *\r\n   * If `n` is negative the result is rounded according to the current `DECIMAL_PLACES` and\r\n   * `ROUNDING_MODE` settings.\r\n   *\r\n   * As the number of digits of the result of the power operation can grow so large so quickly,\r\n   * e.g. 123.456**10000 has over 50000 digits, the number of significant digits calculated is\r\n   * limited to the value of the `POW_PRECISION` setting (unless a modulus `m` is specified).\r\n   *\r\n   * By default `POW_PRECISION` is set to 0. This means that an unlimited number of significant\r\n   * digits will be calculated, and that the method's performance will decrease dramatically for\r\n   * larger exponents.\r\n   *\r\n   * If `m` is specified and the value of `m`, `n` and this BigNumber are integers and `n` is\r\n   * positive, then a fast modular exponentiation algorithm is used, otherwise the operation will\r\n   * be performed as `x.pow(n).modulo(m)` with a `POW_PRECISION` of 0.\r\n   *\r\n   * Throws if `n` is not an integer.\r\n   *\r\n   * ```ts\r\n   * Math.pow(0.7, 2)                   // 0.48999999999999994\r\n   * x = new BigNumber(0.7)\r\n   * x.pow(2)                           // '0.49'\r\n   * BigNumber(3).pow(-2)               // '0.11111111111111111111'\r\n   * ```\r\n   *\r\n   * @param n The exponent, an integer.\r\n   * @param [m] The modulus.\r\n   */\r\n  pow(n: BigNumber.Value, m?: BigNumber.Value): BigNumber;\r\n  pow(n: number, m?: BigNumber.Value): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber rounded to an integer using\r\n   * rounding mode `rm`.\r\n   *\r\n   * If `rm` is omitted, or is `null` or `undefined`, `ROUNDING_MODE` is used.\r\n   *\r\n   * Throws if `rm` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(123.456)\r\n   * x.integerValue()                        // '123'\r\n   * x.integerValue(BigNumber.ROUND_CEIL)    // '124'\r\n   * y = new BigNumber(-12.7)\r\n   * y.integerValue()                        // '-13'\r\n   * x.integerValue(BigNumber.ROUND_DOWN)    // '-12'\r\n   * ```\r\n   *\r\n   * @param {BigNumber.RoundingMode} [rm] The roundng mode, an integer, 0 to 8.\r\n   */\r\n  integerValue(rm?: BigNumber.RoundingMode): BigNumber;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is equal to the value of `n`, otherwise returns\r\n   * `false`.\r\n   *\r\n   * As with JavaScript, `NaN` does not equal `NaN`.\r\n   *\r\n   * ```ts\r\n   * 0 === 1e-324                           // true\r\n   * x = new BigNumber(0)\r\n   * x.isEqualTo('1e-324')                  // false\r\n   * BigNumber(-0).isEqualTo(x)             // true  ( -0 === 0 )\r\n   * BigNumber(255).isEqualTo('ff', 16)     // true\r\n   *\r\n   * y = new BigNumber(NaN)\r\n   * y.isEqualTo(NaN)                // false\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  isEqualTo(n: BigNumber.Value, base?: number): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is equal to the value of `n`, otherwise returns\r\n   * `false`.\r\n   *\r\n   * As with JavaScript, `NaN` does not equal `NaN`.\r\n   *\r\n   * ```ts\r\n   * 0 === 1e-324                    // true\r\n   * x = new BigNumber(0)\r\n   * x.eq('1e-324')                  // false\r\n   * BigNumber(-0).eq(x)             // true  ( -0 === 0 )\r\n   * BigNumber(255).eq('ff', 16)     // true\r\n   *\r\n   * y = new BigNumber(NaN)\r\n   * y.eq(NaN)                       // false\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  eq(n: BigNumber.Value, base?: number): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is a finite number, otherwise returns `false`.\r\n   *\r\n   * The only possible non-finite values of a BigNumber are `NaN`, `Infinity` and `-Infinity`.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(1)\r\n   * x.isFinite()                    // true\r\n   * y = new BigNumber(Infinity)\r\n   * y.isFinite()                    // false\r\n   * ```\r\n   */\r\n  isFinite(): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is greater than the value of `n`, otherwise\r\n   * returns `false`.\r\n   *\r\n   * ```ts\r\n   * 0.1 > (0.3 - 0.2)                             // true\r\n   * x = new BigNumber(0.1)\r\n   * x.isGreaterThan(BigNumber(0.3).minus(0.2))    // false\r\n   * BigNumber(0).isGreaterThan(x)                 // false\r\n   * BigNumber(11, 3).isGreaterThan(11.1, 2)       // true\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  isGreaterThan(n: BigNumber.Value, base?: number): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is greater than the value of `n`, otherwise\r\n   * returns `false`.\r\n   *\r\n   * ```ts\r\n   * 0.1 > (0.3 - 0                     // true\r\n   * x = new BigNumber(0.1)\r\n   * x.gt(BigNumber(0.3).minus(0.2))    // false\r\n   * BigNumber(0).gt(x)                 // false\r\n   * BigNumber(11, 3).gt(11.1, 2)       // true\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  gt(n: BigNumber.Value, base?: number): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is greater than or equal to the value of `n`,\r\n   * otherwise returns `false`.\r\n   *\r\n   * ```ts\r\n   * (0.3 - 0.2) >= 0.1                                  // false\r\n   * x = new BigNumber(0.3).minus(0.2)\r\n   * x.isGreaterThanOrEqualTo(0.1)                       // true\r\n   * BigNumber(1).isGreaterThanOrEqualTo(x)              // true\r\n   * BigNumber(10, 18).isGreaterThanOrEqualTo('i', 36)   // true\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  isGreaterThanOrEqualTo(n: BigNumber.Value, base?: number): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is greater than or equal to the value of `n`,\r\n   * otherwise returns `false`.\r\n   *\r\n   * ```ts\r\n   * (0.3 - 0.2) >= 0.1                    // false\r\n   * x = new BigNumber(0.3).minus(0.2)\r\n   * x.gte(0.1)                            // true\r\n   * BigNumber(1).gte(x)                   // true\r\n   * BigNumber(10, 18).gte('i', 36)        // true\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  gte(n: BigNumber.Value, base?: number): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is an integer, otherwise returns `false`.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(1)\r\n   * x.isInteger()                   // true\r\n   * y = new BigNumber(123.456)\r\n   * y.isInteger()                   // false\r\n   * ```\r\n   */\r\n  isInteger(): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is less than the value of `n`, otherwise returns\r\n   * `false`.\r\n   *\r\n   * ```ts\r\n   * (0.3 - 0.2) < 0.1                       // true\r\n   * x = new BigNumber(0.3).minus(0.2)\r\n   * x.isLessThan(0.1)                       // false\r\n   * BigNumber(0).isLessThan(x)              // true\r\n   * BigNumber(11.1, 2).isLessThan(11, 3)    // true\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  isLessThan(n: BigNumber.Value, base?: number): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is less than the value of `n`, otherwise returns\r\n   * `false`.\r\n   *\r\n   * ```ts\r\n   * (0.3 - 0.2) < 0.1                       // true\r\n   * x = new BigNumber(0.3).minus(0.2)\r\n   * x.lt(0.1)                               // false\r\n   * BigNumber(0).lt(x)                      // true\r\n   * BigNumber(11.1, 2).lt(11, 3)            // true\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  lt(n: BigNumber.Value, base?: number): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is less than or equal to the value of `n`,\r\n   * otherwise returns `false`.\r\n   *\r\n   * ```ts\r\n   * 0.1 <= (0.3 - 0.2)                                 // false\r\n   * x = new BigNumber(0.1)\r\n   * x.isLessThanOrEqualTo(BigNumber(0.3).minus(0.2))   // true\r\n   * BigNumber(-1).isLessThanOrEqualTo(x)               // true\r\n   * BigNumber(10, 18).isLessThanOrEqualTo('i', 36)     // true\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  isLessThanOrEqualTo(n: BigNumber.Value, base?: number): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is less than or equal to the value of `n`,\r\n   * otherwise returns `false`.\r\n   *\r\n   * ```ts\r\n   * 0.1 <= (0.3 - 0.2)                  // false\r\n   * x = new BigNumber(0.1)\r\n   * x.lte(BigNumber(0.3).minus(0.2))    // true\r\n   * BigNumber(-1).lte(x)                // true\r\n   * BigNumber(10, 18).lte('i', 36)      // true\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  lte(n: BigNumber.Value, base?: number): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is `NaN`, otherwise returns `false`.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(NaN)\r\n   * x.isNaN()                       // true\r\n   * y = new BigNumber('Infinity')\r\n   * y.isNaN()                       // false\r\n   * ```\r\n   */\r\n  isNaN(): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is negative, otherwise returns `false`.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(-0)\r\n   * x.isNegative()                  // true\r\n   * y = new BigNumber(2)\r\n   * y.isNegative()                  // false\r\n   * ```\r\n   */\r\n  isNegative(): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is positive, otherwise returns `false`.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(-0)\r\n   * x.isPositive()                  // false\r\n   * y = new BigNumber(2)\r\n   * y.isPositive()                  // true\r\n   * ```\r\n   */\r\n  isPositive(): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is zero or minus zero, otherwise returns `false`.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(-0)\r\n   * x.isZero()                 // true\r\n   * ```\r\n   */\r\n  isZero(): boolean;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber minus `n`.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * 0.3 - 0.1                       // 0.19999999999999998\r\n   * x = new BigNumber(0.3)\r\n   * x.minus(0.1)                    // '0.2'\r\n   * x.minus(0.6, 20)                // '0'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  minus(n: BigNumber.Value, base?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber modulo `n`, i.e. the integer\r\n   * remainder of dividing this BigNumber by `n`.\r\n   *\r\n   * The value returned, and in particular its sign, is dependent on the value of the `MODULO_MODE`\r\n   * setting of this BigNumber constructor. If it is 1 (default value), the result will have the\r\n   * same sign as this BigNumber, and it will match that of Javascript's `%` operator (within the\r\n   * limits of double precision) and BigDecimal's `remainder` method.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * See `MODULO_MODE` for a description of the other modulo modes.\r\n   *\r\n   * ```ts\r\n   * 1 % 0.9                         // 0.09999999999999998\r\n   * x = new BigNumber(1)\r\n   * x.modulo(0.9)                   // '0.1'\r\n   * y = new BigNumber(33)\r\n   * y.modulo('a', 33)               // '3'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  modulo(n: BigNumber.Value, base?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber modulo `n`, i.e. the integer\r\n   * remainder of dividing this BigNumber by `n`.\r\n   *\r\n   * The value returned, and in particular its sign, is dependent on the value of the `MODULO_MODE`\r\n   * setting of this BigNumber constructor. If it is 1 (default value), the result will have the\r\n   * same sign as this BigNumber, and it will match that of Javascript's `%` operator (within the\r\n   * limits of double precision) and BigDecimal's `remainder` method.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * See `MODULO_MODE` for a description of the other modulo modes.\r\n   *\r\n   * ```ts\r\n   * 1 % 0.9                      // 0.09999999999999998\r\n   * x = new BigNumber(1)\r\n   * x.mod(0.9)                   // '0.1'\r\n   * y = new BigNumber(33)\r\n   * y.mod('a', 33)               // '3'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  mod(n: BigNumber.Value, base?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber multiplied by `n`.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * 0.6 * 3                                // 1.7999999999999998\r\n   * x = new BigNumber(0.6)\r\n   * y = x.multipliedBy(3)                  // '1.8'\r\n   * BigNumber('7e+500').multipliedBy(y)    // '1.26e+501'\r\n   * x.multipliedBy('-a', 16)               // '-6'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  multipliedBy(n: BigNumber.Value, base?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber multiplied by `n`.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * 0.6 * 3                         // 1.7999999999999998\r\n   * x = new BigNumber(0.6)\r\n   * y = x.times(3)                  // '1.8'\r\n   * BigNumber('7e+500').times(y)    // '1.26e+501'\r\n   * x.times('-a', 16)               // '-6'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  times(n: BigNumber.Value, base?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber negated, i.e. multiplied by -1.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(1.8)\r\n   * x.negated()                     // '-1.8'\r\n   * y = new BigNumber(-1.3)\r\n   * y.negated()                     // '1.3'\r\n   * ```\r\n   */\r\n  negated(): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber plus `n`.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * 0.1 + 0.2                       // 0.30000000000000004\r\n   * x = new BigNumber(0.1)\r\n   * y = x.plus(0.2)                 // '0.3'\r\n   * BigNumber(0.7).plus(x).plus(y)  // '1.1'\r\n   * x.plus('0.1', 8)                // '0.225'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  plus(n: BigNumber.Value, base?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns the number of significant digits of the value of this BigNumber, or `null` if the value\r\n   * of this BigNumber is `Infinity` or `NaN`.\r\n   *\r\n   * If `includeZeros` is true then any trailing zeros of the integer part of the value of this\r\n   * BigNumber are counted as significant digits, otherwise they are not.\r\n   *\r\n   * Throws if `includeZeros` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(9876.54321)\r\n   * x.precision()                         // 9\r\n   * y = new BigNumber(987000)\r\n   * y.precision(false)                    // 3\r\n   * y.precision(true)                     // 6\r\n   * ```\r\n   *\r\n   * @param [includeZeros] Whether to include integer trailing zeros in the significant digit count.\r\n   */\r\n  precision(includeZeros?: boolean): number;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber rounded to a precision of\r\n   * `significantDigits` significant digits using rounding mode `roundingMode`.\r\n   *\r\n   * If `roundingMode` is omitted or is `null` or `undefined`, `ROUNDING_MODE` will be used.\r\n   *\r\n   * Throws if `significantDigits` or `roundingMode` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(9876.54321)\r\n   * x.precision(6)                         // '9876.54'\r\n   * x.precision(6, BigNumber.ROUND_UP)     // '9876.55'\r\n   * x.precision(2)                         // '9900'\r\n   * x.precision(2, 1)                      // '9800'\r\n   * x                                      // '9876.54321'\r\n   * ```\r\n   *\r\n   * @param significantDigits Significant digits, integer, 1 to 1e+9.\r\n   * @param [roundingMode] Rounding mode, integer, 0 to 8.\r\n   */\r\n  precision(significantDigits: number, roundingMode?: BigNumber.RoundingMode): BigNumber;\r\n\r\n  /**\r\n   * Returns the number of significant digits of the value of this BigNumber,\r\n   * or `null` if the value of this BigNumber is `Infinity` or `NaN`.\r\n   *\r\n   * If `includeZeros` is true then any trailing zeros of the integer part of\r\n   * the value of this BigNumber are counted as significant digits, otherwise\r\n   * they are not.\r\n   *\r\n   * Throws if `includeZeros` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(9876.54321)\r\n   * x.sd()                         // 9\r\n   * y = new BigNumber(987000)\r\n   * y.sd(false)                    // 3\r\n   * y.sd(true)                     // 6\r\n   * ```\r\n   *\r\n   * @param [includeZeros] Whether to include integer trailing zeros in the significant digit count.\r\n   */\r\n  sd(includeZeros?: boolean): number;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber rounded to a precision of\r\n   * `significantDigits` significant digits using rounding mode `roundingMode`.\r\n   *\r\n   * If `roundingMode` is omitted or is `null` or `undefined`, `ROUNDING_MODE` will be used.\r\n   *\r\n   * Throws if `significantDigits` or `roundingMode` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(9876.54321)\r\n   * x.sd(6)                           // '9876.54'\r\n   * x.sd(6, BigNumber.ROUND_UP)       // '9876.55'\r\n   * x.sd(2)                           // '9900'\r\n   * x.sd(2, 1)                        // '9800'\r\n   * x                                 // '9876.54321'\r\n   * ```\r\n   *\r\n   * @param significantDigits Significant digits, integer, 1 to 1e+9.\r\n   * @param [roundingMode] Rounding mode, integer, 0 to 8.\r\n   */\r\n  sd(significantDigits: number, roundingMode?: BigNumber.RoundingMode): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber shifted by `n` places.\r\n   *\r\n   * The shift is of the decimal point, i.e. of powers of ten, and is to the left if `n` is negative\r\n   * or to the right if `n` is positive.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * Throws if `n` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(1.23)\r\n   * x.shiftedBy(3)                      // '1230'\r\n   * x.shiftedBy(-3)                     // '0.00123'\r\n   * ```\r\n   *\r\n   * @param n The shift value, integer, -9007199254740991 to 9007199254740991.\r\n   */\r\n  shiftedBy(n: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the square root of the value of this BigNumber, rounded\r\n   * according to the current `DECIMAL_PLACES` and `ROUNDING_MODE` settings.\r\n   *\r\n   * The return value will be correctly rounded, i.e. rounded as if the result was first calculated\r\n   * to an infinite number of correct digits before rounding.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(16)\r\n   * x.squareRoot()                  // '4'\r\n   * y = new BigNumber(3)\r\n   * y.squareRoot()                  // '1.73205080756887729353'\r\n   * ```\r\n   */\r\n  squareRoot(): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the square root of the value of this BigNumber, rounded\r\n   * according to the current `DECIMAL_PLACES` and `ROUNDING_MODE` settings.\r\n   *\r\n   * The return value will be correctly rounded, i.e. rounded as if the result was first calculated\r\n   * to an infinite number of correct digits before rounding.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(16)\r\n   * x.sqrt()                  // '4'\r\n   * y = new BigNumber(3)\r\n   * y.sqrt()                  // '1.73205080756887729353'\r\n   * ```\r\n   */\r\n  sqrt(): BigNumber;\r\n\r\n  /**\r\n   * Returns a string representing the value of this BigNumber in exponential notation rounded using\r\n   * rounding mode `roundingMode` to `decimalPlaces` decimal places, i.e with one digit before the\r\n   * decimal point and `decimalPlaces` digits after it.\r\n   *\r\n   * If the value of this BigNumber in exponential notation has fewer than `decimalPlaces` fraction\r\n   * digits, the return value will be appended with zeros accordingly.\r\n   *\r\n   * If `decimalPlaces` is omitted, or is `null` or `undefined`, the number of digits after the\r\n   * decimal point defaults to the minimum number of digits necessary to represent the value\r\n   * exactly.\r\n   *\r\n   * If `roundingMode` is omitted or is `null` or `undefined`, `ROUNDING_MODE` is used.\r\n   *\r\n   * Throws if `decimalPlaces` or `roundingMode` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = 45.6\r\n   * y = new BigNumber(x)\r\n   * x.toExponential()               // '4.56e+1'\r\n   * y.toExponential()               // '4.56e+1'\r\n   * x.toExponential(0)              // '5e+1'\r\n   * y.toExponential(0)              // '5e+1'\r\n   * x.toExponential(1)              // '4.6e+1'\r\n   * y.toExponential(1)              // '4.6e+1'\r\n   * y.toExponential(1, 1)           // '4.5e+1'  (ROUND_DOWN)\r\n   * x.toExponential(3)              // '4.560e+1'\r\n   * y.toExponential(3)              // '4.560e+1'\r\n   * ```\r\n   *\r\n   * @param [decimalPlaces] Decimal places, integer, 0 to 1e+9.\r\n   * @param [roundingMode] Rounding mode, integer, 0 to 8.\r\n   */\r\n  toExponential(decimalPlaces: number, roundingMode?: BigNumber.RoundingMode): string;\r\n  toExponential(): string;\r\n\r\n  /**\r\n   * Returns a string representing the value of this BigNumber in normal (fixed-point) notation\r\n   * rounded to `decimalPlaces` decimal places using rounding mode `roundingMode`.\r\n   *\r\n   * If the value of this BigNumber in normal notation has fewer than `decimalPlaces` fraction\r\n   * digits, the return value will be appended with zeros accordingly.\r\n   *\r\n   * Unlike `Number.prototype.toFixed`, which returns exponential notation if a number is greater or\r\n   * equal to 10**21, this method will always return normal notation.\r\n   *\r\n   * If `decimalPlaces` is omitted or is `null` or `undefined`, the return value will be unrounded\r\n   * and in normal notation. This is also unlike `Number.prototype.toFixed`, which returns the value\r\n   * to zero decimal places. It is useful when normal notation is required and the current\r\n   * `EXPONENTIAL_AT` setting causes `toString` to return exponential notation.\r\n   *\r\n   * If `roundingMode` is omitted or is `null` or `undefined`, `ROUNDING_MODE` is used.\r\n   *\r\n   * Throws if `decimalPlaces` or `roundingMode` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = 3.456\r\n   * y = new BigNumber(x)\r\n   * x.toFixed()                     // '3'\r\n   * y.toFixed()                     // '3.456'\r\n   * y.toFixed(0)                    // '3'\r\n   * x.toFixed(2)                    // '3.46'\r\n   * y.toFixed(2)                    // '3.46'\r\n   * y.toFixed(2, 1)                 // '3.45'  (ROUND_DOWN)\r\n   * x.toFixed(5)                    // '3.45600'\r\n   * y.toFixed(5)                    // '3.45600'\r\n   * ```\r\n   *\r\n   * @param [decimalPlaces] Decimal places, integer, 0 to 1e+9.\r\n   * @param [roundingMode] Rounding mode, integer, 0 to 8.\r\n   */\r\n  toFixed(decimalPlaces: number, roundingMode?: BigNumber.RoundingMode): string;\r\n  toFixed(): string;\r\n\r\n  /**\r\n   * Returns a string representing the value of this BigNumber in normal (fixed-point) notation\r\n   * rounded to `decimalPlaces` decimal places using rounding mode `roundingMode`, and formatted\r\n   * according to the properties of the `format` or `FORMAT` object.\r\n   *\r\n   * The formatting object may contain some or all of the properties shown in the examples below.\r\n   *\r\n   * If `decimalPlaces` is omitted or is `null` or `undefined`, then the return value is not\r\n   * rounded to a fixed number of decimal places.\r\n   *\r\n   * If `roundingMode` is omitted or is `null` or `undefined`, `ROUNDING_MODE` is used.\r\n   *\r\n   * If `format` is omitted or is `null` or `undefined`, `FORMAT` is used.\r\n   *\r\n   * Throws if `decimalPlaces`, `roundingMode`, or `format` is invalid.\r\n   *\r\n   * ```ts\r\n   * fmt = {\r\n   *   decimalSeparator: '.',\r\n   *   groupSeparator: ',',\r\n   *   groupSize: 3,\r\n   *   secondaryGroupSize: 0,\r\n   *   fractionGroupSeparator: ' ',\r\n   *   fractionGroupSize: 0\r\n   * }\r\n   *\r\n   * x = new BigNumber('123456789.123456789')\r\n   *\r\n   * // Set the global formatting options\r\n   * BigNumber.config({ FORMAT: fmt })\r\n   *\r\n   * x.toFormat()                              // '123,456,789.123456789'\r\n   * x.toFormat(3)                             // '123,456,789.123'\r\n   *\r\n   * // If a reference to the object assigned to FORMAT has been retained,\r\n   * // the format properties can be changed directly\r\n   * fmt.groupSeparator = ' '\r\n   * fmt.fractionGroupSize = 5\r\n   * x.toFormat()                              // '123 456 789.12345 6789'\r\n   *\r\n   * // Alternatively, pass the formatting options as an argument\r\n   * fmt = {\r\n   *   decimalSeparator: ',',\r\n   *   groupSeparator: '.',\r\n   *   groupSize: 3,\r\n   *   secondaryGroupSize: 2\r\n   * }\r\n   *\r\n   * x.toFormat()                              // '123 456 789.12345 6789'\r\n   * x.toFormat(fmt)                           // '12.34.56.789,123456789'\r\n   * x.toFormat(2, fmt)                        // '12.34.56.789,12'\r\n   * x.toFormat(3, BigNumber.ROUND_UP, fmt)    // '12.34.56.789,124'\r\n   * ```\r\n   *\r\n   * @param [decimalPlaces] Decimal places, integer, 0 to 1e+9.\r\n   * @param [roundingMode] Rounding mode, integer, 0 to 8.\r\n   * @param [format] Formatting options object. See `BigNumber.Format`.\r\n   */\r\n  toFormat(decimalPlaces: number, roundingMode: BigNumber.RoundingMode, format?: BigNumber.Format): string;\r\n  toFormat(decimalPlaces: number, roundingMode?: BigNumber.RoundingMode): string;\r\n  toFormat(decimalPlaces?: number): string;\r\n  toFormat(decimalPlaces: number, format: BigNumber.Format): string;\r\n  toFormat(format: BigNumber.Format): string;\r\n\r\n  /**\r\n   * Returns an array of two BigNumbers representing the value of this BigNumber as a simple\r\n   * fraction with an integer numerator and an integer denominator.\r\n   * The denominator will be a positive non-zero value less than or equal to `max_denominator`.\r\n   * If a maximum denominator, `max_denominator`, is not specified, or is `null` or `undefined`, the\r\n   * denominator will be the lowest value necessary to represent the number exactly.\r\n   *\r\n   * Throws if `max_denominator` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(1.75)\r\n   * x.toFraction()                  // '7, 4'\r\n   *\r\n   * pi = new BigNumber('3.14159265358')\r\n   * pi.toFraction()                 // '157079632679,50000000000'\r\n   * pi.toFraction(100000)           // '312689, 99532'\r\n   * pi.toFraction(10000)            // '355, 113'\r\n   * pi.toFraction(100)              // '311, 99'\r\n   * pi.toFraction(10)               // '22, 7'\r\n   * pi.toFraction(1)                // '3, 1'\r\n   * ```\r\n   *\r\n   * @param [max_denominator] The maximum denominator, integer > 0, or Infinity.\r\n   */\r\n  toFraction(max_denominator?: BigNumber.Value): [BigNumber, BigNumber];\r\n\r\n  /** As `valueOf`. */\r\n  toJSON(): string;\r\n\r\n  /**\r\n   * Returns the value of this BigNumber as a JavaScript primitive number.\r\n   *\r\n   * Using the unary plus operator gives the same result.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(456.789)\r\n   * x.toNumber()                    // 456.789\r\n   * +x                              // 456.789\r\n   *\r\n   * y = new BigNumber('45987349857634085409857349856430985')\r\n   * y.toNumber()                    // 4.598734985763409e+34\r\n   *\r\n   * z = new BigNumber(-0)\r\n   * 1 / z.toNumber()                // -Infinity\r\n   * 1 / +z                          // -Infinity\r\n   * ```\r\n   */\r\n  toNumber(): number;\r\n\r\n  /**\r\n   * Returns a string representing the value of this BigNumber rounded to `significantDigits`\r\n   * significant digits using rounding mode `roundingMode`.\r\n   *\r\n   * If `significantDigits` is less than the number of digits necessary to represent the integer\r\n   * part of the value in normal (fixed-point) notation, then exponential notation is used.\r\n   *\r\n   * If `significantDigits` is omitted, or is `null` or `undefined`, then the return value is the\r\n   * same as `n.toString()`.\r\n   *\r\n   * If `roundingMode` is omitted or is `null` or `undefined`, `ROUNDING_MODE` is used.\r\n   *\r\n   * Throws if `significantDigits` or `roundingMode` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = 45.6\r\n   * y = new BigNumber(x)\r\n   * x.toPrecision()                 // '45.6'\r\n   * y.toPrecision()                 // '45.6'\r\n   * x.toPrecision(1)                // '5e+1'\r\n   * y.toPrecision(1)                // '5e+1'\r\n   * y.toPrecision(2, 0)             // '4.6e+1'  (ROUND_UP)\r\n   * y.toPrecision(2, 1)             // '4.5e+1'  (ROUND_DOWN)\r\n   * x.toPrecision(5)                // '45.600'\r\n   * y.toPrecision(5)                // '45.600'\r\n   * ```\r\n   *\r\n   * @param [significantDigits] Significant digits, integer, 1 to 1e+9.\r\n   * @param [roundingMode] Rounding mode, integer 0 to 8.\r\n   */\r\n  toPrecision(significantDigits: number, roundingMode?: BigNumber.RoundingMode): string;\r\n  toPrecision(): string;\r\n\r\n  /**\r\n   * Returns a string representing the value of this BigNumber in base `base`, or base 10 if `base`\r\n   * is omitted or is `null` or `undefined`.\r\n   *\r\n   * For bases above 10, and using the default base conversion alphabet (see `ALPHABET`), values\r\n   * from 10 to 35 are represented by a-z (the same as `Number.prototype.toString`).\r\n   *\r\n   * If a base is specified the value is rounded according to the current `DECIMAL_PLACES` and\r\n   * `ROUNDING_MODE` settings, otherwise it is not.\r\n   *\r\n   * If a base is not specified, and this BigNumber has a positive exponent that is equal to or\r\n   * greater than the positive component of the current `EXPONENTIAL_AT` setting, or a negative\r\n   * exponent equal to or less than the negative component of the setting, then exponential notation\r\n   * is returned.\r\n   *\r\n   * If `base` is `null` or `undefined` it is ignored.\r\n   *\r\n   * Throws if `base` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(750000)\r\n   * x.toString()                    // '750000'\r\n   * BigNumber.config({ EXPONENTIAL_AT: 5 })\r\n   * x.toString()                    // '7.5e+5'\r\n   *\r\n   * y = new BigNumber(362.875)\r\n   * y.toString(2)                   // '101101010.111'\r\n   * y.toString(9)                   // '442.77777777777777777778'\r\n   * y.toString(32)                  // 'ba.s'\r\n   *\r\n   * BigNumber.config({ DECIMAL_PLACES: 4 });\r\n   * z = new BigNumber('1.23456789')\r\n   * z.toString()                    // '1.23456789'\r\n   * z.toString(10)                  // '1.2346'\r\n   * ```\r\n   *\r\n   * @param [base] The base, integer, 2 to 36 (or `ALPHABET.length`, see `ALPHABET`).\r\n   */\r\n  toString(base?: number): string;\r\n\r\n  /**\r\n   * As `toString`, but does not accept a base argument and includes the minus sign for negative\r\n   * zero.\r\n   *\r\n   * ``ts\r\n   * x = new BigNumber('-0')\r\n   * x.toString()                    // '0'\r\n   * x.valueOf()                     // '-0'\r\n   * y = new BigNumber('1.777e+457')\r\n   * y.valueOf()                     // '1.777e+457'\r\n   * ```\r\n   */\r\n  valueOf(): string;\r\n\r\n  /** Helps ES6 import. */\r\n  private static readonly default?: BigNumber.Constructor;\r\n\r\n  /** Helps ES6 import. */\r\n  private static readonly BigNumber?: BigNumber.Constructor;\r\n\r\n  /** Rounds away from zero. */\r\n  static readonly ROUND_UP: 0;\r\n\r\n  /** Rounds towards zero. */\r\n  static readonly ROUND_DOWN: 1;\r\n\r\n  /** Rounds towards Infinity. */\r\n  static readonly ROUND_CEIL: 2;\r\n\r\n  /** Rounds towards -Infinity. */\r\n  static readonly ROUND_FLOOR: 3;\r\n\r\n  /** Rounds towards nearest neighbour. If equidistant, rounds away from zero . */\r\n  static readonly ROUND_HALF_UP: 4;\r\n\r\n  /** Rounds towards nearest neighbour. If equidistant, rounds towards zero. */\r\n  static readonly ROUND_HALF_DOWN: 5;\r\n\r\n  /** Rounds towards nearest neighbour. If equidistant, rounds towards even neighbour. */\r\n  static readonly ROUND_HALF_EVEN: 6;\r\n\r\n  /** Rounds towards nearest neighbour. If equidistant, rounds towards Infinity. */\r\n  static readonly ROUND_HALF_CEIL: 7;\r\n\r\n  /** Rounds towards nearest neighbour. If equidistant, rounds towards -Infinity. */\r\n  static readonly ROUND_HALF_FLOOR: 8;\r\n\r\n  /** See `MODULO_MODE`. */\r\n  static readonly EUCLID: 9;\r\n\r\n  /**\r\n   * To aid in debugging, if a `BigNumber.DEBUG` property is `true` then an error will be thrown\r\n   * if the BigNumber constructor receives an invalid `BigNumber.Value`, or if `BigNumber.isBigNumber`\r\n   * receives a BigNumber instance that is malformed.\r\n   *\r\n   * ```ts\r\n   * // No error, and BigNumber NaN is returned.\r\n   * new BigNumber('blurgh')    // 'NaN'\r\n   * new BigNumber(9, 2)        // 'NaN'\r\n   * BigNumber.DEBUG = true\r\n   * new BigNumber('blurgh')    // '[BigNumber Error] Not a number'\r\n   * new BigNumber(9, 2)        // '[BigNumber Error] Not a base 2 number'\r\n   * ```\r\n   *\r\n   * An error will also be thrown if a `BigNumber.Value` is of type number with more than 15\r\n   * significant digits, as calling `toString` or `valueOf` on such numbers may not result\r\n   * in the intended value.\r\n   *\r\n   * ```ts\r\n   * console.log(823456789123456.3)       //  823456789123456.2\r\n   * // No error, and the returned BigNumber does not have the same value as the number literal.\r\n   * new BigNumber(823456789123456.3)     // '823456789123456.2'\r\n   * BigNumber.DEBUG = true\r\n   * new BigNumber(823456789123456.3)\r\n   * // '[BigNumber Error] Number primitive has more than 15 significant digits'\r\n   * ```\r\n   *\r\n   * Check that a BigNumber instance is well-formed:\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(10)\r\n   *\r\n   * BigNumber.DEBUG = false\r\n   * // Change x.c to an illegitimate value.\r\n   * x.c = NaN\r\n   * // No error, as BigNumber.DEBUG is false.\r\n   * BigNumber.isBigNumber(x)    // true\r\n   *\r\n   * BigNumber.DEBUG = true\r\n   * BigNumber.isBigNumber(x)    // '[BigNumber Error] Invalid BigNumber'\r\n   * ```\r\n   */\r\n  static DEBUG?: boolean;\r\n\r\n  /**\r\n   * Returns a new independent BigNumber constructor with configuration as described by `object`, or\r\n   * with the default configuration if object is `null` or `undefined`.\r\n   *\r\n   * Throws if `object` is not an object.\r\n   *\r\n   * ```ts\r\n   * BigNumber.config({ DECIMAL_PLACES: 5 })\r\n   * BN = BigNumber.clone({ DECIMAL_PLACES: 9 })\r\n   *\r\n   * x = new BigNumber(1)\r\n   * y = new BN(1)\r\n   *\r\n   * x.div(3)                        // 0.33333\r\n   * y.div(3)                        // 0.333333333\r\n   *\r\n   * // BN = BigNumber.clone({ DECIMAL_PLACES: 9 }) is equivalent to:\r\n   * BN = BigNumber.clone()\r\n   * BN.config({ DECIMAL_PLACES: 9 })\r\n   * ```\r\n   *\r\n   * @param [object] The configuration object.\r\n   */\r\n  static clone(object?: BigNumber.Config): BigNumber.Constructor;\r\n\r\n  /**\r\n   * Configures the settings that apply to this BigNumber constructor.\r\n   *\r\n   * The configuration object, `object`, contains any number of the properties shown in the example\r\n   * below.\r\n   *\r\n   * Returns an object with the above properties and their current values.\r\n   *\r\n   * Throws if `object` is not an object, or if an invalid value is assigned to one or more of the\r\n   * properties.\r\n   *\r\n   * ```ts\r\n   * BigNumber.config({\r\n   *     DECIMAL_PLACES: 40,\r\n   *     ROUNDING_MODE: BigNumber.ROUND_HALF_CEIL,\r\n   *     EXPONENTIAL_AT: [-10, 20],\r\n   *     RANGE: [-500, 500],\r\n   *     CRYPTO: true,\r\n   *     MODULO_MODE: BigNumber.ROUND_FLOOR,\r\n   *     POW_PRECISION: 80,\r\n   *     FORMAT: {\r\n   *         groupSize: 3,\r\n   *         groupSeparator: ' ',\r\n   *         decimalSeparator: ','\r\n   *     },\r\n   *     ALPHABET: '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'\r\n   * });\r\n   *\r\n   * BigNumber.config().DECIMAL_PLACES        // 40\r\n   * ```\r\n   *\r\n   * @param object The configuration object.\r\n   */\r\n  static config(object: BigNumber.Config): BigNumber.Config;\r\n\r\n  /**\r\n   * Returns `true` if `value` is a BigNumber instance, otherwise returns `false`.\r\n   *\r\n   * If `BigNumber.DEBUG` is `true`, throws if a BigNumber instance is not well-formed.\r\n   *\r\n   * ```ts\r\n   * x = 42\r\n   * y = new BigNumber(x)\r\n   *\r\n   * BigNumber.isBigNumber(x)             // false\r\n   * y instanceof BigNumber               // true\r\n   * BigNumber.isBigNumber(y)             // true\r\n   *\r\n   * BN = BigNumber.clone();\r\n   * z = new BN(x)\r\n   * z instanceof BigNumber               // false\r\n   * BigNumber.isBigNumber(z)             // true\r\n   * ```\r\n   *\r\n   * @param value The value to test.\r\n   */\r\n  static isBigNumber(value: any): value is BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the maximum of the arguments.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber('3257869345.0378653')\r\n   * BigNumber.maximum(4e9, x, '123456789.9')      // '4000000000'\r\n   *\r\n   * arr = [12, '13', new BigNumber(14)]\r\n   * BigNumber.maximum.apply(null, arr)            // '14'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   */\r\n  static maximum(...n: BigNumber.Value[]): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the maximum of the arguments.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber('3257869345.0378653')\r\n   * BigNumber.max(4e9, x, '123456789.9')      // '4000000000'\r\n   *\r\n   * arr = [12, '13', new BigNumber(14)]\r\n   * BigNumber.max.apply(null, arr)            // '14'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   */\r\n  static max(...n: BigNumber.Value[]): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the minimum of the arguments.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber('3257869345.0378653')\r\n   * BigNumber.minimum(4e9, x, '123456789.9')          // '123456789.9'\r\n   *\r\n   * arr = [2, new BigNumber(-14), '-15.9999', -12]\r\n   * BigNumber.minimum.apply(null, arr)                // '-15.9999'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   */\r\n  static minimum(...n: BigNumber.Value[]): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the minimum of the arguments.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber('3257869345.0378653')\r\n   * BigNumber.min(4e9, x, '123456789.9')             // '123456789.9'\r\n   *\r\n   * arr = [2, new BigNumber(-14), '-15.9999', -12]\r\n   * BigNumber.min.apply(null, arr)                   // '-15.9999'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   */\r\n  static min(...n: BigNumber.Value[]): BigNumber;\r\n\r\n  /**\r\n   * Returns a new BigNumber with a pseudo-random value equal to or greater than 0 and less than 1.\r\n   *\r\n   * The return value will have `decimalPlaces` decimal places, or less if trailing zeros are\r\n   * produced. If `decimalPlaces` is omitted, the current `DECIMAL_PLACES` setting will be used.\r\n   *\r\n   * Depending on the value of this BigNumber constructor's `CRYPTO` setting and the support for the\r\n   * `crypto` object in the host environment, the random digits of the return value are generated by\r\n   * either `Math.random` (fastest), `crypto.getRandomValues` (Web Cryptography API in recent\r\n   * browsers) or `crypto.randomBytes` (Node.js).\r\n   *\r\n   * To be able to set `CRYPTO` to true when using Node.js, the `crypto` object must be available\r\n   * globally:\r\n   *\r\n   * ```ts\r\n   * global.crypto = require('crypto')\r\n   * ```\r\n   *\r\n   * If `CRYPTO` is true, i.e. one of the `crypto` methods is to be used, the value of a returned\r\n   * BigNumber should be cryptographically secure and statistically indistinguishable from a random\r\n   * value.\r\n   *\r\n   * Throws if `decimalPlaces` is invalid.\r\n   *\r\n   * ```ts\r\n   * BigNumber.config({ DECIMAL_PLACES: 10 })\r\n   * BigNumber.random()              // '0.4117936847'\r\n   * BigNumber.random(20)            // '0.78193327636914089009'\r\n   * ```\r\n   *\r\n   * @param [decimalPlaces] Decimal places, integer, 0 to 1e+9.\r\n   */\r\n  static random(decimalPlaces?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the sum of the arguments.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber('3257869345.0378653')\r\n   * BigNumber.sum(4e9, x, '123456789.9')      // '7381326134.9378653'\r\n   *\r\n   * arr = [2, new BigNumber(14), '15.9999', 12]\r\n   * BigNumber.sum.apply(null, arr)            // '43.9999'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   */\r\n  static sum(...n: BigNumber.Value[]): BigNumber;\r\n\r\n  /**\r\n   * Configures the settings that apply to this BigNumber constructor.\r\n   *\r\n   * The configuration object, `object`, contains any number of the properties shown in the example\r\n   * below.\r\n   *\r\n   * Returns an object with the above properties and their current values.\r\n   *\r\n   * Throws if `object` is not an object, or if an invalid value is assigned to one or more of the\r\n   * properties.\r\n   *\r\n   * ```ts\r\n   * BigNumber.set({\r\n   *     DECIMAL_PLACES: 40,\r\n   *     ROUNDING_MODE: BigNumber.ROUND_HALF_CEIL,\r\n   *     EXPONENTIAL_AT: [-10, 20],\r\n   *     RANGE: [-500, 500],\r\n   *     CRYPTO: true,\r\n   *     MODULO_MODE: BigNumber.ROUND_FLOOR,\r\n   *     POW_PRECISION: 80,\r\n   *     FORMAT: {\r\n   *         groupSize: 3,\r\n   *         groupSeparator: ' ',\r\n   *         decimalSeparator: ','\r\n   *     },\r\n   *     ALPHABET: '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'\r\n   * });\r\n   *\r\n   * BigNumber.set().DECIMAL_PLACES        // 40\r\n   * ```\r\n   *\r\n   * @param object The configuration object.\r\n   */\r\n  static set(object: BigNumber.Config): BigNumber.Config;\r\n}\r\n"},{"name":"@taquito/batch/rpc-batch-provider.d.ts","dts":"import { Context } from '../context';\r\nimport { ContractMethod } from '../contract/contract';\r\nimport { EstimationProvider, ContractProvider } from '../contract/interface';\r\nimport { BatchOperation } from '../operations/batch-operation';\r\nimport { OperationEmitter } from '../operations/operation-emitter';\r\nimport { ActivationParams, DelegateParams, OriginateParams, TransferParams, ParamsWithKind } from '../operations/types';\r\nimport { OpKind } from '@taquito/rpc';\r\nexport declare const BATCH_KINDS: OpKind[];\r\nexport declare type BatchKinds = OpKind.ACTIVATION | OpKind.ORIGINATION | OpKind.TRANSACTION | OpKind.DELEGATION;\r\nexport declare class OperationBatch extends OperationEmitter {\r\n    private estimator;\r\n    private operations;\r\n    constructor(context: Context, estimator: EstimationProvider);\r\n    /**\r\n     *\r\n     * @description Add a transaction operation to the batch\r\n     *\r\n     * @param params Transfer operation parameter\r\n     */\r\n    withTransfer(params: TransferParams): this;\r\n    /**\r\n     *\r\n     * @description Add a transaction operation to the batch\r\n     *\r\n     * @param params Transfer operation parameter\r\n     */\r\n    withContractCall(params: ContractMethod<ContractProvider>): this;\r\n    /**\r\n     *\r\n     * @description Add a delegation operation to the batch\r\n     *\r\n     * @param params Delegation operation parameter\r\n     */\r\n    withDelegation(params: DelegateParams): this;\r\n    /**\r\n     *\r\n     * @description Add an activation operation to the batch\r\n     *\r\n     * @param params Activation operation parameter\r\n     */\r\n    withActivation({ pkh, secret }: ActivationParams): this;\r\n    /**\r\n     *\r\n     * @description Add an origination operation to the batch\r\n     *\r\n     * @param params Origination operation parameter\r\n     */\r\n    withOrigination(params: OriginateParams): this;\r\n    private getRPCOp;\r\n    /**\r\n     *\r\n     * @description Add a group operation to the batch. Operation will be applied in the order they are in the params array\r\n     *\r\n     * @param params Operations parameter\r\n     */\r\n    with(params: ParamsWithKind[]): this;\r\n    /**\r\n     *\r\n     * @description Forge and Inject the operation batch\r\n     *\r\n     * @param params Optionally specify the source of the operation\r\n     */\r\n    send(params?: {\r\n        source?: string;\r\n    }): Promise<BatchOperation>;\r\n}\r\nexport declare class RPCBatchProvider {\r\n    private context;\r\n    private estimator;\r\n    constructor(context: Context, estimator: EstimationProvider);\r\n    /***\r\n     *\r\n     * @description Batch a group of operation together. Operations will be applied in the order in which they are added to the batch\r\n     *\r\n     * @param params List of operation to batch together\r\n     */\r\n    batch(params?: ParamsWithKind[]): OperationBatch;\r\n}\r\n"},{"name":"@taquito/contract/big-map.d.ts","dts":"import { Schema } from '@taquito/michelson-encoder';\r\nimport BigNumber from 'bignumber.js';\r\nimport { ContractProvider } from './interface';\r\nexport declare class BigMapAbstraction {\r\n    private id;\r\n    private schema;\r\n    private provider;\r\n    constructor(id: BigNumber, schema: Schema, provider: ContractProvider);\r\n    get<T>(keyToEncode: string): Promise<T | undefined>;\r\n    toJSON(): string;\r\n    toString(): string;\r\n}\r\n"},{"name":"@taquito/contract/compose.d.ts","dts":"import { Wallet } from '../wallet/wallet';\r\nimport { Context } from '../context';\r\nimport { ContractAbstraction } from './contract';\r\nimport { ContractProvider } from './interface';\r\nexport declare function compose<ContractAbsComposer1 extends ContractAbstraction<ContractProvider | Wallet>, ContractAbsComposer2 extends ContractAbstraction<ContractProvider | Wallet>, ContractAbstractionComposed>(functioncomposer1: (abs: ContractAbsComposer1, context: Context) => ContractAbsComposer2, functioncomposer2: (abs: ContractAbsComposer2, context: Context) => ContractAbstractionComposed): (abs: ContractAbsComposer1, context: Context) => ContractAbstractionComposed;\r\n"},{"name":"@taquito/contract/contract.d.ts","dts":"import { ParameterSchema, Schema } from '@taquito/michelson-encoder';\r\nimport { EntrypointsResponse, ScriptResponse } from '@taquito/rpc';\r\nimport { TransactionOperation } from '../operations/transaction-operation';\r\nimport { TransferParams } from '../operations/types';\r\nimport { TransactionWalletOperation, Wallet } from '../wallet';\r\nimport { ContractProvider, StorageProvider } from './interface';\r\ninterface SendParams {\r\n    fee?: number;\r\n    storageLimit?: number;\r\n    gasLimit?: number;\r\n    amount: number;\r\n    source?: string;\r\n    mutez?: boolean;\r\n}\r\n/**\r\n * @description Utility class to send smart contract operation\r\n */\r\nexport declare class ContractMethod<T extends ContractProvider | Wallet> {\r\n    private provider;\r\n    private address;\r\n    private parameterSchema;\r\n    private name;\r\n    private args;\r\n    private isMultipleEntrypoint;\r\n    private isAnonymous;\r\n    constructor(provider: T, address: string, parameterSchema: ParameterSchema, name: string, args: any[], isMultipleEntrypoint?: boolean, isAnonymous?: boolean);\r\n    /**\r\n     * @description Get the schema of the smart contract method\r\n     */\r\n    get schema(): any;\r\n    /**\r\n     *\r\n     * @description Send the smart contract operation\r\n     *\r\n     * @param Options generic operation parameter\r\n     */\r\n    send(params?: Partial<SendParams>): Promise<T extends Wallet ? TransactionWalletOperation : TransactionOperation>;\r\n    /**\r\n     *\r\n     * @description Create transfer params to be used with TezosToolkit.contract.transfer methods\r\n     *\r\n     * @param Options generic transfer operation parameters\r\n     */\r\n    toTransferParams({ fee, gasLimit, storageLimit, source, amount, mutez, }?: Partial<SendParams>): TransferParams;\r\n}\r\n/**\r\n * @description Utility class to retrieve data from a smart contract's storage without incurring fees via a contract's view method\r\n */\r\nexport declare class ContractView {\r\n    private currentContract;\r\n    private provider;\r\n    private name;\r\n    private chainId;\r\n    private callbackParametersSchema;\r\n    private parameterSchema;\r\n    private args;\r\n    constructor(currentContract: ContractAbstraction<ContractProvider | Wallet>, provider: ContractProvider, name: string, chainId: string, callbackParametersSchema: ParameterSchema, parameterSchema: ParameterSchema, args: any[]);\r\n    /**\r\n     *\r\n     * @description Find which lambda contract to use based on the current network,\r\n     * encode parameters to Michelson,\r\n     * create an instance of Lambdaview to retrive data, and\r\n     * Decode Michelson response\r\n     *\r\n     * @param Options Address of a lambda contract (sandbox users)\r\n     */\r\n    read(customLambdaAddress?: string): Promise<any>;\r\n}\r\nexport declare type Contract = ContractAbstraction<ContractProvider>;\r\nexport declare type WalletContract = ContractAbstraction<Wallet>;\r\n/**\r\n * @description Smart contract abstraction\r\n */\r\nexport declare class ContractAbstraction<T extends ContractProvider | Wallet> {\r\n    readonly address: string;\r\n    readonly script: ScriptResponse;\r\n    private storageProvider;\r\n    readonly entrypoints: EntrypointsResponse;\r\n    private chainId;\r\n    /**\r\n     * @description Contains methods that are implemented by the target Tezos Smart Contract, and offers the user to call the Smart Contract methods as if they were native TS/JS methods.\r\n     * NB: if the contract contains annotation it will include named properties; if not it will be indexed by a number.\r\n     *\r\n     */\r\n    methods: {\r\n        [key: string]: (...args: any[]) => ContractMethod<T>;\r\n    };\r\n    views: {\r\n        [key: string]: (...args: any[]) => ContractView;\r\n    };\r\n    readonly schema: Schema;\r\n    readonly parameterSchema: ParameterSchema;\r\n    constructor(address: string, script: ScriptResponse, provider: T, storageProvider: StorageProvider, entrypoints: EntrypointsResponse, chainId: string);\r\n    private _initializeMethods;\r\n    /**\r\n     * @description Return a friendly representation of the smart contract storage\r\n     */\r\n    storage<T>(): Promise<T>;\r\n    /**\r\n     *\r\n     * @description Return a friendly representation of the smart contract big map value\r\n     *\r\n     * @param key BigMap key to fetch\r\n     *\r\n     * @deprecated getBigMapKey has been deprecated in favor of getBigMapKeyByID\r\n     *\r\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-script\r\n     */\r\n    bigMap(key: string): Promise<unknown>;\r\n}\r\nexport {};\r\n"},{"name":"@taquito/contract/errors.d.ts","dts":"export declare class InvalidParameterError implements Error {\r\n    smartContractMethodName: string;\r\n    sigs: any[];\r\n    args: any[];\r\n    name: string;\r\n    message: string;\r\n    constructor(smartContractMethodName: string, sigs: any[], args: any[]);\r\n}\r\nexport declare class UndefinedLambdaContractError implements Error {\r\n    name: string;\r\n    message: string;\r\n    constructor();\r\n}\r\nexport declare class InvalidDelegationSource implements Error {\r\n    source: string;\r\n    name: string;\r\n    message: string;\r\n    constructor(source: string);\r\n}\r\nexport declare class InvalidCodeParameter implements Error {\r\n    message: string;\r\n    readonly data: any;\r\n    name: string;\r\n    constructor(message: string, data: any);\r\n}\r\nexport declare class InvalidInitParameter implements Error {\r\n    message: string;\r\n    readonly data: any;\r\n    name: string;\r\n    constructor(message: string, data: any);\r\n}\r\n"},{"name":"@taquito/contract/estimate.d.ts","dts":"/**\r\n * Examples of use :\r\n *\r\n *  Estimate a transfer operation :\r\n * ```\r\n * // Assuming that provider and signer are already configured...\r\n *\r\n * const amount = 2;\r\n * const address = 'tz1h3rQ8wBxFd8L9B3d7Jhaawu6Z568XU3xY';\r\n *\r\n * // Estimate gasLimit, storageLimit and fees for a transfer operation\r\n * const est = await Tezos.estimate.transfer({ to: address, amount: amount })\r\n * console.log(est.burnFeeMutez, est.gasLimit, est.minimalFeeMutez, est.storageLimit,\r\n *  est.suggestedFeeMutez, est.totalCost, est.usingBaseFeeMutez)\r\n *\r\n * ```\r\n *\r\n * Estimate a contract origination :\r\n * ```\r\n * // generic.json is referring to a Michelson Smart Contract\r\n *\r\n * const genericMultisigJSON = require('./generic.json')\r\n * const est = await Tezos.estimate.originate({\r\n *   code: genericMultisigJSON,\r\n *   storage: {\r\n *     stored_counter: 0,\r\n *     threshold: 1,\r\n *     keys: ['edpkuLxx9PQD8fZ45eUzrK3BhfDZJHhBuK4Zi49DcEGANwd2rpX82t']\r\n *   }\r\n * })\r\n * console.log(est.burnFeeMutez, est.gasLimit, est.minimalFeeMutez, est.storageLimit,\r\n *   est.suggestedFeeMutez, est.totalCost, est.usingBaseFeeMutez)\r\n *\r\n * ```\r\n */\r\nexport declare class Estimate {\r\n    private readonly _milligasLimit;\r\n    private readonly _storageLimit;\r\n    private readonly opSize;\r\n    private readonly minimalFeePerStorageByteMutez;\r\n    /**\r\n     * @description Base fee in mutez (1 mutez = 1e106 tez)\r\n     */\r\n    private readonly baseFeeMutez;\r\n    constructor(_milligasLimit: number | string, _storageLimit: number | string, opSize: number | string, minimalFeePerStorageByteMutez: number | string, \r\n    /**\r\n     * @description Base fee in mutez (1 mutez = 1e106 tez)\r\n     */\r\n    baseFeeMutez?: number | string);\r\n    /**\r\n     * @description The number of Mutez that will be burned for the storage of the [operation](https://tezos.gitlab.io/user/glossary.html#operations). (Storage + Allocation fees)\r\n     */\r\n    get burnFeeMutez(): number;\r\n    /**\r\n     * @description  The limit on the amount of storage an [operation](https://tezos.gitlab.io/user/glossary.html#operations) can use.\r\n     */\r\n    get storageLimit(): number;\r\n    /**\r\n     * @description The limit on the amount of [gas](https://tezos.gitlab.io/user/glossary.html#gas) a given operation can consume.\r\n     */\r\n    get gasLimit(): number;\r\n    private get operationFeeMutez();\r\n    private roundUp;\r\n    /**\r\n     * @description Minimum fees for the [operation](https://tezos.gitlab.io/user/glossary.html#operations) according to [baker](https://tezos.gitlab.io/user/glossary.html#baker) defaults.\r\n     */\r\n    get minimalFeeMutez(): number;\r\n    /**\r\n     * @description The suggested fee for the operation which includes minimal fees and a small buffer.\r\n     */\r\n    get suggestedFeeMutez(): number;\r\n    /**\r\n     * @description Fees according to your specified base fee will ensure that at least minimum fees are used.\r\n     */\r\n    get usingBaseFeeMutez(): number;\r\n    /**\r\n     * @description The sum of `minimalFeeMutez` + `burnFeeMutez`.\r\n     */\r\n    get totalCost(): number;\r\n    /**\r\n     * @description Since Delphinet, consumed gas is provided in milligas for more precision.\r\n     * This function returns an estimation of the gas that operation will consume in milligas.\r\n     */\r\n    get consumedMilligas(): number;\r\n}\r\n"},{"name":"@taquito/contract/index.d.ts","dts":"export * from './contract';\r\nexport * from './errors';\r\nexport * from './interface';\r\nexport * from './manager-lambda';\r\nexport * from './prepare';\r\nexport * from './view_lambda';\r\nexport { compose } from './compose';\r\n"},{"name":"@taquito/contract/interface.d.ts","dts":"import { Schema } from '@taquito/michelson-encoder';\r\nimport { OperationBatch } from '../batch/rpc-batch-provider';\r\nimport { Context } from '../context';\r\nimport { DelegateOperation } from '../operations/delegate-operation';\r\nimport { OriginationOperation } from '../operations/origination-operation';\r\nimport { TransactionOperation } from '../operations/transaction-operation';\r\nimport { DelegateParams, OriginateParams, TransferParams, RegisterDelegateParams, ParamsWithKind } from '../operations/types';\r\nimport { ContractAbstraction } from './contract';\r\nimport { Estimate } from './estimate';\r\nexport declare type ContractSchema = Schema | unknown;\r\nexport interface EstimationProvider {\r\n    /**\r\n     *\r\n     * @description Estimate gasLimit, storageLimit and fees for an origination operation\r\n     *\r\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\r\n     *\r\n     * @param Estimate\r\n     */\r\n    originate(params: OriginateParams): Promise<Estimate>;\r\n    /**\r\n     *\r\n     * @description Estimate gasLimit, storageLimit and fees for an transfer operation\r\n     *\r\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\r\n     *\r\n     * @param Estimate\r\n     */\r\n    transfer({ fee, storageLimit, gasLimit, ...rest }: TransferParams): Promise<Estimate>;\r\n    /**\r\n     *\r\n     * @description Estimate gasLimit, storageLimit and fees for a delegate operation\r\n     *\r\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\r\n     *\r\n     * @param Estimate\r\n     */\r\n    setDelegate(params: DelegateParams): Promise<Estimate>;\r\n    /**\r\n     *\r\n     * @description Estimate gasLimit, storageLimit and fees for a delegate operation\r\n     *\r\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\r\n     *\r\n     * @param Estimate\r\n     */\r\n    registerDelegate(params?: RegisterDelegateParams): Promise<Estimate>;\r\n    batch(params: ParamsWithKind[]): Promise<Estimate[]>;\r\n}\r\nexport interface StorageProvider {\r\n    /**\r\n     *\r\n     * @description Return a well formatted json object of the contract storage\r\n     *\r\n     * @param contract contract address you want to get the storage from\r\n     * @param schema optional schema can either be the contract script rpc response or a michelson-encoder schema\r\n     *\r\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-script\r\n     */\r\n    getStorage<T>(contract: string, schema?: ContractSchema): Promise<T>;\r\n    /**\r\n     *\r\n     * @description Return a well formatted json object of the contract big map storage\r\n     *\r\n     * @param contract contract address you want to get the storage from\r\n     * @param key contract big map key to fetch value from\r\n     * @param schema optional schema can either be the contract script rpc response or a michelson-encoder schema\r\n     *\r\n     * @deprecated Deprecated in favor of getBigMapKeyByID\r\n     *\r\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-script\r\n     */\r\n    getBigMapKey<T>(contract: string, key: string, schema?: ContractSchema): Promise<T>;\r\n    /**\r\n     *\r\n     * @description Return a well formatted json object of a big map value\r\n     *\r\n     * @param id Big Map ID\r\n     * @param keyToEncode key to query (will be encoded properly according to the schema)\r\n     * @param schema Big Map schema (can be determined using your contract type)\r\n     *\r\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-big-maps-big-map-id-script-expr\r\n     */\r\n    getBigMapKeyByID<T>(id: string, keyToEncode: string, schema: Schema): Promise<T>;\r\n}\r\nexport interface ContractProvider extends StorageProvider {\r\n    /**\r\n     *\r\n     * @description Originate a new contract according to the script in parameters. Will sign and inject an operation using the current context\r\n     *\r\n     * @returns An operation handle with the result from the rpc node\r\n     *\r\n     * @param OriginationOperation Originate operation parameter\r\n     */\r\n    originate(contract: OriginateParams): Promise<OriginationOperation>;\r\n    /**\r\n     *\r\n     * @description Set the delegate for a contract. Will sign and inject an operation using the current context\r\n     *\r\n     * @returns An operation handle with the result from the rpc node\r\n     *\r\n     * @param SetDelegate operation parameter\r\n     */\r\n    setDelegate(params: DelegateParams): Promise<DelegateOperation>;\r\n    /**\r\n     *\r\n     * @description Register the current address as delegate. Will sign and inject an operation using the current context\r\n     *\r\n     * @returns An operation handle with the result from the rpc node\r\n     *\r\n     * @param RegisterDelegate operation parameter\r\n     */\r\n    registerDelegate(params: DelegateParams): Promise<DelegateOperation>;\r\n    /**\r\n     *\r\n     * @description Transfer tz from current address to a specific address. Will sign and inject an operation using the current context\r\n     *\r\n     * @returns An operation handle with the result from the rpc node\r\n     *\r\n     * @param Transfer operation parameter\r\n     */\r\n    transfer(params: TransferParams): Promise<TransactionOperation>;\r\n    at<T extends ContractAbstraction<ContractProvider>>(address: string, contractAbstractionComposer?: (abs: ContractAbstraction<ContractProvider>, context: Context) => T): Promise<T>;\r\n    /**\r\n     *\r\n     * @description Batch a group of operation together. Operations will be applied in the order in which they are added to the batch\r\n     *\r\n     * @param params List of operation to batch together\r\n     */\r\n    batch(params?: ParamsWithKind[]): OperationBatch;\r\n}\r\n"},{"name":"@taquito/contract/lambda-view.d.ts","dts":"import { MichelsonV1Expression } from '@taquito/rpc';\r\nimport { Contract, ContractAbstraction, WalletContract } from './contract';\r\nimport { ContractProvider } from './interface';\r\nimport { Wallet } from '../wallet';\r\nexport default class LambdaView {\r\n    private lambdaContract;\r\n    private viewContract;\r\n    readonly viewMethod: string;\r\n    private contractParameter;\r\n    readonly voidLambda: Object;\r\n    constructor(lambdaContract: Contract | WalletContract, viewContract: ContractAbstraction<ContractProvider | Wallet>, viewMethod?: string, contractParameter?: MichelsonV1Expression);\r\n    execute(): Promise<any>;\r\n    private createVoidLambda;\r\n    private getView;\r\n}\r\n"},{"name":"@taquito/contract/manager-lambda.d.ts","dts":"export declare const MANAGER_LAMBDA: {\r\n    setDelegate: (key: string) => ({\r\n        prim: string;\r\n        args?: undefined;\r\n    } | {\r\n        prim: string;\r\n        args: ({\r\n            prim: string;\r\n            string?: undefined;\r\n        } | {\r\n            string: string;\r\n            prim?: undefined;\r\n        })[];\r\n    })[];\r\n    removeDelegate: () => ({\r\n        prim: string;\r\n        args?: undefined;\r\n    } | {\r\n        prim: string;\r\n        args: {\r\n            prim: string;\r\n        }[];\r\n    })[];\r\n    transferImplicit: (key: string, mutez: number) => ({\r\n        prim: string;\r\n        args?: undefined;\r\n    } | {\r\n        prim: string;\r\n        args: ({\r\n            prim: string;\r\n            string?: undefined;\r\n        } | {\r\n            string: string;\r\n            prim?: undefined;\r\n        })[];\r\n    } | {\r\n        prim: string;\r\n        args: ({\r\n            prim: string;\r\n            int?: undefined;\r\n        } | {\r\n            int: string;\r\n            prim?: undefined;\r\n        })[];\r\n    })[];\r\n    transferToContract: (key: string, amount: number) => ({\r\n        prim: string;\r\n        args?: undefined;\r\n    } | {\r\n        prim: string;\r\n        args: ({\r\n            prim: string;\r\n            string?: undefined;\r\n        } | {\r\n            string: string;\r\n            prim?: undefined;\r\n        })[];\r\n    } | {\r\n        prim: string;\r\n        args: {\r\n            prim: string;\r\n        }[][][];\r\n    }[] | {\r\n        prim: string;\r\n        args: ({\r\n            prim: string;\r\n            int?: undefined;\r\n        } | {\r\n            int: string;\r\n            prim?: undefined;\r\n        })[];\r\n    })[];\r\n};\r\n"},{"name":"@taquito/contract/naive-estimate-provider.d.ts","dts":"import { DEFAULT_FEE, Protocols } from '../constants';\r\nimport { OriginateParams, TransferParams, ParamsWithKind } from '../operations/types';\r\nimport { Estimate } from './estimate';\r\nimport { EstimationProvider } from './interface';\r\n/**\r\n * @description Nave implementation of an estimate provider. Will work for basic transaction but your operation risk to fail if they are more complex (smart contract interaction)\r\n */\r\nexport declare class NaiveEstimateProvider implements EstimationProvider {\r\n    private readonly protocol;\r\n    private _costPerByte;\r\n    constructor(protocol: Protocols);\r\n    /**\r\n     *\r\n     * @description Estimate gasLimit, storageLimit and fees for an origination operation\r\n     *\r\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\r\n     *\r\n     * @param OriginationOperation Originate operation parameter\r\n     */\r\n    originate({ fee, storageLimit, gasLimit, }: OriginateParams): Promise<Estimate>;\r\n    /**\r\n     *\r\n     * @description Estimate gasLimit, storageLimit and fees for an transfer operation\r\n     *\r\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\r\n     *\r\n     * @param TransferOperation Originate operation parameter\r\n     */\r\n    transfer({ fee, storageLimit, gasLimit, }: TransferParams): Promise<Estimate>;\r\n    /**\r\n     *\r\n     * @description Estimate gasLimit, storageLimit and fees for a delegate operation\r\n     *\r\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\r\n     *\r\n     * @param Estimate\r\n     */\r\n    setDelegate({ fee, gasLimit, }: {\r\n        fee?: DEFAULT_FEE | undefined;\r\n        gasLimit?: number | undefined;\r\n    }): Promise<Estimate>;\r\n    /**\r\n     *\r\n     * @description Estimate gasLimit, storageLimit and fees for a delegate operation\r\n     *\r\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\r\n     *\r\n     * @param Estimate\r\n     */\r\n    registerDelegate({ fee, gasLimit, }: {\r\n        fee?: DEFAULT_FEE | undefined;\r\n        gasLimit?: number | undefined;\r\n    }): Promise<Estimate>;\r\n    batch(params: ParamsWithKind[]): Promise<Estimate[]>;\r\n}\r\n"},{"name":"@taquito/contract/prepare.d.ts","dts":"import { OriginateParams, RPCOriginationOperation, TransferParams, RPCTransferOperation, DelegateParams, RPCDelegateOperation, RegisterDelegateParams } from '../operations/types';\r\nexport declare const createOriginationOperation: ({ code, init, balance, delegate, storage, fee, gasLimit, storageLimit, mutez }: OriginateParams) => Promise<RPCOriginationOperation>;\r\nexport declare const createTransferOperation: ({ to, amount, parameter, fee, gasLimit, storageLimit, mutez, }: TransferParams) => Promise<RPCTransferOperation>;\r\nexport declare const createSetDelegateOperation: ({ delegate, source, fee, gasLimit, storageLimit, }: DelegateParams) => Promise<RPCDelegateOperation>;\r\nexport declare const createRegisterDelegateOperation: ({ fee, gasLimit, storageLimit, }: RegisterDelegateParams, source: string) => Promise<RPCDelegateOperation>;\r\n"},{"name":"@taquito/contract/rpc-contract-provider.d.ts","dts":"import { Schema } from '@taquito/michelson-encoder';\r\nimport { OperationBatch } from '../batch/rpc-batch-provider';\r\nimport { Context } from '../context';\r\nimport { DelegateOperation } from '../operations/delegate-operation';\r\nimport { OperationEmitter } from '../operations/operation-emitter';\r\nimport { OriginationOperation } from '../operations/origination-operation';\r\nimport { TransactionOperation } from '../operations/transaction-operation';\r\nimport { DelegateParams, OriginateParams, ParamsWithKind, RegisterDelegateParams, TransferParams } from '../operations/types';\r\nimport { ContractAbstraction } from './contract';\r\nimport { ContractProvider, ContractSchema, EstimationProvider, StorageProvider } from './interface';\r\nexport declare class RpcContractProvider extends OperationEmitter implements ContractProvider, StorageProvider {\r\n    private estimator;\r\n    constructor(context: Context, estimator: EstimationProvider);\r\n    contractProviderTypeSymbol: symbol;\r\n    /**\r\n     *\r\n     * @description Return a well formatted json object of the contract storage\r\n     *\r\n     * @param contract contract address you want to get the storage from\r\n     * @param schema optional schema can either be the contract script rpc response or a michelson-encoder schema\r\n     *\r\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-script\r\n     */\r\n    getStorage<T>(contract: string, schema?: ContractSchema): Promise<T>;\r\n    /**\r\n     *\r\n     * @description Return a well formatted json object of the contract big map storage\r\n     *\r\n     * @param contract contract address you want to get the storage from\r\n     * @param key contract big map key to fetch value from\r\n     * @param schema optional schema can either be the contract script rpc response or a michelson-encoder schema\r\n     *\r\n     * @deprecated Deprecated in favor of getBigMapKeyByID\r\n     *\r\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-script\r\n     */\r\n    getBigMapKey<T>(contract: string, key: string, schema?: ContractSchema): Promise<T>;\r\n    /**\r\n     *\r\n     * @description Return a well formatted json object of a big map value\r\n     *\r\n     * @param id Big Map ID\r\n     * @param keyToEncode key to query (will be encoded properly according to the schema)\r\n     * @param schema Big Map schema (can be determined using your contract type)\r\n     *\r\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-big-maps-big-map-id-script-expr\r\n     */\r\n    getBigMapKeyByID<T>(id: string, keyToEncode: string, schema: Schema): Promise<T>;\r\n    /**\r\n     *\r\n     * @description Originate a new contract according to the script in parameters. Will sign and inject an operation using the current context\r\n     *\r\n     * @returns An operation handle with the result from the rpc node\r\n     *\r\n     * @warn You cannot specify storage and init at the same time (use init to pass the raw michelson representation of storage)\r\n     *\r\n     * @param OriginationOperation Originate operation parameter\r\n     */\r\n    originate(params: OriginateParams): Promise<OriginationOperation>;\r\n    /**\r\n     *\r\n     * @description Set the delegate for a contract. Will sign and inject an operation using the current context\r\n     *\r\n     * @returns An operation handle with the result from the rpc node\r\n     *\r\n     * @param SetDelegate operation parameter\r\n     */\r\n    setDelegate(params: DelegateParams): Promise<DelegateOperation>;\r\n    /**\r\n     *\r\n     * @description Register the current address as delegate. Will sign and inject an operation using the current context\r\n     *\r\n     * @returns An operation handle with the result from the rpc node\r\n     *\r\n     * @param RegisterDelegate operation parameter\r\n     */\r\n    registerDelegate(params: RegisterDelegateParams): Promise<DelegateOperation>;\r\n    /**\r\n     *\r\n     * @description Transfer tz from current address to a specific address. Will sign and inject an operation using the current context\r\n     *\r\n     * @returns An operation handle with the result from the rpc node\r\n     *\r\n     * @param Transfer operation parameter\r\n     */\r\n    transfer(params: TransferParams): Promise<TransactionOperation>;\r\n    at<T extends ContractAbstraction<ContractProvider>>(address: string, contractAbstractionComposer?: ContractAbstractionComposer<T>): Promise<T>;\r\n    /**\r\n     *\r\n     * @description Batch a group of operation together. Operations will be applied in the order in which they are added to the batch\r\n     *\r\n     * @returns A batch object from which we can add more operation or send a command to execute the batch\r\n     *\r\n     * @param params List of operation to batch together\r\n     */\r\n    batch(params?: ParamsWithKind[]): OperationBatch;\r\n}\r\ndeclare type ContractAbstractionComposer<T> = (abs: ContractAbstraction<ContractProvider>, context: Context) => T;\r\nexport {};\r\n"},{"name":"@taquito/contract/rpc-estimate-provider.d.ts","dts":"import { OperationEmitter } from '../operations/operation-emitter';\r\nimport { DelegateParams, OriginateParams, ParamsWithKind, RegisterDelegateParams, TransferParams } from '../operations/types';\r\nimport { Estimate } from './estimate';\r\nimport { EstimationProvider } from './interface';\r\nexport declare class RPCEstimateProvider extends OperationEmitter implements EstimationProvider {\r\n    private readonly ALLOCATION_STORAGE;\r\n    private readonly ORIGINATION_STORAGE;\r\n    private getAccountLimits;\r\n    private createEstimateFromOperationContent;\r\n    private createEstimate;\r\n    /**\r\n     *\r\n     * @description Estimate gasLimit, storageLimit and fees for an origination operation\r\n     *\r\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\r\n     *\r\n     * @param OriginationOperation Originate operation parameter\r\n     */\r\n    originate({ fee, storageLimit, gasLimit, ...rest }: OriginateParams): Promise<Estimate>;\r\n    /**\r\n     *\r\n     * @description Estimate gasLimit, storageLimit and fees for an transfer operation\r\n     *\r\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\r\n     *\r\n     * @param TransferOperation Originate operation parameter\r\n     */\r\n    transfer({ fee, storageLimit, gasLimit, ...rest }: TransferParams): Promise<Estimate>;\r\n    /**\r\n     *\r\n     * @description Estimate gasLimit, storageLimit and fees for a delegate operation\r\n     *\r\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\r\n     *\r\n     * @param Estimate\r\n     */\r\n    setDelegate({ fee, gasLimit, storageLimit, ...rest }: DelegateParams): Promise<Estimate>;\r\n    batch(params: ParamsWithKind[]): Promise<Estimate[]>;\r\n    /**\r\n     *\r\n     * @description Estimate gasLimit, storageLimit and fees for a delegate operation\r\n     *\r\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\r\n     *\r\n     * @param Estimate\r\n     */\r\n    registerDelegate(params: RegisterDelegateParams): Promise<Estimate>;\r\n}\r\n"},{"name":"@taquito/contract/semantic.d.ts","dts":"import { Semantic } from '@taquito/michelson-encoder';\r\nimport { ContractProvider } from './interface';\r\nexport declare const smartContractAbstractionSemantic: (p: ContractProvider) => Semantic;\r\n"},{"name":"@taquito/contract/view_lambda.d.ts","dts":"export declare const VIEW_LAMBDA: {\r\n    code: ({\r\n        prim: string;\r\n        args: {\r\n            prim: string;\r\n            args: ({\r\n                prim: string;\r\n                args?: undefined;\r\n            } | {\r\n                prim: string;\r\n                args: ({\r\n                    prim: string;\r\n                    args: {\r\n                        prim: string;\r\n                    }[];\r\n                } | {\r\n                    prim: string;\r\n                    args?: undefined;\r\n                })[];\r\n            })[];\r\n        }[];\r\n    } | {\r\n        prim: string;\r\n        args: {\r\n            prim: string;\r\n        }[];\r\n    } | {\r\n        prim: string;\r\n        args: {\r\n            prim: string;\r\n        }[][];\r\n    })[];\r\n    storage: string;\r\n};\r\n"},{"name":"@taquito/extension/extension.d.ts","dts":"import { Context } from \"../context\";\r\nexport interface Extension {\r\n    configureContext(context: Context): void;\r\n}\r\n"},{"name":"@taquito/forger/composite-forger.d.ts","dts":"import { Forger, ForgeParams, ForgeResponse } from './interface';\r\nexport declare class ForgingMismatchError implements Error {\r\n    results: string[];\r\n    name: string;\r\n    message: string;\r\n    constructor(results: string[]);\r\n}\r\nexport declare class CompositeForger implements Forger {\r\n    private forgers;\r\n    constructor(forgers: Forger[]);\r\n    forge({ branch, contents }: ForgeParams): Promise<ForgeResponse>;\r\n}\r\n"},{"name":"@taquito/forger/interface.d.ts","dts":"import { OperationContents } from '@taquito/rpc';\r\nexport interface ForgeParams {\r\n    branch: string;\r\n    contents: OperationContents[];\r\n}\r\nexport declare type ForgeResponse = string;\r\nexport interface Forger {\r\n    forge(params: ForgeParams): Promise<ForgeResponse>;\r\n}\r\n"},{"name":"@taquito/forger/rpc-forger.d.ts","dts":"import { Forger, ForgeParams, ForgeResponse } from './interface';\r\nimport { Context } from '../context';\r\nexport declare class RpcForger implements Forger {\r\n    private context;\r\n    constructor(context: Context);\r\n    forge({ branch, contents }: ForgeParams): Promise<ForgeResponse>;\r\n}\r\n"},{"name":"@taquito/injector/interface.d.ts","dts":"export declare type InjectorParams = string;\r\nexport declare type TxHash = string;\r\nexport interface Injector {\r\n    inject(signedOperationBytes: InjectorParams): Promise<TxHash>;\r\n}\r\n"},{"name":"@taquito/injector/rpc-injector.d.ts","dts":"import { Injector } from './interface';\r\nimport { Context } from '../context';\r\nexport declare class RpcInjector implements Injector {\r\n    private context;\r\n    constructor(context: Context);\r\n    inject(signedOperationBytes: string): Promise<string>;\r\n}\r\n"},{"name":"@taquito/operations/batch-operation.d.ts","dts":"import { OperationContentsAndResult } from '@taquito/rpc';\r\nimport { Context } from '../context';\r\nimport { Operation } from './operations';\r\nimport { FeeConsumingOperation, ForgedBytes, GasConsumingOperation, RPCOperation, StorageConsumingOperation } from './types';\r\nexport declare class BatchOperation extends Operation implements GasConsumingOperation, StorageConsumingOperation, FeeConsumingOperation {\r\n    private readonly params;\r\n    readonly source: string;\r\n    constructor(hash: string, params: RPCOperation[], source: string, raw: ForgedBytes, results: OperationContentsAndResult[], context: Context);\r\n    private sumProp;\r\n    get status(): \"applied\" | \"failed\" | \"skipped\" | \"backtracked\" | \"unknown\";\r\n    get fee(): any;\r\n    get gasLimit(): any;\r\n    get storageLimit(): any;\r\n    get consumedGas(): string;\r\n    get storageDiff(): string;\r\n    get errors(): import(\"@taquito/rpc\").TezosGenericOperationError[];\r\n}\r\n"},{"name":"@taquito/operations/delegate-operation.d.ts","dts":"import { OperationContentsAndResult } from '@taquito/rpc';\r\nimport { Context } from '../context';\r\nimport { Operation } from './operations';\r\nimport { FeeConsumingOperation, ForgedBytes, GasConsumingOperation, RPCDelegateOperation, StorageConsumingOperation } from './types';\r\n/**\r\n * @description Delegation operation provide utility function to fetch newly issued delegation\r\n *\r\n * @warn Currently support only one delegation per operation\r\n */\r\nexport declare class DelegateOperation extends Operation implements GasConsumingOperation, StorageConsumingOperation, FeeConsumingOperation {\r\n    private readonly params;\r\n    readonly source: string;\r\n    constructor(hash: string, params: RPCDelegateOperation, source: string, raw: ForgedBytes, results: OperationContentsAndResult[], context: Context);\r\n    get operationResults(): import(\"@taquito/rpc\").OperationResultDelegation | undefined;\r\n    get status(): \"applied\" | \"failed\" | \"skipped\" | \"backtracked\" | \"unknown\";\r\n    get delegate(): string;\r\n    get isRegisterOperation(): boolean;\r\n    get fee(): number;\r\n    get gasLimit(): number;\r\n    get storageLimit(): number;\r\n    get consumedGas(): string | undefined;\r\n    get errors(): import(\"@taquito/rpc\").TezosGenericOperationError[] | undefined;\r\n}\r\n"},{"name":"@taquito/operations/operation-emitter.d.ts","dts":"import { OperationContents, OperationContentsAndResult, RpcClient, RPCRunOperationParam } from '@taquito/rpc';\r\nimport { Context } from '../context';\r\nimport { Estimate } from '../contract/estimate';\r\nimport { ForgedBytes, PrepareOperationParams } from './types';\r\nexport interface PreparedOperation {\r\n    opOb: {\r\n        branch: string;\r\n        contents: OperationContents[];\r\n        protocol: string;\r\n    };\r\n    counter: number;\r\n}\r\nexport declare abstract class OperationEmitter {\r\n    protected context: Context;\r\n    get rpc(): RpcClient;\r\n    get signer(): import(\"../taquito\").Signer;\r\n    constructor(context: Context);\r\n    protected prepareOperation({ operation, source, }: PrepareOperationParams): Promise<PreparedOperation>;\r\n    protected prepareAndForge(params: PrepareOperationParams): Promise<{\r\n        opbytes: string;\r\n        opOb: {\r\n            branch: string;\r\n            contents: OperationContents[];\r\n            protocol: string;\r\n        };\r\n        counter: number;\r\n    }>;\r\n    protected forge({ opOb: { branch, contents, protocol }, counter }: PreparedOperation): Promise<{\r\n        opbytes: string;\r\n        opOb: {\r\n            branch: string;\r\n            contents: OperationContents[];\r\n            protocol: string;\r\n        };\r\n        counter: number;\r\n    }>;\r\n    protected simulate(op: RPCRunOperationParam): Promise<{\r\n        opResponse: import(\"@taquito/rpc\").PreapplyResponse;\r\n        op: RPCRunOperationParam;\r\n        context: Context;\r\n    }>;\r\n    protected estimate<T extends {\r\n        fee?: number;\r\n        gasLimit?: number;\r\n        storageLimit?: number;\r\n    }>({ fee, gasLimit, storageLimit, ...rest }: T, estimator: (param: T) => Promise<Estimate>): Promise<{\r\n        fee: number;\r\n        gasLimit: number;\r\n        storageLimit: number;\r\n    }>;\r\n    protected signAndInject(forgedBytes: ForgedBytes): Promise<{\r\n        hash: string;\r\n        forgedBytes: ForgedBytes;\r\n        opResponse: OperationContentsAndResult[];\r\n        context: Context;\r\n    }>;\r\n}\r\n"},{"name":"@taquito/operations/operation-errors.d.ts","dts":"import { MichelsonV1ExpressionBase, OperationResultDelegation, OperationResultOrigination, OperationResultReveal, OperationResultTransaction, PreapplyResponse, TezosGenericOperationError } from '@taquito/rpc';\r\nexport interface TezosOperationErrorWithMessage extends TezosGenericOperationError {\r\n    with: MichelsonV1ExpressionBase;\r\n}\r\nexport declare class TezosOperationError implements Error {\r\n    errors: TezosGenericOperationError[];\r\n    name: string;\r\n    id: string;\r\n    kind: string;\r\n    message: string;\r\n    constructor(errors: TezosGenericOperationError[]);\r\n}\r\nexport declare class TezosPreapplyFailureError implements Error {\r\n    result: any;\r\n    name: string;\r\n    message: string;\r\n    constructor(result: any);\r\n}\r\nexport declare type MergedOperationResult = OperationResultDelegation & OperationResultOrigination & OperationResultTransaction & OperationResultReveal & {\r\n    fee?: string;\r\n};\r\nexport declare const flattenOperationResult: (response: PreapplyResponse | PreapplyResponse[]) => MergedOperationResult[];\r\n/***\r\n * @description Flatten all error from preapply response (including internal error)\r\n */\r\nexport declare const flattenErrors: (response: PreapplyResponse | PreapplyResponse[], status?: string) => TezosGenericOperationError[];\r\n"},{"name":"@taquito/operations/operations.d.ts","dts":"import { OperationContentsAndResult, OperationContentsAndResultReveal } from '@taquito/rpc';\r\nimport { Context } from '../context';\r\nimport { ForgedBytes } from './types';\r\n/**\r\n * @description Utility class to interact with Tezos operations\r\n */\r\nexport declare class Operation {\r\n    readonly hash: string;\r\n    readonly raw: ForgedBytes;\r\n    readonly results: OperationContentsAndResult[];\r\n    protected readonly context: Context;\r\n    private _pollingConfig$;\r\n    private _currentHeadPromise;\r\n    private currentHead$;\r\n    private polling$;\r\n    private confirmed$;\r\n    protected _foundAt: number;\r\n    get includedInBlock(): number;\r\n    /**\r\n     *\r\n     * @param hash Operation hash\r\n     * @param raw Raw operation that was injected\r\n     * @param context Taquito context allowing access to rpc and signer\r\n     */\r\n    constructor(hash: string, raw: ForgedBytes, results: OperationContentsAndResult[], context: Context);\r\n    get revealOperation(): false | OperationContentsAndResultReveal | undefined;\r\n    get revealStatus(): \"applied\" | \"failed\" | \"skipped\" | \"backtracked\" | \"unknown\";\r\n    get status(): \"applied\" | \"failed\" | \"skipped\" | \"backtracked\" | \"unknown\";\r\n    /**\r\n     *\r\n     * @param confirmations [0] Number of confirmation to wait for\r\n     * @param interval [10] Polling interval\r\n     * @param timeout [180] Timeout\r\n     */\r\n    confirmation(confirmations?: number, interval?: number, timeout?: number): Promise<number>;\r\n}\r\n"},{"name":"@taquito/operations/origination-operation.d.ts","dts":"import { OperationContentsAndResult, OperationResultOrigination } from '@taquito/rpc';\r\nimport { Context } from '../context';\r\nimport { RpcContractProvider } from '../contract/rpc-contract-provider';\r\nimport { Operation } from './operations';\r\nimport { FeeConsumingOperation, ForgedBytes, GasConsumingOperation, RPCOriginationOperation, StorageConsumingOperation } from './types';\r\n/**\r\n * @description Origination operation provide utility function to fetch newly originated contract\r\n *\r\n * @warn Currently support only one origination per operation\r\n */\r\nexport declare class OriginationOperation extends Operation implements GasConsumingOperation, StorageConsumingOperation, FeeConsumingOperation {\r\n    private readonly params;\r\n    private contractProvider;\r\n    /**\r\n     * @description Contract address of the newly originated contract\r\n     */\r\n    readonly contractAddress?: string;\r\n    constructor(hash: string, params: RPCOriginationOperation, raw: ForgedBytes, results: OperationContentsAndResult[], context: Context, contractProvider: RpcContractProvider);\r\n    get status(): \"applied\" | \"failed\" | \"skipped\" | \"backtracked\" | \"unknown\";\r\n    get operationResults(): OperationResultOrigination | undefined;\r\n    get fee(): number;\r\n    get gasLimit(): number;\r\n    get storageLimit(): number;\r\n    get consumedGas(): string | undefined;\r\n    get storageDiff(): string | undefined;\r\n    get storageSize(): string | undefined;\r\n    get errors(): import(\"@taquito/rpc\").TezosGenericOperationError[] | undefined;\r\n    /**\r\n     * @description Provide the contract abstract of the newly originated contract\r\n     */\r\n    contract(confirmations?: number, interval?: number, timeout?: number): Promise<import(\"../contract\").ContractAbstraction<import(\"../contract\").ContractProvider>>;\r\n}\r\n"},{"name":"@taquito/operations/transaction-operation.d.ts","dts":"import { OperationContentsAndResult, OperationContentsAndResultTransaction } from '@taquito/rpc';\r\nimport BigNumber from 'bignumber.js';\r\nimport { Context } from '../context';\r\nimport { Operation } from './operations';\r\nimport { FeeConsumingOperation, ForgedBytes, GasConsumingOperation, RPCTransferOperation, StorageConsumingOperation } from './types';\r\n/**\r\n * @description Transaction operation provides utility functions to fetch a newly issued transaction\r\n *\r\n * @warn Currently supports one transaction per operation\r\n */\r\nexport declare class TransactionOperation extends Operation implements GasConsumingOperation, StorageConsumingOperation, FeeConsumingOperation {\r\n    private readonly params;\r\n    readonly source: string;\r\n    constructor(hash: string, params: RPCTransferOperation, source: string, raw: ForgedBytes, results: OperationContentsAndResult[], context: Context);\r\n    get operationResults(): OperationContentsAndResultTransaction[];\r\n    get status(): \"applied\" | \"failed\" | \"skipped\" | \"backtracked\" | \"unknown\";\r\n    get amount(): BigNumber;\r\n    get destination(): string;\r\n    get fee(): number;\r\n    get gasLimit(): number;\r\n    get storageLimit(): number;\r\n    private sumProp;\r\n    get consumedGas(): string;\r\n    get storageDiff(): string;\r\n    get storageSize(): string;\r\n    get errors(): import(\"@taquito/rpc\").TezosGenericOperationError[];\r\n}\r\n"},{"name":"@taquito/operations/types.d.ts","dts":"import { OperationObject, InternalOperationResultKindEnum, OpKind, TransactionOperationParameter } from '@taquito/rpc';\r\nexport { OpKind } from '@taquito/rpc';\r\nexport declare type withKind<T, K extends OpKind> = T & {\r\n    kind: K;\r\n};\r\nexport declare type ParamsWithKind = withKind<OriginateParams, OpKind.ORIGINATION> | withKind<DelegateParams, OpKind.DELEGATION> | withKind<TransferParams, OpKind.TRANSACTION> | withKind<ActivationParams, OpKind.ACTIVATION>;\r\nexport declare const attachKind: <T, K extends OpKind>(op: T, kind: K) => withKind<T, K>;\r\nexport declare const findWithKind: <T extends {\r\n    kind: OpKind;\r\n}, K extends OpKind>(arr: T[], kind: K) => (T & {\r\n    kind: K;\r\n}) | undefined;\r\nexport declare const isKind: <T extends {\r\n    kind: OpKind;\r\n}, K extends OpKind>(op: T, kind: K) => op is withKind<T, K>;\r\nexport declare type RPCOpWithFee = RPCTransferOperation | RPCOriginationOperation | RPCDelegateOperation | RPCRevealOperation;\r\nexport declare type RPCOpWithSource = RPCTransferOperation | RPCOriginationOperation | RPCDelegateOperation | RPCRevealOperation;\r\nexport declare const isOpWithFee: <T extends {\r\n    kind: OpKind;\r\n}>(op: T) => op is withKind<T, InternalOperationResultKindEnum>;\r\nexport declare const isOpRequireReveal: <T extends {\r\n    kind: OpKind;\r\n}>(op: T) => op is withKind<T, OpKind.ORIGINATION | OpKind.DELEGATION | OpKind.TRANSACTION>;\r\nexport declare type SourceKinds = InternalOperationResultKindEnum;\r\nexport declare const isSourceOp: <T extends {\r\n    kind: OpKind;\r\n}>(op: T) => op is withKind<T, InternalOperationResultKindEnum>;\r\nexport declare const hasMetadata: <T extends {\r\n    kind: OpKind;\r\n}, K>(op: T) => op is T & {\r\n    metadata: K;\r\n};\r\nexport declare const hasMetadataWithResult: <T extends {\r\n    kind: OpKind;\r\n}, K>(op: T) => op is T & {\r\n    metadata: {\r\n        operation_result: K;\r\n    };\r\n};\r\nexport declare const hasMetadataWithInternalOperationResult: <T extends {\r\n    kind: OpKind;\r\n}, K>(op: T) => op is T & {\r\n    metadata: {\r\n        internal_operation_results?: K | undefined;\r\n    };\r\n};\r\nexport interface GasConsumingOperation {\r\n    consumedGas?: string;\r\n    gasLimit: number;\r\n}\r\nexport interface StorageConsumingOperation {\r\n    storageDiff?: string;\r\n    storageSize?: string;\r\n    storageLimit: number;\r\n}\r\nexport interface FeeConsumingOperation {\r\n    fee: number;\r\n}\r\nexport declare type OriginateParamsBase = {\r\n    balance?: string;\r\n    code: string | object[];\r\n    delegate?: string;\r\n    fee?: number;\r\n    gasLimit?: number;\r\n    storageLimit?: number;\r\n    mutez?: boolean;\r\n};\r\n/**\r\n * @description Parameters for originate method\r\n */\r\nexport declare type OriginateParams = OriginateParamsBase & ({\r\n    init?: never;\r\n    /** JS representation of a storage object */\r\n    storage: any;\r\n} | {\r\n    /** Initial storage object value. Either Micheline or JSON encoded */\r\n    init: string | object;\r\n    storage?: never;\r\n});\r\nexport interface ActivationParams {\r\n    pkh: string;\r\n    secret: string;\r\n}\r\n/**\r\n * @description RPC origination operation\r\n */\r\nexport interface RPCOriginationOperation {\r\n    kind: OpKind.ORIGINATION;\r\n    fee: number;\r\n    gas_limit: number;\r\n    storage_limit: number;\r\n    balance: string;\r\n    delegate?: string;\r\n    source?: string;\r\n    script: {\r\n        code: any;\r\n        storage: any;\r\n    };\r\n}\r\n/**\r\n * @description RPC reveal operation\r\n */\r\nexport interface RPCRevealOperation {\r\n    kind: OpKind.REVEAL;\r\n    fee: number;\r\n    public_key: string;\r\n    source?: string;\r\n    gas_limit: number;\r\n    storage_limit: number;\r\n}\r\n/**\r\n * @description Result of a forge operation contains the operation plus its encoded version\r\n */\r\nexport interface ForgedBytes {\r\n    opbytes: string;\r\n    opOb: OperationObject;\r\n    counter: number;\r\n}\r\n/**\r\n * @description Parameters for setDelegate method\r\n */\r\nexport interface DelegateParams {\r\n    source: string;\r\n    delegate: string;\r\n    fee?: number;\r\n    gasLimit?: number;\r\n    storageLimit?: number;\r\n}\r\n/**\r\n * @description Parameters for registerDelegate method\r\n */\r\nexport interface RegisterDelegateParams {\r\n    fee?: number;\r\n    gasLimit?: number;\r\n    storageLimit?: number;\r\n}\r\n/**\r\n * @description RPC delegation operation\r\n */\r\nexport interface RPCDelegateOperation {\r\n    kind: OpKind.DELEGATION;\r\n    source?: string;\r\n    fee: number;\r\n    gas_limit: number;\r\n    storage_limit: number;\r\n    delegate: string;\r\n}\r\n/**\r\n * @description Parameters for transfer method\r\n */\r\nexport interface TransferParams {\r\n    to: string;\r\n    source?: string;\r\n    amount: number;\r\n    fee?: number;\r\n    parameter?: TransactionOperationParameter;\r\n    gasLimit?: number;\r\n    storageLimit?: number;\r\n    mutez?: boolean;\r\n}\r\n/**\r\n * @description RPC transfer operation\r\n */\r\nexport interface RPCTransferOperation {\r\n    kind: OpKind.TRANSACTION;\r\n    fee: number;\r\n    gas_limit: number;\r\n    storage_limit: number;\r\n    amount: string;\r\n    source?: string;\r\n    destination: string;\r\n    parameters?: TransactionOperationParameter;\r\n}\r\n/**\r\n * @description RPC activate account operation\r\n */\r\nexport interface RPCActivateOperation {\r\n    kind: OpKind.ACTIVATION;\r\n    pkh: string;\r\n    secret: string;\r\n}\r\nexport declare type RPCOperation = RPCOriginationOperation | RPCTransferOperation | RPCDelegateOperation | RPCRevealOperation | RPCActivateOperation;\r\nexport declare type PrepareOperationParams = {\r\n    operation: RPCOperation | RPCOperation[];\r\n    source?: string;\r\n};\r\n"},{"name":"@taquito/parser/interface.d.ts","dts":"import { OriginateParams } from '../operations/types';\r\nexport interface ParserProvider {\r\n    prepareCodeOrigination(params: OriginateParams): Promise<OriginateParams>;\r\n}\r\n"},{"name":"@taquito/parser/michel-codec-parser.d.ts","dts":"import { Context } from '../context';\r\nimport { ParserProvider } from './interface';\r\nimport { Expr } from '@taquito/michel-codec';\r\nimport { OriginateParams } from '../operations/types';\r\nexport declare class MichelCodecParser implements ParserProvider {\r\n    private context;\r\n    constructor(context: Context);\r\n    private getNextProto;\r\n    parseScript(src: string): Promise<Expr[] | null>;\r\n    parseMichelineExpression(src: string): Promise<Expr | null>;\r\n    parseJSON(src: object): Promise<Expr>;\r\n    prepareCodeOrigination(params: OriginateParams): Promise<OriginateParams>;\r\n    private formatCodeParam;\r\n    private formatInitParam;\r\n}\r\n"},{"name":"@taquito/parser/noop-parser.d.ts","dts":"import { OriginateParams } from \"../operations/types\";\r\nimport { ParserProvider } from \"./interface\";\r\nexport declare class NoopParser implements ParserProvider {\r\n    prepareCodeOrigination(params: OriginateParams): Promise<OriginateParams>;\r\n}\r\n"},{"name":"@taquito/signer/interface.d.ts","dts":"/**\r\n * @description Signer interface which is used across taquito in order to sign and inject operation\r\n */\r\nexport interface Signer {\r\n    /**\r\n     *\r\n     * @param op Operation to sign\r\n     * @param magicByte Magic bytes 1 for block, 2 for endorsement, 3 for generic\r\n     */\r\n    sign(op: {}, magicByte?: Uint8Array): Promise<{\r\n        bytes: string;\r\n        sig: string;\r\n        prefixSig: string;\r\n        sbytes: string;\r\n    }>;\r\n    /**\r\n     * @description Return the public key of the account used by the signer\r\n     */\r\n    publicKey(): Promise<string>;\r\n    /**\r\n     * @description Return the public key hash of the account used by the signer\r\n     */\r\n    publicKeyHash(): Promise<string>;\r\n    /**\r\n     * @description Optionally return the secret key of the account used by the signer\r\n     */\r\n    secretKey(): Promise<string | undefined>;\r\n}\r\n"},{"name":"@taquito/signer/noop.d.ts","dts":"import { Signer } from './interface';\r\nexport declare class UnconfiguredSignerError implements Error {\r\n    name: string;\r\n    message: string;\r\n}\r\n/**\r\n * @description Default signer implementation which does nothing and produce invalid signature\r\n */\r\nexport declare class NoopSigner implements Signer {\r\n    publicKey(): Promise<string>;\r\n    publicKeyHash(): Promise<string>;\r\n    secretKey(): Promise<string>;\r\n    sign(_bytes: string, _watermark?: Uint8Array): Promise<any>;\r\n}\r\n"},{"name":"@taquito/subscribe/filters.d.ts","dts":"import { OpFilter, FilterExpression, Filter, OperationContent } from './interface';\r\nexport declare const evaluateOpFilter: (op: OperationContent, filter: OpFilter) => boolean | undefined;\r\nexport declare const evaluateExpression: (op: OperationContent, exp: FilterExpression) => boolean;\r\nexport declare const evaluateFilter: (op: OperationContent, filter: Filter) => boolean;\r\n"},{"name":"@taquito/subscribe/interface.d.ts","dts":"import { OperationEntry } from '@taquito/rpc';\r\nexport declare type FilterExpression = {\r\n    or?: ExpressionOrOpFilter[];\r\n    and?: ExpressionOrOpFilter[];\r\n};\r\nexport interface OpHashFilter {\r\n    opHash: string;\r\n}\r\nexport interface SourceFilter {\r\n    source: string;\r\n}\r\nexport interface KindFilter {\r\n    kind: string;\r\n}\r\nexport interface DestinationFilter {\r\n    destination: string;\r\n}\r\nexport declare type OpFilter = OpHashFilter | SourceFilter | KindFilter | DestinationFilter;\r\nexport declare type ExpressionOrOpFilter = OpFilter | FilterExpression;\r\nexport declare type Filter = ExpressionOrOpFilter | ExpressionOrOpFilter[];\r\nexport declare type OperationContent = OperationEntry['contents'][0] & {\r\n    hash: string;\r\n};\r\nexport interface SubscribeProvider {\r\n    subscribe(filter: 'head'): Subscription<string>;\r\n    subscribeOperation(filter: Filter): Subscription<OperationContent>;\r\n}\r\nexport interface Subscription<T> {\r\n    on(type: 'error', cb: (error: Error) => void): void;\r\n    on(type: 'data', cb: (data: T) => void): void;\r\n    on(type: 'close', cb: () => void): void;\r\n    off(type: 'error', cb: (error: Error) => void): void;\r\n    off(type: 'data', cb: (data: T) => void): void;\r\n    off(type: 'close', cb: () => void): void;\r\n    close(): void;\r\n}\r\n"},{"name":"@taquito/subscribe/observable-subscription.d.ts","dts":"import { Observable } from 'rxjs';\r\nimport { Subscription } from './interface';\r\nexport declare class ObservableSubscription<T> implements Subscription<T> {\r\n    private shouldRetry;\r\n    private errorListeners;\r\n    private messageListeners;\r\n    private closeListeners;\r\n    private completed$;\r\n    constructor(obs: Observable<T>, shouldRetry?: boolean);\r\n    private call;\r\n    private remove;\r\n    on(type: 'error', cb: (error: Error) => void): void;\r\n    on(type: 'data', cb: (data: T) => void): void;\r\n    on(type: 'close', cb: () => void): void;\r\n    off(type: 'error', cb: (error: Error) => void): void;\r\n    off(type: 'data', cb: (data: T) => void): void;\r\n    off(type: 'close', cb: () => void): void;\r\n    close(): void;\r\n}\r\n"},{"name":"@taquito/subscribe/polling-provider.d.ts","dts":"import { Context } from '../context';\r\nimport { Filter, SubscribeProvider, Subscription, OperationContent } from './interface';\r\nexport declare class PollingSubscribeProvider implements SubscribeProvider {\r\n    private context;\r\n    readonly POLL_INTERVAL: number;\r\n    private newBlock$;\r\n    constructor(context: Context, POLL_INTERVAL?: number);\r\n    subscribe(_filter: 'head'): Subscription<string>;\r\n    subscribeOperation(filter: Filter): Subscription<OperationContent>;\r\n}\r\n"},{"name":"@taquito/tz/interface.d.ts","dts":"import BigNumber from 'bignumber.js';\r\nimport { Operation } from '../operations/operations';\r\nexport interface TzProvider {\r\n    /**\r\n     *\r\n     * @param address Tezos address you want to get the balance for (eg tz1...)\r\n     */\r\n    getBalance(address: string): Promise<BigNumber>;\r\n    /**\r\n     *\r\n     * @param address Tezos address you want to get the delegate for (eg tz1...)\r\n     */\r\n    getDelegate(address: string): Promise<string | null>;\r\n    activate(pkh: string, secret: string): Promise<Operation>;\r\n}\r\n"},{"name":"@taquito/tz/rpc-tz-provider.d.ts","dts":"import BigNumber from 'bignumber.js';\r\nimport { Context } from '../context';\r\nimport { OperationEmitter } from '../operations/operation-emitter';\r\nimport { Operation } from '../operations/operations';\r\nimport { TzProvider } from './interface';\r\nexport declare class RpcTzProvider extends OperationEmitter implements TzProvider {\r\n    constructor(context: Context);\r\n    getBalance(address: string): Promise<BigNumber>;\r\n    getDelegate(address: string): Promise<string | null>;\r\n    activate(pkh: string, secret: string): Promise<Operation>;\r\n}\r\n"},{"name":"@taquito/wallet/delegation-operation.d.ts","dts":"import { BlockResponse, OperationContentsAndResultReveal } from '@taquito/rpc';\r\nimport { Observable } from 'rxjs';\r\nimport { Context } from '../context';\r\nimport { WalletOperation, OperationStatus } from './operation';\r\nexport declare class DelegationWalletOperation extends WalletOperation {\r\n    readonly opHash: string;\r\n    protected readonly context: Context;\r\n    constructor(opHash: string, context: Context, newHead$: Observable<BlockResponse>);\r\n    revealOperation(): Promise<OperationContentsAndResultReveal | undefined>;\r\n    delegationOperation(): Promise<OperationContentsAndResultReveal | undefined>;\r\n    status(): Promise<OperationStatus>;\r\n}\r\n"},{"name":"@taquito/wallet/index.d.ts","dts":"export * from './wallet';\r\nexport * from './operation';\r\nexport * from './transaction-operation';\r\nexport * from './origination-operation';\r\nexport * from './delegation-operation';\r\nexport * from './interface';\r\nexport * from './legacy';\r\n"},{"name":"@taquito/wallet/interface.d.ts","dts":"import { DelegateParams, OriginateParams, TransferParams } from '../operations/types';\r\nexport declare type WalletDefinedFields = 'fee' | 'gasLimit' | 'storageLimit' | 'source';\r\nexport declare type WalletTransferParams = Omit<TransferParams, WalletDefinedFields>;\r\nexport declare type WalletOriginateParams = Omit<OriginateParams, WalletDefinedFields>;\r\nexport declare type WalletDelegateParams = Omit<DelegateParams, WalletDefinedFields>;\r\nexport interface WalletProvider {\r\n    /**\r\n     * @description Request the public key hash from the wallet\r\n     */\r\n    getPKH: () => Promise<string>;\r\n    /**\r\n     * @description Transform WalletTransferParams into a format compliant with the underlying wallet\r\n     */\r\n    mapTransferParamsToWalletParams: (params: WalletTransferParams) => Promise<any>;\r\n    /**\r\n     * @description Transform WalletOriginateParams into a format compliant with the underlying wallet\r\n     */\r\n    mapOriginateParamsToWalletParams: (params: WalletOriginateParams) => Promise<any>;\r\n    /**\r\n     * @description Transform WalletDelegateParams into a format compliant with the underlying wallet\r\n     */\r\n    mapDelegateParamsToWalletParams: (params: WalletDelegateParams) => Promise<any>;\r\n    /**\r\n     * @description Request the wallet to send an operation batch\r\n     */\r\n    sendOperations: (params: any[]) => Promise<string>;\r\n}\r\n"},{"name":"@taquito/wallet/legacy.d.ts","dts":"import { Context } from '../context';\r\nimport { OpKind } from '../operations/types';\r\nimport { WalletDelegateParams, WalletOriginateParams, WalletProvider, WalletTransferParams } from './interface';\r\nimport { WalletParamsWithKind } from './wallet';\r\nexport declare class LegacyWalletProvider implements WalletProvider {\r\n    private context;\r\n    constructor(context: Context);\r\n    getPKH(): Promise<string>;\r\n    mapTransferParamsToWalletParams(params: WalletTransferParams): Promise<import(\"../operations/types\").withKind<Pick<import(\"../operations/types\").TransferParams, \"to\" | \"amount\" | \"parameter\" | \"mutez\">, OpKind.TRANSACTION>>;\r\n    mapOriginateParamsToWalletParams(params: WalletOriginateParams): Promise<import(\"../operations/types\").withKind<Pick<import(\"../operations/types\").OriginateParams, \"mutez\" | \"balance\" | \"code\" | \"delegate\" | \"init\" | \"storage\">, OpKind.ORIGINATION>>;\r\n    mapDelegateParamsToWalletParams(params: WalletDelegateParams): Promise<import(\"../operations/types\").withKind<Pick<import(\"../operations/types\").DelegateParams, \"delegate\">, OpKind.DELEGATION>>;\r\n    sendOperations(params: WalletParamsWithKind[]): Promise<string>;\r\n}\r\n"},{"name":"@taquito/wallet/operation.d.ts","dts":"import { BlockResponse, OperationContentsAndResult, OperationResultStatusEnum } from '@taquito/rpc';\r\nimport { Observable, ReplaySubject } from 'rxjs';\r\nimport { Context } from '../context';\r\nimport { Receipt } from './receipt';\r\nexport declare type OperationStatus = 'pending' | 'unknown' | OperationResultStatusEnum;\r\nexport declare class MissedBlockDuringConfirmationError implements Error {\r\n    name: string;\r\n    message: string;\r\n}\r\n/**\r\n * @description WalletOperation allows to monitor operation inclusion on chains and surface information related to the operation\r\n */\r\nexport declare class WalletOperation {\r\n    readonly opHash: string;\r\n    protected readonly context: Context;\r\n    private _newHead$;\r\n    protected _operationResult: ReplaySubject<OperationContentsAndResult[]>;\r\n    protected _includedInBlock: ReplaySubject<BlockResponse>;\r\n    protected _included: boolean;\r\n    private lastHead;\r\n    protected newHead$: Observable<BlockResponse>;\r\n    private confirmed$;\r\n    operationResults(): Promise<OperationContentsAndResult[]>;\r\n    /**\r\n     * @description Receipt expose the total amount of tezos token burn and spent on fees\r\n     * The promise returned by receipt will resolve only once the transaction is included\r\n     */\r\n    receipt(): Promise<Receipt>;\r\n    /**\r\n     *\r\n     * @param opHash Operation hash\r\n     * @param raw Raw operation that was injected\r\n     * @param context Taquito context allowing access to rpc and signer\r\n     */\r\n    constructor(opHash: string, context: Context, _newHead$: Observable<BlockResponse>);\r\n    getCurrentConfirmation(): Promise<number>;\r\n    isInCurrentBranch(tipBlockIdentifier?: string): Promise<boolean>;\r\n    confirmationObservable(confirmations?: number): Observable<{\r\n        block: BlockResponse;\r\n        expectedConfirmation: number;\r\n        currentConfirmation: number;\r\n        completed: boolean;\r\n        isInCurrentBranch: () => Promise<boolean>;\r\n    }>;\r\n    /**\r\n     *\r\n     * @param confirmations [0] Number of confirmation to wait for\r\n     */\r\n    confirmation(confirmations?: number): Promise<{\r\n        block: BlockResponse;\r\n        expectedConfirmation: number;\r\n        currentConfirmation: number;\r\n        completed: boolean;\r\n        isInCurrentBranch: () => Promise<boolean>;\r\n    }>;\r\n}\r\n"},{"name":"@taquito/wallet/opreation-factory.d.ts","dts":"import { BlockResponse } from '@taquito/rpc';\r\nimport { MonoTypeOperatorFunction, Observable, SchedulerLike } from 'rxjs';\r\nimport { Context } from '../context';\r\nimport { DelegationWalletOperation } from './delegation-operation';\r\nimport { WalletOperation } from './operation';\r\nimport { OriginationWalletOperation } from './origination-operation';\r\nimport { TransactionWalletOperation } from './transaction-operation';\r\nexport declare const cacheUntil: <T>(cacheUntilObs: Observable<any>) => MonoTypeOperatorFunction<T>;\r\nexport declare const createNewPollingBasedHeadObservable: (pollingTimer: Observable<number>, sharedHeadOb: Observable<BlockResponse>, context: Context, scheduler?: SchedulerLike | undefined) => Observable<BlockResponse>;\r\nexport interface OperationFactoryConfig {\r\n    blockIdentifier?: string;\r\n}\r\nexport declare class OperationFactory {\r\n    private context;\r\n    constructor(context: Context);\r\n    private sharedHeadObs;\r\n    private createNewHeadObservable;\r\n    private createPastBlockWalker;\r\n    private createHeadObservableFromConfig;\r\n    createOperation(hash: string, config?: OperationFactoryConfig): WalletOperation;\r\n    createTransactionOperation(hash: string, config?: OperationFactoryConfig): TransactionWalletOperation;\r\n    createDelegationOperation(hash: string, config?: OperationFactoryConfig): DelegationWalletOperation;\r\n    createOriginationOperation(hash: string, config?: OperationFactoryConfig): OriginationWalletOperation;\r\n}\r\n"},{"name":"@taquito/wallet/origination-operation.d.ts","dts":"import { BlockResponse, OperationContentsAndResultOrigination, OperationContentsAndResultReveal } from '@taquito/rpc';\r\nimport { Observable } from 'rxjs';\r\nimport { Context } from '../context';\r\nimport { WalletOperation, OperationStatus } from './operation';\r\nexport declare class OriginationWalletOperation extends WalletOperation {\r\n    readonly opHash: string;\r\n    protected readonly context: Context;\r\n    constructor(opHash: string, context: Context, newHead$: Observable<BlockResponse>);\r\n    originationOperation(): Promise<OperationContentsAndResultOrigination | undefined>;\r\n    revealOperation(): Promise<OperationContentsAndResultReveal | undefined>;\r\n    status(): Promise<OperationStatus>;\r\n    contract(): Promise<import(\"../contract\").ContractAbstraction<import(\"./wallet\").Wallet>>;\r\n}\r\n"},{"name":"@taquito/wallet/receipt.d.ts","dts":"import { OperationContentsAndResult } from '@taquito/rpc';\r\nimport BigNumber from 'bignumber.js';\r\nexport interface Receipt {\r\n    totalFee: BigNumber;\r\n    totalGas: BigNumber;\r\n    totalStorage: BigNumber;\r\n    totalAllocationBurn: BigNumber;\r\n    totalOriginationBurn: BigNumber;\r\n    totalPaidStorageDiff: BigNumber;\r\n    totalStorageBurn: BigNumber;\r\n}\r\nexport declare const receiptFromOperation: (op: OperationContentsAndResult[], { ALLOCATION_BURN, ORIGINATION_BURN }?: {\r\n    ALLOCATION_BURN: number;\r\n    ORIGINATION_BURN: number;\r\n}) => Receipt;\r\n"},{"name":"@taquito/wallet/transaction-operation.d.ts","dts":"import { WalletOperation, OperationStatus } from './operation';\r\nimport { Context } from '../context';\r\nimport { Observable } from 'rxjs';\r\nimport { BlockResponse, OperationContentsAndResultReveal, OperationContentsAndResultTransaction } from '@taquito/rpc';\r\nexport declare class TransactionWalletOperation extends WalletOperation {\r\n    readonly opHash: string;\r\n    protected readonly context: Context;\r\n    constructor(opHash: string, context: Context, newHead$: Observable<BlockResponse>);\r\n    revealOperation(): Promise<OperationContentsAndResultReveal | undefined>;\r\n    transactionOperation(): Promise<OperationContentsAndResultTransaction | undefined>;\r\n    status(): Promise<OperationStatus>;\r\n}\r\n"},{"name":"@taquito/wallet/wallet.d.ts","dts":"import { Context } from '../context';\r\nimport { ContractAbstraction, ContractMethod } from '../contract';\r\nimport { OpKind, withKind } from '../operations/types';\r\nimport { WalletDelegateParams, WalletOriginateParams, WalletProvider, WalletTransferParams } from './interface';\r\nexport interface PKHOption {\r\n    forceRefetch?: boolean;\r\n}\r\nexport declare type WalletParamsWithKind = withKind<WalletTransferParams, OpKind.TRANSACTION> | withKind<WalletOriginateParams, OpKind.ORIGINATION> | withKind<WalletDelegateParams, OpKind.DELEGATION>;\r\nexport declare class WalletOperationBatch {\r\n    private walletProvider;\r\n    private context;\r\n    private operations;\r\n    constructor(walletProvider: WalletProvider, context: Context);\r\n    /**\r\n     *\r\n     * @description Add a transaction operation to the batch\r\n     *\r\n     * @param params Transfer operation parameter\r\n     */\r\n    withTransfer(params: WalletTransferParams): this;\r\n    /**\r\n     *\r\n     * @description Add a transaction operation to the batch\r\n     *\r\n     * @param params Transfer operation parameter\r\n     */\r\n    withContractCall(params: ContractMethod<Wallet>): this;\r\n    /**\r\n     *\r\n     * @description Add a delegation operation to the batch\r\n     *\r\n     * @param params Delegation operation parameter\r\n     */\r\n    withDelegation(params: WalletDelegateParams): this;\r\n    /**\r\n     *\r\n     * @description Add an origination operation to the batch\r\n     *\r\n     * @param params Origination operation parameter\r\n     */\r\n    withOrigination(params: WalletOriginateParams): this;\r\n    private mapOperation;\r\n    /**\r\n     *\r\n     * @description Add a group operation to the batch. Operation will be applied in the order they are in the params array\r\n     *\r\n     * @param params Operations parameter\r\n     */\r\n    with(params: WalletParamsWithKind[]): this;\r\n    /**\r\n     *\r\n     * @description Submit batch operation to wallet\r\n     *\r\n     */\r\n    send(): Promise<import(\"./operation\").WalletOperation>;\r\n}\r\nexport declare class Wallet {\r\n    private context;\r\n    constructor(context: Context);\r\n    private get walletProvider();\r\n    private _pkh?;\r\n    /**\r\n     * @description Retrieve the PKH of the account that is currently in use by the wallet\r\n     *\r\n     * @param option Option to use while fetching the PKH.\r\n     * If forceRefetch is specified the wallet provider implementation will refetch the PKH from the wallet\r\n     */\r\n    pkh({ forceRefetch }?: PKHOption): Promise<string>;\r\n    private walletCommand;\r\n    /**\r\n     *\r\n     * @description Originate a new contract according to the script in parameters.\r\n     *\r\n     * @returns An operation handle with the result from the rpc node\r\n     *\r\n     * @param originateParams Originate operation parameter\r\n     */\r\n    originate(params: WalletOriginateParams): {\r\n        send: () => Promise<import(\"./origination-operation\").OriginationWalletOperation>;\r\n    };\r\n    /**\r\n     *\r\n     * @description Set the delegate for a contract.\r\n     *\r\n     * @returns An operation handle with the result from the rpc node\r\n     *\r\n     * @param delegateParams operation parameter\r\n     */\r\n    setDelegate(params: WalletDelegateParams): {\r\n        send: () => Promise<import(\"./delegation-operation\").DelegationWalletOperation>;\r\n    };\r\n    /**\r\n     *\r\n     * @description Register the current address as delegate.\r\n     *\r\n     * @returns An operation handle with the result from the rpc node\r\n     *\r\n     */\r\n    registerDelegate(): {\r\n        send: () => Promise<import(\"./delegation-operation\").DelegationWalletOperation>;\r\n    };\r\n    /**\r\n     *\r\n     * @description Transfer tezos tokens from current address to a specific address or call a smart contract.\r\n     *\r\n     * @returns A wallet command from which we can send the operation to the wallet\r\n     *\r\n     * @param params operation parameter\r\n     */\r\n    transfer(params: WalletTransferParams): {\r\n        send: () => Promise<import(\"./transaction-operation\").TransactionWalletOperation>;\r\n    };\r\n    /**\r\n     *\r\n     * @description Create a batch of operation\r\n     *\r\n     * @returns A batch object from which we can add more operation or send a command to the wallet to execute the batch\r\n     *\r\n     * @param params List of operation to initialize the batch with\r\n     */\r\n    batch(params?: Parameters<WalletOperationBatch['with']>[0]): WalletOperationBatch;\r\n    /**\r\n     *\r\n     * @description Create an smart contract abstraction for the address specified. Calling entrypoints with the returned\r\n     * smart contract abstraction will leverage the wallet provider to make smart contract calls\r\n     *\r\n     * @param address Smart contract address\r\n     */\r\n    at<T extends ContractAbstraction<Wallet>>(address: string, contractAbstractionComposer?: (abs: ContractAbstraction<Wallet>, context: Context) => T): Promise<T>;\r\n}\r\n"},{"name":"@taquito/constants.d.ts","dts":"export declare enum DEFAULT_GAS_LIMIT {\r\n    DELEGATION = 10600,\r\n    ORIGINATION = 10600,\r\n    TRANSFER = 10600,\r\n    REVEAL = 10600\r\n}\r\nexport declare enum DEFAULT_FEE {\r\n    DELEGATION = 1257,\r\n    ORIGINATION = 10000,\r\n    TRANSFER = 10000,\r\n    REVEAL = 1420\r\n}\r\nexport declare enum DEFAULT_STORAGE_LIMIT {\r\n    DELEGATION = 0,\r\n    ORIGINATION = 257,\r\n    TRANSFER = 257,\r\n    REVEAL = 0\r\n}\r\nexport declare enum Protocols {\r\n    Pt24m4xi = \"Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd\",\r\n    PsBABY5H = \"PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU\",\r\n    PsBabyM1 = \"PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS\",\r\n    PsCARTHA = \"PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb\",\r\n    PsDELPH1 = \"PsDELPH1Kxsxt8f9eWbxQeRxkjfbxoqM52jvs5Y5fBxWWh4ifpo\",\r\n    PtEdo2Zk = \"PtEdo2ZkT9oKpimTah6x2embF25oss54njMuPzkJTEi5RqfdZFA\"\r\n}\r\nexport declare const protocols: {\r\n    '004': Protocols[];\r\n    '005': Protocols[];\r\n    '006': Protocols[];\r\n    '007': Protocols[];\r\n    '008': Protocols[];\r\n};\r\nexport declare enum DefaultLambdaAddresses {\r\n    MAINNET = \"KT1CPuTzwC7h7uLXd5WQmpMFso1HxrLBUtpE\",\r\n    CARTHAGENET = \"KT1VAy1o1FGiXYfD3YT7x7k5eF5HSHhmc1u6\",\r\n    DELPHINET = \"KT19abMFs3haqyKYwqdLjK9GbtofryZLvpiK\",\r\n    EDONET = \"KT1A64nVZDccAHGAsf1ZyVajXZcbiwjV3SnN\"\r\n}\r\nexport declare enum ChainIds {\r\n    MAINNET = \"NetXdQprcVkpaWU\",\r\n    CARTHAGENET = \"NetXjD3HPJJjmcd\",\r\n    DELPHINET = \"NetXm8tYqnMWky1\",\r\n    EDONET = \"NetXSgo1ZT2DRUG\"\r\n}\r\n"},{"name":"@taquito/context.d.ts","dts":"import { RpcClient } from '@taquito/rpc';\r\nimport { Protocols } from './constants';\r\nimport { Forger } from './forger/interface';\r\nimport { Injector } from './injector/interface';\r\nimport { Signer } from './signer/interface';\r\nimport { OperationFactory } from './wallet/opreation-factory';\r\nimport { RpcTzProvider } from './tz/rpc-tz-provider';\r\nimport { RPCEstimateProvider } from './contract/rpc-estimate-provider';\r\nimport { RpcContractProvider } from './contract/rpc-contract-provider';\r\nimport { RPCBatchProvider } from './batch/rpc-batch-provider';\r\nimport { Wallet, WalletProvider } from './wallet';\r\nimport { ParserProvider } from './parser/interface';\r\nexport interface TaquitoProvider<T, K extends Array<any>> {\r\n    new (context: Context, ...rest: K): T;\r\n}\r\nexport interface Config {\r\n    confirmationPollingIntervalSecond?: number;\r\n    confirmationPollingTimeoutSecond?: number;\r\n    defaultConfirmationCount?: number;\r\n    shouldObservableSubscriptionRetry?: boolean;\r\n}\r\nexport declare const defaultConfig: Required<Config>;\r\n/**\r\n * @description Encapsulate common service used throughout different part of the library\r\n */\r\nexport declare class Context {\r\n    private _rpc;\r\n    private _signer;\r\n    private _proto?;\r\n    private _config?;\r\n    private _rpcClient;\r\n    private _forger;\r\n    private _parser;\r\n    private _injector;\r\n    private _walletProvider;\r\n    readonly operationFactory: OperationFactory;\r\n    readonly tz: RpcTzProvider;\r\n    readonly estimate: RPCEstimateProvider;\r\n    readonly contract: RpcContractProvider;\r\n    readonly batch: RPCBatchProvider;\r\n    readonly wallet: Wallet;\r\n    constructor(_rpc: RpcClient | string, _signer?: Signer, _proto?: Protocols | undefined, _config?: Partial<Config> | undefined, forger?: Forger, injector?: Injector, wallet?: WalletProvider, parser?: ParserProvider);\r\n    get config(): Required<Config>;\r\n    set config(value: Required<Config>);\r\n    get rpc(): RpcClient;\r\n    set rpc(value: RpcClient);\r\n    get injector(): Injector;\r\n    set injector(value: Injector);\r\n    get forger(): Forger;\r\n    set forger(value: Forger);\r\n    get signer(): Signer;\r\n    get walletProvider(): WalletProvider;\r\n    set walletProvider(value: WalletProvider);\r\n    set signer(value: Signer);\r\n    set proto(value: Protocols | undefined);\r\n    get proto(): Protocols | undefined;\r\n    get parser(): ParserProvider;\r\n    set parser(value: ParserProvider);\r\n    isAnyProtocolActive(protocol?: string[]): Promise<boolean>;\r\n    /**\r\n     * @description Create a copy of the current context. Useful when you have long running operation and you do not want a context change to affect the operation\r\n     */\r\n    clone(): Context;\r\n}\r\n"},{"name":"@taquito/format.d.ts","dts":"import BigNumber from 'bignumber.js';\r\nexport declare function format(from: \"tz\" | \"mtz\" | \"mutez\" | undefined, to: \"tz\" | \"mtz\" | \"mutez\" | undefined, amount: number | string | BigNumber): string | number | BigNumber;\r\n"},{"name":"@taquito/taquito.d.ts","dts":"/**\r\n * @packageDocumentation\r\n * @module @taquito/taquito\r\n */\r\nimport { RpcClient } from '@taquito/rpc';\r\nimport { RPCBatchProvider } from './batch/rpc-batch-provider';\r\nimport { Protocols } from './constants';\r\nimport { Config, TaquitoProvider } from './context';\r\nimport { ContractProvider, EstimationProvider } from './contract/interface';\r\nimport { Extension } from './extension/extension';\r\nimport { Forger } from './forger/interface';\r\nimport { format } from './format';\r\nimport { Signer } from './signer/interface';\r\nimport { SubscribeProvider } from './subscribe/interface';\r\nimport { TzProvider } from './tz/interface';\r\nimport { Wallet, WalletProvider } from './wallet';\r\nimport { OperationFactory } from './wallet/opreation-factory';\r\nexport { MichelsonMap, UnitValue } from '@taquito/michelson-encoder';\r\nexport * from './constants';\r\nexport * from './context';\r\nexport { TaquitoProvider } from './context';\r\nexport * from './contract';\r\nexport * from './contract/big-map';\r\nexport { CompositeForger } from './forger/composite-forger';\r\nexport * from './forger/interface';\r\nexport { RpcForger } from './forger/rpc-forger';\r\nexport { TezosOperationError, TezosOperationErrorWithMessage, TezosPreapplyFailureError, } from './operations/operation-errors';\r\nexport { OpKind } from './operations/types';\r\nexport * from './signer/interface';\r\nexport * from './subscribe/interface';\r\nexport { SubscribeProvider } from './subscribe/interface';\r\nexport { PollingSubscribeProvider } from './subscribe/polling-provider';\r\nexport * from './tz/interface';\r\nexport * from './wallet';\r\nexport { Extension } from './extension/extension';\r\nexport * from './parser/interface';\r\nexport * from './parser/michel-codec-parser';\r\nexport * from './parser/noop-parser';\r\nexport interface SetProviderOptions {\r\n    forger?: Forger;\r\n    wallet?: WalletProvider;\r\n    rpc?: string | RpcClient;\r\n    stream?: string | SubscribeProvider;\r\n    signer?: Signer;\r\n    protocol?: Protocols;\r\n    config?: Config;\r\n}\r\n/**\r\n * @description Facade class that surfaces all of the libraries capability and allow it's configuration\r\n *\r\n * @param _rpc The RPC server to use\r\n */\r\nexport declare class TezosToolkit {\r\n    private _rpc;\r\n    private _stream;\r\n    private _options;\r\n    private _rpcClient;\r\n    private _wallet;\r\n    private _context;\r\n    /**\r\n     * @deprecated TezosToolkit.batch has been deprecated in favor of TezosToolkit.contract.batch\r\n     *\r\n     */\r\n    batch: RPCBatchProvider['batch'];\r\n    readonly format: typeof format;\r\n    constructor(_rpc: RpcClient | string);\r\n    /**\r\n     * @description Sets configuration on the Tezos Taquito instance. Allows user to choose which signer, rpc client, rpc url, forger and so forth\r\n     *\r\n     * @param options rpc url or rpcClient to use to interact with the Tezos network\r\n     *\r\n     * @example Tezos.setProvider({rpc: 'https://api.tez.ie/rpc/mainnet', signer: new InMemorySigner.fromSecretKey(edsk...)})\r\n     * @example Tezos.setProvider({ config: { confirmationPollingTimeoutSecond: 300 }})\r\n     *\r\n     */\r\n    setProvider({ rpc, stream, signer, protocol, config, forger, wallet }: SetProviderOptions): void;\r\n    /**\r\n     * @description Sets signer provider on the Tezos Taquito instance.\r\n     *\r\n     * @param options signer to use to interact with the Tezos network\r\n     *\r\n     * @example Tezos.setSignerProvider(new InMemorySigner.fromSecretKey('edsk...'))\r\n     *\r\n     */\r\n    setSignerProvider(signer?: SetProviderOptions['signer']): void;\r\n    /**\r\n     * @description Sets rpc provider on the Tezos Taquito instance\r\n     *\r\n     * @param options rpc url or rpcClient to use to interact with the Tezos network\r\n     *\r\n     * @example Tezos.setRpcProvider('https://api.tez.ie/rpc/mainnet')\r\n     *\r\n     */\r\n    setRpcProvider(rpc?: SetProviderOptions['rpc']): void;\r\n    /**\r\n     * @description Sets forger provider on the Tezos Taquito instance\r\n     *\r\n     * @param options forger to use to interact with the Tezos network\r\n     *\r\n     * @example Tezos.setForgerProvider(localForger)\r\n     *\r\n     */\r\n    setForgerProvider(forger?: SetProviderOptions['forger']): void;\r\n    /**\r\n     * @description Sets stream provider on the Tezos Taquito instance\r\n     *\r\n     * @param options stream to use to interact with the Tezos network\r\n     *\r\n     * @example Tezos.setStreamProvider(...)\r\n     *\r\n     */\r\n    setStreamProvider(stream?: SetProviderOptions['stream']): void;\r\n    /**\r\n     * @description Sets wallet provider on the Tezos Taquito instance\r\n     *\r\n     * @param options wallet to use to interact with the Tezos network\r\n     *\r\n     * @example Tezos.setWalletProvider(...)\r\n     *\r\n     */\r\n    setWalletProvider(wallet?: SetProviderOptions['wallet']): void;\r\n    /**\r\n     * @description Provide access to tezos account management\r\n     */\r\n    get tz(): TzProvider;\r\n    /**\r\n     * @description Provide access to smart contract utilities\r\n     */\r\n    get contract(): ContractProvider;\r\n    get wallet(): Wallet;\r\n    get operation(): OperationFactory;\r\n    /**\r\n     * @description Provide access to operation estimation utilities\r\n     */\r\n    get estimate(): EstimationProvider;\r\n    /**\r\n     * @description Provide access to streaming utilities backed by an streamer implementation\r\n     */\r\n    get stream(): SubscribeProvider;\r\n    /**\r\n     * @description Provide access to the currently used rpc client\r\n     */\r\n    get rpc(): RpcClient;\r\n    /**\r\n     * @description Provide access to the currently used signer\r\n     */\r\n    get signer(): Signer;\r\n    /**\r\n     * @description Allow to add a module to the TezosToolkit instance. This method adds the appropriate Providers(s) required by the module to the internal context.\r\n     *\r\n     * @param module extension to add to the TezosToolkit instance\r\n     *\r\n     * @example Tezos.addExtension(new Tzip16Module());\r\n     */\r\n    addExtension(module: Extension): void;\r\n    getFactory<T, K extends Array<any>>(ctor: TaquitoProvider<T, K>): (...args: K) => T;\r\n}\r\n"},{"name":"@taquito/taquito/node_modules/bignumber.js/bignumber.d.ts","dts":"// Type definitions for bignumber.js >=8.1.0\r\n// Project: https://github.com/MikeMcl/bignumber.js\r\n// Definitions by: Michael Mclaughlin <https://github.com/MikeMcl>\r\n// Definitions: https://github.com/MikeMcl/bignumber.js\r\n\r\n// Documentation: http://mikemcl.github.io/bignumber.js/\r\n//\r\n// Exports:\r\n//\r\n//   class     BigNumber (default export)\r\n//   type      BigNumber.Constructor\r\n//   type      BigNumber.ModuloMode\r\n//   type      BigNumber.RoundingMOde\r\n//   type      BigNumber.Value\r\n//   interface BigNumber.Config\r\n//   interface BigNumber.Format\r\n//   interface BigNumber.Instance\r\n//\r\n// Example:\r\n//\r\n//   import {BigNumber} from \"bignumber.js\"\r\n//   //import BigNumber from \"bignumber.js\"\r\n//\r\n//   let rm: BigNumber.RoundingMode = BigNumber.ROUND_UP;\r\n//   let f: BigNumber.Format = { decimalSeparator: ',' };\r\n//   let c: BigNumber.Config = { DECIMAL_PLACES: 4, ROUNDING_MODE: rm, FORMAT: f };\r\n//   BigNumber.config(c);\r\n//\r\n//   let v: BigNumber.Value = '12345.6789';\r\n//   let b: BigNumber = new BigNumber(v);\r\n//\r\n// The use of compiler option `--strictNullChecks` is recommended.\r\n\r\nexport default BigNumber;\r\n\r\nexport namespace BigNumber {\r\n\r\n  /** See `BigNumber.config` (alias `BigNumber.set`) and `BigNumber.clone`. */\r\n  interface Config {\r\n\r\n    /**\r\n     * An integer, 0 to 1e+9. Default value: 20.\r\n     *\r\n     * The maximum number of decimal places of the result of operations involving division, i.e.\r\n     * division, square root and base conversion operations, and exponentiation when the exponent is\r\n     * negative.\r\n     *\r\n     * ```ts\r\n     * BigNumber.config({ DECIMAL_PLACES: 5 })\r\n     * BigNumber.set({ DECIMAL_PLACES: 5 })\r\n     * ```\r\n     */\r\n    DECIMAL_PLACES?: number;\r\n\r\n    /**\r\n     * An integer, 0 to 8. Default value: `BigNumber.ROUND_HALF_UP` (4).\r\n     *\r\n     * The rounding mode used in operations that involve division (see `DECIMAL_PLACES`) and the\r\n     * default rounding mode of the `decimalPlaces`, `precision`, `toExponential`, `toFixed`,\r\n     * `toFormat` and `toPrecision` methods.\r\n     *\r\n     * The modes are available as enumerated properties of the BigNumber constructor.\r\n     *\r\n     * ```ts\r\n     * BigNumber.config({ ROUNDING_MODE: 0 })\r\n     * BigNumber.set({ ROUNDING_MODE: BigNumber.ROUND_UP })\r\n     * ```\r\n     */\r\n    ROUNDING_MODE?: BigNumber.RoundingMode;\r\n\r\n    /**\r\n     * An integer, 0 to 1e+9, or an array, [-1e+9 to 0, 0 to 1e+9].\r\n     * Default value: `[-7, 20]`.\r\n     *\r\n     * The exponent value(s) at which `toString` returns exponential notation.\r\n     *\r\n     * If a single number is assigned, the value is the exponent magnitude.\r\n     *\r\n     * If an array of two numbers is assigned then the first number is the negative exponent value at\r\n     * and beneath which exponential notation is used, and the second number is the positive exponent\r\n     * value at and above which exponential notation is used.\r\n     *\r\n     * For example, to emulate JavaScript numbers in terms of the exponent values at which they begin\r\n     * to use exponential notation, use `[-7, 20]`.\r\n     *\r\n     * ```ts\r\n     * BigNumber.config({ EXPONENTIAL_AT: 2 })\r\n     * new BigNumber(12.3)         // '12.3'        e is only 1\r\n     * new BigNumber(123)          // '1.23e+2'\r\n     * new BigNumber(0.123)        // '0.123'       e is only -1\r\n     * new BigNumber(0.0123)       // '1.23e-2'\r\n     *\r\n     * BigNumber.config({ EXPONENTIAL_AT: [-7, 20] })\r\n     * new BigNumber(123456789)    // '123456789'   e is only 8\r\n     * new BigNumber(0.000000123)  // '1.23e-7'\r\n     *\r\n     * // Almost never return exponential notation:\r\n     * BigNumber.config({ EXPONENTIAL_AT: 1e+9 })\r\n     *\r\n     * // Always return exponential notation:\r\n     * BigNumber.config({ EXPONENTIAL_AT: 0 })\r\n     * ```\r\n     *\r\n     * Regardless of the value of `EXPONENTIAL_AT`, the `toFixed` method will always return a value in\r\n     * normal notation and the `toExponential` method will always return a value in exponential form.\r\n     * Calling `toString` with a base argument, e.g. `toString(10)`, will also always return normal\r\n     * notation.\r\n     */\r\n    EXPONENTIAL_AT?: number | [number, number];\r\n\r\n    /**\r\n     * An integer, magnitude 1 to 1e+9, or an array, [-1e+9 to -1, 1 to 1e+9].\r\n     * Default value: `[-1e+9, 1e+9]`.\r\n     *\r\n     * The exponent value(s) beyond which overflow to Infinity and underflow to zero occurs.\r\n     *\r\n     * If a single number is assigned, it is the maximum exponent magnitude: values wth a positive\r\n     * exponent of greater magnitude become Infinity and those with a negative exponent of greater\r\n     * magnitude become zero.\r\n     *\r\n     * If an array of two numbers is assigned then the first number is the negative exponent limit and\r\n     * the second number is the positive exponent limit.\r\n     *\r\n     * For example, to emulate JavaScript numbers in terms of the exponent values at which they\r\n     * become zero and Infinity, use [-324, 308].\r\n     *\r\n     * ```ts\r\n     * BigNumber.config({ RANGE: 500 })\r\n     * BigNumber.config().RANGE     // [ -500, 500 ]\r\n     * new BigNumber('9.999e499')   // '9.999e+499'\r\n     * new BigNumber('1e500')       // 'Infinity'\r\n     * new BigNumber('1e-499')      // '1e-499'\r\n     * new BigNumber('1e-500')      // '0'\r\n     *\r\n     * BigNumber.config({ RANGE: [-3, 4] })\r\n     * new BigNumber(99999)         // '99999'      e is only 4\r\n     * new BigNumber(100000)        // 'Infinity'   e is 5\r\n     * new BigNumber(0.001)         // '0.01'       e is only -3\r\n     * new BigNumber(0.0001)        // '0'          e is -4\r\n     * ```\r\n     * The largest possible magnitude of a finite BigNumber is 9.999...e+1000000000.\r\n     * The smallest possible magnitude of a non-zero BigNumber is 1e-1000000000.\r\n     */\r\n    RANGE?: number | [number, number];\r\n\r\n    /**\r\n     * A boolean: `true` or `false`. Default value: `false`.\r\n     *\r\n     * The value that determines whether cryptographically-secure pseudo-random number generation is\r\n     * used. If `CRYPTO` is set to true then the random method will generate random digits using\r\n     * `crypto.getRandomValues` in browsers that support it, or `crypto.randomBytes` if using a\r\n     * version of Node.js that supports it.\r\n     *\r\n     * If neither function is supported by the host environment then attempting to set `CRYPTO` to\r\n     * `true` will fail and an exception will be thrown.\r\n     *\r\n     * If `CRYPTO` is `false` then the source of randomness used will be `Math.random` (which is\r\n     * assumed to generate at least 30 bits of randomness).\r\n     *\r\n     * See `BigNumber.random`.\r\n     *\r\n     * ```ts\r\n     * // Node.js\r\n     * global.crypto = require('crypto')\r\n     *\r\n     * BigNumber.config({ CRYPTO: true })\r\n     * BigNumber.config().CRYPTO       // true\r\n     * BigNumber.random()              // 0.54340758610486147524\r\n     * ```\r\n     */\r\n    CRYPTO?: boolean;\r\n\r\n    /**\r\n     * An integer, 0, 1, 3, 6 or 9. Default value: `BigNumber.ROUND_DOWN` (1).\r\n     *\r\n     * The modulo mode used when calculating the modulus: `a mod n`.\r\n     * The quotient, `q = a / n`, is calculated according to the `ROUNDING_MODE` that corresponds to\r\n     * the chosen `MODULO_MODE`.\r\n     * The remainder, `r`, is calculated as: `r = a - n * q`.\r\n     *\r\n     * The modes that are most commonly used for the modulus/remainder operation are shown in the\r\n     * following table. Although the other rounding modes can be used, they may not give useful\r\n     * results.\r\n     *\r\n     * Property           | Value | Description\r\n     * :------------------|:------|:------------------------------------------------------------------\r\n     *  `ROUND_UP`        |   0   | The remainder is positive if the dividend is negative.\r\n     *  `ROUND_DOWN`      |   1   | The remainder has the same sign as the dividend.\r\n     *                    |       | Uses 'truncating division' and matches JavaScript's `%` operator .\r\n     *  `ROUND_FLOOR`     |   3   | The remainder has the same sign as the divisor.\r\n     *                    |       | This matches Python's `%` operator.\r\n     *  `ROUND_HALF_EVEN` |   6   | The IEEE 754 remainder function.\r\n     *  `EUCLID`          |   9   | The remainder is always positive.\r\n     *                    |       | Euclidian division: `q = sign(n) * floor(a / abs(n))`\r\n     *\r\n     * The rounding/modulo modes are available as enumerated properties of the BigNumber constructor.\r\n     *\r\n     * See `modulo`.\r\n     *\r\n     * ```ts\r\n     * BigNumber.config({ MODULO_MODE: BigNumber.EUCLID })\r\n     * BigNumber.set({ MODULO_MODE: 9 })          // equivalent\r\n     * ```\r\n     */\r\n    MODULO_MODE?: BigNumber.ModuloMode;\r\n\r\n    /**\r\n     * An integer, 0 to 1e+9. Default value: 0.\r\n     *\r\n     * The maximum precision, i.e. number of significant digits, of the result of the power operation\r\n     * - unless a modulus is specified.\r\n     *\r\n     * If set to 0, the number of significant digits will not be limited.\r\n     *\r\n     * See `exponentiatedBy`.\r\n     *\r\n     * ```ts\r\n     * BigNumber.config({ POW_PRECISION: 100 })\r\n     * ```\r\n     */\r\n    POW_PRECISION?: number;\r\n\r\n    /**\r\n     * An object including any number of the properties shown below.\r\n     *\r\n     * The object configures the format of the string returned by the `toFormat` method.\r\n     * The example below shows the properties of the object that are recognised, and\r\n     * their default values.\r\n     *\r\n     * Unlike the other configuration properties, the values of the properties of the `FORMAT` object\r\n     * will not be checked for validity - the existing object will simply be replaced by the object\r\n     * that is passed in.\r\n     *\r\n     * See `toFormat`.\r\n     *\r\n     * ```ts\r\n     * BigNumber.config({\r\n     *   FORMAT: {\r\n     *     // string to prepend\r\n     *     prefix: '',\r\n     *     // the decimal separator\r\n     *     decimalSeparator: '.',\r\n     *     // the grouping separator of the integer part\r\n     *     groupSeparator: ',',\r\n     *     // the primary grouping size of the integer part\r\n     *     groupSize: 3,\r\n     *     // the secondary grouping size of the integer part\r\n     *     secondaryGroupSize: 0,\r\n     *     // the grouping separator of the fraction part\r\n     *     fractionGroupSeparator: ' ',\r\n     *     // the grouping size of the fraction part\r\n     *     fractionGroupSize: 0,\r\n     *     // string to append\r\n     *     suffix: ''\r\n     *   }\r\n     * })\r\n     * ```\r\n     */\r\n    FORMAT?: BigNumber.Format;\r\n\r\n    /**\r\n     * The alphabet used for base conversion. The length of the alphabet corresponds to the maximum\r\n     * value of the base argument that can be passed to the BigNumber constructor or `toString`.\r\n     *\r\n     * Default value: `'0123456789abcdefghijklmnopqrstuvwxyz'`.\r\n     *\r\n     * There is no maximum length for the alphabet, but it must be at least 2 characters long,\r\n     * and it must not contain whitespace or a repeated character, or the sign indicators '+' and\r\n     * '-', or the decimal separator '.'.\r\n     *\r\n     * ```ts\r\n     * // duodecimal (base 12)\r\n     * BigNumber.config({ ALPHABET: '0123456789TE' })\r\n     * x = new BigNumber('T', 12)\r\n     * x.toString()                // '10'\r\n     * x.toString(12)              // 'T'\r\n     * ```\r\n     */\r\n    ALPHABET?: string;\r\n  }\r\n\r\n  /** See `FORMAT` and `toFormat`. */\r\n  interface Format {\r\n\r\n    /** The string to prepend. */\r\n    prefix?: string;\r\n\r\n    /** The decimal separator. */\r\n    decimalSeparator?: string;\r\n\r\n    /** The grouping separator of the integer part. */\r\n    groupSeparator?: string;\r\n\r\n    /** The primary grouping size of the integer part. */\r\n    groupSize?: number;\r\n\r\n    /** The secondary grouping size of the integer part. */\r\n    secondaryGroupSize?: number;\r\n\r\n    /** The grouping separator of the fraction part. */\r\n    fractionGroupSeparator?: string;\r\n\r\n    /** The grouping size of the fraction part. */\r\n    fractionGroupSize?: number;\r\n\r\n    /** The string to append. */\r\n    suffix?: string;\r\n  }\r\n\r\n  interface Instance {\r\n\r\n    /** The coefficient of the value of this BigNumber, an array of base 1e14 integer numbers, or null. */\r\n    readonly c: number[] | null;\r\n\r\n    /** The exponent of the value of this BigNumber, an integer number, -1000000000 to 1000000000, or null. */\r\n    readonly e: number | null;\r\n\r\n    /** The sign of the value of this BigNumber, -1, 1, or null. */\r\n    readonly s: number | null;\r\n\r\n    [key: string]: any;\r\n  }\r\n\r\n  type Constructor = typeof BigNumber;\r\n  type ModuloMode = 0 | 1 | 3 | 6 | 9;\r\n  type RoundingMode = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\r\n  type Value = string | number | Instance;\r\n}\r\n\r\nexport declare class BigNumber implements BigNumber.Instance {\r\n\r\n  /** Used internally to identify a BigNumber instance. */\r\n  private readonly _isBigNumber: true;\r\n\r\n  /** The coefficient of the value of this BigNumber, an array of base 1e14 integer numbers, or null. */\r\n  readonly c: number[] | null;\r\n\r\n  /** The exponent of the value of this BigNumber, an integer number, -1000000000 to 1000000000, or null. */\r\n  readonly e: number | null;\r\n\r\n  /** The sign of the value of this BigNumber, -1, 1, or null. */\r\n  readonly s: number | null;\r\n\r\n  /**\r\n   * Returns a new instance of a BigNumber object with value `n`, where `n` is a numeric value in\r\n   * the specified `base`, or base 10 if `base` is omitted or is `null` or `undefined`.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(123.4567)              // '123.4567'\r\n   * // 'new' is optional\r\n   * y = BigNumber(x)                         // '123.4567'\r\n   * ```\r\n   *\r\n   * If `n` is a base 10 value it can be in normal (fixed-point) or exponential notation.\r\n   * Values in other bases must be in normal notation. Values in any base can have fraction digits,\r\n   * i.e. digits after the decimal point.\r\n   *\r\n   * ```ts\r\n   * new BigNumber(43210)                     // '43210'\r\n   * new BigNumber('4.321e+4')                // '43210'\r\n   * new BigNumber('-735.0918e-430')          // '-7.350918e-428'\r\n   * new BigNumber('123412421.234324', 5)     // '607236.557696'\r\n   * ```\r\n   *\r\n   * Signed `0`, signed `Infinity` and `NaN` are supported.\r\n   *\r\n   * ```ts\r\n   * new BigNumber('-Infinity')               // '-Infinity'\r\n   * new BigNumber(NaN)                       // 'NaN'\r\n   * new BigNumber(-0)                        // '0'\r\n   * new BigNumber('.5')                      // '0.5'\r\n   * new BigNumber('+2')                      // '2'\r\n   * ```\r\n   *\r\n   * String values in hexadecimal literal form, e.g. `'0xff'`, are valid, as are string values with\r\n   * the octal and binary prefixs `'0o'` and `'0b'`. String values in octal literal form without the\r\n   * prefix will be interpreted as decimals, e.g. `'011'` is interpreted as 11, not 9.\r\n   *\r\n   * ```ts\r\n   * new BigNumber(-10110100.1, 2)            // '-180.5'\r\n   * new BigNumber('-0b10110100.1')           // '-180.5'\r\n   * new BigNumber('ff.8', 16)                // '255.5'\r\n   * new BigNumber('0xff.8')                  // '255.5'\r\n   * ```\r\n   *\r\n   * If a base is specified, `n` is rounded according to the current `DECIMAL_PLACES` and\r\n   * `ROUNDING_MODE` settings. This includes base 10, so don't include a `base` parameter for decimal\r\n   * values unless this behaviour is desired.\r\n   *\r\n   * ```ts\r\n   * BigNumber.config({ DECIMAL_PLACES: 5 })\r\n   * new BigNumber(1.23456789)                // '1.23456789'\r\n   * new BigNumber(1.23456789, 10)            // '1.23457'\r\n   * ```\r\n   *\r\n   * An error is thrown if `base` is invalid.\r\n   *\r\n   * There is no limit to the number of digits of a value of type string (other than that of\r\n   * JavaScript's maximum array size). See `RANGE` to set the maximum and minimum possible exponent\r\n   * value of a BigNumber.\r\n   *\r\n   * ```ts\r\n   * new BigNumber('5032485723458348569331745.33434346346912144534543')\r\n   * new BigNumber('4.321e10000000')\r\n   * ```\r\n   *\r\n   * BigNumber `NaN` is returned if `n` is invalid (unless `BigNumber.DEBUG` is `true`, see below).\r\n   *\r\n   * ```ts\r\n   * new BigNumber('.1*')                    // 'NaN'\r\n   * new BigNumber('blurgh')                 // 'NaN'\r\n   * new BigNumber(9, 2)                     // 'NaN'\r\n   * ```\r\n   *\r\n   * To aid in debugging, if `BigNumber.DEBUG` is `true` then an error will be thrown on an\r\n   * invalid `n`. An error will also be thrown if `n` is of type number with more than 15\r\n   * significant digits, as calling `toString` or `valueOf` on these numbers may not result in the\r\n   * intended value.\r\n   *\r\n   * ```ts\r\n   * console.log(823456789123456.3)          //  823456789123456.2\r\n   * new BigNumber(823456789123456.3)        // '823456789123456.2'\r\n   * BigNumber.DEBUG = true\r\n   * // 'Error: Number has more than 15 significant digits'\r\n   * new BigNumber(823456789123456.3)\r\n   * // 'Error: Not a base 2 number'\r\n   * new BigNumber(9, 2)\r\n   * ```\r\n   *\r\n   * A BigNumber can also be created from an object literal.\r\n   * Use `isBigNumber` to check that it is well-formed.\r\n   *\r\n   * ```ts\r\n   * new BigNumber({ s: 1, e: 2, c: [ 777, 12300000000000 ], _isBigNumber: true })    // '777.123'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param base The base of `n`, integer, 2 to 36 (or `ALPHABET.length`, see `ALPHABET`).\r\n   */\r\n  constructor(n: BigNumber.Value, base?: number);\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the absolute value, i.e. the magnitude, of the value of this\r\n   * BigNumber.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(-0.8)\r\n   * x.absoluteValue()           // '0.8'\r\n   * ```\r\n   */\r\n  absoluteValue(): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the absolute value, i.e. the magnitude, of the value of this\r\n   * BigNumber.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(-0.8)\r\n   * x.abs()                     // '0.8'\r\n   * ```\r\n   */\r\n  abs(): BigNumber;\r\n\r\n  /**\r\n   *  Returns |                                                               |\r\n   * :-------:|:--------------------------------------------------------------|\r\n   *     1    | If the value of this BigNumber is greater than the value of `n`\r\n   *    -1    | If the value of this BigNumber is less than the value of `n`\r\n   *     0    | If this BigNumber and `n` have the same value\r\n   *  `null`  | If the value of either this BigNumber or `n` is `NaN`\r\n   *\r\n   * ```ts\r\n   *\r\n   * x = new BigNumber(Infinity)\r\n   * y = new BigNumber(5)\r\n   * x.comparedTo(y)                 // 1\r\n   * x.comparedTo(x.minus(1))        // 0\r\n   * y.comparedTo(NaN)               // null\r\n   * y.comparedTo('110', 2)          // -1\r\n   * ```\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  comparedTo(n: BigNumber.Value, base?: number): number;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber rounded by rounding mode\r\n   * `roundingMode` to a maximum of `decimalPlaces` decimal places.\r\n   *\r\n   * If `decimalPlaces` is omitted, or is `null` or `undefined`, the return value is the number of\r\n   * decimal places of the value of this BigNumber, or `null` if the value of this BigNumber is\r\n   * `Infinity` or `NaN`.\r\n   *\r\n   * If `roundingMode` is omitted, or is `null` or `undefined`, `ROUNDING_MODE` is used.\r\n   *\r\n   * Throws if `decimalPlaces` or `roundingMode` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(1234.56)\r\n   * x.decimalPlaces()                      // 2\r\n   * x.decimalPlaces(1)                     // '1234.6'\r\n   * x.decimalPlaces(2)                     // '1234.56'\r\n   * x.decimalPlaces(10)                    // '1234.56'\r\n   * x.decimalPlaces(0, 1)                  // '1234'\r\n   * x.decimalPlaces(0, 6)                  // '1235'\r\n   * x.decimalPlaces(1, 1)                  // '1234.5'\r\n   * x.decimalPlaces(1, BigNumber.ROUND_HALF_EVEN)     // '1234.6'\r\n   * x                                      // '1234.56'\r\n   * y = new BigNumber('9.9e-101')\r\n   * y.decimalPlaces()                      // 102\r\n   * ```\r\n   *\r\n   * @param [decimalPlaces] Decimal places, integer, 0 to 1e+9.\r\n   * @param [roundingMode] Rounding mode, integer, 0 to 8.\r\n   */\r\n  decimalPlaces(): number;\r\n  decimalPlaces(decimalPlaces: number, roundingMode?: BigNumber.RoundingMode): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber rounded by rounding mode\r\n   * `roundingMode` to a maximum of `decimalPlaces` decimal places.\r\n   *\r\n   * If `decimalPlaces` is omitted, or is `null` or `undefined`, the return value is the number of\r\n   * decimal places of the value of this BigNumber, or `null` if the value of this BigNumber is\r\n   * `Infinity` or `NaN`.\r\n   *\r\n   * If `roundingMode` is omitted, or is `null` or `undefined`, `ROUNDING_MODE` is used.\r\n   *\r\n   * Throws if `decimalPlaces` or `roundingMode` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(1234.56)\r\n   * x.dp()                                 // 2\r\n   * x.dp(1)                                // '1234.6'\r\n   * x.dp(2)                                // '1234.56'\r\n   * x.dp(10)                               // '1234.56'\r\n   * x.dp(0, 1)                             // '1234'\r\n   * x.dp(0, 6)                             // '1235'\r\n   * x.dp(1, 1)                             // '1234.5'\r\n   * x.dp(1, BigNumber.ROUND_HALF_EVEN)     // '1234.6'\r\n   * x                                      // '1234.56'\r\n   * y = new BigNumber('9.9e-101')\r\n   * y.dp()                                 // 102\r\n   * ```\r\n   *\r\n   * @param [decimalPlaces] Decimal places, integer, 0 to 1e+9.\r\n   * @param [roundingMode] Rounding mode, integer, 0 to 8.\r\n   */\r\n  dp(): number;\r\n  dp(decimalPlaces: number, roundingMode?: BigNumber.RoundingMode): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber divided by `n`, rounded\r\n   * according to the current `DECIMAL_PLACES` and `ROUNDING_MODE` settings.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(355)\r\n   * y = new BigNumber(113)\r\n   * x.dividedBy(y)                  // '3.14159292035398230088'\r\n   * x.dividedBy(5)                  // '71'\r\n   * x.dividedBy(47, 16)             // '5'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  dividedBy(n: BigNumber.Value, base?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber divided by `n`, rounded\r\n   * according to the current `DECIMAL_PLACES` and `ROUNDING_MODE` settings.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(355)\r\n   * y = new BigNumber(113)\r\n   * x.div(y)                    // '3.14159292035398230088'\r\n   * x.div(5)                    // '71'\r\n   * x.div(47, 16)               // '5'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  div(n: BigNumber.Value, base?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the integer part of dividing the value of this BigNumber by\r\n   * `n`.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(5)\r\n   * y = new BigNumber(3)\r\n   * x.dividedToIntegerBy(y)              // '1'\r\n   * x.dividedToIntegerBy(0.7)            // '7'\r\n   * x.dividedToIntegerBy('0.f', 16)      // '5'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  dividedToIntegerBy(n: BigNumber.Value, base?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the integer part of dividing the value of this BigNumber by\r\n   * `n`.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(5)\r\n   * y = new BigNumber(3)\r\n   * x.idiv(y)                       // '1'\r\n   * x.idiv(0.7)                     // '7'\r\n   * x.idiv('0.f', 16)               // '5'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  idiv(n: BigNumber.Value, base?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber exponentiated by `n`, i.e.\r\n   * raised to the power `n`, and optionally modulo a modulus `m`.\r\n   *\r\n   * If `n` is negative the result is rounded according to the current `DECIMAL_PLACES` and\r\n   * `ROUNDING_MODE` settings.\r\n   *\r\n   * As the number of digits of the result of the power operation can grow so large so quickly,\r\n   * e.g. 123.456**10000 has over 50000 digits, the number of significant digits calculated is\r\n   * limited to the value of the `POW_PRECISION` setting (unless a modulus `m` is specified).\r\n   *\r\n   * By default `POW_PRECISION` is set to 0. This means that an unlimited number of significant\r\n   * digits will be calculated, and that the method's performance will decrease dramatically for\r\n   * larger exponents.\r\n   *\r\n   * If `m` is specified and the value of `m`, `n` and this BigNumber are integers and `n` is\r\n   * positive, then a fast modular exponentiation algorithm is used, otherwise the operation will\r\n   * be performed as `x.exponentiatedBy(n).modulo(m)` with a `POW_PRECISION` of 0.\r\n   *\r\n   * Throws if `n` is not an integer.\r\n   *\r\n   * ```ts\r\n   * Math.pow(0.7, 2)                    // 0.48999999999999994\r\n   * x = new BigNumber(0.7)\r\n   * x.exponentiatedBy(2)                // '0.49'\r\n   * BigNumber(3).exponentiatedBy(-2)    // '0.11111111111111111111'\r\n   * ```\r\n   *\r\n   * @param n The exponent, an integer.\r\n   * @param [m] The modulus.\r\n   */\r\n  exponentiatedBy(n: BigNumber.Value, m?: BigNumber.Value): BigNumber;\r\n  exponentiatedBy(n: number, m?: BigNumber.Value): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber exponentiated by `n`, i.e.\r\n   * raised to the power `n`, and optionally modulo a modulus `m`.\r\n   *\r\n   * If `n` is negative the result is rounded according to the current `DECIMAL_PLACES` and\r\n   * `ROUNDING_MODE` settings.\r\n   *\r\n   * As the number of digits of the result of the power operation can grow so large so quickly,\r\n   * e.g. 123.456**10000 has over 50000 digits, the number of significant digits calculated is\r\n   * limited to the value of the `POW_PRECISION` setting (unless a modulus `m` is specified).\r\n   *\r\n   * By default `POW_PRECISION` is set to 0. This means that an unlimited number of significant\r\n   * digits will be calculated, and that the method's performance will decrease dramatically for\r\n   * larger exponents.\r\n   *\r\n   * If `m` is specified and the value of `m`, `n` and this BigNumber are integers and `n` is\r\n   * positive, then a fast modular exponentiation algorithm is used, otherwise the operation will\r\n   * be performed as `x.pow(n).modulo(m)` with a `POW_PRECISION` of 0.\r\n   *\r\n   * Throws if `n` is not an integer.\r\n   *\r\n   * ```ts\r\n   * Math.pow(0.7, 2)                   // 0.48999999999999994\r\n   * x = new BigNumber(0.7)\r\n   * x.pow(2)                           // '0.49'\r\n   * BigNumber(3).pow(-2)               // '0.11111111111111111111'\r\n   * ```\r\n   *\r\n   * @param n The exponent, an integer.\r\n   * @param [m] The modulus.\r\n   */\r\n  pow(n: BigNumber.Value, m?: BigNumber.Value): BigNumber;\r\n  pow(n: number, m?: BigNumber.Value): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber rounded to an integer using\r\n   * rounding mode `rm`.\r\n   *\r\n   * If `rm` is omitted, or is `null` or `undefined`, `ROUNDING_MODE` is used.\r\n   *\r\n   * Throws if `rm` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(123.456)\r\n   * x.integerValue()                        // '123'\r\n   * x.integerValue(BigNumber.ROUND_CEIL)    // '124'\r\n   * y = new BigNumber(-12.7)\r\n   * y.integerValue()                        // '-13'\r\n   * x.integerValue(BigNumber.ROUND_DOWN)    // '-12'\r\n   * ```\r\n   *\r\n   * @param {BigNumber.RoundingMode} [rm] The roundng mode, an integer, 0 to 8.\r\n   */\r\n  integerValue(rm?: BigNumber.RoundingMode): BigNumber;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is equal to the value of `n`, otherwise returns\r\n   * `false`.\r\n   *\r\n   * As with JavaScript, `NaN` does not equal `NaN`.\r\n   *\r\n   * ```ts\r\n   * 0 === 1e-324                           // true\r\n   * x = new BigNumber(0)\r\n   * x.isEqualTo('1e-324')                  // false\r\n   * BigNumber(-0).isEqualTo(x)             // true  ( -0 === 0 )\r\n   * BigNumber(255).isEqualTo('ff', 16)     // true\r\n   *\r\n   * y = new BigNumber(NaN)\r\n   * y.isEqualTo(NaN)                // false\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  isEqualTo(n: BigNumber.Value, base?: number): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is equal to the value of `n`, otherwise returns\r\n   * `false`.\r\n   *\r\n   * As with JavaScript, `NaN` does not equal `NaN`.\r\n   *\r\n   * ```ts\r\n   * 0 === 1e-324                    // true\r\n   * x = new BigNumber(0)\r\n   * x.eq('1e-324')                  // false\r\n   * BigNumber(-0).eq(x)             // true  ( -0 === 0 )\r\n   * BigNumber(255).eq('ff', 16)     // true\r\n   *\r\n   * y = new BigNumber(NaN)\r\n   * y.eq(NaN)                       // false\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  eq(n: BigNumber.Value, base?: number): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is a finite number, otherwise returns `false`.\r\n   *\r\n   * The only possible non-finite values of a BigNumber are `NaN`, `Infinity` and `-Infinity`.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(1)\r\n   * x.isFinite()                    // true\r\n   * y = new BigNumber(Infinity)\r\n   * y.isFinite()                    // false\r\n   * ```\r\n   */\r\n  isFinite(): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is greater than the value of `n`, otherwise\r\n   * returns `false`.\r\n   *\r\n   * ```ts\r\n   * 0.1 > (0.3 - 0.2)                             // true\r\n   * x = new BigNumber(0.1)\r\n   * x.isGreaterThan(BigNumber(0.3).minus(0.2))    // false\r\n   * BigNumber(0).isGreaterThan(x)                 // false\r\n   * BigNumber(11, 3).isGreaterThan(11.1, 2)       // true\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  isGreaterThan(n: BigNumber.Value, base?: number): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is greater than the value of `n`, otherwise\r\n   * returns `false`.\r\n   *\r\n   * ```ts\r\n   * 0.1 > (0.3 - 0                     // true\r\n   * x = new BigNumber(0.1)\r\n   * x.gt(BigNumber(0.3).minus(0.2))    // false\r\n   * BigNumber(0).gt(x)                 // false\r\n   * BigNumber(11, 3).gt(11.1, 2)       // true\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  gt(n: BigNumber.Value, base?: number): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is greater than or equal to the value of `n`,\r\n   * otherwise returns `false`.\r\n   *\r\n   * ```ts\r\n   * (0.3 - 0.2) >= 0.1                                  // false\r\n   * x = new BigNumber(0.3).minus(0.2)\r\n   * x.isGreaterThanOrEqualTo(0.1)                       // true\r\n   * BigNumber(1).isGreaterThanOrEqualTo(x)              // true\r\n   * BigNumber(10, 18).isGreaterThanOrEqualTo('i', 36)   // true\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  isGreaterThanOrEqualTo(n: BigNumber.Value, base?: number): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is greater than or equal to the value of `n`,\r\n   * otherwise returns `false`.\r\n   *\r\n   * ```ts\r\n   * (0.3 - 0.2) >= 0.1                    // false\r\n   * x = new BigNumber(0.3).minus(0.2)\r\n   * x.gte(0.1)                            // true\r\n   * BigNumber(1).gte(x)                   // true\r\n   * BigNumber(10, 18).gte('i', 36)        // true\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  gte(n: BigNumber.Value, base?: number): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is an integer, otherwise returns `false`.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(1)\r\n   * x.isInteger()                   // true\r\n   * y = new BigNumber(123.456)\r\n   * y.isInteger()                   // false\r\n   * ```\r\n   */\r\n  isInteger(): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is less than the value of `n`, otherwise returns\r\n   * `false`.\r\n   *\r\n   * ```ts\r\n   * (0.3 - 0.2) < 0.1                       // true\r\n   * x = new BigNumber(0.3).minus(0.2)\r\n   * x.isLessThan(0.1)                       // false\r\n   * BigNumber(0).isLessThan(x)              // true\r\n   * BigNumber(11.1, 2).isLessThan(11, 3)    // true\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  isLessThan(n: BigNumber.Value, base?: number): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is less than the value of `n`, otherwise returns\r\n   * `false`.\r\n   *\r\n   * ```ts\r\n   * (0.3 - 0.2) < 0.1                       // true\r\n   * x = new BigNumber(0.3).minus(0.2)\r\n   * x.lt(0.1)                               // false\r\n   * BigNumber(0).lt(x)                      // true\r\n   * BigNumber(11.1, 2).lt(11, 3)            // true\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  lt(n: BigNumber.Value, base?: number): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is less than or equal to the value of `n`,\r\n   * otherwise returns `false`.\r\n   *\r\n   * ```ts\r\n   * 0.1 <= (0.3 - 0.2)                                 // false\r\n   * x = new BigNumber(0.1)\r\n   * x.isLessThanOrEqualTo(BigNumber(0.3).minus(0.2))   // true\r\n   * BigNumber(-1).isLessThanOrEqualTo(x)               // true\r\n   * BigNumber(10, 18).isLessThanOrEqualTo('i', 36)     // true\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  isLessThanOrEqualTo(n: BigNumber.Value, base?: number): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is less than or equal to the value of `n`,\r\n   * otherwise returns `false`.\r\n   *\r\n   * ```ts\r\n   * 0.1 <= (0.3 - 0.2)                  // false\r\n   * x = new BigNumber(0.1)\r\n   * x.lte(BigNumber(0.3).minus(0.2))    // true\r\n   * BigNumber(-1).lte(x)                // true\r\n   * BigNumber(10, 18).lte('i', 36)      // true\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  lte(n: BigNumber.Value, base?: number): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is `NaN`, otherwise returns `false`.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(NaN)\r\n   * x.isNaN()                       // true\r\n   * y = new BigNumber('Infinity')\r\n   * y.isNaN()                       // false\r\n   * ```\r\n   */\r\n  isNaN(): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is negative, otherwise returns `false`.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(-0)\r\n   * x.isNegative()                  // true\r\n   * y = new BigNumber(2)\r\n   * y.isNegative()                  // false\r\n   * ```\r\n   */\r\n  isNegative(): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is positive, otherwise returns `false`.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(-0)\r\n   * x.isPositive()                  // false\r\n   * y = new BigNumber(2)\r\n   * y.isPositive()                  // true\r\n   * ```\r\n   */\r\n  isPositive(): boolean;\r\n\r\n  /**\r\n   * Returns `true` if the value of this BigNumber is zero or minus zero, otherwise returns `false`.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(-0)\r\n   * x.isZero()                 // true\r\n   * ```\r\n   */\r\n  isZero(): boolean;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber minus `n`.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * 0.3 - 0.1                       // 0.19999999999999998\r\n   * x = new BigNumber(0.3)\r\n   * x.minus(0.1)                    // '0.2'\r\n   * x.minus(0.6, 20)                // '0'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  minus(n: BigNumber.Value, base?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber modulo `n`, i.e. the integer\r\n   * remainder of dividing this BigNumber by `n`.\r\n   *\r\n   * The value returned, and in particular its sign, is dependent on the value of the `MODULO_MODE`\r\n   * setting of this BigNumber constructor. If it is 1 (default value), the result will have the\r\n   * same sign as this BigNumber, and it will match that of Javascript's `%` operator (within the\r\n   * limits of double precision) and BigDecimal's `remainder` method.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * See `MODULO_MODE` for a description of the other modulo modes.\r\n   *\r\n   * ```ts\r\n   * 1 % 0.9                         // 0.09999999999999998\r\n   * x = new BigNumber(1)\r\n   * x.modulo(0.9)                   // '0.1'\r\n   * y = new BigNumber(33)\r\n   * y.modulo('a', 33)               // '3'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  modulo(n: BigNumber.Value, base?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber modulo `n`, i.e. the integer\r\n   * remainder of dividing this BigNumber by `n`.\r\n   *\r\n   * The value returned, and in particular its sign, is dependent on the value of the `MODULO_MODE`\r\n   * setting of this BigNumber constructor. If it is 1 (default value), the result will have the\r\n   * same sign as this BigNumber, and it will match that of Javascript's `%` operator (within the\r\n   * limits of double precision) and BigDecimal's `remainder` method.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * See `MODULO_MODE` for a description of the other modulo modes.\r\n   *\r\n   * ```ts\r\n   * 1 % 0.9                      // 0.09999999999999998\r\n   * x = new BigNumber(1)\r\n   * x.mod(0.9)                   // '0.1'\r\n   * y = new BigNumber(33)\r\n   * y.mod('a', 33)               // '3'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  mod(n: BigNumber.Value, base?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber multiplied by `n`.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * 0.6 * 3                                // 1.7999999999999998\r\n   * x = new BigNumber(0.6)\r\n   * y = x.multipliedBy(3)                  // '1.8'\r\n   * BigNumber('7e+500').multipliedBy(y)    // '1.26e+501'\r\n   * x.multipliedBy('-a', 16)               // '-6'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  multipliedBy(n: BigNumber.Value, base?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber multiplied by `n`.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * 0.6 * 3                         // 1.7999999999999998\r\n   * x = new BigNumber(0.6)\r\n   * y = x.times(3)                  // '1.8'\r\n   * BigNumber('7e+500').times(y)    // '1.26e+501'\r\n   * x.times('-a', 16)               // '-6'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  times(n: BigNumber.Value, base?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber negated, i.e. multiplied by -1.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(1.8)\r\n   * x.negated()                     // '-1.8'\r\n   * y = new BigNumber(-1.3)\r\n   * y.negated()                     // '1.3'\r\n   * ```\r\n   */\r\n  negated(): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber plus `n`.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * 0.1 + 0.2                       // 0.30000000000000004\r\n   * x = new BigNumber(0.1)\r\n   * y = x.plus(0.2)                 // '0.3'\r\n   * BigNumber(0.7).plus(x).plus(y)  // '1.1'\r\n   * x.plus('0.1', 8)                // '0.225'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   * @param [base] The base of n.\r\n   */\r\n  plus(n: BigNumber.Value, base?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns the number of significant digits of the value of this BigNumber, or `null` if the value\r\n   * of this BigNumber is `Infinity` or `NaN`.\r\n   *\r\n   * If `includeZeros` is true then any trailing zeros of the integer part of the value of this\r\n   * BigNumber are counted as significant digits, otherwise they are not.\r\n   *\r\n   * Throws if `includeZeros` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(9876.54321)\r\n   * x.precision()                         // 9\r\n   * y = new BigNumber(987000)\r\n   * y.precision(false)                    // 3\r\n   * y.precision(true)                     // 6\r\n   * ```\r\n   *\r\n   * @param [includeZeros] Whether to include integer trailing zeros in the significant digit count.\r\n   */\r\n  precision(includeZeros?: boolean): number;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber rounded to a precision of\r\n   * `significantDigits` significant digits using rounding mode `roundingMode`.\r\n   *\r\n   * If `roundingMode` is omitted or is `null` or `undefined`, `ROUNDING_MODE` will be used.\r\n   *\r\n   * Throws if `significantDigits` or `roundingMode` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(9876.54321)\r\n   * x.precision(6)                         // '9876.54'\r\n   * x.precision(6, BigNumber.ROUND_UP)     // '9876.55'\r\n   * x.precision(2)                         // '9900'\r\n   * x.precision(2, 1)                      // '9800'\r\n   * x                                      // '9876.54321'\r\n   * ```\r\n   *\r\n   * @param significantDigits Significant digits, integer, 1 to 1e+9.\r\n   * @param [roundingMode] Rounding mode, integer, 0 to 8.\r\n   */\r\n  precision(significantDigits: number, roundingMode?: BigNumber.RoundingMode): BigNumber;\r\n\r\n  /**\r\n   * Returns the number of significant digits of the value of this BigNumber,\r\n   * or `null` if the value of this BigNumber is `Infinity` or `NaN`.\r\n   *\r\n   * If `includeZeros` is true then any trailing zeros of the integer part of\r\n   * the value of this BigNumber are counted as significant digits, otherwise\r\n   * they are not.\r\n   *\r\n   * Throws if `includeZeros` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(9876.54321)\r\n   * x.sd()                         // 9\r\n   * y = new BigNumber(987000)\r\n   * y.sd(false)                    // 3\r\n   * y.sd(true)                     // 6\r\n   * ```\r\n   *\r\n   * @param [includeZeros] Whether to include integer trailing zeros in the significant digit count.\r\n   */\r\n  sd(includeZeros?: boolean): number;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber rounded to a precision of\r\n   * `significantDigits` significant digits using rounding mode `roundingMode`.\r\n   *\r\n   * If `roundingMode` is omitted or is `null` or `undefined`, `ROUNDING_MODE` will be used.\r\n   *\r\n   * Throws if `significantDigits` or `roundingMode` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(9876.54321)\r\n   * x.sd(6)                           // '9876.54'\r\n   * x.sd(6, BigNumber.ROUND_UP)       // '9876.55'\r\n   * x.sd(2)                           // '9900'\r\n   * x.sd(2, 1)                        // '9800'\r\n   * x                                 // '9876.54321'\r\n   * ```\r\n   *\r\n   * @param significantDigits Significant digits, integer, 1 to 1e+9.\r\n   * @param [roundingMode] Rounding mode, integer, 0 to 8.\r\n   */\r\n  sd(significantDigits: number, roundingMode?: BigNumber.RoundingMode): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the value of this BigNumber shifted by `n` places.\r\n   *\r\n   * The shift is of the decimal point, i.e. of powers of ten, and is to the left if `n` is negative\r\n   * or to the right if `n` is positive.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * Throws if `n` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(1.23)\r\n   * x.shiftedBy(3)                      // '1230'\r\n   * x.shiftedBy(-3)                     // '0.00123'\r\n   * ```\r\n   *\r\n   * @param n The shift value, integer, -9007199254740991 to 9007199254740991.\r\n   */\r\n  shiftedBy(n: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the square root of the value of this BigNumber, rounded\r\n   * according to the current `DECIMAL_PLACES` and `ROUNDING_MODE` settings.\r\n   *\r\n   * The return value will be correctly rounded, i.e. rounded as if the result was first calculated\r\n   * to an infinite number of correct digits before rounding.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(16)\r\n   * x.squareRoot()                  // '4'\r\n   * y = new BigNumber(3)\r\n   * y.squareRoot()                  // '1.73205080756887729353'\r\n   * ```\r\n   */\r\n  squareRoot(): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the square root of the value of this BigNumber, rounded\r\n   * according to the current `DECIMAL_PLACES` and `ROUNDING_MODE` settings.\r\n   *\r\n   * The return value will be correctly rounded, i.e. rounded as if the result was first calculated\r\n   * to an infinite number of correct digits before rounding.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(16)\r\n   * x.sqrt()                  // '4'\r\n   * y = new BigNumber(3)\r\n   * y.sqrt()                  // '1.73205080756887729353'\r\n   * ```\r\n   */\r\n  sqrt(): BigNumber;\r\n\r\n  /**\r\n   * Returns a string representing the value of this BigNumber in exponential notation rounded using\r\n   * rounding mode `roundingMode` to `decimalPlaces` decimal places, i.e with one digit before the\r\n   * decimal point and `decimalPlaces` digits after it.\r\n   *\r\n   * If the value of this BigNumber in exponential notation has fewer than `decimalPlaces` fraction\r\n   * digits, the return value will be appended with zeros accordingly.\r\n   *\r\n   * If `decimalPlaces` is omitted, or is `null` or `undefined`, the number of digits after the\r\n   * decimal point defaults to the minimum number of digits necessary to represent the value\r\n   * exactly.\r\n   *\r\n   * If `roundingMode` is omitted or is `null` or `undefined`, `ROUNDING_MODE` is used.\r\n   *\r\n   * Throws if `decimalPlaces` or `roundingMode` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = 45.6\r\n   * y = new BigNumber(x)\r\n   * x.toExponential()               // '4.56e+1'\r\n   * y.toExponential()               // '4.56e+1'\r\n   * x.toExponential(0)              // '5e+1'\r\n   * y.toExponential(0)              // '5e+1'\r\n   * x.toExponential(1)              // '4.6e+1'\r\n   * y.toExponential(1)              // '4.6e+1'\r\n   * y.toExponential(1, 1)           // '4.5e+1'  (ROUND_DOWN)\r\n   * x.toExponential(3)              // '4.560e+1'\r\n   * y.toExponential(3)              // '4.560e+1'\r\n   * ```\r\n   *\r\n   * @param [decimalPlaces] Decimal places, integer, 0 to 1e+9.\r\n   * @param [roundingMode] Rounding mode, integer, 0 to 8.\r\n   */\r\n  toExponential(decimalPlaces: number, roundingMode?: BigNumber.RoundingMode): string;\r\n  toExponential(): string;\r\n\r\n  /**\r\n   * Returns a string representing the value of this BigNumber in normal (fixed-point) notation\r\n   * rounded to `decimalPlaces` decimal places using rounding mode `roundingMode`.\r\n   *\r\n   * If the value of this BigNumber in normal notation has fewer than `decimalPlaces` fraction\r\n   * digits, the return value will be appended with zeros accordingly.\r\n   *\r\n   * Unlike `Number.prototype.toFixed`, which returns exponential notation if a number is greater or\r\n   * equal to 10**21, this method will always return normal notation.\r\n   *\r\n   * If `decimalPlaces` is omitted or is `null` or `undefined`, the return value will be unrounded\r\n   * and in normal notation. This is also unlike `Number.prototype.toFixed`, which returns the value\r\n   * to zero decimal places. It is useful when normal notation is required and the current\r\n   * `EXPONENTIAL_AT` setting causes `toString` to return exponential notation.\r\n   *\r\n   * If `roundingMode` is omitted or is `null` or `undefined`, `ROUNDING_MODE` is used.\r\n   *\r\n   * Throws if `decimalPlaces` or `roundingMode` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = 3.456\r\n   * y = new BigNumber(x)\r\n   * x.toFixed()                     // '3'\r\n   * y.toFixed()                     // '3.456'\r\n   * y.toFixed(0)                    // '3'\r\n   * x.toFixed(2)                    // '3.46'\r\n   * y.toFixed(2)                    // '3.46'\r\n   * y.toFixed(2, 1)                 // '3.45'  (ROUND_DOWN)\r\n   * x.toFixed(5)                    // '3.45600'\r\n   * y.toFixed(5)                    // '3.45600'\r\n   * ```\r\n   *\r\n   * @param [decimalPlaces] Decimal places, integer, 0 to 1e+9.\r\n   * @param [roundingMode] Rounding mode, integer, 0 to 8.\r\n   */\r\n  toFixed(decimalPlaces: number, roundingMode?: BigNumber.RoundingMode): string;\r\n  toFixed(): string;\r\n\r\n  /**\r\n   * Returns a string representing the value of this BigNumber in normal (fixed-point) notation\r\n   * rounded to `decimalPlaces` decimal places using rounding mode `roundingMode`, and formatted\r\n   * according to the properties of the `format` or `FORMAT` object.\r\n   *\r\n   * The formatting object may contain some or all of the properties shown in the examples below.\r\n   *\r\n   * If `decimalPlaces` is omitted or is `null` or `undefined`, then the return value is not\r\n   * rounded to a fixed number of decimal places.\r\n   *\r\n   * If `roundingMode` is omitted or is `null` or `undefined`, `ROUNDING_MODE` is used.\r\n   *\r\n   * If `format` is omitted or is `null` or `undefined`, `FORMAT` is used.\r\n   *\r\n   * Throws if `decimalPlaces`, `roundingMode`, or `format` is invalid.\r\n   *\r\n   * ```ts\r\n   * fmt = {\r\n   *   decimalSeparator: '.',\r\n   *   groupSeparator: ',',\r\n   *   groupSize: 3,\r\n   *   secondaryGroupSize: 0,\r\n   *   fractionGroupSeparator: ' ',\r\n   *   fractionGroupSize: 0\r\n   * }\r\n   *\r\n   * x = new BigNumber('123456789.123456789')\r\n   *\r\n   * // Set the global formatting options\r\n   * BigNumber.config({ FORMAT: fmt })\r\n   *\r\n   * x.toFormat()                              // '123,456,789.123456789'\r\n   * x.toFormat(3)                             // '123,456,789.123'\r\n   *\r\n   * // If a reference to the object assigned to FORMAT has been retained,\r\n   * // the format properties can be changed directly\r\n   * fmt.groupSeparator = ' '\r\n   * fmt.fractionGroupSize = 5\r\n   * x.toFormat()                              // '123 456 789.12345 6789'\r\n   *\r\n   * // Alternatively, pass the formatting options as an argument\r\n   * fmt = {\r\n   *   decimalSeparator: ',',\r\n   *   groupSeparator: '.',\r\n   *   groupSize: 3,\r\n   *   secondaryGroupSize: 2\r\n   * }\r\n   *\r\n   * x.toFormat()                              // '123 456 789.12345 6789'\r\n   * x.toFormat(fmt)                           // '12.34.56.789,123456789'\r\n   * x.toFormat(2, fmt)                        // '12.34.56.789,12'\r\n   * x.toFormat(3, BigNumber.ROUND_UP, fmt)    // '12.34.56.789,124'\r\n   * ```\r\n   *\r\n   * @param [decimalPlaces] Decimal places, integer, 0 to 1e+9.\r\n   * @param [roundingMode] Rounding mode, integer, 0 to 8.\r\n   * @param [format] Formatting options object. See `BigNumber.Format`.\r\n   */\r\n  toFormat(decimalPlaces: number, roundingMode: BigNumber.RoundingMode, format?: BigNumber.Format): string;\r\n  toFormat(decimalPlaces: number, roundingMode?: BigNumber.RoundingMode): string;\r\n  toFormat(decimalPlaces?: number): string;\r\n  toFormat(decimalPlaces: number, format: BigNumber.Format): string;\r\n  toFormat(format: BigNumber.Format): string;\r\n\r\n  /**\r\n   * Returns an array of two BigNumbers representing the value of this BigNumber as a simple\r\n   * fraction with an integer numerator and an integer denominator.\r\n   * The denominator will be a positive non-zero value less than or equal to `max_denominator`.\r\n   * If a maximum denominator, `max_denominator`, is not specified, or is `null` or `undefined`, the\r\n   * denominator will be the lowest value necessary to represent the number exactly.\r\n   *\r\n   * Throws if `max_denominator` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(1.75)\r\n   * x.toFraction()                  // '7, 4'\r\n   *\r\n   * pi = new BigNumber('3.14159265358')\r\n   * pi.toFraction()                 // '157079632679,50000000000'\r\n   * pi.toFraction(100000)           // '312689, 99532'\r\n   * pi.toFraction(10000)            // '355, 113'\r\n   * pi.toFraction(100)              // '311, 99'\r\n   * pi.toFraction(10)               // '22, 7'\r\n   * pi.toFraction(1)                // '3, 1'\r\n   * ```\r\n   *\r\n   * @param [max_denominator] The maximum denominator, integer > 0, or Infinity.\r\n   */\r\n  toFraction(max_denominator?: BigNumber.Value): [BigNumber, BigNumber];\r\n\r\n  /** As `valueOf`. */\r\n  toJSON(): string;\r\n\r\n  /**\r\n   * Returns the value of this BigNumber as a JavaScript primitive number.\r\n   *\r\n   * Using the unary plus operator gives the same result.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(456.789)\r\n   * x.toNumber()                    // 456.789\r\n   * +x                              // 456.789\r\n   *\r\n   * y = new BigNumber('45987349857634085409857349856430985')\r\n   * y.toNumber()                    // 4.598734985763409e+34\r\n   *\r\n   * z = new BigNumber(-0)\r\n   * 1 / z.toNumber()                // -Infinity\r\n   * 1 / +z                          // -Infinity\r\n   * ```\r\n   */\r\n  toNumber(): number;\r\n\r\n  /**\r\n   * Returns a string representing the value of this BigNumber rounded to `significantDigits`\r\n   * significant digits using rounding mode `roundingMode`.\r\n   *\r\n   * If `significantDigits` is less than the number of digits necessary to represent the integer\r\n   * part of the value in normal (fixed-point) notation, then exponential notation is used.\r\n   *\r\n   * If `significantDigits` is omitted, or is `null` or `undefined`, then the return value is the\r\n   * same as `n.toString()`.\r\n   *\r\n   * If `roundingMode` is omitted or is `null` or `undefined`, `ROUNDING_MODE` is used.\r\n   *\r\n   * Throws if `significantDigits` or `roundingMode` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = 45.6\r\n   * y = new BigNumber(x)\r\n   * x.toPrecision()                 // '45.6'\r\n   * y.toPrecision()                 // '45.6'\r\n   * x.toPrecision(1)                // '5e+1'\r\n   * y.toPrecision(1)                // '5e+1'\r\n   * y.toPrecision(2, 0)             // '4.6e+1'  (ROUND_UP)\r\n   * y.toPrecision(2, 1)             // '4.5e+1'  (ROUND_DOWN)\r\n   * x.toPrecision(5)                // '45.600'\r\n   * y.toPrecision(5)                // '45.600'\r\n   * ```\r\n   *\r\n   * @param [significantDigits] Significant digits, integer, 1 to 1e+9.\r\n   * @param [roundingMode] Rounding mode, integer 0 to 8.\r\n   */\r\n  toPrecision(significantDigits: number, roundingMode?: BigNumber.RoundingMode): string;\r\n  toPrecision(): string;\r\n\r\n  /**\r\n   * Returns a string representing the value of this BigNumber in base `base`, or base 10 if `base`\r\n   * is omitted or is `null` or `undefined`.\r\n   *\r\n   * For bases above 10, and using the default base conversion alphabet (see `ALPHABET`), values\r\n   * from 10 to 35 are represented by a-z (the same as `Number.prototype.toString`).\r\n   *\r\n   * If a base is specified the value is rounded according to the current `DECIMAL_PLACES` and\r\n   * `ROUNDING_MODE` settings, otherwise it is not.\r\n   *\r\n   * If a base is not specified, and this BigNumber has a positive exponent that is equal to or\r\n   * greater than the positive component of the current `EXPONENTIAL_AT` setting, or a negative\r\n   * exponent equal to or less than the negative component of the setting, then exponential notation\r\n   * is returned.\r\n   *\r\n   * If `base` is `null` or `undefined` it is ignored.\r\n   *\r\n   * Throws if `base` is invalid.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(750000)\r\n   * x.toString()                    // '750000'\r\n   * BigNumber.config({ EXPONENTIAL_AT: 5 })\r\n   * x.toString()                    // '7.5e+5'\r\n   *\r\n   * y = new BigNumber(362.875)\r\n   * y.toString(2)                   // '101101010.111'\r\n   * y.toString(9)                   // '442.77777777777777777778'\r\n   * y.toString(32)                  // 'ba.s'\r\n   *\r\n   * BigNumber.config({ DECIMAL_PLACES: 4 });\r\n   * z = new BigNumber('1.23456789')\r\n   * z.toString()                    // '1.23456789'\r\n   * z.toString(10)                  // '1.2346'\r\n   * ```\r\n   *\r\n   * @param [base] The base, integer, 2 to 36 (or `ALPHABET.length`, see `ALPHABET`).\r\n   */\r\n  toString(base?: number): string;\r\n\r\n  /**\r\n   * As `toString`, but does not accept a base argument and includes the minus sign for negative\r\n   * zero.\r\n   *\r\n   * ``ts\r\n   * x = new BigNumber('-0')\r\n   * x.toString()                    // '0'\r\n   * x.valueOf()                     // '-0'\r\n   * y = new BigNumber('1.777e+457')\r\n   * y.valueOf()                     // '1.777e+457'\r\n   * ```\r\n   */\r\n  valueOf(): string;\r\n\r\n  /** Helps ES6 import. */\r\n  private static readonly default?: BigNumber.Constructor;\r\n\r\n  /** Helps ES6 import. */\r\n  private static readonly BigNumber?: BigNumber.Constructor;\r\n\r\n  /** Rounds away from zero. */\r\n  static readonly ROUND_UP: 0;\r\n\r\n  /** Rounds towards zero. */\r\n  static readonly ROUND_DOWN: 1;\r\n\r\n  /** Rounds towards Infinity. */\r\n  static readonly ROUND_CEIL: 2;\r\n\r\n  /** Rounds towards -Infinity. */\r\n  static readonly ROUND_FLOOR: 3;\r\n\r\n  /** Rounds towards nearest neighbour. If equidistant, rounds away from zero . */\r\n  static readonly ROUND_HALF_UP: 4;\r\n\r\n  /** Rounds towards nearest neighbour. If equidistant, rounds towards zero. */\r\n  static readonly ROUND_HALF_DOWN: 5;\r\n\r\n  /** Rounds towards nearest neighbour. If equidistant, rounds towards even neighbour. */\r\n  static readonly ROUND_HALF_EVEN: 6;\r\n\r\n  /** Rounds towards nearest neighbour. If equidistant, rounds towards Infinity. */\r\n  static readonly ROUND_HALF_CEIL: 7;\r\n\r\n  /** Rounds towards nearest neighbour. If equidistant, rounds towards -Infinity. */\r\n  static readonly ROUND_HALF_FLOOR: 8;\r\n\r\n  /** See `MODULO_MODE`. */\r\n  static readonly EUCLID: 9;\r\n\r\n  /**\r\n   * To aid in debugging, if a `BigNumber.DEBUG` property is `true` then an error will be thrown\r\n   * if the BigNumber constructor receives an invalid `BigNumber.Value`, or if `BigNumber.isBigNumber`\r\n   * receives a BigNumber instance that is malformed.\r\n   *\r\n   * ```ts\r\n   * // No error, and BigNumber NaN is returned.\r\n   * new BigNumber('blurgh')    // 'NaN'\r\n   * new BigNumber(9, 2)        // 'NaN'\r\n   * BigNumber.DEBUG = true\r\n   * new BigNumber('blurgh')    // '[BigNumber Error] Not a number'\r\n   * new BigNumber(9, 2)        // '[BigNumber Error] Not a base 2 number'\r\n   * ```\r\n   *\r\n   * An error will also be thrown if a `BigNumber.Value` is of type number with more than 15\r\n   * significant digits, as calling `toString` or `valueOf` on such numbers may not result\r\n   * in the intended value.\r\n   *\r\n   * ```ts\r\n   * console.log(823456789123456.3)       //  823456789123456.2\r\n   * // No error, and the returned BigNumber does not have the same value as the number literal.\r\n   * new BigNumber(823456789123456.3)     // '823456789123456.2'\r\n   * BigNumber.DEBUG = true\r\n   * new BigNumber(823456789123456.3)\r\n   * // '[BigNumber Error] Number primitive has more than 15 significant digits'\r\n   * ```\r\n   *\r\n   * Check that a BigNumber instance is well-formed:\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber(10)\r\n   *\r\n   * BigNumber.DEBUG = false\r\n   * // Change x.c to an illegitimate value.\r\n   * x.c = NaN\r\n   * // No error, as BigNumber.DEBUG is false.\r\n   * BigNumber.isBigNumber(x)    // true\r\n   *\r\n   * BigNumber.DEBUG = true\r\n   * BigNumber.isBigNumber(x)    // '[BigNumber Error] Invalid BigNumber'\r\n   * ```\r\n   */\r\n  static DEBUG?: boolean;\r\n\r\n  /**\r\n   * Returns a new independent BigNumber constructor with configuration as described by `object`, or\r\n   * with the default configuration if object is `null` or `undefined`.\r\n   *\r\n   * Throws if `object` is not an object.\r\n   *\r\n   * ```ts\r\n   * BigNumber.config({ DECIMAL_PLACES: 5 })\r\n   * BN = BigNumber.clone({ DECIMAL_PLACES: 9 })\r\n   *\r\n   * x = new BigNumber(1)\r\n   * y = new BN(1)\r\n   *\r\n   * x.div(3)                        // 0.33333\r\n   * y.div(3)                        // 0.333333333\r\n   *\r\n   * // BN = BigNumber.clone({ DECIMAL_PLACES: 9 }) is equivalent to:\r\n   * BN = BigNumber.clone()\r\n   * BN.config({ DECIMAL_PLACES: 9 })\r\n   * ```\r\n   *\r\n   * @param [object] The configuration object.\r\n   */\r\n  static clone(object?: BigNumber.Config): BigNumber.Constructor;\r\n\r\n  /**\r\n   * Configures the settings that apply to this BigNumber constructor.\r\n   *\r\n   * The configuration object, `object`, contains any number of the properties shown in the example\r\n   * below.\r\n   *\r\n   * Returns an object with the above properties and their current values.\r\n   *\r\n   * Throws if `object` is not an object, or if an invalid value is assigned to one or more of the\r\n   * properties.\r\n   *\r\n   * ```ts\r\n   * BigNumber.config({\r\n   *     DECIMAL_PLACES: 40,\r\n   *     ROUNDING_MODE: BigNumber.ROUND_HALF_CEIL,\r\n   *     EXPONENTIAL_AT: [-10, 20],\r\n   *     RANGE: [-500, 500],\r\n   *     CRYPTO: true,\r\n   *     MODULO_MODE: BigNumber.ROUND_FLOOR,\r\n   *     POW_PRECISION: 80,\r\n   *     FORMAT: {\r\n   *         groupSize: 3,\r\n   *         groupSeparator: ' ',\r\n   *         decimalSeparator: ','\r\n   *     },\r\n   *     ALPHABET: '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'\r\n   * });\r\n   *\r\n   * BigNumber.config().DECIMAL_PLACES        // 40\r\n   * ```\r\n   *\r\n   * @param object The configuration object.\r\n   */\r\n  static config(object: BigNumber.Config): BigNumber.Config;\r\n\r\n  /**\r\n   * Returns `true` if `value` is a BigNumber instance, otherwise returns `false`.\r\n   *\r\n   * If `BigNumber.DEBUG` is `true`, throws if a BigNumber instance is not well-formed.\r\n   *\r\n   * ```ts\r\n   * x = 42\r\n   * y = new BigNumber(x)\r\n   *\r\n   * BigNumber.isBigNumber(x)             // false\r\n   * y instanceof BigNumber               // true\r\n   * BigNumber.isBigNumber(y)             // true\r\n   *\r\n   * BN = BigNumber.clone();\r\n   * z = new BN(x)\r\n   * z instanceof BigNumber               // false\r\n   * BigNumber.isBigNumber(z)             // true\r\n   * ```\r\n   *\r\n   * @param value The value to test.\r\n   */\r\n  static isBigNumber(value: any): value is BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the maximum of the arguments.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber('3257869345.0378653')\r\n   * BigNumber.maximum(4e9, x, '123456789.9')      // '4000000000'\r\n   *\r\n   * arr = [12, '13', new BigNumber(14)]\r\n   * BigNumber.maximum.apply(null, arr)            // '14'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   */\r\n  static maximum(...n: BigNumber.Value[]): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the maximum of the arguments.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber('3257869345.0378653')\r\n   * BigNumber.max(4e9, x, '123456789.9')      // '4000000000'\r\n   *\r\n   * arr = [12, '13', new BigNumber(14)]\r\n   * BigNumber.max.apply(null, arr)            // '14'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   */\r\n  static max(...n: BigNumber.Value[]): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the minimum of the arguments.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber('3257869345.0378653')\r\n   * BigNumber.minimum(4e9, x, '123456789.9')          // '123456789.9'\r\n   *\r\n   * arr = [2, new BigNumber(-14), '-15.9999', -12]\r\n   * BigNumber.minimum.apply(null, arr)                // '-15.9999'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   */\r\n  static minimum(...n: BigNumber.Value[]): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the minimum of the arguments.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber('3257869345.0378653')\r\n   * BigNumber.min(4e9, x, '123456789.9')             // '123456789.9'\r\n   *\r\n   * arr = [2, new BigNumber(-14), '-15.9999', -12]\r\n   * BigNumber.min.apply(null, arr)                   // '-15.9999'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   */\r\n  static min(...n: BigNumber.Value[]): BigNumber;\r\n\r\n  /**\r\n   * Returns a new BigNumber with a pseudo-random value equal to or greater than 0 and less than 1.\r\n   *\r\n   * The return value will have `decimalPlaces` decimal places, or less if trailing zeros are\r\n   * produced. If `decimalPlaces` is omitted, the current `DECIMAL_PLACES` setting will be used.\r\n   *\r\n   * Depending on the value of this BigNumber constructor's `CRYPTO` setting and the support for the\r\n   * `crypto` object in the host environment, the random digits of the return value are generated by\r\n   * either `Math.random` (fastest), `crypto.getRandomValues` (Web Cryptography API in recent\r\n   * browsers) or `crypto.randomBytes` (Node.js).\r\n   *\r\n   * To be able to set `CRYPTO` to true when using Node.js, the `crypto` object must be available\r\n   * globally:\r\n   *\r\n   * ```ts\r\n   * global.crypto = require('crypto')\r\n   * ```\r\n   *\r\n   * If `CRYPTO` is true, i.e. one of the `crypto` methods is to be used, the value of a returned\r\n   * BigNumber should be cryptographically secure and statistically indistinguishable from a random\r\n   * value.\r\n   *\r\n   * Throws if `decimalPlaces` is invalid.\r\n   *\r\n   * ```ts\r\n   * BigNumber.config({ DECIMAL_PLACES: 10 })\r\n   * BigNumber.random()              // '0.4117936847'\r\n   * BigNumber.random(20)            // '0.78193327636914089009'\r\n   * ```\r\n   *\r\n   * @param [decimalPlaces] Decimal places, integer, 0 to 1e+9.\r\n   */\r\n  static random(decimalPlaces?: number): BigNumber;\r\n\r\n  /**\r\n   * Returns a BigNumber whose value is the sum of the arguments.\r\n   *\r\n   * The return value is always exact and unrounded.\r\n   *\r\n   * ```ts\r\n   * x = new BigNumber('3257869345.0378653')\r\n   * BigNumber.sum(4e9, x, '123456789.9')      // '7381326134.9378653'\r\n   *\r\n   * arr = [2, new BigNumber(14), '15.9999', 12]\r\n   * BigNumber.sum.apply(null, arr)            // '43.9999'\r\n   * ```\r\n   *\r\n   * @param n A numeric value.\r\n   */\r\n  static sum(...n: BigNumber.Value[]): BigNumber;\r\n\r\n  /**\r\n   * Configures the settings that apply to this BigNumber constructor.\r\n   *\r\n   * The configuration object, `object`, contains any number of the properties shown in the example\r\n   * below.\r\n   *\r\n   * Returns an object with the above properties and their current values.\r\n   *\r\n   * Throws if `object` is not an object, or if an invalid value is assigned to one or more of the\r\n   * properties.\r\n   *\r\n   * ```ts\r\n   * BigNumber.set({\r\n   *     DECIMAL_PLACES: 40,\r\n   *     ROUNDING_MODE: BigNumber.ROUND_HALF_CEIL,\r\n   *     EXPONENTIAL_AT: [-10, 20],\r\n   *     RANGE: [-500, 500],\r\n   *     CRYPTO: true,\r\n   *     MODULO_MODE: BigNumber.ROUND_FLOOR,\r\n   *     POW_PRECISION: 80,\r\n   *     FORMAT: {\r\n   *         groupSize: 3,\r\n   *         groupSeparator: ' ',\r\n   *         decimalSeparator: ','\r\n   *     },\r\n   *     ALPHABET: '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'\r\n   * });\r\n   *\r\n   * BigNumber.set().DECIMAL_PLACES        // 40\r\n   * ```\r\n   *\r\n   * @param object The configuration object.\r\n   */\r\n  static set(object: BigNumber.Config): BigNumber.Config;\r\n}\r\n"},{"name":"@taquito/utils/dist/types/constants.d.ts","dts":"export declare enum Prefix {\r\n    TZ1 = \"tz1\",\r\n    TZ2 = \"tz2\",\r\n    TZ3 = \"tz3\",\r\n    KT = \"KT\",\r\n    KT1 = \"KT1\",\r\n    EDSK2 = \"edsk2\",\r\n    SPSK = \"spsk\",\r\n    P2SK = \"p2sk\",\r\n    EDPK = \"edpk\",\r\n    SPPK = \"sppk\",\r\n    P2PK = \"p2pk\",\r\n    EDESK = \"edesk\",\r\n    SPESK = \"spesk\",\r\n    P2ESK = \"p2esk\",\r\n    EDSK = \"edsk\",\r\n    EDSIG = \"edsig\",\r\n    SPSIG = \"spsig\",\r\n    P2SIG = \"p2sig\",\r\n    SIG = \"sig\",\r\n    NET = \"Net\",\r\n    NCE = \"nce\",\r\n    B = \"b\",\r\n    O = \"o\",\r\n    LO = \"Lo\",\r\n    LLO = \"LLo\",\r\n    P = \"P\",\r\n    CO = \"Co\",\r\n    ID = \"id\",\r\n    EXPR = \"expr\",\r\n    TZ = \"TZ\"\r\n}\r\nexport declare const prefix: {\r\n    tz1: Uint8Array;\r\n    tz2: Uint8Array;\r\n    tz3: Uint8Array;\r\n    KT: Uint8Array;\r\n    KT1: Uint8Array;\r\n    edsk: Uint8Array;\r\n    edsk2: Uint8Array;\r\n    spsk: Uint8Array;\r\n    p2sk: Uint8Array;\r\n    edpk: Uint8Array;\r\n    sppk: Uint8Array;\r\n    p2pk: Uint8Array;\r\n    edesk: Uint8Array;\r\n    spesk: Uint8Array;\r\n    p2esk: Uint8Array;\r\n    edsig: Uint8Array;\r\n    spsig: Uint8Array;\r\n    p2sig: Uint8Array;\r\n    sig: Uint8Array;\r\n    Net: Uint8Array;\r\n    nce: Uint8Array;\r\n    b: Uint8Array;\r\n    o: Uint8Array;\r\n    Lo: Uint8Array;\r\n    LLo: Uint8Array;\r\n    P: Uint8Array;\r\n    Co: Uint8Array;\r\n    id: Uint8Array;\r\n    expr: Uint8Array;\r\n    TZ: Uint8Array;\r\n};\r\nexport declare const prefixLength: {\r\n    [key: string]: number;\r\n};\r\n"},{"name":"@taquito/utils/dist/types/taquito-utils.d.ts","dts":"/**\r\n * @packageDocumentation\r\n * @module @taquito/utils\r\n */\r\nimport { Buffer } from 'buffer';\r\nexport * from './validators';\r\nexport { prefix, Prefix, prefixLength } from './constants';\r\n/**\r\n *\r\n * @description Hash a string using the BLAKE2b algorithm, base58 encode the hash obtained and appends the prefix 'expr' to it\r\n *\r\n * @param value Value in hex\r\n */\r\nexport declare function encodeExpr(value: string): any;\r\n/**\r\n *\r\n * @description Base58 encode a string or a Uint8Array and append a prefix to it\r\n *\r\n * @param value Value to base58 encode\r\n * @param prefix prefix to append to the encoded string\r\n */\r\nexport declare function b58cencode(value: string | Uint8Array, prefix: Uint8Array): any;\r\n/**\r\n *\r\n * @description Base58 decode a string and remove the prefix from it\r\n *\r\n * @param value Value to base58 decode\r\n * @param prefix prefix to remove from the decoded string\r\n */\r\nexport declare const b58cdecode: (enc: string, prefixArg: Uint8Array) => Uint8Array;\r\n/**\r\n *\r\n * @description Base58 decode a string with predefined prefix\r\n *\r\n * @param value Value to base58 decode\r\n */\r\nexport declare function b58decode(payload: string): string;\r\n/**\r\n *\r\n * @description Base58 encode a public key using predefined prefix\r\n *\r\n * @param value Public Key to base58 encode\r\n */\r\nexport declare function encodePubKey(value: string): any;\r\n/**\r\n *\r\n * @description Base58 encode a key according to its prefix\r\n *\r\n * @param value Key to base58 encode\r\n */\r\nexport declare function encodeKey(value: string): any;\r\n/**\r\n *\r\n * @description Base58 encode a key hash according to its prefix\r\n *\r\n * @param value Key to base58 encode\r\n */\r\nexport declare function encodeKeyHash(value: string): any;\r\n/**\r\n *\r\n * @description Convert an hex string to a Uint8Array\r\n *\r\n * @param hex Hex string to convert\r\n */\r\nexport declare const hex2buf: (hex: string) => Uint8Array;\r\n/**\r\n *\r\n * @description Merge 2 buffers together\r\n *\r\n * @param b1 First buffer\r\n * @param b2 Second buffer\r\n */\r\nexport declare const mergebuf: (b1: Uint8Array, b2: Uint8Array) => Uint8Array;\r\n/**\r\n *\r\n * @description Flatten a michelson json representation to an array\r\n *\r\n * @param s michelson json\r\n */\r\nexport declare const mic2arr: (s: any) => any;\r\n/**\r\n *\r\n * @description Convert a buffer to an hex string\r\n *\r\n * @param buffer Buffer to convert\r\n */\r\nexport declare const buf2hex: (buffer: Buffer) => string;\r\n/**\r\n *\r\n * @description Convert a string to bytes\r\n *\r\n * @param str String to convert\r\n */\r\nexport declare function char2Bytes(str: string): string;\r\n/**\r\n *\r\n * @description Convert bytes to a string\r\n *\r\n * @param str Bytes to convert\r\n */\r\nexport declare function bytes2Char(hex: string): string;\r\n"},{"name":"@taquito/utils/dist/types/validators.d.ts","dts":"import { Prefix } from './constants';\r\nexport declare enum ValidationResult {\r\n    NO_PREFIX_MATCHED = 0,\r\n    INVALID_CHECKSUM = 1,\r\n    INVALID_LENGTH = 2,\r\n    VALID = 3\r\n}\r\nexport declare function isValidPrefix(value: any): value is Prefix;\r\n/**\r\n * @description Used to check if an address or a contract address is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateAddress } from '@taquito/utils';\r\n * const pkh = 'tz1L9r8mWmRPndRhuvMCWESLGSVeFzQ9NAWx'\r\n * const validation = validateAddress(pkh)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\r\nexport declare function validateAddress(value: any): ValidationResult;\r\n/**\r\n * @description Used to check if a chain id is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateChain } from '@taquito/utils';\r\n * const chainId = 'NetXdQprcVkpaWU'\r\n * const validation = validateChain(chainId)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\r\nexport declare function validateChain(value: any): ValidationResult;\r\n/**\r\n * @description Used to check if a contract address is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateContractAddress } from '@taquito/utils';\r\n * const contractAddress = 'KT1JVErLYTgtY8uGGZ4mso2npTSxqVLDRVbC'\r\n * const validation = validateContractAddress(contractAddress)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\r\nexport declare function validateContractAddress(value: any): ValidationResult;\r\n/**\r\n * @description Used to check if a key hash is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateKeyHash } from '@taquito/utils';\r\n * const keyHashWithoutPrefix = '1L9r8mWmRPndRhuvMCWESLGSVeFzQ9NAWx'\r\n * const validation = validateKeyHash(keyHashWithoutPrefix)\r\n * console.log(validation)\r\n * // This example return 0 which correspond to NO_PREFIX_MATCHED\r\n * ```\r\n */\r\nexport declare function validateKeyHash(value: any): ValidationResult;\r\n/**\r\n * @description Used to check if a signature is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateSignature } from '@taquito/utils';\r\n * const signature = 'edsigtkpiSSschcaCt9pUVrpNPf7TTcgvgDEDD6NCEHMy8NNQJCGnMfLZzYoQj74yLjo9wx6MPVV29CvVzgi7qEcEUok3k7AuMg'\r\n * const validation = validateSignature(signature)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\r\nexport declare function validateSignature(value: any): ValidationResult;\r\n/**\r\n * @description Used to check if a signature is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validatePublicKey } from '@taquito/utils';\r\n * const publicKey = 'edsigtkpiSSschcaCt9pUVrpNPf7TTcgvgDEDD6NCEHMy8NNQJCGnMfLZzYoQj74yLjo9wx6MPVV29CvVzgi7qEcEUok3k7AuMg'\r\n * const validation = validatePublicKey(publicKey)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\r\nexport declare function validatePublicKey(value: any): ValidationResult;\r\n"}]