(globalThis.webpackChunkbeacon_docs=globalThis.webpackChunkbeacon_docs||[]).push([[3365],{6732:()=>{},13543:()=>{},15340:()=>{},16864:(e,n,t)=>{"use strict";t.d(n,{A:()=>o});var r=t(96540);const o=function(){if("undefined"==typeof window)return{width:999,height:999};const[e,n]=(0,r.useState)({width:window.innerWidth,height:window.innerHeight});return(0,r.useEffect)(()=>{function e(){n({width:window.innerWidth,height:window.innerHeight})}return window.addEventListener("resize",e),()=>window.removeEventListener("resize",e)},[]),e}},18641:()=>{},21638:()=>{},38664:()=>{},47790:()=>{},58954:()=>{},66247:()=>{},72615:()=>{},73776:()=>{},76450:(e,n,t)=>{"use strict";t.d(n,{A:()=>p});var r=t(96540),o=t(95293);const a=[{name:"@airgap/beacon-blockchain-substrate/types/messages/permission-request.d.ts",dts:"import { AppMetadata, PermissionRequestV3 } from '@airgap/beacon-types';\nimport { SubstratePermissionScope } from '../permission-scope';\nexport interface SubstratePermissionRequest extends PermissionRequestV3<'substrate'> {\n    blockchainData: {\n        scopes: SubstratePermissionScope[];\n        appMetadata: AppMetadata;\n        network?: {\n            genesisHash: string;\n            rpc?: string;\n        }[];\n    };\n}\n"},{name:"@airgap/beacon-blockchain-substrate/types/messages/permission-response.d.ts",dts:"import { AppMetadata, PermissionResponseV3 } from '@airgap/beacon-types';\nimport { SubstratePermissionScope } from '../permission-scope';\nexport interface SubstratePermissionResponse extends PermissionResponseV3<'substrate'> {\n    blockchainData: {\n        appMetadata: AppMetadata;\n        scopes: SubstratePermissionScope[];\n        accounts: {\n            accountId: string;\n            network?: {\n                genesisHash: string;\n                rpc?: string;\n            };\n            publicKey: string;\n            address: string;\n        }[];\n    };\n}\n"},{name:"@airgap/beacon-blockchain-substrate/types/messages/sign-payload-request.d.ts",dts:"import { BlockchainMessage } from '@airgap/beacon-types';\nimport { SubstrateMessageType } from '../message-type';\nimport { SubstratePermissionScope } from '../permission-scope';\nexport interface SubstrateSignPayloadRequest extends BlockchainMessage<'substrate'> {\n    blockchainData: {\n        type: SubstrateMessageType.sign_payload_request;\n        scope: SubstratePermissionScope.sign_payload_json | SubstratePermissionScope.sign_payload_json;\n        payload: {\n            type: 'json';\n            /**\n             * @description The checkpoint hash of the block, in hex\n             */\n            blockHash: string;\n            /**\n             * @description The checkpoint block number, in hex\n             */\n            blockNumber: string;\n            /**\n             * @description The era for this transaction, in hex\n             */\n            era: string;\n            /**\n             * @description The genesis hash of the chain, in hex\n             */\n            genesisHash: string;\n            /**\n             * @description The encoded method (with arguments) in hex\n             */\n            method: string;\n            /**\n             * @description The nonce for this transaction, in hex\n             */\n            nonce: string;\n            /**\n             * @description The current spec version for the runtime\n             */\n            specVersion: string;\n            /**\n             * @description The tip for this transaction, in hex\n             */\n            tip: string;\n            /**\n             * @description The current transaction version for the runtime\n             */\n            transactionVersion: string;\n            /**\n             * @description The applicable signed extensions for this runtime\n             */\n            signedExtensions: string[];\n            /**\n             * @description The version of the extrinsic we are dealing with\n             */\n            version: number;\n        } | {\n            type: 'raw';\n            isMutable: boolean;\n            dataType: 'bytes' | 'payload';\n            data: string;\n        };\n        mode: 'submit' | 'submit-and-return' | 'return';\n    };\n}\n"},{name:"@airgap/beacon-blockchain-substrate/types/messages/sign-payload-response.d.ts",dts:"export type SubstrateSignPayloadResponse = {\n    transactionHash: string;\n} | {\n    transactionHash: string;\n    signature: string;\n    payload?: string;\n} | {\n    signature: string;\n    payload?: string;\n};\n"},{name:"@airgap/beacon-blockchain-substrate/types/messages/transfer-request.d.ts",dts:"import { BlockchainMessage } from '@airgap/beacon-types';\nimport { SubstrateMessageType } from '../message-type';\nimport { SubstratePermissionScope } from '../permission-scope';\nexport interface SubstrateTransferRequest extends BlockchainMessage<'substrate'> {\n    blockchainData: {\n        type: SubstrateMessageType.transfer_request;\n        scope: SubstratePermissionScope.transfer;\n        sourceAddress: string;\n        amount: string;\n        recipient: string;\n        network: {\n            genesisHash: string;\n            rpc?: string;\n        };\n        mode: 'submit' | 'submit-and-return' | 'return';\n    };\n}\n"},{name:"@airgap/beacon-blockchain-substrate/types/messages/transfer-response.d.ts",dts:"export type SubstrateTransferResponse = {\n    transactionHash: string;\n} | {\n    transactionHash: string;\n    signature: string;\n    payload?: string;\n} | {\n    signature: string;\n    payload?: string;\n};\n"},{name:"@airgap/beacon-blockchain-substrate/types/message-type.d.ts",dts:"export declare enum SubstrateMessageType {\n    'transfer_request' = \"transfer_request\",\n    'sign_payload_request' = \"sign_payload_request\"\n}\n"},{name:"@airgap/beacon-blockchain-substrate/types/permission-scope.d.ts",dts:"export declare enum SubstratePermissionScope {\n    'transfer' = \"transfer\",\n    'sign_payload_json' = \"sign_payload_json\",\n    'sign_payload_raw' = \"sign_payload_raw\"\n}\n"},{name:"@airgap/beacon-blockchain-substrate/ui/alert/alert-templates.d.ts",dts:"export declare const alertTemplates: {\n    default: {\n        css: string;\n    };\n    pair: {\n        css: string;\n    };\n};\n"},{name:"@airgap/beacon-blockchain-substrate/ui/alert/wallet-lists.d.ts",dts:"import { App, DesktopApp, ExtensionApp, WebApp } from '@airgap/beacon-types';\nexport declare const extensionList: ExtensionApp[];\nexport declare const desktopList: DesktopApp[];\nexport declare const webList: WebApp[];\nexport declare const iOSList: App[];\n"},{name:"@airgap/beacon-blockchain-substrate/ui/toast/toast-templates.d.ts",dts:"export declare const toastTemplates: {\n    default: {\n        css: string;\n    };\n};\n"},{name:"@airgap/beacon-blockchain-substrate/util/is-kusama-message.d.ts",dts:""},{name:"@airgap/beacon-blockchain-substrate/blockchain.d.ts",dts:"import { Blockchain, BlockchainMessage, ResponseInput, ExtensionApp, DesktopApp, WebApp, App } from '@airgap/beacon-types';\nimport { SubstratePermissionResponse } from './types/messages/permission-response';\nexport declare class SubstrateBlockchain implements Blockchain {\n    readonly identifier: string;\n    validateRequest(input: BlockchainMessage): Promise<void>;\n    handleResponse(input: ResponseInput): Promise<void>;\n    getWalletLists(): Promise<{\n        extensionList: ExtensionApp[];\n        desktopList: DesktopApp[];\n        webList: WebApp[];\n        iOSList: App[];\n    }>;\n    getAccountInfosFromPermissionResponse(permissionResponse: SubstratePermissionResponse): Promise<{\n        accountId: string;\n        address: string;\n        publicKey: string;\n    }[]>;\n}\n"},{name:"@airgap/beacon-blockchain-substrate/index.d.ts",dts:"export { SubstrateBlockchain } from './blockchain';\nexport * from './types/message-type';\nexport * from './types/permission-scope';\nexport * from './types/messages/permission-request';\nexport * from './types/messages/permission-response';\nexport * from './types/messages/sign-payload-request';\nexport * from './types/messages/sign-payload-response';\nexport * from './types/messages/transfer-request';\nexport * from './types/messages/transfer-response';\n"},{name:"@airgap/beacon-blockchain-substrate/dist/esm/types/messages/permission-request.d.ts",dts:"import { AppMetadata, PermissionRequestV3 } from '@airgap/beacon-types';\nimport { SubstratePermissionScope } from '../permission-scope';\nexport interface SubstratePermissionRequest extends PermissionRequestV3<'substrate'> {\n    blockchainData: {\n        scopes: SubstratePermissionScope[];\n        appMetadata: AppMetadata;\n        network?: {\n            genesisHash: string;\n            rpc?: string;\n        }[];\n    };\n}\n"},{name:"@airgap/beacon-blockchain-substrate/dist/esm/types/messages/permission-response.d.ts",dts:"import { AppMetadata, PermissionResponseV3 } from '@airgap/beacon-types';\nimport { SubstratePermissionScope } from '../permission-scope';\nexport interface SubstratePermissionResponse extends PermissionResponseV3<'substrate'> {\n    blockchainData: {\n        appMetadata: AppMetadata;\n        scopes: SubstratePermissionScope[];\n        accounts: {\n            accountId: string;\n            network?: {\n                genesisHash: string;\n                rpc?: string;\n            };\n            publicKey: string;\n            address: string;\n        }[];\n    };\n}\n"},{name:"@airgap/beacon-blockchain-substrate/dist/esm/types/messages/sign-payload-request.d.ts",dts:"import { BlockchainMessage } from '@airgap/beacon-types';\nimport { SubstrateMessageType } from '../message-type';\nimport { SubstratePermissionScope } from '../permission-scope';\nexport interface SubstrateSignPayloadRequest extends BlockchainMessage<'substrate'> {\n    blockchainData: {\n        type: SubstrateMessageType.sign_payload_request;\n        scope: SubstratePermissionScope.sign_payload_json | SubstratePermissionScope.sign_payload_json;\n        payload: {\n            type: 'json';\n            /**\n             * @description The checkpoint hash of the block, in hex\n             */\n            blockHash: string;\n            /**\n             * @description The checkpoint block number, in hex\n             */\n            blockNumber: string;\n            /**\n             * @description The era for this transaction, in hex\n             */\n            era: string;\n            /**\n             * @description The genesis hash of the chain, in hex\n             */\n            genesisHash: string;\n            /**\n             * @description The encoded method (with arguments) in hex\n             */\n            method: string;\n            /**\n             * @description The nonce for this transaction, in hex\n             */\n            nonce: string;\n            /**\n             * @description The current spec version for the runtime\n             */\n            specVersion: string;\n            /**\n             * @description The tip for this transaction, in hex\n             */\n            tip: string;\n            /**\n             * @description The current transaction version for the runtime\n             */\n            transactionVersion: string;\n            /**\n             * @description The applicable signed extensions for this runtime\n             */\n            signedExtensions: string[];\n            /**\n             * @description The version of the extrinsic we are dealing with\n             */\n            version: number;\n        } | {\n            type: 'raw';\n            isMutable: boolean;\n            dataType: 'bytes' | 'payload';\n            data: string;\n        };\n        mode: 'submit' | 'submit-and-return' | 'return';\n    };\n}\n"},{name:"@airgap/beacon-blockchain-substrate/dist/esm/types/messages/sign-payload-response.d.ts",dts:"export type SubstrateSignPayloadResponse = {\n    transactionHash: string;\n} | {\n    transactionHash: string;\n    signature: string;\n    payload?: string;\n} | {\n    signature: string;\n    payload?: string;\n};\n"},{name:"@airgap/beacon-blockchain-substrate/dist/esm/types/messages/transfer-request.d.ts",dts:"import { BlockchainMessage } from '@airgap/beacon-types';\nimport { SubstrateMessageType } from '../message-type';\nimport { SubstratePermissionScope } from '../permission-scope';\nexport interface SubstrateTransferRequest extends BlockchainMessage<'substrate'> {\n    blockchainData: {\n        type: SubstrateMessageType.transfer_request;\n        scope: SubstratePermissionScope.transfer;\n        sourceAddress: string;\n        amount: string;\n        recipient: string;\n        network: {\n            genesisHash: string;\n            rpc?: string;\n        };\n        mode: 'submit' | 'submit-and-return' | 'return';\n    };\n}\n"},{name:"@airgap/beacon-blockchain-substrate/dist/esm/types/messages/transfer-response.d.ts",dts:"export type SubstrateTransferResponse = {\n    transactionHash: string;\n} | {\n    transactionHash: string;\n    signature: string;\n    payload?: string;\n} | {\n    signature: string;\n    payload?: string;\n};\n"},{name:"@airgap/beacon-blockchain-substrate/dist/esm/types/message-type.d.ts",dts:"export declare enum SubstrateMessageType {\n    'transfer_request' = \"transfer_request\",\n    'sign_payload_request' = \"sign_payload_request\"\n}\n"},{name:"@airgap/beacon-blockchain-substrate/dist/esm/types/permission-scope.d.ts",dts:"export declare enum SubstratePermissionScope {\n    'transfer' = \"transfer\",\n    'sign_payload_json' = \"sign_payload_json\",\n    'sign_payload_raw' = \"sign_payload_raw\"\n}\n"},{name:"@airgap/beacon-blockchain-substrate/dist/esm/ui/alert/alert-templates.d.ts",dts:"export declare const alertTemplates: {\n    default: {\n        css: string;\n    };\n    pair: {\n        css: string;\n    };\n};\n"},{name:"@airgap/beacon-blockchain-substrate/dist/esm/ui/alert/wallet-lists.d.ts",dts:"import { App, DesktopApp, ExtensionApp, WebApp } from '@airgap/beacon-types';\nexport declare const extensionList: ExtensionApp[];\nexport declare const desktopList: DesktopApp[];\nexport declare const webList: WebApp[];\nexport declare const iOSList: App[];\n"},{name:"@airgap/beacon-blockchain-substrate/dist/esm/ui/toast/toast-templates.d.ts",dts:"export declare const toastTemplates: {\n    default: {\n        css: string;\n    };\n};\n"},{name:"@airgap/beacon-blockchain-substrate/dist/esm/util/is-kusama-message.d.ts",dts:""},{name:"@airgap/beacon-blockchain-substrate/dist/esm/blockchain.d.ts",dts:"import { Blockchain, BlockchainMessage, ResponseInput, ExtensionApp, DesktopApp, WebApp, App } from '@airgap/beacon-types';\nimport { SubstratePermissionResponse } from './types/messages/permission-response';\nexport declare class SubstrateBlockchain implements Blockchain {\n    readonly identifier: string;\n    validateRequest(input: BlockchainMessage): Promise<void>;\n    handleResponse(input: ResponseInput): Promise<void>;\n    getWalletLists(): Promise<{\n        extensionList: ExtensionApp[];\n        desktopList: DesktopApp[];\n        webList: WebApp[];\n        iOSList: App[];\n    }>;\n    getAccountInfosFromPermissionResponse(permissionResponse: SubstratePermissionResponse): Promise<{\n        accountId: string;\n        address: string;\n        publicKey: string;\n    }[]>;\n}\n"},{name:"@airgap/beacon-blockchain-substrate/dist/esm/index.d.ts",dts:"export { SubstrateBlockchain } from './blockchain';\nexport * from './types/message-type';\nexport * from './types/permission-scope';\nexport * from './types/messages/permission-request';\nexport * from './types/messages/permission-response';\nexport * from './types/messages/sign-payload-request';\nexport * from './types/messages/sign-payload-response';\nexport * from './types/messages/transfer-request';\nexport * from './types/messages/transfer-response';\n"},{name:"@airgap/beacon-blockchain-tezos/ui/alert/alert-templates.d.ts",dts:"export declare const alertTemplates: {\n    default: {\n        css: string;\n    };\n    pair: {\n        css: string;\n    };\n};\n"},{name:"@airgap/beacon-blockchain-tezos/ui/alert/wallet-lists.d.ts",dts:"import { App, DesktopApp, ExtensionApp, WebApp } from '@airgap/beacon-types';\nexport declare const extensionList: ExtensionApp[];\nexport declare const desktopList: DesktopApp[];\nexport declare const webList: WebApp[];\nexport declare const iOSList: App[];\n"},{name:"@airgap/beacon-blockchain-tezos/ui/toast/toast-templates.d.ts",dts:"export declare const toastTemplates: {\n    default: {\n        css: string;\n    };\n};\n"},{name:"@airgap/beacon-blockchain-tezos/blockchain.d.ts",dts:"import { Blockchain, BlockchainMessage, PermissionResponseV3, ResponseInput, App, DesktopApp, ExtensionApp, WebApp } from '@airgap/beacon-types';\nexport declare class TezosBlockchain implements Blockchain {\n    readonly identifier: string;\n    validateRequest(input: BlockchainMessage): Promise<void>;\n    handleResponse(input: ResponseInput): Promise<void>;\n    getWalletLists(): Promise<{\n        extensionList: ExtensionApp[];\n        desktopList: DesktopApp[];\n        webList: WebApp[];\n        iOSList: App[];\n    }>;\n    getAccountInfosFromPermissionResponse(_permissionResponse: PermissionResponseV3<'tezos'>): Promise<{\n        accountId: string;\n        address: string;\n        publicKey: string;\n    }[]>;\n}\n"},{name:"@airgap/beacon-blockchain-tezos/index.d.ts",dts:"export { TezosBlockchain } from './blockchain';\n"},{name:"@airgap/beacon-blockchain-tezos/dist/esm/ui/alert/alert-templates.d.ts",dts:"export declare const alertTemplates: {\n    default: {\n        css: string;\n    };\n    pair: {\n        css: string;\n    };\n};\n"},{name:"@airgap/beacon-blockchain-tezos/dist/esm/ui/alert/wallet-lists.d.ts",dts:"import { App, DesktopApp, ExtensionApp, WebApp } from '@airgap/beacon-types';\nexport declare const extensionList: ExtensionApp[];\nexport declare const desktopList: DesktopApp[];\nexport declare const webList: WebApp[];\nexport declare const iOSList: App[];\n"},{name:"@airgap/beacon-blockchain-tezos/dist/esm/ui/toast/toast-templates.d.ts",dts:"export declare const toastTemplates: {\n    default: {\n        css: string;\n    };\n};\n"},{name:"@airgap/beacon-blockchain-tezos/dist/esm/blockchain.d.ts",dts:"import { Blockchain, BlockchainMessage, PermissionResponseV3, ResponseInput, App, DesktopApp, ExtensionApp, WebApp } from '@airgap/beacon-types';\nexport declare class TezosBlockchain implements Blockchain {\n    readonly identifier: string;\n    validateRequest(input: BlockchainMessage): Promise<void>;\n    handleResponse(input: ResponseInput): Promise<void>;\n    getWalletLists(): Promise<{\n        extensionList: ExtensionApp[];\n        desktopList: DesktopApp[];\n        webList: WebApp[];\n        iOSList: App[];\n    }>;\n    getAccountInfosFromPermissionResponse(_permissionResponse: PermissionResponseV3<'tezos'>): Promise<{\n        accountId: string;\n        address: string;\n        publicKey: string;\n    }[]>;\n}\n"},{name:"@airgap/beacon-blockchain-tezos/dist/esm/index.d.ts",dts:"export { TezosBlockchain } from './blockchain';\n"},{name:"@airgap/beacon-core/clients/beacon-client/BeaconClient.d.ts",dts:"import { ExposedPromise } from '@airgap/beacon-utils';\nimport { AnalyticsInterface, Storage } from '@airgap/beacon-types';\nimport { BeaconClientOptions } from './BeaconClientOptions';\nimport { KeyPair } from '@stablelib/ed25519';\n/**\n * @internalapi\n *\n * The beacon client is an abstract client that handles everything that is shared between all other clients.\n * Specifically, it handles managing the beaconId and and the local keypair.\n */\nexport declare abstract class BeaconClient {\n    /**\n     * The name of the client\n     */\n    readonly name: string;\n    /**\n     * The URL of the dApp Icon. This can be used to display the icon of the dApp on in the wallet\n     */\n    readonly iconUrl?: string;\n    /**\n     * The URL of the dApp.\n     */\n    readonly appUrl?: string;\n    /** The beaconId is a public key that is used to identify one specific application (dapp or wallet).\n     * This is used inside a message to specify the sender, for example.\n     */\n    protected _beaconId: ExposedPromise<string>;\n    get beaconId(): Promise<string>;\n    protected storage: Storage;\n    protected analytics: AnalyticsInterface;\n    /**\n     * The local keypair that is used for the communication encryption\n     */\n    protected _keyPair: ExposedPromise<KeyPair>;\n    protected get keyPair(): Promise<KeyPair>;\n    constructor(config: BeaconClientOptions);\n    /**\n     * This resets the SDK. After using this method, this instance is no longer usable. You will have to instanciate a new client.\n     */\n    destroy(): Promise<void>;\n    /**\n     * This method initializes the SDK by setting some values in the storage and generating a keypair.\n     */\n    protected initSDK(): Promise<void>;\n    /**\n     * Removes all beacon values from the storage.\n     */\n    private removeBeaconEntriesFromStorage;\n    /**\n     * This method tries to load the seed from storage, if it doesn't exist, a new one will be created and persisted.\n     */\n    private loadOrCreateBeaconSecret;\n}\n"},{name:"@airgap/beacon-core/clients/beacon-client/BeaconClientOptions.d.ts",dts:"import { AnalyticsInterface, Storage } from '@airgap/beacon-types';\n/**\n * @internalapi\n */\nexport interface BeaconClientOptions {\n    /**\n     * Name of the application\n     */\n    name: string;\n    /**\n     * A URL to the icon of the application\n     */\n    iconUrl?: string;\n    /**\n     * A URL to the website of the application\n     */\n    appUrl?: string;\n    /**\n     * The storage that will be used by the SDK\n     */\n    storage: Storage;\n    /**\n     * The analytics instance that will be used by the SDK\n     */\n    analytics?: AnalyticsInterface;\n}\n"},{name:"@airgap/beacon-core/clients/client/Client.d.ts",dts:"import { ExposedPromise } from '@airgap/beacon-utils';\nimport { ConnectionContext, TransportType, TransportStatus, BeaconBaseMessage, AccountInfo, PeerInfo, AppMetadata, BeaconRequestMessage, BeaconMessageWrapper, NodeDistributions } from '@airgap/beacon-types';\nimport { BeaconClient } from '../beacon-client/BeaconClient';\nimport { AccountManager } from '../../managers/AccountManager';\nimport { ClientOptions } from './ClientOptions';\nimport { Transport } from '../../transports/Transport';\n/**\n * @internalapi\n *\n * This abstract class handles the a big part of the logic that is shared between the dapp and wallet client.\n * For example, it selects and manages the transport and accounts.\n */\nexport declare abstract class Client extends BeaconClient {\n    protected readonly accountManager: AccountManager;\n    protected handleResponse: (_event: BeaconRequestMessage | BeaconMessageWrapper<BeaconBaseMessage>, connectionInfo: ConnectionContext) => void;\n    /**\n     * How many requests can be sent after another\n     */\n    protected readonly rateLimit: number;\n    /**\n     * The time window in seconds in which the \"rateLimit\" is checked\n     */\n    protected readonly rateLimitWindowInSeconds: number;\n    /**\n     * Stores the times when requests have been made to determine if the rate limit has been reached\n     */\n    protected requestCounter: number[];\n    protected readonly matrixNodes: NodeDistributions;\n    private transportListeners;\n    protected _transport: ExposedPromise<Transport<any>>;\n    protected get transport(): Promise<Transport<any>>;\n    /**\n     * Returns the connection status of the Client\n     */\n    get connectionStatus(): TransportStatus;\n    /**\n     * Returns whether or not the transaport is ready\n     */\n    get ready(): Promise<void>;\n    constructor(config: ClientOptions);\n    protected cleanup(): Promise<void>;\n    /**\n     * Return all locally known accounts\n     */\n    getAccounts(): Promise<AccountInfo[]>;\n    /**\n     * Return the account by ID\n     * @param accountIdentifier The ID of an account\n     */\n    getAccount(accountIdentifier: string): Promise<AccountInfo | undefined>;\n    /**\n     * Remove the account by ID\n     * @param accountIdentifier The ID of an account\n     */\n    removeAccount(accountIdentifier: string): Promise<void>;\n    /**\n     * Remove all locally stored accounts\n     */\n    removeAllAccounts(): Promise<void>;\n    /**\n     * Add a new request (current timestamp) to the pending requests, remove old ones and check if we are above the limit\n     */\n    addRequestAndCheckIfRateLimited(): Promise<boolean>;\n    /**\n     * This method initializes the client. It will check if the connection should be established to a\n     * browser extension or if the P2P transport should be used.\n     *\n     * @param transport A transport that can be provided by the user\n     */\n    init(transport: Transport<any>): Promise<TransportType>;\n    /**\n     * Returns the metadata of this DApp\n     */\n    getOwnAppMetadata(): Promise<AppMetadata>;\n    /**\n     * Return all known peers\n     */\n    getPeers(): Promise<PeerInfo[]>;\n    /**\n     * Add a new peer to the known peers\n     * @param peer The new peer to add\n     */\n    addPeer(peer: PeerInfo): Promise<void>;\n    destroy(): Promise<void>;\n    /**\n     * A \"setter\" for when the transport needs to be changed.\n     */\n    protected setTransport(transport?: Transport<any>): Promise<void>;\n    protected addListener(transport: Transport<any>): Promise<void>;\n    protected sendDisconnectToPeer(peer: PeerInfo, transport?: Transport<any>): Promise<void>;\n}\n"},{name:"@airgap/beacon-core/clients/client/ClientOptions.d.ts",dts:"import { Storage, NodeDistributions } from '@airgap/beacon-types';\n/**\n * @internalapi\n */\nexport interface ClientOptions {\n    /**\n     * Name of the application\n     */\n    name: string;\n    /**\n     * A URL to the icon of the application\n     */\n    iconUrl?: string;\n    /**\n     * A URL to the website of the application\n     */\n    appUrl?: string;\n    /**\n     * The storage that will be used by the SDK\n     */\n    storage: Storage;\n    /**\n     * Disable all default Events and UI elements. If passed together with \"eventHandlers\",\n     * the default eventHandlers will be removed, and the ones passed by the user will be added.\n     */\n    disableDefaultEvents?: boolean;\n    /**\n     * A list of matrix nodes to connect to. If a non-empty array is passed, the default options will be overwritten.\n     * One node will be randomly selected based on the local keypair and the other nodes will be used as a fallback in case the primary node goes down.\n     *\n     * Only provide the hostname, no https:// prefix. Eg. { [Regions.EU1]: ['matrix.example.com'] }\n     */\n    matrixNodes?: NodeDistributions;\n    /**\n     * Automatically switch between apps on Mobile Devices (Enabled by Default)\n     */\n    enableAppSwitching?: boolean;\n    /**\n     * Enable metrics tracking (Disabled by Default)\n     */\n    enableMetrics?: boolean;\n}\n"},{name:"@airgap/beacon-core/errors/AbortedBeaconError.d.ts",dts:"import { BeaconError } from './BeaconError';\n/**\n * @category Error\n */\nexport declare class AbortedBeaconError extends BeaconError {\n    name: string;\n    title: string;\n    constructor();\n}\n"},{name:"@airgap/beacon-core/errors/BeaconError.d.ts",dts:"import { BeaconErrorType } from '@airgap/beacon-types';\n/**\n * @category Error\n */\nexport declare abstract class BeaconError implements Error {\n    name: string;\n    message: string;\n    title: string;\n    description: string;\n    get fullDescription(): {\n        description: string;\n        data?: string;\n    };\n    constructor(errorType: BeaconErrorType, message: string);\n}\n"},{name:"@airgap/beacon-core/errors/BroadcastBeaconError.d.ts",dts:"import { BeaconError } from './BeaconError';\n/**\n * @category Error\n */\nexport declare class BroadcastBeaconError extends BeaconError {\n    name: string;\n    title: string;\n    constructor();\n}\n"},{name:"@airgap/beacon-core/errors/EncryptionTypeNotSupportedBeaconError.d.ts",dts:"/**\n * @category Error\n */\n"},{name:"@airgap/beacon-core/errors/NetworkNotSupportedBeaconError.d.ts",dts:"import { BeaconError } from './BeaconError';\n/**\n * @category Error\n */\nexport declare class NetworkNotSupportedBeaconError extends BeaconError {\n    name: string;\n    title: string;\n    constructor();\n}\n"},{name:"@airgap/beacon-core/errors/NoAddressBeaconError.d.ts",dts:"import { BeaconError } from './BeaconError';\n/**\n * @category Error\n */\nexport declare class NoAddressBeaconError extends BeaconError {\n    name: string;\n    title: string;\n    constructor();\n}\n"},{name:"@airgap/beacon-core/errors/NoPrivateKeyBeaconError.d.ts",dts:"import { BeaconError } from './BeaconError';\n/**\n * @category Error\n */\nexport declare class NoPrivateKeyBeaconError extends BeaconError {\n    name: string;\n    title: string;\n    constructor();\n}\n"},{name:"@airgap/beacon-core/errors/NotGrantedBeaconError.d.ts",dts:"import { BeaconError } from './BeaconError';\n/**\n * @category Error\n */\nexport declare class NotGrantedBeaconError extends BeaconError {\n    name: string;\n    title: string;\n    constructor();\n}\n"},{name:"@airgap/beacon-core/errors/ParametersInvalidBeaconError.d.ts",dts:"import { BeaconError } from './BeaconError';\n/**\n * @category Error\n */\nexport declare class ParametersInvalidBeaconError extends BeaconError {\n    name: string;\n    title: string;\n    constructor();\n}\n"},{name:"@airgap/beacon-core/errors/SignatureTypeNotSupportedBeaconError.d.ts",dts:"import { BeaconError } from './BeaconError';\n/**\n * @category Error\n */\nexport declare class SignatureTypeNotSupportedBeaconError extends BeaconError {\n    name: string;\n    title: string;\n    constructor();\n}\n"},{name:"@airgap/beacon-core/errors/TooManyOperationsBeaconError.d.ts",dts:"import { BeaconError } from './BeaconError';\n/**\n * @category Error\n */\nexport declare class TooManyOperationsBeaconError extends BeaconError {\n    name: string;\n    title: string;\n    constructor();\n}\n"},{name:"@airgap/beacon-core/errors/TransactionInvalidBeaconError.d.ts",dts:"import { BeaconError } from './BeaconError';\n/**\n * @category Error\n */\nexport declare class TransactionInvalidBeaconError extends BeaconError {\n    readonly data: unknown;\n    name: string;\n    title: string;\n    get fullDescription(): {\n        description: string;\n        data?: string;\n    };\n    constructor(data: unknown);\n}\n"},{name:"@airgap/beacon-core/errors/UnknownBeaconError.d.ts",dts:"import { BeaconError } from './BeaconError';\n/**\n * @category Error\n */\nexport declare class UnknownBeaconError extends BeaconError {\n    name: string;\n    title: string;\n    constructor();\n}\n"},{name:"@airgap/beacon-core/errors/get-error.d.ts",dts:"import { BeaconError } from './BeaconError';\nimport { BroadcastBeaconError } from './BroadcastBeaconError';\nimport { NetworkNotSupportedBeaconError } from './NetworkNotSupportedBeaconError';\nimport { BeaconErrorType } from '@airgap/beacon-types';\nexport { BeaconError };\nexport { BroadcastBeaconError, NetworkNotSupportedBeaconError };\ndeclare const getError: (errorType: BeaconErrorType, errorData: unknown) => BeaconError;\nexport default getError;\n"},{name:"@airgap/beacon-core/managers/AccountManager.d.ts",dts:"import { Storage, AccountInfo, BeaconMessage } from '@airgap/beacon-types';\n/**\n * @internalapi\n *\n * The AccountManager provides CRUD functionality for account entities and persists them to the provided storage.\n */\nexport declare class AccountManager {\n    private readonly storageManager;\n    constructor(storage: Storage);\n    getAccounts(): Promise<AccountInfo[]>;\n    getAccount(accountIdentifier: string): Promise<AccountInfo | undefined>;\n    addAccount(accountInfo: AccountInfo): Promise<void>;\n    updateAccount(accountIdentifier: string, accountInfo: Partial<AccountInfo>): Promise<AccountInfo | undefined>;\n    removeAccount(accountIdentifier: string): Promise<void>;\n    removeAccounts(accountIdentifiers: string[]): Promise<void>;\n    removeAllAccounts(): Promise<void>;\n    hasPermission(message: BeaconMessage): Promise<boolean>;\n}\n"},{name:"@airgap/beacon-core/managers/AppMetadataManager.d.ts",dts:"import { Storage, AppMetadata } from '@airgap/beacon-types';\n/**\n * @internalapi\n *\n * The AppMetadataManager provides CRUD functionality for app-metadata entities and persists them to the provided storage.\n */\nexport declare class AppMetadataManager {\n    private readonly storageManager;\n    constructor(storage: Storage);\n    getAppMetadataList(): Promise<AppMetadata[]>;\n    getAppMetadata(senderId: string): Promise<AppMetadata | undefined>;\n    addAppMetadata(appMetadata: AppMetadata): Promise<void>;\n    removeAppMetadata(senderId: string): Promise<void>;\n    removeAppMetadatas(senderIds: string[]): Promise<void>;\n    removeAllAppMetadata(): Promise<void>;\n}\n"},{name:"@airgap/beacon-core/managers/PeerManager.d.ts",dts:"import { Storage, StorageKey, StorageKeyReturnType } from '@airgap/beacon-types';\nimport { ArrayElem } from './StorageManager';\n/**\n * @internalapi\n *\n * The PeerManager provides CRUD functionality for peer entities and persists them to the provided storage.\n */\nexport declare class PeerManager<T extends StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET | StorageKey.TRANSPORT_WALLETCONNECT_PEERS_DAPP> {\n    private readonly storageManager;\n    constructor(storage: Storage, key: T);\n    hasPeer(publicKey: string): Promise<boolean>;\n    getPeers(): Promise<StorageKeyReturnType[T]>;\n    getPeer(publicKey: string): Promise<ArrayElem<StorageKeyReturnType[T]> | undefined>;\n    addPeer(peerInfo: ArrayElem<StorageKeyReturnType[T]>): Promise<void>;\n    removePeer(publicKey: string): Promise<void>;\n    removePeers(publicKeys: string[]): Promise<void>;\n    removeAllPeers(): Promise<void>;\n}\n"},{name:"@airgap/beacon-core/managers/PermissionManager.d.ts",dts:"import { BeaconMessage, Storage, PermissionInfo } from '@airgap/beacon-types';\n/**\n * @internalapi\n *\n * The PermissionManager provides CRUD functionality for permission entities and persists them to the provided storage.\n */\nexport declare class PermissionManager {\n    private readonly storageManager;\n    constructor(storage: Storage);\n    getPermissions(): Promise<PermissionInfo[]>;\n    getPermission(accountIdentifier: string): Promise<PermissionInfo | undefined>;\n    addPermission(permissionInfo: PermissionInfo): Promise<void>;\n    removePermission(accountIdentifier: string, senderId: string): Promise<void>;\n    removePermissions(accountIdentifiers: string[]): Promise<void>;\n    removeAllPermissions(): Promise<void>;\n    hasPermission(message: BeaconMessage): Promise<boolean>;\n}\n"},{name:"@airgap/beacon-core/managers/PermissionValidator.d.ts",dts:"import { BeaconMessage, PermissionEntity } from '@airgap/beacon-types';\n/**\n * @internalapi\n *\n * The PermissionValidator is used to check if permissions for a certain message type have been given\n */\nexport declare class PermissionValidator {\n    /**\n     * Check if permissions were given for a certain message type.\n     *\n     * PermissionRequest and BroadcastRequest will always return true.\n     *\n     * @param message Beacon Message\n     */\n    static hasPermission(message: BeaconMessage, getOne: (id: string) => Promise<PermissionEntity | undefined>, getAll: () => Promise<PermissionEntity[]>): Promise<boolean>;\n}\n"},{name:"@airgap/beacon-core/managers/StorageManager.d.ts",dts:"import { StorageKey, Storage, StorageKeyReturnType } from '@airgap/beacon-types';\n/** Type workaround for https://github.com/Microsoft/TypeScript/issues/7294#issuecomment-465794460 */\nexport type ArrayElem<A> = A extends (infer Elem)[] ? Elem : never;\n/**\n * @internalapi\n *\n * The StorageManager provides CRUD functionality for specific entities and persists them to the provided storage.\n */\nexport declare class StorageManager<T extends StorageKey.ACCOUNTS | StorageKey.APP_METADATA_LIST | StorageKey.PERMISSION_LIST | StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET | StorageKey.TRANSPORT_WALLETCONNECT_PEERS_DAPP> {\n    private readonly storage;\n    private readonly storageKey;\n    constructor(storage: Storage, storageKey: T);\n    getAll(): Promise<StorageKeyReturnType[T]>;\n    getOne(predicate: (element: ArrayElem<StorageKeyReturnType[T]>) => boolean): Promise<ArrayElem<StorageKeyReturnType[T]> | undefined>;\n    addOne(element: ArrayElem<StorageKeyReturnType[T]>, predicate: (element: ArrayElem<StorageKeyReturnType[T]>) => boolean, overwrite?: boolean): Promise<void>;\n    remove(predicate: (element: ArrayElem<StorageKeyReturnType[T]>) => boolean): Promise<void>;\n    removeAll(): Promise<void>;\n}\n"},{name:"@airgap/beacon-core/migrations/migrate-0.7.0.d.ts",dts:"import { PermissionScope, AccountIdentifier, Origin, Network } from '@airgap/beacon-types';\nexport interface AccountInfoOld {\n    accountIdentifier: AccountIdentifier;\n    beaconId: string;\n    origin: {\n        type: Origin;\n        id: string;\n    };\n    address: string;\n    pubkey: string;\n    network: Network;\n    scopes: PermissionScope[];\n    connectedAt: Date;\n}\nexport interface P2PPairingRequestOld {\n    name: string;\n    pubKey: string;\n    relayServer: string;\n}\nexport declare const migrate_0_7_0: (storage: Storage) => Promise<void>;\n"},{name:"@airgap/beacon-core/migrations/migrations.d.ts",dts:"import { Storage } from '@airgap/beacon-types';\nexport declare const migrate: (storage: Storage) => Promise<void>;\n"},{name:"@airgap/beacon-core/storage/ChromeStorage.d.ts",dts:"import { Storage, StorageKey, StorageKeyReturnType } from '@airgap/beacon-types';\n/**\n * @internalapi\n *\n * A storage that can be used in chrome extensions\n */\nexport declare class ChromeStorage implements Storage {\n    static isSupported(): Promise<boolean>;\n    get<K extends StorageKey>(key: K): Promise<StorageKeyReturnType[K]>;\n    set<K extends StorageKey>(key: K, value: StorageKeyReturnType[K]): Promise<void>;\n    delete<K extends StorageKey>(key: K): Promise<void>;\n    subscribeToStorageChanged(_callback: (arg: {\n        eventType: 'storageCleared' | 'entryModified';\n        key: string | null;\n        oldValue: string | null;\n        newValue: string | null;\n    }) => {}): Promise<void>;\n    getPrefixedKey(key: string): string;\n}\n"},{name:"@airgap/beacon-core/storage/IndexedDBStorage.d.ts",dts:"import { Storage, StorageKey, StorageKeyReturnType } from '@airgap/beacon-types';\nexport declare class IndexedDBStorage extends Storage {\n    private readonly dbName;\n    private readonly storeNames;\n    private db;\n    private isSupported;\n    /**\n     * @param dbName Name of the database.\n     * @param storeNames An array of object store names to create in the database.\n     *                   The first store in the array will be used as the default if none is specified.\n     */\n    constructor(dbName?: string, storeNames?: string[]);\n    private isIndexedDBSupported;\n    private initDB;\n    /**\n     * Performs a transaction on the given object store.\n     * @param mode Transaction mode.\n     * @param storeName The name of the object store.\n     * @param operation The operation to perform with the object store.\n     */\n    private transaction;\n    /**\n     * Retrieves a value by key from the specified object store.\n     * If no store is specified, the default (first in the list) is used.\n     */\n    get<K extends StorageKey>(key: K, storeName?: string): Promise<StorageKeyReturnType[K]>;\n    get(key: string, storeName?: string): Promise<string | undefined>;\n    /**\n     * Stores a key/value pair in the specified object store.\n     */\n    set<K extends StorageKey>(key: K, value: StorageKeyReturnType[K], storeName?: string): Promise<void>;\n    set(key: string, value: string, storeName?: string): Promise<void>;\n    /**\n     * Deletes an entry by key from the specified object store.\n     */\n    delete<K extends StorageKey>(key: K, storeName?: string): Promise<void>;\n    delete(key: string, storeName?: string): Promise<void>;\n    /**\n     * Retrieves all values from the specified object store.\n     */\n    getAll(storeName?: string): Promise<string[]>;\n    /**\n     * Retrieves all keys from the specified object store.\n     */\n    getAllKeys(storeName?: string): Promise<IDBValidKey[]>;\n    /**\n     * Clears all entries from the specified object store.\n     */\n    clearStore(storeName?: string): Promise<void>;\n    getPrefixedKey<K extends StorageKey>(key: K): string;\n    subscribeToStorageChanged(callback: (arg: {\n        eventType: 'storageCleared' | 'entryModified';\n        key: string | null;\n        oldValue: string | null;\n        newValue: string | null;\n    }) => {}): Promise<void>;\n    /**\n     * Copies all key/value pairs from the source store into a target store.\n     * @param targetDBName Name of the target database.\n     * @param targetStoreName Name of the target object store.\n     * @param skipKeys Keys to skip.\n     * @param sourceStoreName (Optional) Source store name \u2013 defaults to the default store.\n     */\n    fillStore(targetDBName: string, targetStoreName: string, skipKeys?: string[], sourceStoreName?: string): Promise<void>;\n}\n"},{name:"@airgap/beacon-core/storage/LocalStorage.d.ts",dts:"import { Storage, StorageKey, StorageKeyReturnType } from '@airgap/beacon-types';\n/**\n * @internalapi\n *\n * A storage that can be used in the browser\n */\nexport declare class LocalStorage extends Storage {\n    private readonly prefix?;\n    constructor(prefix?: string | undefined);\n    static isSupported(): Promise<boolean>;\n    get<K extends StorageKey>(key: K): Promise<StorageKeyReturnType[K]>;\n    set<K extends StorageKey>(key: K, value: StorageKeyReturnType[K]): Promise<void>;\n    delete<K extends StorageKey>(key: K): Promise<void>;\n    subscribeToStorageChanged(callback: (arg: {\n        eventType: 'storageCleared' | 'entryModified';\n        key: string | null;\n        oldValue: string | null;\n        newValue: string | null;\n    }) => {}): Promise<void>;\n    getPrefixedKey(key: string): string;\n}\n"},{name:"@airgap/beacon-core/storage/StorageValidator.d.ts",dts:"import { Storage } from '@airgap/beacon-types';\nexport declare class StorageValidator {\n    private readonly storage;\n    constructor(storage: Storage);\n    private validateNumber;\n    private validateText;\n    private validateBoolean;\n    private validateArray;\n    private objHasProperty;\n    private innerValidate;\n    validate(): Promise<boolean>;\n}\n"},{name:"@airgap/beacon-core/storage/WCStorage.d.ts",dts:"export declare class WCStorage {\n    private readonly localStorage;\n    private readonly indexedDB;\n    private channel;\n    onMessageHandler: ((type: string) => void) | undefined;\n    onErrorHandler: ((data: any) => void) | undefined;\n    constructor();\n    private onMessage;\n    private onError;\n    notify(type: string): void;\n    hasPairings(): Promise<boolean>;\n    hasSessions(): Promise<boolean>;\n    backup(): void;\n    resetState(): Promise<void>;\n}\n"},{name:"@airgap/beacon-core/storage/getStorage.d.ts",dts:"import { Storage } from '@airgap/beacon-types';\n/**\n * Get a supported storage on this platform\n */\nexport declare const getStorage: () => Promise<Storage>;\n"},{name:"@airgap/beacon-core/transports/clients/ClientEvents.d.ts",dts:'export declare const enum ClientEvents {\n    CLOSE_ALERT = "CLOSE_ALERT",\n    RESET_STATE = "RESET_STATE",\n    WC_ACK_NOTIFICATION = "WC_ACK_NOTIFICATION",\n    ON_RELAYER_ERROR = "ON_RELAYER_ERROR"\n}\n'},{name:"@airgap/beacon-core/transports/clients/CommunicationClient.d.ts",dts:"import { PeerInfoType } from '@airgap/beacon-types';\nimport { KeyPair } from '@stablelib/ed25519';\nimport { SessionKeys } from '@stablelib/x25519-session';\nimport { ClientEvents } from './ClientEvents';\n/**\n * @internalapi\n *\n *\n */\nexport declare abstract class CommunicationClient {\n    protected keyPair?: KeyPair | undefined;\n    constructor(keyPair?: KeyPair | undefined);\n    eventHandlers: Map<ClientEvents, Function>;\n    protected isMobileOS: () => boolean;\n    /**\n     * Get the public key\n     */\n    getPublicKey(): Promise<string>;\n    /**\n     * get the public key hash\n     */\n    getPublicKeyHash(): Promise<string>;\n    /**\n     * Create a cryptobox server\n     *\n     * @param otherPublicKey\n     * @param selfKeypair\n     */\n    protected createCryptoBoxServer(otherPublicKey: string, selfKeypair: KeyPair): Promise<SessionKeys>;\n    /**\n     * Create a cryptobox client\n     *\n     * @param otherPublicKey\n     * @param selfKeypair\n     */\n    protected createCryptoBoxClient(otherPublicKey: string, selfKeypair: KeyPair): Promise<SessionKeys>;\n    /**\n     * Encrypt a message for a specific publicKey (receiver, asymmetric)\n     *\n     * @param recipientPublicKey\n     * @param message\n     */\n    protected encryptMessageAsymmetric(recipientPublicKey: string, message: string): Promise<string>;\n    abstract unsubscribeFromEncryptedMessages(): Promise<void>;\n    abstract unsubscribeFromEncryptedMessage(senderPublicKey: string): Promise<void>;\n    abstract sendMessage(message: string, peer?: PeerInfoType): Promise<void>;\n}\n"},{name:"@airgap/beacon-core/transports/clients/MessageBasedClient.d.ts",dts:"import { CommunicationClient } from './CommunicationClient';\nimport { PostMessagePairingRequest, PostMessagePairingResponse } from '@airgap/beacon-types';\nimport { KeyPair } from '@stablelib/ed25519';\n/**\n * @internalapi\n *\n *\n */\nexport declare abstract class MessageBasedClient extends CommunicationClient {\n    protected readonly name: string;\n    /**\n     * The listeners that will be notified of new messages\n     */\n    protected abstract readonly activeListeners: Map<string, unknown>;\n    constructor(name: string, keyPair: KeyPair);\n    /**\n     * start the client and make sure all dependencies are ready\n     */\n    start(): Promise<void>;\n    /**\n     * Get the pairing request information. This will be shared with the peer during the connection setup\n     */\n    getPairingRequestInfo(): Promise<PostMessagePairingRequest>;\n    /**\n     * Get the pairing response information. This will be shared with the peer during the connection setup\n     */\n    getPairingResponseInfo(request: PostMessagePairingRequest): Promise<PostMessagePairingResponse>;\n    /**\n     * Unsubscribe from encrypted messages from a specific peer\n     *\n     * @param senderPublicKey\n     */\n    unsubscribeFromEncryptedMessage(senderPublicKey: string): Promise<void>;\n    /**\n     * Unsubscribe from all encrypted messages\n     */\n    unsubscribeFromEncryptedMessages(): Promise<void>;\n    /**\n     * Decrypt a message from a specific peer\n     *\n     * @param senderPublicKey\n     * @param payload\n     */\n    protected decryptMessage(senderPublicKey: string, payload: string): Promise<string>;\n    /**\n     * Encrypt a message for a specific publicKey (receiver)\n     *\n     * @param recipientPublicKey\n     * @param message\n     */\n    protected encryptMessage(recipientPublicKey: string, message: string): Promise<string>;\n    /**\n     * Initialize the connection\n     */\n    abstract init(): Promise<void>;\n}\n"},{name:"@airgap/beacon-core/transports/Transport.d.ts",dts:"import { TransportType, TransportStatus, PeerInfo, StorageKey, ConnectionContext } from '@airgap/beacon-types';\nimport { PeerManager } from '../managers/PeerManager';\nimport { CommunicationClient } from './clients/CommunicationClient';\nimport { ClientEvents } from './clients/ClientEvents';\n/**\n * @internalapi\n *\n *\n */\nexport declare abstract class Transport<T extends PeerInfo = PeerInfo, K extends StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET | StorageKey.TRANSPORT_WALLETCONNECT_PEERS_DAPP = any, S extends CommunicationClient = any> {\n    /**\n     * The type of the transport\n     */\n    readonly type: TransportType;\n    /**\n     * The name of the app\n     */\n    protected readonly name: string;\n    /**\n     * The status of the transport\n     */\n    protected _isConnected: TransportStatus;\n    protected readonly peerManager: PeerManager<K>;\n    /**\n     * The client handling the encryption/decryption of messages\n     */\n    protected client: S;\n    /**\n     * The listener that will be invoked when a new peer is connected\n     */\n    protected newPeerListener?: (peer: T) => void;\n    setEventHandler(event: ClientEvents, fun: Function): void;\n    /**\n     * The listeners that will be notified when new messages are coming in\n     */\n    private listeners;\n    /**\n     * Return the status of the connection\n     */\n    get connectionStatus(): TransportStatus;\n    constructor(name: string, client: S, peerManager: PeerManager<K>);\n    /**\n     * Returns a promise that resolves to true if the transport is available, false if it is not\n     */\n    static isAvailable(): Promise<boolean>;\n    /**\n     * Connect the transport\n     */\n    connect(): Promise<void>;\n    /**\n     * Disconnect the transport\n     */\n    disconnect(): Promise<void>;\n    /**\n     * Send a message through the transport\n     *\n     * @param message The message to send\n     * @param recipient The recipient of the message\n     */\n    send(message: string, peer?: PeerInfo): Promise<void>;\n    /**\n     * Add a listener to be called when a new message is received\n     *\n     * @param listener The listener that will be registered\n     */\n    addListener(listener: (message: unknown, connectionInfo: ConnectionContext) => void): Promise<void>;\n    /**\n     * Remove a listener\n     *\n     * @param listener\n     */\n    removeListener(listener: (message: string, connectionInfo: ConnectionContext) => void): Promise<void>;\n    getPeers(): Promise<T[]>;\n    addPeer(newPeer: T, _sendPairingResponse?: boolean): Promise<void>;\n    removePeer(peerToBeRemoved: T): Promise<void>;\n    removeAllPeers(): Promise<void>;\n    /**\n     * Notify the listeners when a new message comes in\n     *\n     * @param message Message\n     * @param connectionInfo Context info about the connection\n     */\n    protected notifyListeners(message: unknown, connectionInfo: ConnectionContext): Promise<void>;\n    abstract listen(publicKey: string): Promise<void>;\n}\n"},{name:"@airgap/beacon-core/utils/Logger.d.ts",dts:"export interface LoggerInterface {\n    debug(method: string, ...args: any[]): void;\n    log(method: string, ...args: any[]): void;\n    warn(method: string, ...args: any[]): void;\n    error(method: string, ...args: any[]): void;\n    time(start: boolean, label?: string): void;\n    timeLog(method: string, ...args: any[]): void;\n}\n/**\n * The logger that is used internally\n */\nexport declare class InternalLogger implements LoggerInterface {\n    constructor();\n    debug(name: string, method: string, ...args: any[]): void;\n    log(name: string, method: string, ...args: any[]): void;\n    warn(name: string, method: string, ...args: any[]): void;\n    error(name: string, method: string, ...args: any[]): void;\n    time(start: boolean, label?: string | undefined): void;\n    timeLog(name: string, method: string, ...args: any[]): void;\n    private _log;\n}\nexport declare class Logger implements LoggerInterface {\n    private readonly name;\n    constructor(service: string);\n    debug(method: string, ...args: any[]): void;\n    log(method: string, ...args: any[]): void;\n    warn(method: string, ...args: any[]): void;\n    error(method: string, ...args: any[]): void;\n    time(start: boolean, label?: string | undefined): void;\n    timeLog(method: string, ...args: any[]): void;\n}\nexport declare const setLogger: (newLogger: LoggerInterface) => void;\nexport declare const getLogger: () => LoggerInterface;\n"},{name:"@airgap/beacon-core/utils/assert-never.d.ts",dts:"/**\n * A helper function to make sure if/elses and switch/cases are exhaustive\n *\n * @param empty The data that has to be empty\n */\nexport declare function assertNever(empty: never): never;\n"},{name:"@airgap/beacon-core/utils/get-account-identifier.d.ts",dts:"import { Network } from '@airgap/beacon-types';\n/**\n * @internalapi\n *\n * Generate a deterministic account identifier based on an address and a network\n *\n * @param address\n * @param network\n */\nexport declare const getAccountIdentifier: (address: string, network: Network) => Promise<string>;\n"},{name:"@airgap/beacon-core/utils/get-sender-id.d.ts",dts:"/**\n * @internalapi\n *\n * Generate a deterministic sender identifier based on a public key\n *\n * @param publicKey\n */\nexport declare const getSenderId: (publicKey: string) => Promise<string>;\n"},{name:"@airgap/beacon-core/utils/multi-tab-channel.d.ts",dts:"export declare class MultiTabChannel {\n    private channel;\n    private elector;\n    private eventListeners;\n    private onBCMessageHandler;\n    private onElectedLeaderHandler;\n    private wasLeader;\n    private initialized;\n    constructor(name: string, onBCMessageHandler: Function, onElectedLeaderHandler: Function);\n    init(): Promise<void>;\n    private onBeforeUnloadHandler;\n    private onMessageHandler;\n    isLeader(): boolean;\n    getLeadership(): Promise<void>;\n    hasLeader(): Promise<boolean>;\n    postMessage(message: any): void;\n}\n"},{name:"@airgap/beacon-core/MockAnalytics.d.ts",dts:"import { AnalyticsInterface } from '@airgap/beacon-types';\nexport declare class MockAnalytics implements AnalyticsInterface {\n    track(_trigger: 'click' | 'event', _section: string, _label: string, _data?: Record<string, any>): void;\n}\n"},{name:"@airgap/beacon-core/MockWindow.d.ts",dts:"type Callback = (message: unknown) => void;\n/**\n * A mock for postmessage if run in node.js environment\n */\ndeclare let windowRef: {\n    postMessage: (message: string | Record<string, unknown>, _target?: string) => void;\n    addEventListener: (_name: string, eventCallback: Callback) => void;\n    removeEventListener: (_name: string, eventCallback: Callback) => void;\n    location: {\n        origin: string;\n    };\n};\ndeclare const clearMockWindowState: () => void;\nexport { windowRef, clearMockWindowState };\n"},{name:"@airgap/beacon-core/Serializer.d.ts",dts:"/**\n * @internalapi\n *\n * The Serializer is used to serialize / deserialize JSON objects and encode them with bs58check\n */\nexport declare class Serializer {\n    /**\n     * Serialize and bs58check encode an object\n     *\n     * @param message JSON object to serialize\n     */\n    serialize(message: unknown): Promise<string>;\n    /**\n     * Deserialize a bs58check encoded string\n     *\n     * @param encoded String to be deserialized\n     */\n    deserialize(encoded: string): Promise<unknown>;\n}\n"},{name:"@airgap/beacon-core/constants.d.ts",dts:"export declare const SDK_VERSION: string;\nexport declare const BEACON_VERSION: string;\nexport declare const NOTIFICATION_ORACLE_URL: string;\nexport declare const BACKEND_URL: string;\n"},{name:"@airgap/beacon-core/debug.d.ts",dts:"export declare const setDebugEnabled: (enabled: boolean) => void;\nexport declare const getDebugEnabled: () => boolean;\n"},{name:"@airgap/beacon-core/index.d.ts",dts:"/**\n * General docs\n * @module public\n */\nimport { Client } from './clients/client/Client';\nimport { BeaconError } from './errors/BeaconError';\nimport { BroadcastBeaconError } from './errors/BroadcastBeaconError';\nimport { NetworkNotSupportedBeaconError } from './errors/NetworkNotSupportedBeaconError';\nimport { NoAddressBeaconError } from './errors/NoAddressBeaconError';\nimport { NoPrivateKeyBeaconError } from './errors/NoPrivateKeyBeaconError';\nimport { NotGrantedBeaconError } from './errors/NotGrantedBeaconError';\nimport { ParametersInvalidBeaconError } from './errors/ParametersInvalidBeaconError';\nimport { TooManyOperationsBeaconError } from './errors/TooManyOperationsBeaconError';\nimport { TransactionInvalidBeaconError } from './errors/TransactionInvalidBeaconError';\nimport { UnknownBeaconError } from './errors/UnknownBeaconError';\nimport { Transport } from './transports/Transport';\nimport { ChromeStorage } from './storage/ChromeStorage';\nimport { LocalStorage } from './storage/LocalStorage';\nimport { getStorage } from './storage/getStorage';\nimport { Serializer } from './Serializer';\nimport { ClientOptions } from './clients/client/ClientOptions';\nimport { SDK_VERSION, BEACON_VERSION } from './constants';\nimport { AccountManager } from './managers/AccountManager';\nimport { AppMetadataManager } from './managers/AppMetadataManager';\nimport { PermissionManager } from './managers/PermissionManager';\nimport { BeaconClient } from './clients/beacon-client/BeaconClient';\nimport { BeaconClientOptions } from './clients/beacon-client/BeaconClientOptions';\nimport { getAccountIdentifier } from './utils/get-account-identifier';\nimport { AbortedBeaconError } from './errors/AbortedBeaconError';\nimport { getSenderId } from './utils/get-sender-id';\nimport { PeerManager } from './managers/PeerManager';\nimport { MessageBasedClient } from './transports/clients/MessageBasedClient';\nimport { setDebugEnabled, getDebugEnabled } from './debug';\nimport { SignatureTypeNotSupportedBeaconError } from './errors/SignatureTypeNotSupportedBeaconError';\nimport { getLogger, Logger, setLogger } from './utils/Logger';\nimport { windowRef } from './MockWindow';\nimport { CommunicationClient } from './transports/clients/CommunicationClient';\nimport { ClientEvents } from './transports/clients/ClientEvents';\nimport { WCStorage } from './storage/WCStorage';\nimport { IndexedDBStorage } from './storage/IndexedDBStorage';\nimport { StorageValidator } from './storage/StorageValidator';\nimport { MultiTabChannel } from './utils/multi-tab-channel';\nimport getError from './errors/get-error';\nexport { BeaconClient, BeaconClientOptions, Client, ClientOptions, ClientEvents };\nexport { getError, BeaconError, AbortedBeaconError, BroadcastBeaconError, NetworkNotSupportedBeaconError, NoAddressBeaconError, NoPrivateKeyBeaconError, NotGrantedBeaconError, ParametersInvalidBeaconError, TooManyOperationsBeaconError, TransactionInvalidBeaconError, SignatureTypeNotSupportedBeaconError, UnknownBeaconError };\nexport { Transport, MessageBasedClient, CommunicationClient };\nexport { ChromeStorage, LocalStorage, WCStorage, IndexedDBStorage, StorageValidator, getStorage };\nexport { PeerManager, AccountManager, AppMetadataManager, PermissionManager };\nexport { SDK_VERSION, BEACON_VERSION };\nexport { getSenderId, getAccountIdentifier, windowRef, MultiTabChannel };\nexport { Serializer, Logger, setLogger, getLogger };\nexport { setDebugEnabled, getDebugEnabled };\nexport { NOTIFICATION_ORACLE_URL, BACKEND_URL } from './constants';\n"},{name:"@airgap/beacon-core/dist/esm/clients/beacon-client/BeaconClient.d.ts",dts:"import { ExposedPromise } from '@airgap/beacon-utils';\nimport { AnalyticsInterface, Storage } from '@airgap/beacon-types';\nimport { BeaconClientOptions } from './BeaconClientOptions';\nimport { KeyPair } from '@stablelib/ed25519';\n/**\n * @internalapi\n *\n * The beacon client is an abstract client that handles everything that is shared between all other clients.\n * Specifically, it handles managing the beaconId and and the local keypair.\n */\nexport declare abstract class BeaconClient {\n    /**\n     * The name of the client\n     */\n    readonly name: string;\n    /**\n     * The URL of the dApp Icon. This can be used to display the icon of the dApp on in the wallet\n     */\n    readonly iconUrl?: string;\n    /**\n     * The URL of the dApp.\n     */\n    readonly appUrl?: string;\n    /** The beaconId is a public key that is used to identify one specific application (dapp or wallet).\n     * This is used inside a message to specify the sender, for example.\n     */\n    protected _beaconId: ExposedPromise<string>;\n    get beaconId(): Promise<string>;\n    protected storage: Storage;\n    protected analytics: AnalyticsInterface;\n    /**\n     * The local keypair that is used for the communication encryption\n     */\n    protected _keyPair: ExposedPromise<KeyPair>;\n    protected get keyPair(): Promise<KeyPair>;\n    constructor(config: BeaconClientOptions);\n    /**\n     * This resets the SDK. After using this method, this instance is no longer usable. You will have to instanciate a new client.\n     */\n    destroy(): Promise<void>;\n    /**\n     * This method initializes the SDK by setting some values in the storage and generating a keypair.\n     */\n    protected initSDK(): Promise<void>;\n    /**\n     * Removes all beacon values from the storage.\n     */\n    private removeBeaconEntriesFromStorage;\n    /**\n     * This method tries to load the seed from storage, if it doesn't exist, a new one will be created and persisted.\n     */\n    private loadOrCreateBeaconSecret;\n}\n"},{name:"@airgap/beacon-core/dist/esm/clients/beacon-client/BeaconClientOptions.d.ts",dts:"import { AnalyticsInterface, Storage } from '@airgap/beacon-types';\n/**\n * @internalapi\n */\nexport interface BeaconClientOptions {\n    /**\n     * Name of the application\n     */\n    name: string;\n    /**\n     * A URL to the icon of the application\n     */\n    iconUrl?: string;\n    /**\n     * A URL to the website of the application\n     */\n    appUrl?: string;\n    /**\n     * The storage that will be used by the SDK\n     */\n    storage: Storage;\n    /**\n     * The analytics instance that will be used by the SDK\n     */\n    analytics?: AnalyticsInterface;\n}\n"},{name:"@airgap/beacon-core/dist/esm/clients/client/Client.d.ts",dts:"import { ExposedPromise } from '@airgap/beacon-utils';\nimport { ConnectionContext, TransportType, TransportStatus, BeaconBaseMessage, AccountInfo, PeerInfo, AppMetadata, BeaconRequestMessage, BeaconMessageWrapper, NodeDistributions } from '@airgap/beacon-types';\nimport { BeaconClient } from '../beacon-client/BeaconClient';\nimport { AccountManager } from '../../managers/AccountManager';\nimport { ClientOptions } from './ClientOptions';\nimport { Transport } from '../../transports/Transport';\n/**\n * @internalapi\n *\n * This abstract class handles the a big part of the logic that is shared between the dapp and wallet client.\n * For example, it selects and manages the transport and accounts.\n */\nexport declare abstract class Client extends BeaconClient {\n    protected readonly accountManager: AccountManager;\n    protected handleResponse: (_event: BeaconRequestMessage | BeaconMessageWrapper<BeaconBaseMessage>, connectionInfo: ConnectionContext) => void;\n    /**\n     * How many requests can be sent after another\n     */\n    protected readonly rateLimit: number;\n    /**\n     * The time window in seconds in which the \"rateLimit\" is checked\n     */\n    protected readonly rateLimitWindowInSeconds: number;\n    /**\n     * Stores the times when requests have been made to determine if the rate limit has been reached\n     */\n    protected requestCounter: number[];\n    protected readonly matrixNodes: NodeDistributions;\n    private transportListeners;\n    protected _transport: ExposedPromise<Transport<any>>;\n    protected get transport(): Promise<Transport<any>>;\n    /**\n     * Returns the connection status of the Client\n     */\n    get connectionStatus(): TransportStatus;\n    /**\n     * Returns whether or not the transaport is ready\n     */\n    get ready(): Promise<void>;\n    constructor(config: ClientOptions);\n    protected cleanup(): Promise<void>;\n    /**\n     * Return all locally known accounts\n     */\n    getAccounts(): Promise<AccountInfo[]>;\n    /**\n     * Return the account by ID\n     * @param accountIdentifier The ID of an account\n     */\n    getAccount(accountIdentifier: string): Promise<AccountInfo | undefined>;\n    /**\n     * Remove the account by ID\n     * @param accountIdentifier The ID of an account\n     */\n    removeAccount(accountIdentifier: string): Promise<void>;\n    /**\n     * Remove all locally stored accounts\n     */\n    removeAllAccounts(): Promise<void>;\n    /**\n     * Add a new request (current timestamp) to the pending requests, remove old ones and check if we are above the limit\n     */\n    addRequestAndCheckIfRateLimited(): Promise<boolean>;\n    /**\n     * This method initializes the client. It will check if the connection should be established to a\n     * browser extension or if the P2P transport should be used.\n     *\n     * @param transport A transport that can be provided by the user\n     */\n    init(transport: Transport<any>): Promise<TransportType>;\n    /**\n     * Returns the metadata of this DApp\n     */\n    getOwnAppMetadata(): Promise<AppMetadata>;\n    /**\n     * Return all known peers\n     */\n    getPeers(): Promise<PeerInfo[]>;\n    /**\n     * Add a new peer to the known peers\n     * @param peer The new peer to add\n     */\n    addPeer(peer: PeerInfo): Promise<void>;\n    destroy(): Promise<void>;\n    /**\n     * A \"setter\" for when the transport needs to be changed.\n     */\n    protected setTransport(transport?: Transport<any>): Promise<void>;\n    protected addListener(transport: Transport<any>): Promise<void>;\n    protected sendDisconnectToPeer(peer: PeerInfo, transport?: Transport<any>): Promise<void>;\n}\n"},{name:"@airgap/beacon-core/dist/esm/clients/client/ClientOptions.d.ts",dts:"import { Storage, NodeDistributions } from '@airgap/beacon-types';\n/**\n * @internalapi\n */\nexport interface ClientOptions {\n    /**\n     * Name of the application\n     */\n    name: string;\n    /**\n     * A URL to the icon of the application\n     */\n    iconUrl?: string;\n    /**\n     * A URL to the website of the application\n     */\n    appUrl?: string;\n    /**\n     * The storage that will be used by the SDK\n     */\n    storage: Storage;\n    /**\n     * Disable all default Events and UI elements. If passed together with \"eventHandlers\",\n     * the default eventHandlers will be removed, and the ones passed by the user will be added.\n     */\n    disableDefaultEvents?: boolean;\n    /**\n     * A list of matrix nodes to connect to. If a non-empty array is passed, the default options will be overwritten.\n     * One node will be randomly selected based on the local keypair and the other nodes will be used as a fallback in case the primary node goes down.\n     *\n     * Only provide the hostname, no https:// prefix. Eg. { [Regions.EU1]: ['matrix.example.com'] }\n     */\n    matrixNodes?: NodeDistributions;\n    /**\n     * Automatically switch between apps on Mobile Devices (Enabled by Default)\n     */\n    enableAppSwitching?: boolean;\n    /**\n     * Enable metrics tracking (Disabled by Default)\n     */\n    enableMetrics?: boolean;\n}\n"},{name:"@airgap/beacon-core/dist/esm/errors/AbortedBeaconError.d.ts",dts:"import { BeaconError } from './BeaconError';\n/**\n * @category Error\n */\nexport declare class AbortedBeaconError extends BeaconError {\n    name: string;\n    title: string;\n    constructor();\n}\n"},{name:"@airgap/beacon-core/dist/esm/errors/BeaconError.d.ts",dts:"import { BeaconErrorType } from '@airgap/beacon-types';\n/**\n * @category Error\n */\nexport declare abstract class BeaconError implements Error {\n    name: string;\n    message: string;\n    title: string;\n    description: string;\n    get fullDescription(): {\n        description: string;\n        data?: string;\n    };\n    constructor(errorType: BeaconErrorType, message: string);\n}\n"},{name:"@airgap/beacon-core/dist/esm/errors/BroadcastBeaconError.d.ts",dts:"import { BeaconError } from './BeaconError';\n/**\n * @category Error\n */\nexport declare class BroadcastBeaconError extends BeaconError {\n    name: string;\n    title: string;\n    constructor();\n}\n"},{name:"@airgap/beacon-core/dist/esm/errors/EncryptionTypeNotSupportedBeaconError.d.ts",dts:"/**\n * @category Error\n */\n"},{name:"@airgap/beacon-core/dist/esm/errors/NetworkNotSupportedBeaconError.d.ts",dts:"import { BeaconError } from './BeaconError';\n/**\n * @category Error\n */\nexport declare class NetworkNotSupportedBeaconError extends BeaconError {\n    name: string;\n    title: string;\n    constructor();\n}\n"},{name:"@airgap/beacon-core/dist/esm/errors/NoAddressBeaconError.d.ts",dts:"import { BeaconError } from './BeaconError';\n/**\n * @category Error\n */\nexport declare class NoAddressBeaconError extends BeaconError {\n    name: string;\n    title: string;\n    constructor();\n}\n"},{name:"@airgap/beacon-core/dist/esm/errors/NoPrivateKeyBeaconError.d.ts",dts:"import { BeaconError } from './BeaconError';\n/**\n * @category Error\n */\nexport declare class NoPrivateKeyBeaconError extends BeaconError {\n    name: string;\n    title: string;\n    constructor();\n}\n"},{name:"@airgap/beacon-core/dist/esm/errors/NotGrantedBeaconError.d.ts",dts:"import { BeaconError } from './BeaconError';\n/**\n * @category Error\n */\nexport declare class NotGrantedBeaconError extends BeaconError {\n    name: string;\n    title: string;\n    constructor();\n}\n"},{name:"@airgap/beacon-core/dist/esm/errors/ParametersInvalidBeaconError.d.ts",dts:"import { BeaconError } from './BeaconError';\n/**\n * @category Error\n */\nexport declare class ParametersInvalidBeaconError extends BeaconError {\n    name: string;\n    title: string;\n    constructor();\n}\n"},{name:"@airgap/beacon-core/dist/esm/errors/SignatureTypeNotSupportedBeaconError.d.ts",dts:"import { BeaconError } from './BeaconError';\n/**\n * @category Error\n */\nexport declare class SignatureTypeNotSupportedBeaconError extends BeaconError {\n    name: string;\n    title: string;\n    constructor();\n}\n"},{name:"@airgap/beacon-core/dist/esm/errors/TooManyOperationsBeaconError.d.ts",dts:"import { BeaconError } from './BeaconError';\n/**\n * @category Error\n */\nexport declare class TooManyOperationsBeaconError extends BeaconError {\n    name: string;\n    title: string;\n    constructor();\n}\n"},{name:"@airgap/beacon-core/dist/esm/errors/TransactionInvalidBeaconError.d.ts",dts:"import { BeaconError } from './BeaconError';\n/**\n * @category Error\n */\nexport declare class TransactionInvalidBeaconError extends BeaconError {\n    readonly data: unknown;\n    name: string;\n    title: string;\n    get fullDescription(): {\n        description: string;\n        data?: string;\n    };\n    constructor(data: unknown);\n}\n"},{name:"@airgap/beacon-core/dist/esm/errors/UnknownBeaconError.d.ts",dts:"import { BeaconError } from './BeaconError';\n/**\n * @category Error\n */\nexport declare class UnknownBeaconError extends BeaconError {\n    name: string;\n    title: string;\n    constructor();\n}\n"},{name:"@airgap/beacon-core/dist/esm/errors/get-error.d.ts",dts:"import { BeaconError } from './BeaconError';\nimport { BroadcastBeaconError } from './BroadcastBeaconError';\nimport { NetworkNotSupportedBeaconError } from './NetworkNotSupportedBeaconError';\nimport { BeaconErrorType } from '@airgap/beacon-types';\nexport { BeaconError };\nexport { BroadcastBeaconError, NetworkNotSupportedBeaconError };\ndeclare const getError: (errorType: BeaconErrorType, errorData: unknown) => BeaconError;\nexport default getError;\n"},{name:"@airgap/beacon-core/dist/esm/managers/AccountManager.d.ts",dts:"import { Storage, AccountInfo, BeaconMessage } from '@airgap/beacon-types';\n/**\n * @internalapi\n *\n * The AccountManager provides CRUD functionality for account entities and persists them to the provided storage.\n */\nexport declare class AccountManager {\n    private readonly storageManager;\n    constructor(storage: Storage);\n    getAccounts(): Promise<AccountInfo[]>;\n    getAccount(accountIdentifier: string): Promise<AccountInfo | undefined>;\n    addAccount(accountInfo: AccountInfo): Promise<void>;\n    updateAccount(accountIdentifier: string, accountInfo: Partial<AccountInfo>): Promise<AccountInfo | undefined>;\n    removeAccount(accountIdentifier: string): Promise<void>;\n    removeAccounts(accountIdentifiers: string[]): Promise<void>;\n    removeAllAccounts(): Promise<void>;\n    hasPermission(message: BeaconMessage): Promise<boolean>;\n}\n"},{name:"@airgap/beacon-core/dist/esm/managers/AppMetadataManager.d.ts",dts:"import { Storage, AppMetadata } from '@airgap/beacon-types';\n/**\n * @internalapi\n *\n * The AppMetadataManager provides CRUD functionality for app-metadata entities and persists them to the provided storage.\n */\nexport declare class AppMetadataManager {\n    private readonly storageManager;\n    constructor(storage: Storage);\n    getAppMetadataList(): Promise<AppMetadata[]>;\n    getAppMetadata(senderId: string): Promise<AppMetadata | undefined>;\n    addAppMetadata(appMetadata: AppMetadata): Promise<void>;\n    removeAppMetadata(senderId: string): Promise<void>;\n    removeAppMetadatas(senderIds: string[]): Promise<void>;\n    removeAllAppMetadata(): Promise<void>;\n}\n"},{name:"@airgap/beacon-core/dist/esm/managers/PeerManager.d.ts",dts:"import { Storage, StorageKey, StorageKeyReturnType } from '@airgap/beacon-types';\nimport { ArrayElem } from './StorageManager';\n/**\n * @internalapi\n *\n * The PeerManager provides CRUD functionality for peer entities and persists them to the provided storage.\n */\nexport declare class PeerManager<T extends StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET | StorageKey.TRANSPORT_WALLETCONNECT_PEERS_DAPP> {\n    private readonly storageManager;\n    constructor(storage: Storage, key: T);\n    hasPeer(publicKey: string): Promise<boolean>;\n    getPeers(): Promise<StorageKeyReturnType[T]>;\n    getPeer(publicKey: string): Promise<ArrayElem<StorageKeyReturnType[T]> | undefined>;\n    addPeer(peerInfo: ArrayElem<StorageKeyReturnType[T]>): Promise<void>;\n    removePeer(publicKey: string): Promise<void>;\n    removePeers(publicKeys: string[]): Promise<void>;\n    removeAllPeers(): Promise<void>;\n}\n"},{name:"@airgap/beacon-core/dist/esm/managers/PermissionManager.d.ts",dts:"import { BeaconMessage, Storage, PermissionInfo } from '@airgap/beacon-types';\n/**\n * @internalapi\n *\n * The PermissionManager provides CRUD functionality for permission entities and persists them to the provided storage.\n */\nexport declare class PermissionManager {\n    private readonly storageManager;\n    constructor(storage: Storage);\n    getPermissions(): Promise<PermissionInfo[]>;\n    getPermission(accountIdentifier: string): Promise<PermissionInfo | undefined>;\n    addPermission(permissionInfo: PermissionInfo): Promise<void>;\n    removePermission(accountIdentifier: string, senderId: string): Promise<void>;\n    removePermissions(accountIdentifiers: string[]): Promise<void>;\n    removeAllPermissions(): Promise<void>;\n    hasPermission(message: BeaconMessage): Promise<boolean>;\n}\n"},{name:"@airgap/beacon-core/dist/esm/managers/PermissionValidator.d.ts",dts:"import { BeaconMessage, PermissionEntity } from '@airgap/beacon-types';\n/**\n * @internalapi\n *\n * The PermissionValidator is used to check if permissions for a certain message type have been given\n */\nexport declare class PermissionValidator {\n    /**\n     * Check if permissions were given for a certain message type.\n     *\n     * PermissionRequest and BroadcastRequest will always return true.\n     *\n     * @param message Beacon Message\n     */\n    static hasPermission(message: BeaconMessage, getOne: (id: string) => Promise<PermissionEntity | undefined>, getAll: () => Promise<PermissionEntity[]>): Promise<boolean>;\n}\n"},{name:"@airgap/beacon-core/dist/esm/managers/StorageManager.d.ts",dts:"import { StorageKey, Storage, StorageKeyReturnType } from '@airgap/beacon-types';\n/** Type workaround for https://github.com/Microsoft/TypeScript/issues/7294#issuecomment-465794460 */\nexport type ArrayElem<A> = A extends (infer Elem)[] ? Elem : never;\n/**\n * @internalapi\n *\n * The StorageManager provides CRUD functionality for specific entities and persists them to the provided storage.\n */\nexport declare class StorageManager<T extends StorageKey.ACCOUNTS | StorageKey.APP_METADATA_LIST | StorageKey.PERMISSION_LIST | StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET | StorageKey.TRANSPORT_WALLETCONNECT_PEERS_DAPP> {\n    private readonly storage;\n    private readonly storageKey;\n    constructor(storage: Storage, storageKey: T);\n    getAll(): Promise<StorageKeyReturnType[T]>;\n    getOne(predicate: (element: ArrayElem<StorageKeyReturnType[T]>) => boolean): Promise<ArrayElem<StorageKeyReturnType[T]> | undefined>;\n    addOne(element: ArrayElem<StorageKeyReturnType[T]>, predicate: (element: ArrayElem<StorageKeyReturnType[T]>) => boolean, overwrite?: boolean): Promise<void>;\n    remove(predicate: (element: ArrayElem<StorageKeyReturnType[T]>) => boolean): Promise<void>;\n    removeAll(): Promise<void>;\n}\n"},{name:"@airgap/beacon-core/dist/esm/migrations/migrate-0.7.0.d.ts",dts:"import { PermissionScope, AccountIdentifier, Origin, Network } from '@airgap/beacon-types';\nexport interface AccountInfoOld {\n    accountIdentifier: AccountIdentifier;\n    beaconId: string;\n    origin: {\n        type: Origin;\n        id: string;\n    };\n    address: string;\n    pubkey: string;\n    network: Network;\n    scopes: PermissionScope[];\n    connectedAt: Date;\n}\nexport interface P2PPairingRequestOld {\n    name: string;\n    pubKey: string;\n    relayServer: string;\n}\nexport declare const migrate_0_7_0: (storage: Storage) => Promise<void>;\n"},{name:"@airgap/beacon-core/dist/esm/migrations/migrations.d.ts",dts:"import { Storage } from '@airgap/beacon-types';\nexport declare const migrate: (storage: Storage) => Promise<void>;\n"},{name:"@airgap/beacon-core/dist/esm/storage/ChromeStorage.d.ts",dts:"import { Storage, StorageKey, StorageKeyReturnType } from '@airgap/beacon-types';\n/**\n * @internalapi\n *\n * A storage that can be used in chrome extensions\n */\nexport declare class ChromeStorage implements Storage {\n    static isSupported(): Promise<boolean>;\n    get<K extends StorageKey>(key: K): Promise<StorageKeyReturnType[K]>;\n    set<K extends StorageKey>(key: K, value: StorageKeyReturnType[K]): Promise<void>;\n    delete<K extends StorageKey>(key: K): Promise<void>;\n    subscribeToStorageChanged(_callback: (arg: {\n        eventType: 'storageCleared' | 'entryModified';\n        key: string | null;\n        oldValue: string | null;\n        newValue: string | null;\n    }) => {}): Promise<void>;\n    getPrefixedKey(key: string): string;\n}\n"},{name:"@airgap/beacon-core/dist/esm/storage/IndexedDBStorage.d.ts",dts:"import { Storage, StorageKey, StorageKeyReturnType } from '@airgap/beacon-types';\nexport declare class IndexedDBStorage extends Storage {\n    private readonly dbName;\n    private readonly storeNames;\n    private db;\n    private isSupported;\n    /**\n     * @param dbName Name of the database.\n     * @param storeNames An array of object store names to create in the database.\n     *                   The first store in the array will be used as the default if none is specified.\n     */\n    constructor(dbName?: string, storeNames?: string[]);\n    private isIndexedDBSupported;\n    private initDB;\n    /**\n     * Performs a transaction on the given object store.\n     * @param mode Transaction mode.\n     * @param storeName The name of the object store.\n     * @param operation The operation to perform with the object store.\n     */\n    private transaction;\n    /**\n     * Retrieves a value by key from the specified object store.\n     * If no store is specified, the default (first in the list) is used.\n     */\n    get<K extends StorageKey>(key: K, storeName?: string): Promise<StorageKeyReturnType[K]>;\n    get(key: string, storeName?: string): Promise<string | undefined>;\n    /**\n     * Stores a key/value pair in the specified object store.\n     */\n    set<K extends StorageKey>(key: K, value: StorageKeyReturnType[K], storeName?: string): Promise<void>;\n    set(key: string, value: string, storeName?: string): Promise<void>;\n    /**\n     * Deletes an entry by key from the specified object store.\n     */\n    delete<K extends StorageKey>(key: K, storeName?: string): Promise<void>;\n    delete(key: string, storeName?: string): Promise<void>;\n    /**\n     * Retrieves all values from the specified object store.\n     */\n    getAll(storeName?: string): Promise<string[]>;\n    /**\n     * Retrieves all keys from the specified object store.\n     */\n    getAllKeys(storeName?: string): Promise<IDBValidKey[]>;\n    /**\n     * Clears all entries from the specified object store.\n     */\n    clearStore(storeName?: string): Promise<void>;\n    getPrefixedKey<K extends StorageKey>(key: K): string;\n    subscribeToStorageChanged(callback: (arg: {\n        eventType: 'storageCleared' | 'entryModified';\n        key: string | null;\n        oldValue: string | null;\n        newValue: string | null;\n    }) => {}): Promise<void>;\n    /**\n     * Copies all key/value pairs from the source store into a target store.\n     * @param targetDBName Name of the target database.\n     * @param targetStoreName Name of the target object store.\n     * @param skipKeys Keys to skip.\n     * @param sourceStoreName (Optional) Source store name \u2013 defaults to the default store.\n     */\n    fillStore(targetDBName: string, targetStoreName: string, skipKeys?: string[], sourceStoreName?: string): Promise<void>;\n}\n"},{name:"@airgap/beacon-core/dist/esm/storage/LocalStorage.d.ts",dts:"import { Storage, StorageKey, StorageKeyReturnType } from '@airgap/beacon-types';\n/**\n * @internalapi\n *\n * A storage that can be used in the browser\n */\nexport declare class LocalStorage extends Storage {\n    private readonly prefix?;\n    constructor(prefix?: string | undefined);\n    static isSupported(): Promise<boolean>;\n    get<K extends StorageKey>(key: K): Promise<StorageKeyReturnType[K]>;\n    set<K extends StorageKey>(key: K, value: StorageKeyReturnType[K]): Promise<void>;\n    delete<K extends StorageKey>(key: K): Promise<void>;\n    subscribeToStorageChanged(callback: (arg: {\n        eventType: 'storageCleared' | 'entryModified';\n        key: string | null;\n        oldValue: string | null;\n        newValue: string | null;\n    }) => {}): Promise<void>;\n    getPrefixedKey(key: string): string;\n}\n"},{name:"@airgap/beacon-core/dist/esm/storage/StorageValidator.d.ts",dts:"import { Storage } from '@airgap/beacon-types';\nexport declare class StorageValidator {\n    private readonly storage;\n    constructor(storage: Storage);\n    private validateNumber;\n    private validateText;\n    private validateBoolean;\n    private validateArray;\n    private objHasProperty;\n    private innerValidate;\n    validate(): Promise<boolean>;\n}\n"},{name:"@airgap/beacon-core/dist/esm/storage/WCStorage.d.ts",dts:"export declare class WCStorage {\n    private readonly localStorage;\n    private readonly indexedDB;\n    private channel;\n    onMessageHandler: ((type: string) => void) | undefined;\n    onErrorHandler: ((data: any) => void) | undefined;\n    constructor();\n    private onMessage;\n    private onError;\n    notify(type: string): void;\n    hasPairings(): Promise<boolean>;\n    hasSessions(): Promise<boolean>;\n    backup(): void;\n    resetState(): Promise<void>;\n}\n"},{name:"@airgap/beacon-core/dist/esm/storage/getStorage.d.ts",dts:"import { Storage } from '@airgap/beacon-types';\n/**\n * Get a supported storage on this platform\n */\nexport declare const getStorage: () => Promise<Storage>;\n"},{name:"@airgap/beacon-core/dist/esm/transports/clients/ClientEvents.d.ts",dts:'export declare const enum ClientEvents {\n    CLOSE_ALERT = "CLOSE_ALERT",\n    RESET_STATE = "RESET_STATE",\n    WC_ACK_NOTIFICATION = "WC_ACK_NOTIFICATION",\n    ON_RELAYER_ERROR = "ON_RELAYER_ERROR"\n}\n'},{name:"@airgap/beacon-core/dist/esm/transports/clients/CommunicationClient.d.ts",dts:"import { PeerInfoType } from '@airgap/beacon-types';\nimport { KeyPair } from '@stablelib/ed25519';\nimport { SessionKeys } from '@stablelib/x25519-session';\nimport { ClientEvents } from './ClientEvents';\n/**\n * @internalapi\n *\n *\n */\nexport declare abstract class CommunicationClient {\n    protected keyPair?: KeyPair | undefined;\n    constructor(keyPair?: KeyPair | undefined);\n    eventHandlers: Map<ClientEvents, Function>;\n    protected isMobileOS: () => boolean;\n    /**\n     * Get the public key\n     */\n    getPublicKey(): Promise<string>;\n    /**\n     * get the public key hash\n     */\n    getPublicKeyHash(): Promise<string>;\n    /**\n     * Create a cryptobox server\n     *\n     * @param otherPublicKey\n     * @param selfKeypair\n     */\n    protected createCryptoBoxServer(otherPublicKey: string, selfKeypair: KeyPair): Promise<SessionKeys>;\n    /**\n     * Create a cryptobox client\n     *\n     * @param otherPublicKey\n     * @param selfKeypair\n     */\n    protected createCryptoBoxClient(otherPublicKey: string, selfKeypair: KeyPair): Promise<SessionKeys>;\n    /**\n     * Encrypt a message for a specific publicKey (receiver, asymmetric)\n     *\n     * @param recipientPublicKey\n     * @param message\n     */\n    protected encryptMessageAsymmetric(recipientPublicKey: string, message: string): Promise<string>;\n    abstract unsubscribeFromEncryptedMessages(): Promise<void>;\n    abstract unsubscribeFromEncryptedMessage(senderPublicKey: string): Promise<void>;\n    abstract sendMessage(message: string, peer?: PeerInfoType): Promise<void>;\n}\n"},{name:"@airgap/beacon-core/dist/esm/transports/clients/MessageBasedClient.d.ts",dts:"import { CommunicationClient } from './CommunicationClient';\nimport { PostMessagePairingRequest, PostMessagePairingResponse } from '@airgap/beacon-types';\nimport { KeyPair } from '@stablelib/ed25519';\n/**\n * @internalapi\n *\n *\n */\nexport declare abstract class MessageBasedClient extends CommunicationClient {\n    protected readonly name: string;\n    /**\n     * The listeners that will be notified of new messages\n     */\n    protected abstract readonly activeListeners: Map<string, unknown>;\n    constructor(name: string, keyPair: KeyPair);\n    /**\n     * start the client and make sure all dependencies are ready\n     */\n    start(): Promise<void>;\n    /**\n     * Get the pairing request information. This will be shared with the peer during the connection setup\n     */\n    getPairingRequestInfo(): Promise<PostMessagePairingRequest>;\n    /**\n     * Get the pairing response information. This will be shared with the peer during the connection setup\n     */\n    getPairingResponseInfo(request: PostMessagePairingRequest): Promise<PostMessagePairingResponse>;\n    /**\n     * Unsubscribe from encrypted messages from a specific peer\n     *\n     * @param senderPublicKey\n     */\n    unsubscribeFromEncryptedMessage(senderPublicKey: string): Promise<void>;\n    /**\n     * Unsubscribe from all encrypted messages\n     */\n    unsubscribeFromEncryptedMessages(): Promise<void>;\n    /**\n     * Decrypt a message from a specific peer\n     *\n     * @param senderPublicKey\n     * @param payload\n     */\n    protected decryptMessage(senderPublicKey: string, payload: string): Promise<string>;\n    /**\n     * Encrypt a message for a specific publicKey (receiver)\n     *\n     * @param recipientPublicKey\n     * @param message\n     */\n    protected encryptMessage(recipientPublicKey: string, message: string): Promise<string>;\n    /**\n     * Initialize the connection\n     */\n    abstract init(): Promise<void>;\n}\n"},{name:"@airgap/beacon-core/dist/esm/transports/Transport.d.ts",dts:"import { TransportType, TransportStatus, PeerInfo, StorageKey, ConnectionContext } from '@airgap/beacon-types';\nimport { PeerManager } from '../managers/PeerManager';\nimport { CommunicationClient } from './clients/CommunicationClient';\nimport { ClientEvents } from './clients/ClientEvents';\n/**\n * @internalapi\n *\n *\n */\nexport declare abstract class Transport<T extends PeerInfo = PeerInfo, K extends StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET | StorageKey.TRANSPORT_WALLETCONNECT_PEERS_DAPP = any, S extends CommunicationClient = any> {\n    /**\n     * The type of the transport\n     */\n    readonly type: TransportType;\n    /**\n     * The name of the app\n     */\n    protected readonly name: string;\n    /**\n     * The status of the transport\n     */\n    protected _isConnected: TransportStatus;\n    protected readonly peerManager: PeerManager<K>;\n    /**\n     * The client handling the encryption/decryption of messages\n     */\n    protected client: S;\n    /**\n     * The listener that will be invoked when a new peer is connected\n     */\n    protected newPeerListener?: (peer: T) => void;\n    setEventHandler(event: ClientEvents, fun: Function): void;\n    /**\n     * The listeners that will be notified when new messages are coming in\n     */\n    private listeners;\n    /**\n     * Return the status of the connection\n     */\n    get connectionStatus(): TransportStatus;\n    constructor(name: string, client: S, peerManager: PeerManager<K>);\n    /**\n     * Returns a promise that resolves to true if the transport is available, false if it is not\n     */\n    static isAvailable(): Promise<boolean>;\n    /**\n     * Connect the transport\n     */\n    connect(): Promise<void>;\n    /**\n     * Disconnect the transport\n     */\n    disconnect(): Promise<void>;\n    /**\n     * Send a message through the transport\n     *\n     * @param message The message to send\n     * @param recipient The recipient of the message\n     */\n    send(message: string, peer?: PeerInfo): Promise<void>;\n    /**\n     * Add a listener to be called when a new message is received\n     *\n     * @param listener The listener that will be registered\n     */\n    addListener(listener: (message: unknown, connectionInfo: ConnectionContext) => void): Promise<void>;\n    /**\n     * Remove a listener\n     *\n     * @param listener\n     */\n    removeListener(listener: (message: string, connectionInfo: ConnectionContext) => void): Promise<void>;\n    getPeers(): Promise<T[]>;\n    addPeer(newPeer: T, _sendPairingResponse?: boolean): Promise<void>;\n    removePeer(peerToBeRemoved: T): Promise<void>;\n    removeAllPeers(): Promise<void>;\n    /**\n     * Notify the listeners when a new message comes in\n     *\n     * @param message Message\n     * @param connectionInfo Context info about the connection\n     */\n    protected notifyListeners(message: unknown, connectionInfo: ConnectionContext): Promise<void>;\n    abstract listen(publicKey: string): Promise<void>;\n}\n"},{name:"@airgap/beacon-core/dist/esm/utils/Logger.d.ts",dts:"export interface LoggerInterface {\n    debug(method: string, ...args: any[]): void;\n    log(method: string, ...args: any[]): void;\n    warn(method: string, ...args: any[]): void;\n    error(method: string, ...args: any[]): void;\n    time(start: boolean, label?: string): void;\n    timeLog(method: string, ...args: any[]): void;\n}\n/**\n * The logger that is used internally\n */\nexport declare class InternalLogger implements LoggerInterface {\n    constructor();\n    debug(name: string, method: string, ...args: any[]): void;\n    log(name: string, method: string, ...args: any[]): void;\n    warn(name: string, method: string, ...args: any[]): void;\n    error(name: string, method: string, ...args: any[]): void;\n    time(start: boolean, label?: string | undefined): void;\n    timeLog(name: string, method: string, ...args: any[]): void;\n    private _log;\n}\nexport declare class Logger implements LoggerInterface {\n    private readonly name;\n    constructor(service: string);\n    debug(method: string, ...args: any[]): void;\n    log(method: string, ...args: any[]): void;\n    warn(method: string, ...args: any[]): void;\n    error(method: string, ...args: any[]): void;\n    time(start: boolean, label?: string | undefined): void;\n    timeLog(method: string, ...args: any[]): void;\n}\nexport declare const setLogger: (newLogger: LoggerInterface) => void;\nexport declare const getLogger: () => LoggerInterface;\n"},{name:"@airgap/beacon-core/dist/esm/utils/assert-never.d.ts",dts:"/**\n * A helper function to make sure if/elses and switch/cases are exhaustive\n *\n * @param empty The data that has to be empty\n */\nexport declare function assertNever(empty: never): never;\n"},{name:"@airgap/beacon-core/dist/esm/utils/get-account-identifier.d.ts",dts:"import { Network } from '@airgap/beacon-types';\n/**\n * @internalapi\n *\n * Generate a deterministic account identifier based on an address and a network\n *\n * @param address\n * @param network\n */\nexport declare const getAccountIdentifier: (address: string, network: Network) => Promise<string>;\n"},{name:"@airgap/beacon-core/dist/esm/utils/get-sender-id.d.ts",dts:"/**\n * @internalapi\n *\n * Generate a deterministic sender identifier based on a public key\n *\n * @param publicKey\n */\nexport declare const getSenderId: (publicKey: string) => Promise<string>;\n"},{name:"@airgap/beacon-core/dist/esm/utils/multi-tab-channel.d.ts",dts:"export declare class MultiTabChannel {\n    private channel;\n    private elector;\n    private eventListeners;\n    private onBCMessageHandler;\n    private onElectedLeaderHandler;\n    private wasLeader;\n    private initialized;\n    constructor(name: string, onBCMessageHandler: Function, onElectedLeaderHandler: Function);\n    init(): Promise<void>;\n    private onBeforeUnloadHandler;\n    private onMessageHandler;\n    isLeader(): boolean;\n    getLeadership(): Promise<void>;\n    hasLeader(): Promise<boolean>;\n    postMessage(message: any): void;\n}\n"},{name:"@airgap/beacon-core/dist/esm/MockAnalytics.d.ts",dts:"import { AnalyticsInterface } from '@airgap/beacon-types';\nexport declare class MockAnalytics implements AnalyticsInterface {\n    track(_trigger: 'click' | 'event', _section: string, _label: string, _data?: Record<string, any>): void;\n}\n"},{name:"@airgap/beacon-core/dist/esm/MockWindow.d.ts",dts:"type Callback = (message: unknown) => void;\n/**\n * A mock for postmessage if run in node.js environment\n */\ndeclare let windowRef: {\n    postMessage: (message: string | Record<string, unknown>, _target?: string) => void;\n    addEventListener: (_name: string, eventCallback: Callback) => void;\n    removeEventListener: (_name: string, eventCallback: Callback) => void;\n    location: {\n        origin: string;\n    };\n};\ndeclare const clearMockWindowState: () => void;\nexport { windowRef, clearMockWindowState };\n"},{name:"@airgap/beacon-core/dist/esm/Serializer.d.ts",dts:"/**\n * @internalapi\n *\n * The Serializer is used to serialize / deserialize JSON objects and encode them with bs58check\n */\nexport declare class Serializer {\n    /**\n     * Serialize and bs58check encode an object\n     *\n     * @param message JSON object to serialize\n     */\n    serialize(message: unknown): Promise<string>;\n    /**\n     * Deserialize a bs58check encoded string\n     *\n     * @param encoded String to be deserialized\n     */\n    deserialize(encoded: string): Promise<unknown>;\n}\n"},{name:"@airgap/beacon-core/dist/esm/constants.d.ts",dts:"export declare const SDK_VERSION: string;\nexport declare const BEACON_VERSION: string;\nexport declare const NOTIFICATION_ORACLE_URL: string;\nexport declare const BACKEND_URL: string;\n"},{name:"@airgap/beacon-core/dist/esm/debug.d.ts",dts:"export declare const setDebugEnabled: (enabled: boolean) => void;\nexport declare const getDebugEnabled: () => boolean;\n"},{name:"@airgap/beacon-core/dist/esm/index.d.ts",dts:"/**\n * General docs\n * @module public\n */\nimport { Client } from './clients/client/Client';\nimport { BeaconError } from './errors/BeaconError';\nimport { BroadcastBeaconError } from './errors/BroadcastBeaconError';\nimport { NetworkNotSupportedBeaconError } from './errors/NetworkNotSupportedBeaconError';\nimport { NoAddressBeaconError } from './errors/NoAddressBeaconError';\nimport { NoPrivateKeyBeaconError } from './errors/NoPrivateKeyBeaconError';\nimport { NotGrantedBeaconError } from './errors/NotGrantedBeaconError';\nimport { ParametersInvalidBeaconError } from './errors/ParametersInvalidBeaconError';\nimport { TooManyOperationsBeaconError } from './errors/TooManyOperationsBeaconError';\nimport { TransactionInvalidBeaconError } from './errors/TransactionInvalidBeaconError';\nimport { UnknownBeaconError } from './errors/UnknownBeaconError';\nimport { Transport } from './transports/Transport';\nimport { ChromeStorage } from './storage/ChromeStorage';\nimport { LocalStorage } from './storage/LocalStorage';\nimport { getStorage } from './storage/getStorage';\nimport { Serializer } from './Serializer';\nimport { ClientOptions } from './clients/client/ClientOptions';\nimport { SDK_VERSION, BEACON_VERSION } from './constants';\nimport { AccountManager } from './managers/AccountManager';\nimport { AppMetadataManager } from './managers/AppMetadataManager';\nimport { PermissionManager } from './managers/PermissionManager';\nimport { BeaconClient } from './clients/beacon-client/BeaconClient';\nimport { BeaconClientOptions } from './clients/beacon-client/BeaconClientOptions';\nimport { getAccountIdentifier } from './utils/get-account-identifier';\nimport { AbortedBeaconError } from './errors/AbortedBeaconError';\nimport { getSenderId } from './utils/get-sender-id';\nimport { PeerManager } from './managers/PeerManager';\nimport { MessageBasedClient } from './transports/clients/MessageBasedClient';\nimport { setDebugEnabled, getDebugEnabled } from './debug';\nimport { SignatureTypeNotSupportedBeaconError } from './errors/SignatureTypeNotSupportedBeaconError';\nimport { getLogger, Logger, setLogger } from './utils/Logger';\nimport { windowRef } from './MockWindow';\nimport { CommunicationClient } from './transports/clients/CommunicationClient';\nimport { ClientEvents } from './transports/clients/ClientEvents';\nimport { WCStorage } from './storage/WCStorage';\nimport { IndexedDBStorage } from './storage/IndexedDBStorage';\nimport { StorageValidator } from './storage/StorageValidator';\nimport { MultiTabChannel } from './utils/multi-tab-channel';\nimport getError from './errors/get-error';\nexport { BeaconClient, BeaconClientOptions, Client, ClientOptions, ClientEvents };\nexport { getError, BeaconError, AbortedBeaconError, BroadcastBeaconError, NetworkNotSupportedBeaconError, NoAddressBeaconError, NoPrivateKeyBeaconError, NotGrantedBeaconError, ParametersInvalidBeaconError, TooManyOperationsBeaconError, TransactionInvalidBeaconError, SignatureTypeNotSupportedBeaconError, UnknownBeaconError };\nexport { Transport, MessageBasedClient, CommunicationClient };\nexport { ChromeStorage, LocalStorage, WCStorage, IndexedDBStorage, StorageValidator, getStorage };\nexport { PeerManager, AccountManager, AppMetadataManager, PermissionManager };\nexport { SDK_VERSION, BEACON_VERSION };\nexport { getSenderId, getAccountIdentifier, windowRef, MultiTabChannel };\nexport { Serializer, Logger, setLogger, getLogger };\nexport { setDebugEnabled, getDebugEnabled };\nexport { NOTIFICATION_ORACLE_URL, BACKEND_URL } from './constants';\n"},{name:"@airgap/beacon-dapp/dapp-client/DAppClient.d.ts",dts:"import { BeaconEvent, BeaconEventHandlerFunction, BeaconEventType } from '../events';\nimport { AccountInfo, TransportType, BeaconMessageType, RequestPermissionInput, RequestSignPayloadInput, RequestOperationInput, RequestBroadcastInput, PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, Network, AppMetadata, ExtendedPeerInfo, ColorMode, Blockchain, BlockchainRequestV3, BlockchainResponseV3, PermissionRequestV3, PermissionResponseV3, ProofOfEventChallengeResponse, RequestProofOfEventChallengeInput, PeerInfoType, SimulatedProofOfEventChallengeResponse, RequestSimulatedProofOfEventChallengeInput } from '@airgap/beacon-types';\nimport { Client, Transport } from '@airgap/beacon-core';\nimport { BlockExplorer } from '../utils/block-explorer';\nimport { DAppClientOptions } from './DAppClientOptions';\nimport { BeaconEventHandler } from '@airgap/beacon-dapp';\nimport { DappPostMessageTransport } from '../transports/DappPostMessageTransport';\nimport { DappP2PTransport } from '../transports/DappP2PTransport';\nimport { DappWalletConnectTransport } from '../transports/DappWalletConnectTransport';\n/**\n * @publicapi\n *\n * The DAppClient has to be used in decentralized applications. It handles all the logic related to connecting to beacon-compatible\n * wallets and sending requests.\n *\n * @category DApp\n */\nexport declare class DAppClient extends Client {\n    /**\n     * The description of the app\n     */\n    readonly description?: string;\n    /**\n     * The block explorer used by the SDK\n     */\n    readonly blockExplorer: BlockExplorer;\n    /**\n     * Automatically switch between apps on Mobile Devices (Enabled by Default)\n     */\n    private enableAppSwitching;\n    /**\n     * Enable metrics tracking (Disabled by Default)\n     */\n    private enableMetrics?;\n    private userId?;\n    network: Network;\n    protected readonly events: BeaconEventHandler;\n    protected postMessageTransport: DappPostMessageTransport | undefined;\n    protected p2pTransport: DappP2PTransport | undefined;\n    protected walletConnectTransport: DappWalletConnectTransport | undefined;\n    protected wcProjectId?: string;\n    protected wcRelayUrl?: string;\n    private isGetActiveAccountHandled;\n    private readonly openRequestsOtherTabs;\n    /**\n     * A map of requests that are currently \"open\", meaning we have sent them to a wallet and are still awaiting a response.\n     */\n    private readonly openRequests;\n    /**\n     * The currently active account. For all requests that are associated to a specific request (operation request, signing request),\n     * the active account is used to determine the network and destination wallet\n     */\n    private _activeAccount;\n    /**\n     * The currently active peer. This is used to address a peer in case the active account is not set. (Eg. for permission requests)\n     */\n    private _activePeer;\n    private _initPromise;\n    private isInitPending;\n    private readonly activeAccountLoaded;\n    private readonly appMetadataManager;\n    private readonly disclaimerText?;\n    private readonly errorMessages;\n    private readonly featuredWallets;\n    private readonly storageValidator;\n    private readonly beaconIDB;\n    private debounceSetActiveAccount;\n    private multiTabChannel;\n    constructor(config: DAppClientOptions);\n    private checkIfBCLeaderExists;\n    private onElectedLeaderhandler;\n    private onBCMessageHandler;\n    private prepareRequest;\n    private createStateSnapshot;\n    private initUserID;\n    initInternalTransports(): Promise<void>;\n    private initEvents;\n    private onRelayerError;\n    private wcToastHandler;\n    private channelClosedHandler;\n    /**\n     * Destroy the instance.\n     *\n     * WARNING: Call `destroy` whenever you no longer need dAppClient\n     * as it frees internal subscriptions to the transport and therefore the instance may no longer work properly.\n     * If you wish to disconnect your dApp, use `disconnect` instead.\n     */\n    destroy(): Promise<void>;\n    init(transport?: Transport<any>, substratePairing?: boolean): Promise<TransportType>;\n    /**\n     * Returns the active account\n     */\n    getActiveAccount(): Promise<AccountInfo | undefined>;\n    private isInvalidState;\n    private resetInvalidState;\n    /**\n     * Sets the active account\n     *\n     * @param account The account that will be set as the active account\n     */\n    setActiveAccount(account?: AccountInfo): Promise<void>;\n    /**\n     * Clear the active account\n     */\n    clearActiveAccount(): Promise<void>;\n    setColorMode(colorMode: ColorMode): Promise<void>;\n    getColorMode(): Promise<ColorMode>;\n    /**\n     * @deprecated\n     *\n     * Use getOwnAppMetadata instead\n     */\n    getAppMetadata(): Promise<AppMetadata>;\n    showPrepare(): Promise<void>;\n    hideUI(elements: ('alert' | 'toast')[]): Promise<void>;\n    private tryToAppSwitch;\n    private addQueryParam;\n    private buildPayload;\n    private updateMetricsStorage;\n    private sendMetrics;\n    private checkMakeRequest;\n    /**\n     * Will remove the account from the local storage and set a new active account if necessary.\n     *\n     * @param accountIdentifier ID of the account\n     */\n    removeAccount(accountIdentifier: string): Promise<void>;\n    /**\n     * Remove all accounts and set active account to undefined\n     */\n    removeAllAccounts(): Promise<void>;\n    /**\n     * Removes a peer and all the accounts that have been connected through that peer\n     *\n     * @param peer Peer to be removed\n     */\n    removePeer(peer: ExtendedPeerInfo, sendDisconnectToPeer?: boolean): Promise<void>;\n    /**\n     * Remove all peers and all accounts that have been connected through those peers\n     */\n    removeAllPeers(sendDisconnectToPeers?: boolean): Promise<void>;\n    /**\n     * Allows the user to subscribe to specific events that are fired in the SDK\n     *\n     * @param internalEvent The event to subscribe to\n     * @param eventCallback The callback that will be called when the event occurs\n     */\n    subscribeToEvent<K extends BeaconEvent>(internalEvent: K, eventCallback: BeaconEventHandlerFunction<BeaconEventType[K]>): Promise<void>;\n    /**\n     * Check if we have permissions to send the specific message type to the active account.\n     * If no active account is set, only permission requests are allowed.\n     *\n     * @param type The type of the message\n     */\n    checkPermissions(type: BeaconMessageType): Promise<boolean>;\n    sendNotification(title: string, message: string, payload: string, protocolIdentifier: string): Promise<string>;\n    private blockchains;\n    addBlockchain(chain: Blockchain): void;\n    removeBlockchain(chainIdentifier: string): void;\n    permissionRequest(input: PermissionRequestV3<string>): Promise<PermissionResponseV3<string>>;\n    request(input: BlockchainRequestV3<string>): Promise<BlockchainResponseV3<string>>;\n    /**\n     * Send a permission request to the DApp. This should be done as the first step. The wallet will respond\n     * with an publicKey and permissions that were given. The account returned will be set as the \"activeAccount\"\n     * and will be used for the following requests.\n     *\n     * @param input The message details we need to prepare the PermissionRequest message.\n     */\n    requestPermissions(input?: RequestPermissionInput): Promise<PermissionResponseOutput>;\n    /**\n     * Send a proof of event request to the wallet. The wallet will either accept or decline the challenge.\n     * If it is accepted, the challenge will be stored, meaning that even if the user refresh the page, the DAppClient will keep checking if the challenge has been fulfilled.\n     * Once the challenge is stored, a challenge stored message will be sent to the wallet.\n     * It's **highly recommended** to run a proof of event challenge to check the identity of an abstracted account\n     *\n     * @param input The message details we need to prepare the ProofOfEventChallenge message.\n     */\n    requestProofOfEventChallenge(input: RequestProofOfEventChallengeInput): Promise<ProofOfEventChallengeResponse>;\n    /**\n     * Send a simulated proof of event request to the wallet. The wallet will either accept or decline the challenge.\n     * It's the same than `requestProofOfEventChallenge` but rather than executing operations on the blockchain to prove the identity,\n     * The wallet will return a list of operations that you'll be able to run on your side to verify the identity of the abstracted account\n     * It's **highly recommended** to run a proof of event challenge to check the identity of an abstracted account\n     *\n     * @param input The message details we need to prepare the SimulatedProofOfEventChallenge message.\n     */\n    requestSimulatedProofOfEventChallenge(input: RequestSimulatedProofOfEventChallengeInput): Promise<SimulatedProofOfEventChallengeResponse>;\n    /**\n     * This method will send a \"SignPayloadRequest\" to the wallet. This method is meant to be used to sign\n     * arbitrary data (eg. a string). It will return the signature in the format of \"edsig...\"\n     *\n     * @param input The message details we need to prepare the SignPayloadRequest message.\n     */\n    requestSignPayload(input: RequestSignPayloadInput): Promise<SignPayloadResponseOutput>;\n    /**\n     * This method will send an \"EncryptPayloadRequest\" to the wallet. This method is meant to be used to encrypt or decrypt\n     * arbitrary data (eg. a string). It will return the encrypted or decrypted payload\n     *\n     * @param input The message details we need to prepare the EncryptPayloadRequest message.\n     */\n    /**\n     * This method sends an OperationRequest to the wallet. This method should be used for all kinds of operations,\n     * eg. transaction or delegation. Not all properties have to be provided. Data like \"counter\" and fees will be\n     * fetched and calculated by the wallet (but they can still be provided if required).\n     *\n     * @param input The message details we need to prepare the OperationRequest message.\n     */\n    requestOperation(input: RequestOperationInput): Promise<OperationResponseOutput>;\n    /**\n     * Sends a \"BroadcastRequest\" to the wallet. This method can be used to inject an already signed transaction\n     * to the network.\n     *\n     * @param input The message details we need to prepare the BroadcastRequest message.\n     */\n    requestBroadcast(input: RequestBroadcastInput): Promise<BroadcastResponseOutput>;\n    protected setActivePeer(peer?: PeerInfoType): Promise<void>;\n    /**\n     * A \"setter\" for when the transport needs to be changed.\n     */\n    protected setTransport(transport?: Transport<any>): Promise<void>;\n    /**\n     * This method will emit an internal error message.\n     *\n     * @param errorMessage The error message to send.\n     */\n    private sendInternalError;\n    /**\n     * This method will remove all accounts associated with a specific peer.\n     *\n     * @param peersToRemove An array of peers for which accounts should be removed\n     */\n    private removeAccountsForPeers;\n    private removeAccountsForPeerIds;\n    /**\n     * This message handles errors that we receive from the wallet.\n     *\n     * @param request The request we sent\n     * @param beaconError The error we received\n     */\n    private handleRequestError;\n    /**\n     * This message will send an event when we receive a successful response to one of the requests we sent.\n     *\n     * @param request The request we sent\n     * @param response The response we received\n     */\n    private notifySuccess;\n    private getWalletInfoFromStorage;\n    private updateStorageWallet;\n    private getWalletInfo;\n    private getPeer;\n    /**\n     * This method handles sending of requests to the DApp. It makes sure that the DAppClient is initialized and connected\n     * to the transport. After that rate limits and permissions will be checked, an ID is attached and the request is sent\n     * to the DApp over the transport.\n     *\n     * @param requestInput The BeaconMessage to be sent to the wallet\n     * @param account The account that the message will be sent to\n     * @param skipResponse If true, the function return as soon as the message is sent\n     */\n    private makeRequest;\n    /**\n     * This method handles sending of requests to the DApp. It makes sure that the DAppClient is initialized and connected\n     * to the transport. After that rate limits and permissions will be checked, an ID is attached and the request is sent\n     * to the DApp over the transport.\n     *\n     * @param requestInput The BeaconMessage to be sent to the wallet\n     * @param account The account that the message will be sent to\n     */\n    private makeRequestV3;\n    private makeRequestBC;\n    disconnect(): Promise<void>;\n    /**\n     * Adds a requests to the \"openRequests\" set so we know what messages have already been answered/handled.\n     *\n     * @param id The ID of the message\n     * @param promise A promise that resolves once the response for that specific message is received\n     */\n    private addOpenRequest;\n    private sendNotificationWithAccessToken;\n    private onNewAccount;\n}\n"},{name:"@airgap/beacon-dapp/dapp-client/DAppClientOptions.d.ts",dts:"import { BeaconEvent, BeaconEventType, BeaconEventHandlerFunction } from '../events';\nimport { BlockExplorer } from '../utils/block-explorer';\nimport { Storage, NetworkType, ColorMode, NodeDistributions, AnalyticsInterface, Network } from '@airgap/beacon-types';\ntype RequireAtLeastOne<T, Keys extends keyof T = keyof T> = Pick<T, Exclude<keyof T, Keys>> & {\n    [K in Keys]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<Keys, K>>>;\n}[Keys];\n/**\n * @category DApp\n */\nexport interface DAppClientOptions {\n    /**\n     * Name of the application\n     */\n    name: string;\n    /**\n     * Description of the application\n     */\n    description?: string;\n    /**\n     * A URL to the icon of the application\n     */\n    iconUrl?: string;\n    /**\n     * A URL to the website of the application\n     */\n    appUrl?: string;\n    /**\n     * The storage that will be used by the SDK\n     */\n    storage?: Storage;\n    /**\n     * An object that will be used to overwrite default event handler behaviour.\n     *\n     * If you plan to overwrite all default events, use \"disableDefaultEvents\" instead.\n     *\n     * This will overwrite the default event handler, so this can lead to unexpected behavior in some cases.\n     * We recommend that you overwrite all handlers if you want to use your own UI.\n     *\n     * If you simply want to be notified of events happening, but do not want to overwrite the default behavior,\n     * please use `subscribeToEvent()` on the DAppClient instead.\n     */\n    eventHandlers?: {\n        [key in BeaconEvent]?: {\n            handler: BeaconEventHandlerFunction<BeaconEventType[key]>;\n        };\n    };\n    /**\n     * Disable all default Events and UI elements. If passed together with \"eventHandlers\",\n     * the default eventHandlers will be removed, and the ones passed by the user will be added.\n     */\n    disableDefaultEvents?: boolean;\n    /**\n     * A list of matrix nodes to connect to. If a non-empty array is passed, the default options will be overwritten.\n     * One node will be randomly selected based on the local keypair and the other nodes will be used as a fallback in case the primary node goes down.\n     *\n     * Only provide the hostname, no https:// prefix. Eg. { [Regions.EU1]: ['matrix.example.com'] }\n     */\n    matrixNodes?: NodeDistributions;\n    /**\n     * The block explorer used by the SDK\n     */\n    blockExplorer?: BlockExplorer;\n    /**\n     * Indicates on which network the DApp is running on.\n     */\n    network?: Network;\n    /**\n     * @deprecated Please use \"network\" instead.\n     * Indicates on which network the DApp is planning to run. This is currently used to adjust the URLs of web-wallets in the pairing alert if they use different URLs for testnets.\n     * You will still have to define the network you intend to use during the permission request.\n     */\n    preferredNetwork?: NetworkType;\n    /**\n     * Set the color mode for the UI elements (alerts and toasts)\n     */\n    colorMode?: ColorMode;\n    /**\n     * A disclaimer text that will be displayed in the pairing alert\n     */\n    disclaimerText?: string;\n    /**\n     * A list of contracts that the DApp is using. Allows to attach human readable error messages for to error codes\n     */\n    errorMessages?: Record<string, Record<string | number, string>>;\n    /**\n     * Configuration that is passed to the WalletConnect transport.\n     *\n     * This is required to enable WalletConnect connections.\n     */\n    walletConnectOptions?: RequireAtLeastOne<{\n        /**\n         * The projectId of the application. Has to be obtained from https://cloud.walletconnect.com/\n         */\n        projectId?: string;\n        /**\n         * The relay server to connect to\n         */\n        relayUrl?: string;\n    }>;\n    /**\n     * The analytics instance that will be used by the SDK\n     */\n    analytics?: AnalyticsInterface;\n    /**\n     * The wallets that will be featured in the UI.\n     */\n    featuredWallets?: string[];\n    /**\n     * Automatically switch between apps on Mobile Devices (Enabled by Default)\n     */\n    enableAppSwitching?: boolean;\n    /**\n     * Enable metrics tracking (Disabled by Default)\n     */\n    enableMetrics?: boolean;\n}\nexport {};\n"},{name:"@airgap/beacon-dapp/transports/DappP2PTransport.d.ts",dts:"import { Storage, StorageKey, ExtendedP2PPairingResponse, NodeDistributions } from '@airgap/beacon-types';\nimport { P2PTransport } from '@airgap/beacon-transport-matrix';\nimport { KeyPair } from '@stablelib/ed25519';\n/**\n * @internalapi\n *\n *\n */\nexport declare class DappP2PTransport extends P2PTransport<ExtendedP2PPairingResponse, StorageKey.TRANSPORT_P2P_PEERS_DAPP> {\n    constructor(name: string, keyPair: KeyPair, storage: Storage, matrixNodes: NodeDistributions, iconUrl?: string, appUrl?: string);\n    startOpenChannelListener(): Promise<void>;\n    listenForNewPeer(newPeerListener: (peer: ExtendedP2PPairingResponse) => void): Promise<void>;\n    stopListeningForNewPeers(): Promise<void>;\n}\n"},{name:"@airgap/beacon-dapp/transports/DappPostMessageTransport.d.ts",dts:"import { StorageKey, Storage, ExtendedPostMessagePairingResponse } from '@airgap/beacon-types';\nimport { PostMessageTransport } from '@airgap/beacon-transport-postmessage';\nimport { KeyPair } from '@stablelib/ed25519';\n/**\n * @internalapi\n *\n *\n */\nexport declare class DappPostMessageTransport extends PostMessageTransport<ExtendedPostMessagePairingResponse, StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP> {\n    constructor(name: string, keyPair: KeyPair, storage: Storage);\n    startOpenChannelListener(): Promise<void>;\n    listenForNewPeer(newPeerListener: (peer: ExtendedPostMessagePairingResponse) => void): Promise<void>;\n    stopListeningForNewPeers(): Promise<void>;\n}\n"},{name:"@airgap/beacon-dapp/transports/DappWalletConnectTransport.d.ts",dts:"import { StorageKey, Storage, ExtendedWalletConnectPairingResponse, NetworkType } from '@airgap/beacon-types';\nimport { WalletConnectTransport } from '@airgap/beacon-transport-walletconnect';\nimport { KeyPair } from '@stablelib/ed25519';\nimport { SignClientTypes } from '@walletconnect/types';\n/**\n * @internalapi\n *\n *\n */\nexport declare class DappWalletConnectTransport extends WalletConnectTransport<ExtendedWalletConnectPairingResponse, StorageKey.TRANSPORT_WALLETCONNECT_PEERS_DAPP> {\n    constructor(name: string, keyPair: KeyPair, storage: Storage, wcOptions: {\n        network: NetworkType;\n        opts: SignClientTypes.Options;\n    }, isLeader: () => Promise<boolean>);\n    listenForNewPeer(newPeerListener: (peer: ExtendedWalletConnectPairingResponse) => void): Promise<void>;\n    stopListeningForNewPeers(): Promise<void>;\n}\n"},{name:"@airgap/beacon-dapp/utils/available-transports.d.ts",dts:"/**\n * An object with promises to indicate whether or not that transport is available.\n */\nexport declare const availableTransports: any;\n"},{name:"@airgap/beacon-dapp/utils/block-explorer.d.ts",dts:"import { Network, NetworkType } from '@airgap/beacon-types';\nexport declare abstract class BlockExplorer {\n    readonly rpcUrls: {\n        [key in NetworkType]: string;\n    };\n    constructor(rpcUrls: {\n        [key in NetworkType]: string;\n    });\n    protected getLinkForNetwork(network: Network): Promise<string>;\n    /**\n     * Return a blockexplorer link for an address\n     *\n     * @param address The address to be opened\n     * @param network The network that was used\n     */\n    abstract getAddressLink(address: string, network: Network): Promise<string>;\n    /**\n     * Return a blockexplorer link for a transaction hash\n     *\n     * @param transactionId The hash of the transaction\n     * @param network The network that was used\n     */\n    abstract getTransactionLink(transactionId: string, network: Network): Promise<string>;\n}\n"},{name:"@airgap/beacon-dapp/utils/get-instance.d.ts",dts:"import { DAppClient } from '../dapp-client/DAppClient';\nimport { DAppClientOptions } from '../dapp-client/DAppClientOptions';\n/** Get a DAppClient instance. Will make sure only one dAppClient exists. After the first instance has been created, the config will be ignored, unless \"reset\" is set */\nexport declare const getDAppClientInstance: (config: DAppClientOptions, reset?: boolean) => DAppClient;\n"},{name:"@airgap/beacon-dapp/utils/shorten-string.d.ts",dts:"export declare const shortenString: (text: string) => string;\n"},{name:"@airgap/beacon-dapp/utils/tzkt-blockexplorer.d.ts",dts:"import { Network, NetworkType } from '@airgap/beacon-types';\nimport { BlockExplorer } from './block-explorer';\nexport declare class TzktBlockExplorer extends BlockExplorer {\n    readonly rpcUrls: {\n        [key in NetworkType]: string;\n    };\n    constructor(rpcUrls?: {\n        [key in NetworkType]: string;\n    });\n    getAddressLink(address: string, network: Network): Promise<string>;\n    getTransactionLink(transactionId: string, network: Network): Promise<string>;\n}\n"},{name:"@airgap/beacon-dapp/beacon-message-events.d.ts",dts:"import { BeaconEvent } from './events';\nimport { BeaconMessageType } from '@airgap/beacon-types';\nexport declare const messageEvents: {\n    [key in BeaconMessageType]: {\n        sent: BeaconEvent;\n        success: BeaconEvent;\n        error: BeaconEvent;\n    };\n};\n"},{name:"@airgap/beacon-dapp/events.d.ts",dts:'import { BlockExplorer, AlertButton } from \'@airgap/beacon-dapp\';\nimport { ExtendedPostMessagePairingResponse, ExtendedP2PPairingResponse, AccountInfo, ErrorResponse, PermissionResponseOutput, OperationResponseOutput, BroadcastResponseOutput, SignPayloadResponseOutput, Network, ConnectionContext, NetworkType, AcknowledgeResponse, WalletInfo, ExtendedWalletConnectPairingResponse, AnalyticsInterface, ProofOfEventChallengeResponseOutput, SimulatedProofOfEventChallengeResponseOutput } from \'@airgap/beacon-types\';\nimport { Transport } from \'@airgap/beacon-core\';\n/**\n * The different events that can be emitted by the beacon-sdk\n */\nexport declare enum BeaconEvent {\n    PERMISSION_REQUEST_SENT = "PERMISSION_REQUEST_SENT",\n    PERMISSION_REQUEST_SUCCESS = "PERMISSION_REQUEST_SUCCESS",\n    PERMISSION_REQUEST_ERROR = "PERMISSION_REQUEST_ERROR",\n    PROOF_OF_EVENT_CHALLENGE_REQUEST_SENT = "PROOF_OF_EVENT_CHALLENGE_REQUEST_SENT",\n    PROOF_OF_EVENT_CHALLENGE_REQUEST_SUCCESS = "PROOF_OF_EVENT_CHALLENGE_REQUEST_SUCCESS",\n    PROOF_OF_EVENT_CHALLENGE_REQUEST_ERROR = "PROOF_OF_EVENT_CHALLENGE_REQUEST_ERROR",\n    SIMULATED_PROOF_OF_EVENT_CHALLENGE_REQUEST_SENT = "SIMULATED_PROOF_OF_EVENT_CHALLENGE_REQUEST_SENT",\n    SIMULATED_PROOF_OF_EVENT_CHALLENGE_REQUEST_SUCCESS = "SIMULATED_PROOF_OF_EVENT_CHALLENGE_REQUEST_SUCCESS",\n    SIMULATED_PROOF_OF_EVENT_CHALLENGE_REQUEST_ERROR = "SIMULATED_PROOF_OF_EVENT_CHALLENGE_REQUEST_ERROR",\n    OPERATION_REQUEST_SENT = "OPERATION_REQUEST_SENT",\n    OPERATION_REQUEST_SUCCESS = "OPERATION_REQUEST_SUCCESS",\n    OPERATION_REQUEST_ERROR = "OPERATION_REQUEST_ERROR",\n    SIGN_REQUEST_SENT = "SIGN_REQUEST_SENT",\n    SIGN_REQUEST_SUCCESS = "SIGN_REQUEST_SUCCESS",\n    SIGN_REQUEST_ERROR = "SIGN_REQUEST_ERROR",\n    BLOCKCHAIN_REQUEST_SUCCESS = "BLOCKCHAIN_REQUEST_SUCCESS",\n    BROADCAST_REQUEST_SENT = "BROADCAST_REQUEST_SENT",\n    BROADCAST_REQUEST_SUCCESS = "BROADCAST_REQUEST_SUCCESS",\n    BROADCAST_REQUEST_ERROR = "BROADCAST_REQUEST_ERROR",\n    ACKNOWLEDGE_RECEIVED = "ACKNOWLEDGE_RECEIVED",\n    LOCAL_RATE_LIMIT_REACHED = "LOCAL_RATE_LIMIT_REACHED",\n    NO_PERMISSIONS = "NO_PERMISSIONS",\n    ACTIVE_ACCOUNT_SET = "ACTIVE_ACCOUNT_SET",\n    ACTIVE_TRANSPORT_SET = "ACTIVE_TRANSPORT_SET",\n    SHOW_PREPARE = "SHOW_PREPARE",\n    HIDE_UI = "HIDE_UI",\n    INVALID_ACTIVE_ACCOUNT_STATE = "INVALID_ACTIVE_ACCOUNT_STATE",\n    INVALID_ACCOUNT_DEACTIVATED = "INVALID_ACCOUNT_DEACTIVATED",\n    PAIR_INIT = "PAIR_INIT",\n    PAIR_SUCCESS = "PAIR_SUCCESS",\n    CHANNEL_CLOSED = "CHANNEL_CLOSED",\n    GENERIC_ERROR = "GENERIC_ERROR",\n    OPEN_BUG_REPORT = "OPEN_BUG_REPORT",\n    RELAYER_ERROR = "RELAYER_ERROR",\n    INTERNAL_ERROR = "INTERNAL_ERROR",\n    UNKNOWN = "UNKNOWN"\n}\nexport interface ExtraInfo {\n    resetCallback?(): Promise<void>;\n}\ninterface RequestSentInfo {\n    extraInfo: ExtraInfo;\n    walletInfo: WalletInfo;\n}\n/**\n * The type of the payload of the different BeaconEvents\n */\nexport interface BeaconEventType {\n    [BeaconEvent.PERMISSION_REQUEST_SENT]: RequestSentInfo;\n    [BeaconEvent.PERMISSION_REQUEST_SUCCESS]: {\n        account: AccountInfo;\n        output: PermissionResponseOutput;\n        blockExplorer: BlockExplorer;\n        connectionContext: ConnectionContext;\n        walletInfo: WalletInfo;\n    };\n    [BeaconEvent.PERMISSION_REQUEST_ERROR]: {\n        errorResponse: ErrorResponse;\n        walletInfo: WalletInfo;\n    };\n    [BeaconEvent.PROOF_OF_EVENT_CHALLENGE_REQUEST_SENT]: RequestSentInfo;\n    [BeaconEvent.PROOF_OF_EVENT_CHALLENGE_REQUEST_SUCCESS]: {\n        account: AccountInfo;\n        output: ProofOfEventChallengeResponseOutput;\n        blockExplorer: BlockExplorer;\n        connectionContext: ConnectionContext;\n        walletInfo: WalletInfo;\n    };\n    [BeaconEvent.PROOF_OF_EVENT_CHALLENGE_REQUEST_ERROR]: {\n        errorResponse: ErrorResponse;\n        walletInfo: WalletInfo;\n    };\n    [BeaconEvent.SIMULATED_PROOF_OF_EVENT_CHALLENGE_REQUEST_SENT]: RequestSentInfo;\n    [BeaconEvent.SIMULATED_PROOF_OF_EVENT_CHALLENGE_REQUEST_SUCCESS]: {\n        account: AccountInfo;\n        output: SimulatedProofOfEventChallengeResponseOutput;\n        blockExplorer: BlockExplorer;\n        connectionContext: ConnectionContext;\n        walletInfo: WalletInfo;\n    };\n    [BeaconEvent.SIMULATED_PROOF_OF_EVENT_CHALLENGE_REQUEST_ERROR]: {\n        errorResponse: ErrorResponse;\n        walletInfo: WalletInfo;\n    };\n    [BeaconEvent.OPERATION_REQUEST_SENT]: RequestSentInfo;\n    [BeaconEvent.OPERATION_REQUEST_SUCCESS]: {\n        account: AccountInfo;\n        output: OperationResponseOutput;\n        blockExplorer: BlockExplorer;\n        connectionContext: ConnectionContext;\n        walletInfo: WalletInfo;\n    };\n    [BeaconEvent.OPERATION_REQUEST_ERROR]: {\n        errorResponse: ErrorResponse;\n        walletInfo: WalletInfo;\n        errorMessages: Record<string, Record<string | number, string>>;\n    };\n    [BeaconEvent.SIGN_REQUEST_SENT]: RequestSentInfo;\n    [BeaconEvent.SIGN_REQUEST_SUCCESS]: {\n        output: SignPayloadResponseOutput;\n        connectionContext: ConnectionContext;\n        walletInfo: WalletInfo;\n    };\n    [BeaconEvent.SIGN_REQUEST_ERROR]: {\n        errorResponse: ErrorResponse;\n        walletInfo: WalletInfo;\n    };\n    [BeaconEvent.BLOCKCHAIN_REQUEST_SUCCESS]: RequestSentInfo;\n    [BeaconEvent.BROADCAST_REQUEST_SENT]: RequestSentInfo;\n    [BeaconEvent.BROADCAST_REQUEST_SUCCESS]: {\n        network: Network;\n        output: BroadcastResponseOutput;\n        blockExplorer: BlockExplorer;\n        connectionContext: ConnectionContext;\n        walletInfo: WalletInfo;\n    };\n    [BeaconEvent.BROADCAST_REQUEST_ERROR]: {\n        errorResponse: ErrorResponse;\n        walletInfo: WalletInfo;\n    };\n    [BeaconEvent.ACKNOWLEDGE_RECEIVED]: {\n        message: AcknowledgeResponse;\n        extraInfo: ExtraInfo;\n        walletInfo: WalletInfo;\n    };\n    [BeaconEvent.LOCAL_RATE_LIMIT_REACHED]: undefined;\n    [BeaconEvent.NO_PERMISSIONS]: undefined;\n    [BeaconEvent.ACTIVE_ACCOUNT_SET]: AccountInfo;\n    [BeaconEvent.ACTIVE_TRANSPORT_SET]: Transport;\n    [BeaconEvent.INVALID_ACTIVE_ACCOUNT_STATE]: undefined;\n    [BeaconEvent.GENERIC_ERROR]: string;\n    [BeaconEvent.INVALID_ACCOUNT_DEACTIVATED]: undefined;\n    [BeaconEvent.SHOW_PREPARE]: {\n        walletInfo?: WalletInfo;\n    };\n    [BeaconEvent.HIDE_UI]: (\'alert\' | \'toast\')[] | undefined;\n    [BeaconEvent.PAIR_INIT]: {\n        p2pPeerInfo: Promise<string>;\n        postmessagePeerInfo: Promise<string>;\n        walletConnectPeerInfo: Promise<string>;\n        networkType: NetworkType;\n        abortedHandler?(): void;\n        disclaimerText?: string;\n        analytics: AnalyticsInterface;\n        featuredWallets?: string[];\n        substratePairing?: boolean;\n    };\n    [BeaconEvent.PAIR_SUCCESS]: ExtendedPostMessagePairingResponse | ExtendedP2PPairingResponse | ExtendedWalletConnectPairingResponse;\n    [BeaconEvent.CHANNEL_CLOSED]: string;\n    [BeaconEvent.INTERNAL_ERROR]: {\n        text: string;\n        buttons?: AlertButton[];\n    };\n    [BeaconEvent.OPEN_BUG_REPORT]: undefined;\n    [BeaconEvent.RELAYER_ERROR]: undefined;\n    [BeaconEvent.UNKNOWN]: undefined;\n}\nexport type BeaconEventHandlerFunction<T = unknown> = (data: T, eventCallback?: AlertButton[]) => void | Promise<void>;\n/**\n * The default event handlers\n */\nexport declare const defaultEventCallbacks: {\n    [key in BeaconEvent]: BeaconEventHandlerFunction<BeaconEventType[key]>;\n};\n/**\n * @internalapi\n *\n * Handles beacon events\n */\nexport declare class BeaconEventHandler {\n    private readonly callbackMap;\n    constructor(eventsToOverride?: {\n        [key in BeaconEvent]?: {\n            handler: BeaconEventHandlerFunction<BeaconEventType[key]>;\n        };\n    }, overrideAll?: boolean);\n    /**\n     * A method to subscribe to a specific beacon event and register a callback\n     *\n     * @param event The event being emitted\n     * @param eventCallback The callback that will be invoked\n     */\n    on<K extends BeaconEvent>(event: K, eventCallback: BeaconEventHandlerFunction<BeaconEventType[K]>): Promise<void>;\n    /**\n     * Emit a beacon event\n     *\n     * @param event The event being emitted\n     * @param data The data to be emit\n     */\n    emit<K extends BeaconEvent>(event: K, data?: BeaconEventType[K], eventCallback?: AlertButton[]): Promise<void>;\n    /**\n     * Override beacon event default callbacks. This can be used to disable default alert/toast behaviour\n     *\n     * @param eventsToOverride An object with the events to override\n     */\n    private overrideDefaults;\n    /**\n     * Set all event callbacks to a specific handler.\n     */\n    private setAllHandlers;\n}\nexport {};\n'},{name:"@airgap/beacon-dapp/index.d.ts",dts:"export * from '@airgap/beacon-core';\nexport * from '@airgap/beacon-transport-matrix';\nexport * from '@airgap/beacon-transport-postmessage';\nexport * from '@airgap/beacon-types';\nexport * from '@airgap/beacon-utils';\nexport * from '@airgap/beacon-ui';\nimport { DAppClient } from './dapp-client/DAppClient';\nimport { DAppClientOptions } from './dapp-client/DAppClientOptions';\nimport { BeaconEvent, BeaconEventHandler, defaultEventCallbacks } from './events';\nimport { BlockExplorer } from './utils/block-explorer';\nimport { TzktBlockExplorer } from './utils/tzkt-blockexplorer';\nimport { getDAppClientInstance } from './utils/get-instance';\nexport { DAppClient, DAppClientOptions, getDAppClientInstance };\nexport { BeaconEvent, BeaconEventHandler, defaultEventCallbacks };\nexport { BlockExplorer, TzktBlockExplorer, TzktBlockExplorer as TezblockBlockExplorer };\n"},{name:"@airgap/beacon-dapp/dist/esm/dapp-client/DAppClient.d.ts",dts:"import { BeaconEvent, BeaconEventHandlerFunction, BeaconEventType } from '../events';\nimport { AccountInfo, TransportType, BeaconMessageType, RequestPermissionInput, RequestSignPayloadInput, RequestOperationInput, RequestBroadcastInput, PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, Network, AppMetadata, ExtendedPeerInfo, ColorMode, Blockchain, BlockchainRequestV3, BlockchainResponseV3, PermissionRequestV3, PermissionResponseV3, ProofOfEventChallengeResponse, RequestProofOfEventChallengeInput, PeerInfoType, SimulatedProofOfEventChallengeResponse, RequestSimulatedProofOfEventChallengeInput } from '@airgap/beacon-types';\nimport { Client, Transport } from '@airgap/beacon-core';\nimport { BlockExplorer } from '../utils/block-explorer';\nimport { DAppClientOptions } from './DAppClientOptions';\nimport { BeaconEventHandler } from '@airgap/beacon-dapp';\nimport { DappPostMessageTransport } from '../transports/DappPostMessageTransport';\nimport { DappP2PTransport } from '../transports/DappP2PTransport';\nimport { DappWalletConnectTransport } from '../transports/DappWalletConnectTransport';\n/**\n * @publicapi\n *\n * The DAppClient has to be used in decentralized applications. It handles all the logic related to connecting to beacon-compatible\n * wallets and sending requests.\n *\n * @category DApp\n */\nexport declare class DAppClient extends Client {\n    /**\n     * The description of the app\n     */\n    readonly description?: string;\n    /**\n     * The block explorer used by the SDK\n     */\n    readonly blockExplorer: BlockExplorer;\n    /**\n     * Automatically switch between apps on Mobile Devices (Enabled by Default)\n     */\n    private enableAppSwitching;\n    /**\n     * Enable metrics tracking (Disabled by Default)\n     */\n    private enableMetrics?;\n    private userId?;\n    network: Network;\n    protected readonly events: BeaconEventHandler;\n    protected postMessageTransport: DappPostMessageTransport | undefined;\n    protected p2pTransport: DappP2PTransport | undefined;\n    protected walletConnectTransport: DappWalletConnectTransport | undefined;\n    protected wcProjectId?: string;\n    protected wcRelayUrl?: string;\n    private isGetActiveAccountHandled;\n    private readonly openRequestsOtherTabs;\n    /**\n     * A map of requests that are currently \"open\", meaning we have sent them to a wallet and are still awaiting a response.\n     */\n    private readonly openRequests;\n    /**\n     * The currently active account. For all requests that are associated to a specific request (operation request, signing request),\n     * the active account is used to determine the network and destination wallet\n     */\n    private _activeAccount;\n    /**\n     * The currently active peer. This is used to address a peer in case the active account is not set. (Eg. for permission requests)\n     */\n    private _activePeer;\n    private _initPromise;\n    private isInitPending;\n    private readonly activeAccountLoaded;\n    private readonly appMetadataManager;\n    private readonly disclaimerText?;\n    private readonly errorMessages;\n    private readonly featuredWallets;\n    private readonly storageValidator;\n    private readonly beaconIDB;\n    private debounceSetActiveAccount;\n    private multiTabChannel;\n    constructor(config: DAppClientOptions);\n    private checkIfBCLeaderExists;\n    private onElectedLeaderhandler;\n    private onBCMessageHandler;\n    private prepareRequest;\n    private createStateSnapshot;\n    private initUserID;\n    initInternalTransports(): Promise<void>;\n    private initEvents;\n    private onRelayerError;\n    private wcToastHandler;\n    private channelClosedHandler;\n    /**\n     * Destroy the instance.\n     *\n     * WARNING: Call `destroy` whenever you no longer need dAppClient\n     * as it frees internal subscriptions to the transport and therefore the instance may no longer work properly.\n     * If you wish to disconnect your dApp, use `disconnect` instead.\n     */\n    destroy(): Promise<void>;\n    init(transport?: Transport<any>, substratePairing?: boolean): Promise<TransportType>;\n    /**\n     * Returns the active account\n     */\n    getActiveAccount(): Promise<AccountInfo | undefined>;\n    private isInvalidState;\n    private resetInvalidState;\n    /**\n     * Sets the active account\n     *\n     * @param account The account that will be set as the active account\n     */\n    setActiveAccount(account?: AccountInfo): Promise<void>;\n    /**\n     * Clear the active account\n     */\n    clearActiveAccount(): Promise<void>;\n    setColorMode(colorMode: ColorMode): Promise<void>;\n    getColorMode(): Promise<ColorMode>;\n    /**\n     * @deprecated\n     *\n     * Use getOwnAppMetadata instead\n     */\n    getAppMetadata(): Promise<AppMetadata>;\n    showPrepare(): Promise<void>;\n    hideUI(elements: ('alert' | 'toast')[]): Promise<void>;\n    private tryToAppSwitch;\n    private addQueryParam;\n    private buildPayload;\n    private updateMetricsStorage;\n    private sendMetrics;\n    private checkMakeRequest;\n    /**\n     * Will remove the account from the local storage and set a new active account if necessary.\n     *\n     * @param accountIdentifier ID of the account\n     */\n    removeAccount(accountIdentifier: string): Promise<void>;\n    /**\n     * Remove all accounts and set active account to undefined\n     */\n    removeAllAccounts(): Promise<void>;\n    /**\n     * Removes a peer and all the accounts that have been connected through that peer\n     *\n     * @param peer Peer to be removed\n     */\n    removePeer(peer: ExtendedPeerInfo, sendDisconnectToPeer?: boolean): Promise<void>;\n    /**\n     * Remove all peers and all accounts that have been connected through those peers\n     */\n    removeAllPeers(sendDisconnectToPeers?: boolean): Promise<void>;\n    /**\n     * Allows the user to subscribe to specific events that are fired in the SDK\n     *\n     * @param internalEvent The event to subscribe to\n     * @param eventCallback The callback that will be called when the event occurs\n     */\n    subscribeToEvent<K extends BeaconEvent>(internalEvent: K, eventCallback: BeaconEventHandlerFunction<BeaconEventType[K]>): Promise<void>;\n    /**\n     * Check if we have permissions to send the specific message type to the active account.\n     * If no active account is set, only permission requests are allowed.\n     *\n     * @param type The type of the message\n     */\n    checkPermissions(type: BeaconMessageType): Promise<boolean>;\n    sendNotification(title: string, message: string, payload: string, protocolIdentifier: string): Promise<string>;\n    private blockchains;\n    addBlockchain(chain: Blockchain): void;\n    removeBlockchain(chainIdentifier: string): void;\n    permissionRequest(input: PermissionRequestV3<string>): Promise<PermissionResponseV3<string>>;\n    request(input: BlockchainRequestV3<string>): Promise<BlockchainResponseV3<string>>;\n    /**\n     * Send a permission request to the DApp. This should be done as the first step. The wallet will respond\n     * with an publicKey and permissions that were given. The account returned will be set as the \"activeAccount\"\n     * and will be used for the following requests.\n     *\n     * @param input The message details we need to prepare the PermissionRequest message.\n     */\n    requestPermissions(input?: RequestPermissionInput): Promise<PermissionResponseOutput>;\n    /**\n     * Send a proof of event request to the wallet. The wallet will either accept or decline the challenge.\n     * If it is accepted, the challenge will be stored, meaning that even if the user refresh the page, the DAppClient will keep checking if the challenge has been fulfilled.\n     * Once the challenge is stored, a challenge stored message will be sent to the wallet.\n     * It's **highly recommended** to run a proof of event challenge to check the identity of an abstracted account\n     *\n     * @param input The message details we need to prepare the ProofOfEventChallenge message.\n     */\n    requestProofOfEventChallenge(input: RequestProofOfEventChallengeInput): Promise<ProofOfEventChallengeResponse>;\n    /**\n     * Send a simulated proof of event request to the wallet. The wallet will either accept or decline the challenge.\n     * It's the same than `requestProofOfEventChallenge` but rather than executing operations on the blockchain to prove the identity,\n     * The wallet will return a list of operations that you'll be able to run on your side to verify the identity of the abstracted account\n     * It's **highly recommended** to run a proof of event challenge to check the identity of an abstracted account\n     *\n     * @param input The message details we need to prepare the SimulatedProofOfEventChallenge message.\n     */\n    requestSimulatedProofOfEventChallenge(input: RequestSimulatedProofOfEventChallengeInput): Promise<SimulatedProofOfEventChallengeResponse>;\n    /**\n     * This method will send a \"SignPayloadRequest\" to the wallet. This method is meant to be used to sign\n     * arbitrary data (eg. a string). It will return the signature in the format of \"edsig...\"\n     *\n     * @param input The message details we need to prepare the SignPayloadRequest message.\n     */\n    requestSignPayload(input: RequestSignPayloadInput): Promise<SignPayloadResponseOutput>;\n    /**\n     * This method will send an \"EncryptPayloadRequest\" to the wallet. This method is meant to be used to encrypt or decrypt\n     * arbitrary data (eg. a string). It will return the encrypted or decrypted payload\n     *\n     * @param input The message details we need to prepare the EncryptPayloadRequest message.\n     */\n    /**\n     * This method sends an OperationRequest to the wallet. This method should be used for all kinds of operations,\n     * eg. transaction or delegation. Not all properties have to be provided. Data like \"counter\" and fees will be\n     * fetched and calculated by the wallet (but they can still be provided if required).\n     *\n     * @param input The message details we need to prepare the OperationRequest message.\n     */\n    requestOperation(input: RequestOperationInput): Promise<OperationResponseOutput>;\n    /**\n     * Sends a \"BroadcastRequest\" to the wallet. This method can be used to inject an already signed transaction\n     * to the network.\n     *\n     * @param input The message details we need to prepare the BroadcastRequest message.\n     */\n    requestBroadcast(input: RequestBroadcastInput): Promise<BroadcastResponseOutput>;\n    protected setActivePeer(peer?: PeerInfoType): Promise<void>;\n    /**\n     * A \"setter\" for when the transport needs to be changed.\n     */\n    protected setTransport(transport?: Transport<any>): Promise<void>;\n    /**\n     * This method will emit an internal error message.\n     *\n     * @param errorMessage The error message to send.\n     */\n    private sendInternalError;\n    /**\n     * This method will remove all accounts associated with a specific peer.\n     *\n     * @param peersToRemove An array of peers for which accounts should be removed\n     */\n    private removeAccountsForPeers;\n    private removeAccountsForPeerIds;\n    /**\n     * This message handles errors that we receive from the wallet.\n     *\n     * @param request The request we sent\n     * @param beaconError The error we received\n     */\n    private handleRequestError;\n    /**\n     * This message will send an event when we receive a successful response to one of the requests we sent.\n     *\n     * @param request The request we sent\n     * @param response The response we received\n     */\n    private notifySuccess;\n    private getWalletInfoFromStorage;\n    private updateStorageWallet;\n    private getWalletInfo;\n    private getPeer;\n    /**\n     * This method handles sending of requests to the DApp. It makes sure that the DAppClient is initialized and connected\n     * to the transport. After that rate limits and permissions will be checked, an ID is attached and the request is sent\n     * to the DApp over the transport.\n     *\n     * @param requestInput The BeaconMessage to be sent to the wallet\n     * @param account The account that the message will be sent to\n     * @param skipResponse If true, the function return as soon as the message is sent\n     */\n    private makeRequest;\n    /**\n     * This method handles sending of requests to the DApp. It makes sure that the DAppClient is initialized and connected\n     * to the transport. After that rate limits and permissions will be checked, an ID is attached and the request is sent\n     * to the DApp over the transport.\n     *\n     * @param requestInput The BeaconMessage to be sent to the wallet\n     * @param account The account that the message will be sent to\n     */\n    private makeRequestV3;\n    private makeRequestBC;\n    disconnect(): Promise<void>;\n    /**\n     * Adds a requests to the \"openRequests\" set so we know what messages have already been answered/handled.\n     *\n     * @param id The ID of the message\n     * @param promise A promise that resolves once the response for that specific message is received\n     */\n    private addOpenRequest;\n    private sendNotificationWithAccessToken;\n    private onNewAccount;\n}\n"},{name:"@airgap/beacon-dapp/dist/esm/dapp-client/DAppClientOptions.d.ts",dts:"import { BeaconEvent, BeaconEventType, BeaconEventHandlerFunction } from '../events';\nimport { BlockExplorer } from '../utils/block-explorer';\nimport { Storage, NetworkType, ColorMode, NodeDistributions, AnalyticsInterface, Network } from '@airgap/beacon-types';\ntype RequireAtLeastOne<T, Keys extends keyof T = keyof T> = Pick<T, Exclude<keyof T, Keys>> & {\n    [K in Keys]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<Keys, K>>>;\n}[Keys];\n/**\n * @category DApp\n */\nexport interface DAppClientOptions {\n    /**\n     * Name of the application\n     */\n    name: string;\n    /**\n     * Description of the application\n     */\n    description?: string;\n    /**\n     * A URL to the icon of the application\n     */\n    iconUrl?: string;\n    /**\n     * A URL to the website of the application\n     */\n    appUrl?: string;\n    /**\n     * The storage that will be used by the SDK\n     */\n    storage?: Storage;\n    /**\n     * An object that will be used to overwrite default event handler behaviour.\n     *\n     * If you plan to overwrite all default events, use \"disableDefaultEvents\" instead.\n     *\n     * This will overwrite the default event handler, so this can lead to unexpected behavior in some cases.\n     * We recommend that you overwrite all handlers if you want to use your own UI.\n     *\n     * If you simply want to be notified of events happening, but do not want to overwrite the default behavior,\n     * please use `subscribeToEvent()` on the DAppClient instead.\n     */\n    eventHandlers?: {\n        [key in BeaconEvent]?: {\n            handler: BeaconEventHandlerFunction<BeaconEventType[key]>;\n        };\n    };\n    /**\n     * Disable all default Events and UI elements. If passed together with \"eventHandlers\",\n     * the default eventHandlers will be removed, and the ones passed by the user will be added.\n     */\n    disableDefaultEvents?: boolean;\n    /**\n     * A list of matrix nodes to connect to. If a non-empty array is passed, the default options will be overwritten.\n     * One node will be randomly selected based on the local keypair and the other nodes will be used as a fallback in case the primary node goes down.\n     *\n     * Only provide the hostname, no https:// prefix. Eg. { [Regions.EU1]: ['matrix.example.com'] }\n     */\n    matrixNodes?: NodeDistributions;\n    /**\n     * The block explorer used by the SDK\n     */\n    blockExplorer?: BlockExplorer;\n    /**\n     * Indicates on which network the DApp is running on.\n     */\n    network?: Network;\n    /**\n     * @deprecated Please use \"network\" instead.\n     * Indicates on which network the DApp is planning to run. This is currently used to adjust the URLs of web-wallets in the pairing alert if they use different URLs for testnets.\n     * You will still have to define the network you intend to use during the permission request.\n     */\n    preferredNetwork?: NetworkType;\n    /**\n     * Set the color mode for the UI elements (alerts and toasts)\n     */\n    colorMode?: ColorMode;\n    /**\n     * A disclaimer text that will be displayed in the pairing alert\n     */\n    disclaimerText?: string;\n    /**\n     * A list of contracts that the DApp is using. Allows to attach human readable error messages for to error codes\n     */\n    errorMessages?: Record<string, Record<string | number, string>>;\n    /**\n     * Configuration that is passed to the WalletConnect transport.\n     *\n     * This is required to enable WalletConnect connections.\n     */\n    walletConnectOptions?: RequireAtLeastOne<{\n        /**\n         * The projectId of the application. Has to be obtained from https://cloud.walletconnect.com/\n         */\n        projectId?: string;\n        /**\n         * The relay server to connect to\n         */\n        relayUrl?: string;\n    }>;\n    /**\n     * The analytics instance that will be used by the SDK\n     */\n    analytics?: AnalyticsInterface;\n    /**\n     * The wallets that will be featured in the UI.\n     */\n    featuredWallets?: string[];\n    /**\n     * Automatically switch between apps on Mobile Devices (Enabled by Default)\n     */\n    enableAppSwitching?: boolean;\n    /**\n     * Enable metrics tracking (Disabled by Default)\n     */\n    enableMetrics?: boolean;\n}\nexport {};\n"},{name:"@airgap/beacon-dapp/dist/esm/transports/DappP2PTransport.d.ts",dts:"import { Storage, StorageKey, ExtendedP2PPairingResponse, NodeDistributions } from '@airgap/beacon-types';\nimport { P2PTransport } from '@airgap/beacon-transport-matrix';\nimport { KeyPair } from '@stablelib/ed25519';\n/**\n * @internalapi\n *\n *\n */\nexport declare class DappP2PTransport extends P2PTransport<ExtendedP2PPairingResponse, StorageKey.TRANSPORT_P2P_PEERS_DAPP> {\n    constructor(name: string, keyPair: KeyPair, storage: Storage, matrixNodes: NodeDistributions, iconUrl?: string, appUrl?: string);\n    startOpenChannelListener(): Promise<void>;\n    listenForNewPeer(newPeerListener: (peer: ExtendedP2PPairingResponse) => void): Promise<void>;\n    stopListeningForNewPeers(): Promise<void>;\n}\n"},{name:"@airgap/beacon-dapp/dist/esm/transports/DappPostMessageTransport.d.ts",dts:"import { StorageKey, Storage, ExtendedPostMessagePairingResponse } from '@airgap/beacon-types';\nimport { PostMessageTransport } from '@airgap/beacon-transport-postmessage';\nimport { KeyPair } from '@stablelib/ed25519';\n/**\n * @internalapi\n *\n *\n */\nexport declare class DappPostMessageTransport extends PostMessageTransport<ExtendedPostMessagePairingResponse, StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP> {\n    constructor(name: string, keyPair: KeyPair, storage: Storage);\n    startOpenChannelListener(): Promise<void>;\n    listenForNewPeer(newPeerListener: (peer: ExtendedPostMessagePairingResponse) => void): Promise<void>;\n    stopListeningForNewPeers(): Promise<void>;\n}\n"},{name:"@airgap/beacon-dapp/dist/esm/transports/DappWalletConnectTransport.d.ts",dts:"import { StorageKey, Storage, ExtendedWalletConnectPairingResponse, NetworkType } from '@airgap/beacon-types';\nimport { WalletConnectTransport } from '@airgap/beacon-transport-walletconnect';\nimport { KeyPair } from '@stablelib/ed25519';\nimport { SignClientTypes } from '@walletconnect/types';\n/**\n * @internalapi\n *\n *\n */\nexport declare class DappWalletConnectTransport extends WalletConnectTransport<ExtendedWalletConnectPairingResponse, StorageKey.TRANSPORT_WALLETCONNECT_PEERS_DAPP> {\n    constructor(name: string, keyPair: KeyPair, storage: Storage, wcOptions: {\n        network: NetworkType;\n        opts: SignClientTypes.Options;\n    }, isLeader: () => Promise<boolean>);\n    listenForNewPeer(newPeerListener: (peer: ExtendedWalletConnectPairingResponse) => void): Promise<void>;\n    stopListeningForNewPeers(): Promise<void>;\n}\n"},{name:"@airgap/beacon-dapp/dist/esm/utils/available-transports.d.ts",dts:"/**\n * An object with promises to indicate whether or not that transport is available.\n */\nexport declare const availableTransports: any;\n"},{name:"@airgap/beacon-dapp/dist/esm/utils/block-explorer.d.ts",dts:"import { Network, NetworkType } from '@airgap/beacon-types';\nexport declare abstract class BlockExplorer {\n    readonly rpcUrls: {\n        [key in NetworkType]: string;\n    };\n    constructor(rpcUrls: {\n        [key in NetworkType]: string;\n    });\n    protected getLinkForNetwork(network: Network): Promise<string>;\n    /**\n     * Return a blockexplorer link for an address\n     *\n     * @param address The address to be opened\n     * @param network The network that was used\n     */\n    abstract getAddressLink(address: string, network: Network): Promise<string>;\n    /**\n     * Return a blockexplorer link for a transaction hash\n     *\n     * @param transactionId The hash of the transaction\n     * @param network The network that was used\n     */\n    abstract getTransactionLink(transactionId: string, network: Network): Promise<string>;\n}\n"},{name:"@airgap/beacon-dapp/dist/esm/utils/get-instance.d.ts",dts:"import { DAppClient } from '../dapp-client/DAppClient';\nimport { DAppClientOptions } from '../dapp-client/DAppClientOptions';\n/** Get a DAppClient instance. Will make sure only one dAppClient exists. After the first instance has been created, the config will be ignored, unless \"reset\" is set */\nexport declare const getDAppClientInstance: (config: DAppClientOptions, reset?: boolean) => DAppClient;\n"},{name:"@airgap/beacon-dapp/dist/esm/utils/shorten-string.d.ts",dts:"export declare const shortenString: (text: string) => string;\n"},{name:"@airgap/beacon-dapp/dist/esm/utils/tzkt-blockexplorer.d.ts",dts:"import { Network, NetworkType } from '@airgap/beacon-types';\nimport { BlockExplorer } from './block-explorer';\nexport declare class TzktBlockExplorer extends BlockExplorer {\n    readonly rpcUrls: {\n        [key in NetworkType]: string;\n    };\n    constructor(rpcUrls?: {\n        [key in NetworkType]: string;\n    });\n    getAddressLink(address: string, network: Network): Promise<string>;\n    getTransactionLink(transactionId: string, network: Network): Promise<string>;\n}\n"},{name:"@airgap/beacon-dapp/dist/esm/beacon-message-events.d.ts",dts:"import { BeaconEvent } from './events';\nimport { BeaconMessageType } from '@airgap/beacon-types';\nexport declare const messageEvents: {\n    [key in BeaconMessageType]: {\n        sent: BeaconEvent;\n        success: BeaconEvent;\n        error: BeaconEvent;\n    };\n};\n"},{name:"@airgap/beacon-dapp/dist/esm/events.d.ts",dts:'import { BlockExplorer, AlertButton } from \'@airgap/beacon-dapp\';\nimport { ExtendedPostMessagePairingResponse, ExtendedP2PPairingResponse, AccountInfo, ErrorResponse, PermissionResponseOutput, OperationResponseOutput, BroadcastResponseOutput, SignPayloadResponseOutput, Network, ConnectionContext, NetworkType, AcknowledgeResponse, WalletInfo, ExtendedWalletConnectPairingResponse, AnalyticsInterface, ProofOfEventChallengeResponseOutput, SimulatedProofOfEventChallengeResponseOutput } from \'@airgap/beacon-types\';\nimport { Transport } from \'@airgap/beacon-core\';\n/**\n * The different events that can be emitted by the beacon-sdk\n */\nexport declare enum BeaconEvent {\n    PERMISSION_REQUEST_SENT = "PERMISSION_REQUEST_SENT",\n    PERMISSION_REQUEST_SUCCESS = "PERMISSION_REQUEST_SUCCESS",\n    PERMISSION_REQUEST_ERROR = "PERMISSION_REQUEST_ERROR",\n    PROOF_OF_EVENT_CHALLENGE_REQUEST_SENT = "PROOF_OF_EVENT_CHALLENGE_REQUEST_SENT",\n    PROOF_OF_EVENT_CHALLENGE_REQUEST_SUCCESS = "PROOF_OF_EVENT_CHALLENGE_REQUEST_SUCCESS",\n    PROOF_OF_EVENT_CHALLENGE_REQUEST_ERROR = "PROOF_OF_EVENT_CHALLENGE_REQUEST_ERROR",\n    SIMULATED_PROOF_OF_EVENT_CHALLENGE_REQUEST_SENT = "SIMULATED_PROOF_OF_EVENT_CHALLENGE_REQUEST_SENT",\n    SIMULATED_PROOF_OF_EVENT_CHALLENGE_REQUEST_SUCCESS = "SIMULATED_PROOF_OF_EVENT_CHALLENGE_REQUEST_SUCCESS",\n    SIMULATED_PROOF_OF_EVENT_CHALLENGE_REQUEST_ERROR = "SIMULATED_PROOF_OF_EVENT_CHALLENGE_REQUEST_ERROR",\n    OPERATION_REQUEST_SENT = "OPERATION_REQUEST_SENT",\n    OPERATION_REQUEST_SUCCESS = "OPERATION_REQUEST_SUCCESS",\n    OPERATION_REQUEST_ERROR = "OPERATION_REQUEST_ERROR",\n    SIGN_REQUEST_SENT = "SIGN_REQUEST_SENT",\n    SIGN_REQUEST_SUCCESS = "SIGN_REQUEST_SUCCESS",\n    SIGN_REQUEST_ERROR = "SIGN_REQUEST_ERROR",\n    BLOCKCHAIN_REQUEST_SUCCESS = "BLOCKCHAIN_REQUEST_SUCCESS",\n    BROADCAST_REQUEST_SENT = "BROADCAST_REQUEST_SENT",\n    BROADCAST_REQUEST_SUCCESS = "BROADCAST_REQUEST_SUCCESS",\n    BROADCAST_REQUEST_ERROR = "BROADCAST_REQUEST_ERROR",\n    ACKNOWLEDGE_RECEIVED = "ACKNOWLEDGE_RECEIVED",\n    LOCAL_RATE_LIMIT_REACHED = "LOCAL_RATE_LIMIT_REACHED",\n    NO_PERMISSIONS = "NO_PERMISSIONS",\n    ACTIVE_ACCOUNT_SET = "ACTIVE_ACCOUNT_SET",\n    ACTIVE_TRANSPORT_SET = "ACTIVE_TRANSPORT_SET",\n    SHOW_PREPARE = "SHOW_PREPARE",\n    HIDE_UI = "HIDE_UI",\n    INVALID_ACTIVE_ACCOUNT_STATE = "INVALID_ACTIVE_ACCOUNT_STATE",\n    INVALID_ACCOUNT_DEACTIVATED = "INVALID_ACCOUNT_DEACTIVATED",\n    PAIR_INIT = "PAIR_INIT",\n    PAIR_SUCCESS = "PAIR_SUCCESS",\n    CHANNEL_CLOSED = "CHANNEL_CLOSED",\n    GENERIC_ERROR = "GENERIC_ERROR",\n    OPEN_BUG_REPORT = "OPEN_BUG_REPORT",\n    RELAYER_ERROR = "RELAYER_ERROR",\n    INTERNAL_ERROR = "INTERNAL_ERROR",\n    UNKNOWN = "UNKNOWN"\n}\nexport interface ExtraInfo {\n    resetCallback?(): Promise<void>;\n}\ninterface RequestSentInfo {\n    extraInfo: ExtraInfo;\n    walletInfo: WalletInfo;\n}\n/**\n * The type of the payload of the different BeaconEvents\n */\nexport interface BeaconEventType {\n    [BeaconEvent.PERMISSION_REQUEST_SENT]: RequestSentInfo;\n    [BeaconEvent.PERMISSION_REQUEST_SUCCESS]: {\n        account: AccountInfo;\n        output: PermissionResponseOutput;\n        blockExplorer: BlockExplorer;\n        connectionContext: ConnectionContext;\n        walletInfo: WalletInfo;\n    };\n    [BeaconEvent.PERMISSION_REQUEST_ERROR]: {\n        errorResponse: ErrorResponse;\n        walletInfo: WalletInfo;\n    };\n    [BeaconEvent.PROOF_OF_EVENT_CHALLENGE_REQUEST_SENT]: RequestSentInfo;\n    [BeaconEvent.PROOF_OF_EVENT_CHALLENGE_REQUEST_SUCCESS]: {\n        account: AccountInfo;\n        output: ProofOfEventChallengeResponseOutput;\n        blockExplorer: BlockExplorer;\n        connectionContext: ConnectionContext;\n        walletInfo: WalletInfo;\n    };\n    [BeaconEvent.PROOF_OF_EVENT_CHALLENGE_REQUEST_ERROR]: {\n        errorResponse: ErrorResponse;\n        walletInfo: WalletInfo;\n    };\n    [BeaconEvent.SIMULATED_PROOF_OF_EVENT_CHALLENGE_REQUEST_SENT]: RequestSentInfo;\n    [BeaconEvent.SIMULATED_PROOF_OF_EVENT_CHALLENGE_REQUEST_SUCCESS]: {\n        account: AccountInfo;\n        output: SimulatedProofOfEventChallengeResponseOutput;\n        blockExplorer: BlockExplorer;\n        connectionContext: ConnectionContext;\n        walletInfo: WalletInfo;\n    };\n    [BeaconEvent.SIMULATED_PROOF_OF_EVENT_CHALLENGE_REQUEST_ERROR]: {\n        errorResponse: ErrorResponse;\n        walletInfo: WalletInfo;\n    };\n    [BeaconEvent.OPERATION_REQUEST_SENT]: RequestSentInfo;\n    [BeaconEvent.OPERATION_REQUEST_SUCCESS]: {\n        account: AccountInfo;\n        output: OperationResponseOutput;\n        blockExplorer: BlockExplorer;\n        connectionContext: ConnectionContext;\n        walletInfo: WalletInfo;\n    };\n    [BeaconEvent.OPERATION_REQUEST_ERROR]: {\n        errorResponse: ErrorResponse;\n        walletInfo: WalletInfo;\n        errorMessages: Record<string, Record<string | number, string>>;\n    };\n    [BeaconEvent.SIGN_REQUEST_SENT]: RequestSentInfo;\n    [BeaconEvent.SIGN_REQUEST_SUCCESS]: {\n        output: SignPayloadResponseOutput;\n        connectionContext: ConnectionContext;\n        walletInfo: WalletInfo;\n    };\n    [BeaconEvent.SIGN_REQUEST_ERROR]: {\n        errorResponse: ErrorResponse;\n        walletInfo: WalletInfo;\n    };\n    [BeaconEvent.BLOCKCHAIN_REQUEST_SUCCESS]: RequestSentInfo;\n    [BeaconEvent.BROADCAST_REQUEST_SENT]: RequestSentInfo;\n    [BeaconEvent.BROADCAST_REQUEST_SUCCESS]: {\n        network: Network;\n        output: BroadcastResponseOutput;\n        blockExplorer: BlockExplorer;\n        connectionContext: ConnectionContext;\n        walletInfo: WalletInfo;\n    };\n    [BeaconEvent.BROADCAST_REQUEST_ERROR]: {\n        errorResponse: ErrorResponse;\n        walletInfo: WalletInfo;\n    };\n    [BeaconEvent.ACKNOWLEDGE_RECEIVED]: {\n        message: AcknowledgeResponse;\n        extraInfo: ExtraInfo;\n        walletInfo: WalletInfo;\n    };\n    [BeaconEvent.LOCAL_RATE_LIMIT_REACHED]: undefined;\n    [BeaconEvent.NO_PERMISSIONS]: undefined;\n    [BeaconEvent.ACTIVE_ACCOUNT_SET]: AccountInfo;\n    [BeaconEvent.ACTIVE_TRANSPORT_SET]: Transport;\n    [BeaconEvent.INVALID_ACTIVE_ACCOUNT_STATE]: undefined;\n    [BeaconEvent.GENERIC_ERROR]: string;\n    [BeaconEvent.INVALID_ACCOUNT_DEACTIVATED]: undefined;\n    [BeaconEvent.SHOW_PREPARE]: {\n        walletInfo?: WalletInfo;\n    };\n    [BeaconEvent.HIDE_UI]: (\'alert\' | \'toast\')[] | undefined;\n    [BeaconEvent.PAIR_INIT]: {\n        p2pPeerInfo: Promise<string>;\n        postmessagePeerInfo: Promise<string>;\n        walletConnectPeerInfo: Promise<string>;\n        networkType: NetworkType;\n        abortedHandler?(): void;\n        disclaimerText?: string;\n        analytics: AnalyticsInterface;\n        featuredWallets?: string[];\n        substratePairing?: boolean;\n    };\n    [BeaconEvent.PAIR_SUCCESS]: ExtendedPostMessagePairingResponse | ExtendedP2PPairingResponse | ExtendedWalletConnectPairingResponse;\n    [BeaconEvent.CHANNEL_CLOSED]: string;\n    [BeaconEvent.INTERNAL_ERROR]: {\n        text: string;\n        buttons?: AlertButton[];\n    };\n    [BeaconEvent.OPEN_BUG_REPORT]: undefined;\n    [BeaconEvent.RELAYER_ERROR]: undefined;\n    [BeaconEvent.UNKNOWN]: undefined;\n}\nexport type BeaconEventHandlerFunction<T = unknown> = (data: T, eventCallback?: AlertButton[]) => void | Promise<void>;\n/**\n * The default event handlers\n */\nexport declare const defaultEventCallbacks: {\n    [key in BeaconEvent]: BeaconEventHandlerFunction<BeaconEventType[key]>;\n};\n/**\n * @internalapi\n *\n * Handles beacon events\n */\nexport declare class BeaconEventHandler {\n    private readonly callbackMap;\n    constructor(eventsToOverride?: {\n        [key in BeaconEvent]?: {\n            handler: BeaconEventHandlerFunction<BeaconEventType[key]>;\n        };\n    }, overrideAll?: boolean);\n    /**\n     * A method to subscribe to a specific beacon event and register a callback\n     *\n     * @param event The event being emitted\n     * @param eventCallback The callback that will be invoked\n     */\n    on<K extends BeaconEvent>(event: K, eventCallback: BeaconEventHandlerFunction<BeaconEventType[K]>): Promise<void>;\n    /**\n     * Emit a beacon event\n     *\n     * @param event The event being emitted\n     * @param data The data to be emit\n     */\n    emit<K extends BeaconEvent>(event: K, data?: BeaconEventType[K], eventCallback?: AlertButton[]): Promise<void>;\n    /**\n     * Override beacon event default callbacks. This can be used to disable default alert/toast behaviour\n     *\n     * @param eventsToOverride An object with the events to override\n     */\n    private overrideDefaults;\n    /**\n     * Set all event callbacks to a specific handler.\n     */\n    private setAllHandlers;\n}\nexport {};\n'},{name:"@airgap/beacon-dapp/dist/esm/index.d.ts",dts:"export * from '@airgap/beacon-core';\nexport * from '@airgap/beacon-transport-matrix';\nexport * from '@airgap/beacon-transport-postmessage';\nexport * from '@airgap/beacon-types';\nexport * from '@airgap/beacon-utils';\nexport * from '@airgap/beacon-ui';\nimport { DAppClient } from './dapp-client/DAppClient';\nimport { DAppClientOptions } from './dapp-client/DAppClientOptions';\nimport { BeaconEvent, BeaconEventHandler, defaultEventCallbacks } from './events';\nimport { BlockExplorer } from './utils/block-explorer';\nimport { TzktBlockExplorer } from './utils/tzkt-blockexplorer';\nimport { getDAppClientInstance } from './utils/get-instance';\nexport { DAppClient, DAppClientOptions, getDAppClientInstance };\nexport { BeaconEvent, BeaconEventHandler, defaultEventCallbacks };\nexport { BlockExplorer, TzktBlockExplorer, TzktBlockExplorer as TezblockBlockExplorer };\n"},{name:"@airgap/beacon-sdk/index.d.ts",dts:"export * from '@airgap/beacon-blockchain-substrate';\nexport * from '@airgap/beacon-blockchain-tezos';\nexport * from '@airgap/beacon-core';\nexport * from '@airgap/beacon-dapp';\nexport * from '@airgap/beacon-transport-matrix';\nexport * from '@airgap/beacon-transport-postmessage';\nexport * from '@airgap/beacon-transport-walletconnect';\nexport * from '@airgap/beacon-types';\nexport * from '@airgap/beacon-utils';\nexport * from '@airgap/beacon-wallet';\n"},{name:"@airgap/beacon-transport-matrix/communication-client/P2PCommunicationClient.d.ts",dts:"import { MatrixClientEvent, MatrixClientEventType, MatrixClientEventMessageContent } from '../matrix-client/models/MatrixClientEvent';\nimport { Storage, P2PPairingRequest, ExtendedP2PPairingResponse, P2PPairingResponse, NodeDistributions } from '@airgap/beacon-types';\nimport { CommunicationClient } from '@airgap/beacon-core';\nimport { ExposedPromise } from '@airgap/beacon-utils';\nimport { KeyPair } from '@stablelib/ed25519';\ninterface BeaconInfoResponse {\n    region: string;\n    known_servers: string[];\n    timestamp: number;\n}\n/**\n * @internalapi\n */\nexport declare class P2PCommunicationClient extends CommunicationClient {\n    private readonly name;\n    readonly replicationCount: number;\n    private readonly storage;\n    private readonly iconUrl?;\n    private readonly appUrl?;\n    private client;\n    private initialEvent;\n    private initialListener;\n    private selectedRegion?;\n    private readonly ENABLED_RELAY_SERVERS;\n    relayServer: ExposedPromise<{\n        server: string;\n        timestamp: number;\n        localTimestamp: number;\n    }> | undefined;\n    private readonly activeListeners;\n    private readonly ignoredRooms;\n    private loginCounter;\n    constructor(name: string, keyPair: KeyPair, replicationCount: number, storage: Storage, matrixNodes?: NodeDistributions, iconUrl?: string | undefined, appUrl?: string | undefined);\n    getPairingRequestInfo(): Promise<P2PPairingRequest>;\n    getPairingResponseInfo(request: P2PPairingRequest): Promise<P2PPairingResponse>;\n    /**\n     * To get the fastest region, we can't simply do one request, because sometimes,\n     * DNS and SSL handshakes make \"faster\" connections slower. So we need to do 2 requests\n     * and check which request was the fastest after 1s.\n     */\n    findBestRegionAndGetServer(): Promise<{\n        server: string;\n        timestamp: number;\n    } | undefined>;\n    getRelayServer(): Promise<{\n        server: string;\n        timestamp: number;\n    }>;\n    getBeaconInfo(server: string): Promise<BeaconInfoResponse>;\n    tryJoinRooms(roomId: string, retry?: number): Promise<void>;\n    start(): Promise<void>;\n    stop(): Promise<void>;\n    reset(): Promise<void>;\n    listenForEncryptedMessage(senderPublicKey: string, messageCallback: (message: string) => void): Promise<void>;\n    unsubscribeFromEncryptedMessage(senderPublicKey: string): Promise<void>;\n    unsubscribeFromEncryptedMessages(): Promise<void>;\n    sendMessage(message: string, peer: P2PPairingRequest | ExtendedP2PPairingResponse): Promise<void>;\n    updatePeerRoom(sender: string, roomId: string): Promise<void>;\n    deleteRoomIdFromRooms(roomId: string): Promise<void>;\n    listenForChannelOpening(messageCallback: (pairingResponse: ExtendedP2PPairingResponse) => void): Promise<void>;\n    waitForJoin(roomId: string, retry?: number): Promise<void>;\n    sendPairingResponse(pairingRequest: P2PPairingRequest): Promise<void>;\n    isTextMessage(content: MatrixClientEventMessageContent<any>): content is MatrixClientEventMessageContent<string>;\n    updateRelayServer(sender: string): Promise<void>;\n    isChannelOpenMessage(content: MatrixClientEventMessageContent<string>): Promise<boolean>;\n    isSender(event: MatrixClientEvent<MatrixClientEventType.MESSAGE>, senderPublicKey: string): Promise<boolean>;\n    private generateNewKeyPair;\n    private getRelevantRoom;\n    private getRelevantJoinedRoom;\n}\nexport {};\n"},{name:"@airgap/beacon-transport-matrix/matrix-client/models/api/MatrixEventSend.d.ts",dts:"export interface MatrixEventSendRequest {\n    content: any;\n}\nexport interface MatrixEventSendResponse {\n    type?: 'event_send';\n    event_id: string;\n}\n"},{name:"@airgap/beacon-transport-matrix/matrix-client/models/api/MatrixLogin.d.ts",dts:"export interface MatrixLoginRequest {\n    type: 'm.login.password';\n    identifier: {\n        type: 'm.id.user';\n        user: string;\n    };\n    password: string;\n    device_id?: string;\n}\nexport interface MatrixLoginResponse {\n    type?: 'login';\n    user_id: string;\n    device_id: string;\n    access_token: string;\n}\n"},{name:"@airgap/beacon-transport-matrix/matrix-client/models/api/MatrixRequest.d.ts",dts:"import { MatrixLoginRequest, MatrixLoginResponse } from './MatrixLogin';\nimport { MatrixRoomCreateRequest, MatrixRoomCreateResponse } from './MatrixRoomCreate';\nimport { MatrixRoomInviteRequest, MatrixRoomInviteResponse } from './MatrixRoomInvite';\nimport { MatrixRoomJoinRequest, MatrixRoomJoinResponse } from './MatrixRoomJoin';\nimport { MatrixEventSendRequest, MatrixEventSendResponse } from './MatrixEventSend';\nimport { MatrixSyncResponse, MatrixSyncRequestParams } from './MatrixSync';\nexport type MatrixRequest<T> = T extends MatrixLoginResponse ? MatrixLoginRequest : T extends MatrixRoomCreateResponse ? MatrixRoomCreateRequest : T extends MatrixRoomInviteResponse ? MatrixRoomInviteRequest : T extends MatrixRoomJoinResponse ? MatrixRoomJoinRequest : T extends MatrixEventSendResponse ? MatrixEventSendRequest : never;\nexport type MatrixRequestParams<T> = T extends MatrixSyncResponse ? MatrixSyncRequestParams : never;\n"},{name:"@airgap/beacon-transport-matrix/matrix-client/models/api/MatrixRoomCreate.d.ts",dts:"export interface MatrixRoomCreateRequest {\n    room_version?: '5';\n    visibility?: 'public' | 'private';\n    room_alias_name?: string;\n    name?: string;\n    topic?: string;\n    invite?: string[];\n    preset?: 'private_chat' | 'public_chat' | 'trusted_private_chat';\n    is_direct?: boolean;\n}\nexport interface MatrixRoomCreateResponse {\n    type?: 'room_create';\n    room_id: string;\n}\n"},{name:"@airgap/beacon-transport-matrix/matrix-client/models/api/MatrixRoomInvite.d.ts",dts:"export interface MatrixRoomInviteRequest {\n    user_id: string;\n}\nexport interface MatrixRoomInviteResponse {\n    type?: 'room_invite';\n}\n"},{name:"@airgap/beacon-transport-matrix/matrix-client/models/api/MatrixRoomJoin.d.ts",dts:"export interface MatrixRoomJoinRequest {\n}\nexport interface MatrixRoomJoinResponse {\n    type?: 'room_join';\n    room_id: string;\n}\n"},{name:"@airgap/beacon-transport-matrix/matrix-client/models/api/MatrixSync.d.ts",dts:"import { MatrixStateEvent } from '../MatrixStateEvent';\nexport interface MatrixSyncJoinedRoom {\n    state: {\n        events: MatrixStateEvent[];\n    };\n    timeline: {\n        events: MatrixStateEvent[];\n    };\n}\nexport interface MatrixSyncInvitedRoom {\n    invite_state: {\n        events: MatrixStateEvent[];\n    };\n}\nexport interface MatrixSyncLeftRoom {\n    state: {\n        events: MatrixStateEvent[];\n    };\n    timeline: {\n        events: MatrixStateEvent[];\n    };\n}\nexport interface MatrixSyncRooms {\n    join?: {\n        [key: string]: MatrixSyncJoinedRoom;\n    };\n    invite?: {\n        [key: string]: MatrixSyncInvitedRoom;\n    };\n    leave?: {\n        [key: string]: MatrixSyncLeftRoom;\n    };\n}\nexport interface MatrixSyncRequestParams {\n    timeout?: number;\n    since?: string;\n}\nexport interface MatrixSyncResponse {\n    type?: 'sync';\n    next_batch: string;\n    rooms?: MatrixSyncRooms;\n}\n"},{name:"@airgap/beacon-transport-matrix/matrix-client/models/MatrixClientEvent.d.ts",dts:'import { MatrixMessage } from \'./MatrixMessage\';\nexport declare enum MatrixClientEventType {\n    INVITE = "invite",\n    MESSAGE = "message"\n}\nexport type MatrixClientEventContent<T> = T extends MatrixClientEventType.INVITE ? MatrixClientEventInviteContent : T extends MatrixClientEventType.MESSAGE ? MatrixClientEventMessageContent<unknown> : never;\nexport interface MatrixClientEventInviteContent {\n    roomId: string;\n    members: string[];\n}\nexport interface MatrixClientEventMessageContent<T> {\n    roomId: string;\n    message: MatrixMessage<T>;\n}\nexport interface MatrixClientEvent<T extends MatrixClientEventType> {\n    type: T;\n    content: MatrixClientEventContent<T>;\n    timestamp?: number;\n}\n'},{name:"@airgap/beacon-transport-matrix/matrix-client/models/MatrixMessage.d.ts",dts:"import { MatrixStateEvent } from './MatrixStateEvent';\nexport declare enum MatrixMessageType {\n    TEXT = \"m.text\"\n}\nexport declare class MatrixMessage<T> {\n    readonly type: MatrixMessageType;\n    readonly sender: string;\n    readonly content: T;\n    readonly timestamp: number;\n    /**\n     * Construct a message from a message event\n     *\n     * @param event\n     */\n    static from(event: MatrixStateEvent): MatrixMessage<unknown> | undefined;\n    private constructor();\n}\n"},{name:"@airgap/beacon-transport-matrix/matrix-client/models/MatrixRoom.d.ts",dts:"import { MatrixSyncRooms } from './api/MatrixSync';\nimport { MatrixMessage } from './MatrixMessage';\nexport declare enum MatrixRoomStatus {\n    UNKNOWN = 0,\n    JOINED = 1,\n    INVITED = 2,\n    LEFT = 3\n}\nexport declare class MatrixRoom {\n    readonly id: string;\n    readonly status: MatrixRoomStatus;\n    readonly members: string[];\n    messages: MatrixMessage<any>[];\n    /**\n     * Reconstruct rooms from a sync response\n     *\n     * @param roomSync\n     */\n    static fromSync(roomSync?: MatrixSyncRooms): MatrixRoom[];\n    /**\n     * Reconstruct a room from an ID or object\n     *\n     * @param roomOrId\n     * @param status\n     */\n    static from(roomOrId: string | MatrixRoom, status?: MatrixRoomStatus): MatrixRoom;\n    /**\n     * Merge new and old state and remove duplicates\n     *\n     * @param newState\n     * @param previousState\n     */\n    static merge(newState: MatrixRoom, previousState?: MatrixRoom): MatrixRoom;\n    /**\n     * Create a room from a join\n     *\n     * @param id\n     * @param joined\n     */\n    private static fromJoined;\n    /**\n     * Create a room from an invite\n     *\n     * @param id\n     * @param invited\n     */\n    private static fromInvited;\n    /**\n     * Create a room from a leave\n     *\n     * @param id\n     * @param left\n     */\n    private static fromLeft;\n    /**\n     * Extract members from an event\n     *\n     * @param events\n     */\n    private static getMembersFromEvents;\n    /**\n     * Extract messages from an event\n     *\n     * @param events\n     */\n    private static getMessagesFromEvents;\n    /**\n     * Get unique events and remove duplicates\n     *\n     * @param events\n     */\n    private static getUniqueEvents;\n    private constructor();\n}\n"},{name:"@airgap/beacon-transport-matrix/matrix-client/models/MatrixStateEvent.d.ts",dts:"import { MatrixMessageType } from './MatrixMessage';\nexport interface MatrixStateEventMessageText extends MatrixStateEventMessage {\n    type: 'm.room.message';\n    content: {\n        msgtype: MatrixMessageType.TEXT;\n        body: string;\n    };\n}\nexport interface MatrixStateEventMessageContent {\n    msgtype: string;\n    body: any;\n    [key: string]: any;\n}\nexport interface MatrixStateEventMessage extends MatrixStateEvent {\n    type: 'm.room.message';\n    content: MatrixStateEventMessageContent;\n}\nexport interface MatrixStateEvent {\n    type: string;\n    sender: string;\n    content: unknown;\n    event_id?: string;\n    origin_server_ts: number;\n}\n"},{name:"@airgap/beacon-transport-matrix/matrix-client/services/MatrixEventService.d.ts",dts:"import { MatrixHttpClient } from '../MatrixHttpClient';\nimport { MatrixEventSendResponse } from '../models/api/MatrixEventSend';\nimport { MatrixSyncResponse } from '../models/api/MatrixSync';\nimport { MatrixStateEventMessageContent } from '../models/MatrixStateEvent';\ninterface MatrixScheduledEvent<T> {\n    accessToken: string;\n    roomId: string;\n    type: MatrixEventType;\n    content: any;\n    txnId: string;\n    onSuccess(response: T): void;\n    onError(error: unknown): void;\n}\ntype MatrixEventType = 'm.room.message';\nexport interface MatrixSyncOptions {\n    syncToken?: string;\n    pollingTimeout?: number;\n}\n/**\n * A service to help with matrix event management\n */\nexport declare class MatrixEventService {\n    private readonly httpClient;\n    private readonly cachedPromises;\n    constructor(httpClient: MatrixHttpClient);\n    /**\n     * Get the latest state from the matrix node\n     *\n     * @param accessToken\n     * @param options\n     */\n    sync(accessToken: string, options?: MatrixSyncOptions): Promise<MatrixSyncResponse>;\n    /**\n     * Send a message to a room\n     *\n     * @param accessToken\n     * @param room\n     * @param content\n     * @param txnId\n     */\n    sendMessage(accessToken: string, roomId: string, content: MatrixStateEventMessageContent, txnId: string): Promise<MatrixEventSendResponse>;\n    /**\n     * Schedules an event to be sent to the node\n     *\n     * @param event\n     */\n    scheduleEvent(event: MatrixScheduledEvent<any>): void;\n    /**\n     * Send an event to the matrix node\n     *\n     * @param scheduledEvent\n     */\n    sendEvent(scheduledEvent: MatrixScheduledEvent<any>): Promise<void>;\n    /**\n     * Check the cache when interacting with the Matrix node, if there is an already ongoing call for the specified key, return its promise instead of duplicating the call.\n     *\n     * @param key\n     * @param promiseProvider\n     */\n    private withCache;\n}\nexport {};\n"},{name:"@airgap/beacon-transport-matrix/matrix-client/services/MatrixRoomService.d.ts",dts:"import { MatrixHttpClient } from '../MatrixHttpClient';\nimport { MatrixRoom } from '../models/MatrixRoom';\nimport { MatrixRoomCreateRequest, MatrixRoomCreateResponse } from '../models/api/MatrixRoomCreate';\nimport { MatrixRoomInviteResponse } from '../models/api/MatrixRoomInvite';\nimport { MatrixRoomJoinResponse } from '../models/api/MatrixRoomJoin';\n/**\n * A service to help with matrix room management\n */\nexport declare class MatrixRoomService {\n    private readonly httpClient;\n    constructor(httpClient: MatrixHttpClient);\n    /**\n     * Create a room\n     *\n     * @param accessToken\n     * @param config\n     */\n    createRoom(accessToken: string, config?: MatrixRoomCreateRequest): Promise<MatrixRoomCreateResponse>;\n    /**\n     * Invite a user to a room\n     *\n     * @param accessToken\n     * @param user\n     * @param room\n     */\n    inviteToRoom(accessToken: string, user: string, room: MatrixRoom): Promise<MatrixRoomInviteResponse>;\n    /**\n     * Join a specific room\n     *\n     * @param accessToken\n     * @param room\n     */\n    joinRoom(accessToken: string, room: MatrixRoom): Promise<MatrixRoomJoinResponse>;\n    /**\n     * Get all joined rooms\n     *\n     * @param accessToken\n     */\n    getJoinedRooms(accessToken: string): Promise<MatrixRoomJoinResponse>;\n}\n"},{name:"@airgap/beacon-transport-matrix/matrix-client/services/MatrixUserService.d.ts",dts:"import { MatrixHttpClient } from '../MatrixHttpClient';\nimport { MatrixLoginResponse } from '../models/api/MatrixLogin';\nexport declare class MatrixUserService {\n    private readonly httpClient;\n    constructor(httpClient: MatrixHttpClient);\n    /**\n     * Log in to the matrix node with username and password\n     *\n     * @param user\n     * @param password\n     * @param deviceId\n     */\n    login(user: string, password: string, deviceId: string): Promise<MatrixLoginResponse>;\n}\n"},{name:"@airgap/beacon-transport-matrix/matrix-client/utils/events.d.ts",dts:"import { MatrixStateEvent, MatrixStateEventMessageText } from '../models/MatrixStateEvent';\n/**\n * Check if an event is a create event\n *\n * @param event MatrixStateEvent\n */\nexport declare const isCreateEvent: (event: MatrixStateEvent) => boolean;\n/**\n * Check if an event is a join event\n *\n * @param event MatrixStateEvent\n */\nexport declare const isJoinEvent: (event: MatrixStateEvent) => boolean;\n/**\n * Check if an event is a message event\n *\n * @param event MatrixStateEvent\n */\nexport declare const isMessageEvent: (event: MatrixStateEvent) => boolean;\n/**\n * Check if an event is a text message event\n *\n * @param event MatrixStateEvent\n */\nexport declare const isTextMessageEvent: (event: MatrixStateEvent) => event is MatrixStateEventMessageText;\n"},{name:"@airgap/beacon-transport-matrix/matrix-client/EventEmitter.d.ts",dts:"type Listener = (...args: any[]) => void;\nexport declare class EventEmitter {\n    private readonly events;\n    on(event: string, listener: Listener): () => void;\n    removeListener(event: string, listener?: Listener): void;\n    removeAllListeners(): void;\n    emit(event: string, ...args: any[]): void;\n    once(event: string, listener: Listener): () => void;\n}\nexport {};\n"},{name:"@airgap/beacon-transport-matrix/matrix-client/MatrixClient.d.ts",dts:"import { Storage } from '@airgap/beacon-types';\nimport { MatrixClientStore } from './MatrixClientStore';\nimport { MatrixHttpClient } from './MatrixHttpClient';\nimport { MatrixRoom } from './models/MatrixRoom';\nimport { MatrixRoomService } from './services/MatrixRoomService';\nimport { MatrixUserService } from './services/MatrixUserService';\nimport { MatrixEventService } from './services/MatrixEventService';\nimport { MatrixClientEventEmitter } from './MatrixClientEventEmitter';\nimport { MatrixClientEventType, MatrixClientEvent } from './models/MatrixClientEvent';\ninterface MatrixClientOptions {\n    baseUrl: string;\n    storage: Storage;\n}\ninterface MatrixLoginConfig {\n    id: string;\n    password: string;\n    deviceId: string;\n}\n/**\n * The matrix client used to connect to the matrix network\n */\nexport declare class MatrixClient {\n    private readonly store;\n    private readonly eventEmitter;\n    private readonly userService;\n    private readonly roomService;\n    private readonly eventService;\n    private readonly httpClient;\n    private isActive;\n    private _isReady;\n    constructor(store: MatrixClientStore, eventEmitter: MatrixClientEventEmitter, userService: MatrixUserService, roomService: MatrixRoomService, eventService: MatrixEventService, httpClient: MatrixHttpClient);\n    /**\n     * Create a matrix client based on the options provided\n     *\n     * @param config\n     */\n    static create(config: MatrixClientOptions): MatrixClient;\n    /**\n     * Return all the rooms we are currently part of\n     */\n    get joinedRooms(): Promise<MatrixRoom[]>;\n    /**\n     * Return all the rooms to which we have received invitations\n     */\n    get invitedRooms(): Promise<MatrixRoom[]>;\n    /**\n     * Return all the rooms that we left\n     */\n    get leftRooms(): Promise<MatrixRoom[]>;\n    /**\n     * Initiate the connection to the matrix node and log in\n     *\n     * @param user\n     */\n    start(user: MatrixLoginConfig): Promise<void>;\n    isConnected(): Promise<void>;\n    /**\n     * Stop all running requests\n     */\n    stop(): Promise<void>;\n    /**\n     * Subscribe to new matrix events\n     *\n     * @param event\n     * @param listener\n     */\n    subscribe<T extends MatrixClientEventType>(event: T, listener: (event: MatrixClientEvent<T>) => void): void;\n    /**\n     * Unsubscribe from matrix events\n     *\n     * @param event\n     * @param listener\n     */\n    unsubscribe(event: MatrixClientEventType, listener: (event: MatrixClientEvent<any>) => void): void;\n    /**\n     * Unsubscribe from all matrix events of this type\n     *\n     * @param event\n     * @param listener\n     */\n    unsubscribeAll(event: MatrixClientEventType): void;\n    getRoomById(id: string): Promise<MatrixRoom>;\n    /**\n     * Create a private room with the supplied members\n     *\n     * @param members Members that will be in the room\n     */\n    createTrustedPrivateRoom(...members: string[]): Promise<string>;\n    /**\n     * Invite user to rooms\n     *\n     * @param user The user to be invited\n     * @param roomsOrIds The rooms the user will be invited to\n     */\n    inviteToRooms(user: string, ...roomsOrIds: string[] | MatrixRoom[]): Promise<void>;\n    /**\n     * Join rooms\n     *\n     * @param roomsOrIds\n     */\n    joinRooms(...roomsOrIds: string[] | MatrixRoom[]): Promise<void>;\n    /**\n     * Send a text message\n     *\n     * @param roomOrId\n     * @param message\n     */\n    sendTextMessage(roomId: string, message: string): Promise<void>;\n    /**\n     * Poll the server to get the latest data and get notified of changes\n     *\n     * @param interval\n     * @param onSyncSuccess\n     * @param onSyncError\n     */\n    private poll;\n    /**\n     * Get state from server\n     */\n    private sync;\n    /**\n     * A helper method that makes sure an access token is provided\n     *\n     * @param name\n     * @param action\n     */\n    private requiresAuthorization;\n    /**\n     * Create a transaction ID\n     */\n    private createTxnId;\n}\nexport {};\n"},{name:"@airgap/beacon-transport-matrix/matrix-client/MatrixClientEventEmitter.d.ts",dts:"import { EventEmitter } from './EventEmitter';\nimport { MatrixStateStore, MatrixStateUpdate } from './MatrixClientStore';\nexport declare class MatrixClientEventEmitter extends EventEmitter {\n    private readonly eventEmitProviders;\n    /**\n     * This method is called every time the state is changed\n     *\n     * @param _oldState\n     * @param _newState\n     * @param stateChange\n     */\n    onStateChanged(_oldState: MatrixStateStore, _newState: MatrixStateStore, stateChange: Partial<MatrixStateUpdate>): void;\n    /**\n     * Emit the message if we have listeners registered for that type\n     *\n     * @param eventType\n     * @param object\n     */\n    private emitIfEvent;\n    /**\n     * Emit a client event\n     *\n     * @param eventType\n     * @param content\n     */\n    private emitClientEvent;\n    /**\n     * Check if event is an invite\n     *\n     * @param stateChange\n     */\n    private isInvite;\n    /**\n     * Emit an invite\n     *\n     * @param eventType\n     * @param stateChange\n     */\n    private emitInvite;\n    /**\n     * Check if event is a message\n     *\n     * @param stateChange\n     */\n    private isMessage;\n    /**\n     * Emit an event to all rooms\n     *\n     * @param eventType\n     * @param stateChange\n     */\n    private emitMessage;\n}\n"},{name:"@airgap/beacon-transport-matrix/matrix-client/MatrixClientStore.d.ts",dts:"import { MatrixRoom } from './models/MatrixRoom';\nimport { Storage } from '@airgap/beacon-types';\ntype OnStateChangedListener = (oldState: MatrixStateStore, newState: MatrixStateStore, stateChange: Partial<MatrixStateUpdate>) => void;\nexport interface MatrixState {\n    isRunning: boolean;\n    userId: string | undefined;\n    deviceId: string | undefined;\n    txnNo: number;\n    accessToken: string | undefined;\n    syncToken: string | undefined;\n    pollingTimeout: number | undefined;\n    pollingRetries: number;\n    rooms: MatrixRoom[] | Record<string, MatrixRoom>;\n}\nexport interface MatrixStateStore extends MatrixState {\n    rooms: Record<string, MatrixRoom>;\n}\nexport interface MatrixStateUpdate extends MatrixState {\n    rooms: MatrixRoom[];\n}\n/**\n * The class managing the local state of matrix\n */\nexport declare class MatrixClientStore {\n    private readonly storage;\n    /**\n     * The state of the matrix client\n     */\n    private state;\n    /**\n     * Listeners that will be called when the state changes\n     */\n    private readonly onStateChangedListeners;\n    /**\n     * A promise that resolves once the client is ready\n     */\n    private waitReadyPromise;\n    constructor(storage: Storage);\n    /**\n     * Get an item from the state\n     *\n     * @param key\n     */\n    get<T extends keyof MatrixStateStore>(key: T): MatrixStateStore[T];\n    /**\n     * Get the room from an ID or room instance\n     *\n     * @param roomOrId\n     */\n    getRoom(roomOrId: string | MatrixRoom): MatrixRoom;\n    /**\n     * Update the state with a partial state\n     *\n     * @param stateUpdate\n     */\n    update(stateUpdate: Partial<MatrixStateUpdate>): Promise<void>;\n    /**\n     * Register listeners that are called once the state has changed\n     *\n     * @param listener\n     * @param subscribed\n     */\n    onStateChanged(listener: OnStateChangedListener, ...subscribed: (keyof MatrixState)[]): void;\n    /**\n     * A promise that resolves once the client is ready\n     */\n    private waitReady;\n    /**\n     * Read state from storage\n     */\n    private initFromStorage;\n    /**\n     * Prepare data before persisting it in storage\n     *\n     * @param toStore\n     */\n    private prepareData;\n    /**\n     * Persist state in storage\n     *\n     * @param stateUpdate\n     */\n    private updateStorage;\n    /**\n     * Set the state\n     *\n     * @param partialState\n     */\n    private setState;\n    /**\n     * Merge room records and eliminate duplicates\n     *\n     * @param oldRooms\n     * @param _newRooms\n     */\n    private mergeRooms;\n    /**\n     * Notify listeners of state changes\n     *\n     * @param oldState\n     * @param newState\n     * @param stateChange\n     */\n    private notifyListeners;\n}\nexport {};\n"},{name:"@airgap/beacon-transport-matrix/matrix-client/MatrixHttpClient.d.ts",dts:"import { MatrixRequest, MatrixRequestParams } from './models/api/MatrixRequest';\ninterface HttpOptions {\n    accessToken?: string;\n}\n/**\n * Handling the HTTP connection to the matrix synapse node\n */\nexport declare class MatrixHttpClient {\n    private readonly baseUrl;\n    private readonly cancelTokenSource;\n    constructor(baseUrl: string);\n    /**\n     * Get data from the synapse node\n     *\n     * @param endpoint\n     * @param options\n     */\n    get<T>(endpoint: string, params?: MatrixRequestParams<T>, options?: HttpOptions): Promise<T>;\n    /**\n     * Post data to the synapse node\n     *\n     * @param endpoint\n     * @param body\n     * @param options\n     * @param params\n     */\n    post<T>(endpoint: string, body: MatrixRequest<T>, options?: HttpOptions, params?: MatrixRequestParams<T>): Promise<T>;\n    /**\n     * Put data to the synapse node\n     *\n     * @param endpoint\n     * @param body\n     * @param options\n     * @param params\n     */\n    put<T>(endpoint: string, body: MatrixRequest<T>, options?: HttpOptions, params?: MatrixRequestParams<T>): Promise<T>;\n    cancelAllRequests(): Promise<void>;\n    /**\n     * Send a request to the synapse node\n     *\n     * @param method\n     * @param endpoint\n     * @param config\n     * @param requestParams\n     * @param data\n     */\n    private send;\n    /**\n     * Get the headers based on the options object\n     *\n     * @param options\n     */\n    private getHeaders;\n    /**\n     * Get parameters\n     *\n     * @param _params\n     */\n    private getParams;\n    /**\n     * Construct API URL\n     */\n    private apiUrl;\n}\nexport {};\n"},{name:"@airgap/beacon-transport-matrix/P2PTransport.d.ts",dts:"import { Transport } from '@airgap/beacon-core';\nimport { ExtendedP2PPairingResponse, Storage, StorageKey, TransportType, P2PPairingRequest, NodeDistributions } from '@airgap/beacon-types';\nimport { P2PCommunicationClient } from '@airgap/beacon-transport-matrix';\nimport { KeyPair } from '@stablelib/ed25519';\n/**\n * @internalapi\n *\n *\n */\nexport declare class P2PTransport<T extends P2PPairingRequest | ExtendedP2PPairingResponse, K extends StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET> extends Transport<T, K, P2PCommunicationClient> {\n    readonly type: TransportType;\n    constructor(name: string, keyPair: KeyPair, storage: Storage, matrixNodes: NodeDistributions, storageKey: K, iconUrl?: string, appUrl?: string);\n    static isAvailable(): Promise<boolean>;\n    connect(): Promise<void>;\n    disconnect(): Promise<void>;\n    startOpenChannelListener(): Promise<void>;\n    getPairingRequestInfo(): Promise<P2PPairingRequest>;\n    listen(publicKey: string): Promise<void>;\n}\n"},{name:"@airgap/beacon-transport-matrix/index.d.ts",dts:"export { P2PCommunicationClient } from './communication-client/P2PCommunicationClient';\nexport { P2PTransport } from './P2PTransport';\n"},{name:"@airgap/beacon-transport-matrix/dist/esm/communication-client/P2PCommunicationClient.d.ts",dts:"import { MatrixClientEvent, MatrixClientEventType, MatrixClientEventMessageContent } from '../matrix-client/models/MatrixClientEvent';\nimport { Storage, P2PPairingRequest, ExtendedP2PPairingResponse, P2PPairingResponse, NodeDistributions } from '@airgap/beacon-types';\nimport { CommunicationClient } from '@airgap/beacon-core';\nimport { ExposedPromise } from '@airgap/beacon-utils';\nimport { KeyPair } from '@stablelib/ed25519';\ninterface BeaconInfoResponse {\n    region: string;\n    known_servers: string[];\n    timestamp: number;\n}\n/**\n * @internalapi\n */\nexport declare class P2PCommunicationClient extends CommunicationClient {\n    private readonly name;\n    readonly replicationCount: number;\n    private readonly storage;\n    private readonly iconUrl?;\n    private readonly appUrl?;\n    private client;\n    private initialEvent;\n    private initialListener;\n    private selectedRegion?;\n    private readonly ENABLED_RELAY_SERVERS;\n    relayServer: ExposedPromise<{\n        server: string;\n        timestamp: number;\n        localTimestamp: number;\n    }> | undefined;\n    private readonly activeListeners;\n    private readonly ignoredRooms;\n    private loginCounter;\n    constructor(name: string, keyPair: KeyPair, replicationCount: number, storage: Storage, matrixNodes?: NodeDistributions, iconUrl?: string | undefined, appUrl?: string | undefined);\n    getPairingRequestInfo(): Promise<P2PPairingRequest>;\n    getPairingResponseInfo(request: P2PPairingRequest): Promise<P2PPairingResponse>;\n    /**\n     * To get the fastest region, we can't simply do one request, because sometimes,\n     * DNS and SSL handshakes make \"faster\" connections slower. So we need to do 2 requests\n     * and check which request was the fastest after 1s.\n     */\n    findBestRegionAndGetServer(): Promise<{\n        server: string;\n        timestamp: number;\n    } | undefined>;\n    getRelayServer(): Promise<{\n        server: string;\n        timestamp: number;\n    }>;\n    getBeaconInfo(server: string): Promise<BeaconInfoResponse>;\n    tryJoinRooms(roomId: string, retry?: number): Promise<void>;\n    start(): Promise<void>;\n    stop(): Promise<void>;\n    reset(): Promise<void>;\n    listenForEncryptedMessage(senderPublicKey: string, messageCallback: (message: string) => void): Promise<void>;\n    unsubscribeFromEncryptedMessage(senderPublicKey: string): Promise<void>;\n    unsubscribeFromEncryptedMessages(): Promise<void>;\n    sendMessage(message: string, peer: P2PPairingRequest | ExtendedP2PPairingResponse): Promise<void>;\n    updatePeerRoom(sender: string, roomId: string): Promise<void>;\n    deleteRoomIdFromRooms(roomId: string): Promise<void>;\n    listenForChannelOpening(messageCallback: (pairingResponse: ExtendedP2PPairingResponse) => void): Promise<void>;\n    waitForJoin(roomId: string, retry?: number): Promise<void>;\n    sendPairingResponse(pairingRequest: P2PPairingRequest): Promise<void>;\n    isTextMessage(content: MatrixClientEventMessageContent<any>): content is MatrixClientEventMessageContent<string>;\n    updateRelayServer(sender: string): Promise<void>;\n    isChannelOpenMessage(content: MatrixClientEventMessageContent<string>): Promise<boolean>;\n    isSender(event: MatrixClientEvent<MatrixClientEventType.MESSAGE>, senderPublicKey: string): Promise<boolean>;\n    private generateNewKeyPair;\n    private getRelevantRoom;\n    private getRelevantJoinedRoom;\n}\nexport {};\n"},{name:"@airgap/beacon-transport-matrix/dist/esm/matrix-client/models/api/MatrixEventSend.d.ts",dts:"export interface MatrixEventSendRequest {\n    content: any;\n}\nexport interface MatrixEventSendResponse {\n    type?: 'event_send';\n    event_id: string;\n}\n"},{name:"@airgap/beacon-transport-matrix/dist/esm/matrix-client/models/api/MatrixLogin.d.ts",dts:"export interface MatrixLoginRequest {\n    type: 'm.login.password';\n    identifier: {\n        type: 'm.id.user';\n        user: string;\n    };\n    password: string;\n    device_id?: string;\n}\nexport interface MatrixLoginResponse {\n    type?: 'login';\n    user_id: string;\n    device_id: string;\n    access_token: string;\n}\n"},{name:"@airgap/beacon-transport-matrix/dist/esm/matrix-client/models/api/MatrixRequest.d.ts",dts:"import { MatrixLoginRequest, MatrixLoginResponse } from './MatrixLogin';\nimport { MatrixRoomCreateRequest, MatrixRoomCreateResponse } from './MatrixRoomCreate';\nimport { MatrixRoomInviteRequest, MatrixRoomInviteResponse } from './MatrixRoomInvite';\nimport { MatrixRoomJoinRequest, MatrixRoomJoinResponse } from './MatrixRoomJoin';\nimport { MatrixEventSendRequest, MatrixEventSendResponse } from './MatrixEventSend';\nimport { MatrixSyncResponse, MatrixSyncRequestParams } from './MatrixSync';\nexport type MatrixRequest<T> = T extends MatrixLoginResponse ? MatrixLoginRequest : T extends MatrixRoomCreateResponse ? MatrixRoomCreateRequest : T extends MatrixRoomInviteResponse ? MatrixRoomInviteRequest : T extends MatrixRoomJoinResponse ? MatrixRoomJoinRequest : T extends MatrixEventSendResponse ? MatrixEventSendRequest : never;\nexport type MatrixRequestParams<T> = T extends MatrixSyncResponse ? MatrixSyncRequestParams : never;\n"},{name:"@airgap/beacon-transport-matrix/dist/esm/matrix-client/models/api/MatrixRoomCreate.d.ts",dts:"export interface MatrixRoomCreateRequest {\n    room_version?: '5';\n    visibility?: 'public' | 'private';\n    room_alias_name?: string;\n    name?: string;\n    topic?: string;\n    invite?: string[];\n    preset?: 'private_chat' | 'public_chat' | 'trusted_private_chat';\n    is_direct?: boolean;\n}\nexport interface MatrixRoomCreateResponse {\n    type?: 'room_create';\n    room_id: string;\n}\n"},{name:"@airgap/beacon-transport-matrix/dist/esm/matrix-client/models/api/MatrixRoomInvite.d.ts",dts:"export interface MatrixRoomInviteRequest {\n    user_id: string;\n}\nexport interface MatrixRoomInviteResponse {\n    type?: 'room_invite';\n}\n"},{name:"@airgap/beacon-transport-matrix/dist/esm/matrix-client/models/api/MatrixRoomJoin.d.ts",dts:"export interface MatrixRoomJoinRequest {\n}\nexport interface MatrixRoomJoinResponse {\n    type?: 'room_join';\n    room_id: string;\n}\n"},{name:"@airgap/beacon-transport-matrix/dist/esm/matrix-client/models/api/MatrixSync.d.ts",dts:"import { MatrixStateEvent } from '../MatrixStateEvent';\nexport interface MatrixSyncJoinedRoom {\n    state: {\n        events: MatrixStateEvent[];\n    };\n    timeline: {\n        events: MatrixStateEvent[];\n    };\n}\nexport interface MatrixSyncInvitedRoom {\n    invite_state: {\n        events: MatrixStateEvent[];\n    };\n}\nexport interface MatrixSyncLeftRoom {\n    state: {\n        events: MatrixStateEvent[];\n    };\n    timeline: {\n        events: MatrixStateEvent[];\n    };\n}\nexport interface MatrixSyncRooms {\n    join?: {\n        [key: string]: MatrixSyncJoinedRoom;\n    };\n    invite?: {\n        [key: string]: MatrixSyncInvitedRoom;\n    };\n    leave?: {\n        [key: string]: MatrixSyncLeftRoom;\n    };\n}\nexport interface MatrixSyncRequestParams {\n    timeout?: number;\n    since?: string;\n}\nexport interface MatrixSyncResponse {\n    type?: 'sync';\n    next_batch: string;\n    rooms?: MatrixSyncRooms;\n}\n"},{name:"@airgap/beacon-transport-matrix/dist/esm/matrix-client/models/MatrixClientEvent.d.ts",dts:'import { MatrixMessage } from \'./MatrixMessage\';\nexport declare enum MatrixClientEventType {\n    INVITE = "invite",\n    MESSAGE = "message"\n}\nexport type MatrixClientEventContent<T> = T extends MatrixClientEventType.INVITE ? MatrixClientEventInviteContent : T extends MatrixClientEventType.MESSAGE ? MatrixClientEventMessageContent<unknown> : never;\nexport interface MatrixClientEventInviteContent {\n    roomId: string;\n    members: string[];\n}\nexport interface MatrixClientEventMessageContent<T> {\n    roomId: string;\n    message: MatrixMessage<T>;\n}\nexport interface MatrixClientEvent<T extends MatrixClientEventType> {\n    type: T;\n    content: MatrixClientEventContent<T>;\n    timestamp?: number;\n}\n'},{name:"@airgap/beacon-transport-matrix/dist/esm/matrix-client/models/MatrixMessage.d.ts",dts:"import { MatrixStateEvent } from './MatrixStateEvent';\nexport declare enum MatrixMessageType {\n    TEXT = \"m.text\"\n}\nexport declare class MatrixMessage<T> {\n    readonly type: MatrixMessageType;\n    readonly sender: string;\n    readonly content: T;\n    readonly timestamp: number;\n    /**\n     * Construct a message from a message event\n     *\n     * @param event\n     */\n    static from(event: MatrixStateEvent): MatrixMessage<unknown> | undefined;\n    private constructor();\n}\n"},{name:"@airgap/beacon-transport-matrix/dist/esm/matrix-client/models/MatrixRoom.d.ts",dts:"import { MatrixSyncRooms } from './api/MatrixSync';\nimport { MatrixMessage } from './MatrixMessage';\nexport declare enum MatrixRoomStatus {\n    UNKNOWN = 0,\n    JOINED = 1,\n    INVITED = 2,\n    LEFT = 3\n}\nexport declare class MatrixRoom {\n    readonly id: string;\n    readonly status: MatrixRoomStatus;\n    readonly members: string[];\n    messages: MatrixMessage<any>[];\n    /**\n     * Reconstruct rooms from a sync response\n     *\n     * @param roomSync\n     */\n    static fromSync(roomSync?: MatrixSyncRooms): MatrixRoom[];\n    /**\n     * Reconstruct a room from an ID or object\n     *\n     * @param roomOrId\n     * @param status\n     */\n    static from(roomOrId: string | MatrixRoom, status?: MatrixRoomStatus): MatrixRoom;\n    /**\n     * Merge new and old state and remove duplicates\n     *\n     * @param newState\n     * @param previousState\n     */\n    static merge(newState: MatrixRoom, previousState?: MatrixRoom): MatrixRoom;\n    /**\n     * Create a room from a join\n     *\n     * @param id\n     * @param joined\n     */\n    private static fromJoined;\n    /**\n     * Create a room from an invite\n     *\n     * @param id\n     * @param invited\n     */\n    private static fromInvited;\n    /**\n     * Create a room from a leave\n     *\n     * @param id\n     * @param left\n     */\n    private static fromLeft;\n    /**\n     * Extract members from an event\n     *\n     * @param events\n     */\n    private static getMembersFromEvents;\n    /**\n     * Extract messages from an event\n     *\n     * @param events\n     */\n    private static getMessagesFromEvents;\n    /**\n     * Get unique events and remove duplicates\n     *\n     * @param events\n     */\n    private static getUniqueEvents;\n    private constructor();\n}\n"},{name:"@airgap/beacon-transport-matrix/dist/esm/matrix-client/models/MatrixStateEvent.d.ts",dts:"import { MatrixMessageType } from './MatrixMessage';\nexport interface MatrixStateEventMessageText extends MatrixStateEventMessage {\n    type: 'm.room.message';\n    content: {\n        msgtype: MatrixMessageType.TEXT;\n        body: string;\n    };\n}\nexport interface MatrixStateEventMessageContent {\n    msgtype: string;\n    body: any;\n    [key: string]: any;\n}\nexport interface MatrixStateEventMessage extends MatrixStateEvent {\n    type: 'm.room.message';\n    content: MatrixStateEventMessageContent;\n}\nexport interface MatrixStateEvent {\n    type: string;\n    sender: string;\n    content: unknown;\n    event_id?: string;\n    origin_server_ts: number;\n}\n"},{name:"@airgap/beacon-transport-matrix/dist/esm/matrix-client/services/MatrixEventService.d.ts",dts:"import { MatrixHttpClient } from '../MatrixHttpClient';\nimport { MatrixEventSendResponse } from '../models/api/MatrixEventSend';\nimport { MatrixSyncResponse } from '../models/api/MatrixSync';\nimport { MatrixStateEventMessageContent } from '../models/MatrixStateEvent';\ninterface MatrixScheduledEvent<T> {\n    accessToken: string;\n    roomId: string;\n    type: MatrixEventType;\n    content: any;\n    txnId: string;\n    onSuccess(response: T): void;\n    onError(error: unknown): void;\n}\ntype MatrixEventType = 'm.room.message';\nexport interface MatrixSyncOptions {\n    syncToken?: string;\n    pollingTimeout?: number;\n}\n/**\n * A service to help with matrix event management\n */\nexport declare class MatrixEventService {\n    private readonly httpClient;\n    private readonly cachedPromises;\n    constructor(httpClient: MatrixHttpClient);\n    /**\n     * Get the latest state from the matrix node\n     *\n     * @param accessToken\n     * @param options\n     */\n    sync(accessToken: string, options?: MatrixSyncOptions): Promise<MatrixSyncResponse>;\n    /**\n     * Send a message to a room\n     *\n     * @param accessToken\n     * @param room\n     * @param content\n     * @param txnId\n     */\n    sendMessage(accessToken: string, roomId: string, content: MatrixStateEventMessageContent, txnId: string): Promise<MatrixEventSendResponse>;\n    /**\n     * Schedules an event to be sent to the node\n     *\n     * @param event\n     */\n    scheduleEvent(event: MatrixScheduledEvent<any>): void;\n    /**\n     * Send an event to the matrix node\n     *\n     * @param scheduledEvent\n     */\n    sendEvent(scheduledEvent: MatrixScheduledEvent<any>): Promise<void>;\n    /**\n     * Check the cache when interacting with the Matrix node, if there is an already ongoing call for the specified key, return its promise instead of duplicating the call.\n     *\n     * @param key\n     * @param promiseProvider\n     */\n    private withCache;\n}\nexport {};\n"},{name:"@airgap/beacon-transport-matrix/dist/esm/matrix-client/services/MatrixRoomService.d.ts",dts:"import { MatrixHttpClient } from '../MatrixHttpClient';\nimport { MatrixRoom } from '../models/MatrixRoom';\nimport { MatrixRoomCreateRequest, MatrixRoomCreateResponse } from '../models/api/MatrixRoomCreate';\nimport { MatrixRoomInviteResponse } from '../models/api/MatrixRoomInvite';\nimport { MatrixRoomJoinResponse } from '../models/api/MatrixRoomJoin';\n/**\n * A service to help with matrix room management\n */\nexport declare class MatrixRoomService {\n    private readonly httpClient;\n    constructor(httpClient: MatrixHttpClient);\n    /**\n     * Create a room\n     *\n     * @param accessToken\n     * @param config\n     */\n    createRoom(accessToken: string, config?: MatrixRoomCreateRequest): Promise<MatrixRoomCreateResponse>;\n    /**\n     * Invite a user to a room\n     *\n     * @param accessToken\n     * @param user\n     * @param room\n     */\n    inviteToRoom(accessToken: string, user: string, room: MatrixRoom): Promise<MatrixRoomInviteResponse>;\n    /**\n     * Join a specific room\n     *\n     * @param accessToken\n     * @param room\n     */\n    joinRoom(accessToken: string, room: MatrixRoom): Promise<MatrixRoomJoinResponse>;\n    /**\n     * Get all joined rooms\n     *\n     * @param accessToken\n     */\n    getJoinedRooms(accessToken: string): Promise<MatrixRoomJoinResponse>;\n}\n"},{name:"@airgap/beacon-transport-matrix/dist/esm/matrix-client/services/MatrixUserService.d.ts",dts:"import { MatrixHttpClient } from '../MatrixHttpClient';\nimport { MatrixLoginResponse } from '../models/api/MatrixLogin';\nexport declare class MatrixUserService {\n    private readonly httpClient;\n    constructor(httpClient: MatrixHttpClient);\n    /**\n     * Log in to the matrix node with username and password\n     *\n     * @param user\n     * @param password\n     * @param deviceId\n     */\n    login(user: string, password: string, deviceId: string): Promise<MatrixLoginResponse>;\n}\n"},{name:"@airgap/beacon-transport-matrix/dist/esm/matrix-client/utils/events.d.ts",dts:"import { MatrixStateEvent, MatrixStateEventMessageText } from '../models/MatrixStateEvent';\n/**\n * Check if an event is a create event\n *\n * @param event MatrixStateEvent\n */\nexport declare const isCreateEvent: (event: MatrixStateEvent) => boolean;\n/**\n * Check if an event is a join event\n *\n * @param event MatrixStateEvent\n */\nexport declare const isJoinEvent: (event: MatrixStateEvent) => boolean;\n/**\n * Check if an event is a message event\n *\n * @param event MatrixStateEvent\n */\nexport declare const isMessageEvent: (event: MatrixStateEvent) => boolean;\n/**\n * Check if an event is a text message event\n *\n * @param event MatrixStateEvent\n */\nexport declare const isTextMessageEvent: (event: MatrixStateEvent) => event is MatrixStateEventMessageText;\n"},{name:"@airgap/beacon-transport-matrix/dist/esm/matrix-client/EventEmitter.d.ts",dts:"type Listener = (...args: any[]) => void;\nexport declare class EventEmitter {\n    private readonly events;\n    on(event: string, listener: Listener): () => void;\n    removeListener(event: string, listener?: Listener): void;\n    removeAllListeners(): void;\n    emit(event: string, ...args: any[]): void;\n    once(event: string, listener: Listener): () => void;\n}\nexport {};\n"},{name:"@airgap/beacon-transport-matrix/dist/esm/matrix-client/MatrixClient.d.ts",dts:"import { Storage } from '@airgap/beacon-types';\nimport { MatrixClientStore } from './MatrixClientStore';\nimport { MatrixHttpClient } from './MatrixHttpClient';\nimport { MatrixRoom } from './models/MatrixRoom';\nimport { MatrixRoomService } from './services/MatrixRoomService';\nimport { MatrixUserService } from './services/MatrixUserService';\nimport { MatrixEventService } from './services/MatrixEventService';\nimport { MatrixClientEventEmitter } from './MatrixClientEventEmitter';\nimport { MatrixClientEventType, MatrixClientEvent } from './models/MatrixClientEvent';\ninterface MatrixClientOptions {\n    baseUrl: string;\n    storage: Storage;\n}\ninterface MatrixLoginConfig {\n    id: string;\n    password: string;\n    deviceId: string;\n}\n/**\n * The matrix client used to connect to the matrix network\n */\nexport declare class MatrixClient {\n    private readonly store;\n    private readonly eventEmitter;\n    private readonly userService;\n    private readonly roomService;\n    private readonly eventService;\n    private readonly httpClient;\n    private isActive;\n    private _isReady;\n    constructor(store: MatrixClientStore, eventEmitter: MatrixClientEventEmitter, userService: MatrixUserService, roomService: MatrixRoomService, eventService: MatrixEventService, httpClient: MatrixHttpClient);\n    /**\n     * Create a matrix client based on the options provided\n     *\n     * @param config\n     */\n    static create(config: MatrixClientOptions): MatrixClient;\n    /**\n     * Return all the rooms we are currently part of\n     */\n    get joinedRooms(): Promise<MatrixRoom[]>;\n    /**\n     * Return all the rooms to which we have received invitations\n     */\n    get invitedRooms(): Promise<MatrixRoom[]>;\n    /**\n     * Return all the rooms that we left\n     */\n    get leftRooms(): Promise<MatrixRoom[]>;\n    /**\n     * Initiate the connection to the matrix node and log in\n     *\n     * @param user\n     */\n    start(user: MatrixLoginConfig): Promise<void>;\n    isConnected(): Promise<void>;\n    /**\n     * Stop all running requests\n     */\n    stop(): Promise<void>;\n    /**\n     * Subscribe to new matrix events\n     *\n     * @param event\n     * @param listener\n     */\n    subscribe<T extends MatrixClientEventType>(event: T, listener: (event: MatrixClientEvent<T>) => void): void;\n    /**\n     * Unsubscribe from matrix events\n     *\n     * @param event\n     * @param listener\n     */\n    unsubscribe(event: MatrixClientEventType, listener: (event: MatrixClientEvent<any>) => void): void;\n    /**\n     * Unsubscribe from all matrix events of this type\n     *\n     * @param event\n     * @param listener\n     */\n    unsubscribeAll(event: MatrixClientEventType): void;\n    getRoomById(id: string): Promise<MatrixRoom>;\n    /**\n     * Create a private room with the supplied members\n     *\n     * @param members Members that will be in the room\n     */\n    createTrustedPrivateRoom(...members: string[]): Promise<string>;\n    /**\n     * Invite user to rooms\n     *\n     * @param user The user to be invited\n     * @param roomsOrIds The rooms the user will be invited to\n     */\n    inviteToRooms(user: string, ...roomsOrIds: string[] | MatrixRoom[]): Promise<void>;\n    /**\n     * Join rooms\n     *\n     * @param roomsOrIds\n     */\n    joinRooms(...roomsOrIds: string[] | MatrixRoom[]): Promise<void>;\n    /**\n     * Send a text message\n     *\n     * @param roomOrId\n     * @param message\n     */\n    sendTextMessage(roomId: string, message: string): Promise<void>;\n    /**\n     * Poll the server to get the latest data and get notified of changes\n     *\n     * @param interval\n     * @param onSyncSuccess\n     * @param onSyncError\n     */\n    private poll;\n    /**\n     * Get state from server\n     */\n    private sync;\n    /**\n     * A helper method that makes sure an access token is provided\n     *\n     * @param name\n     * @param action\n     */\n    private requiresAuthorization;\n    /**\n     * Create a transaction ID\n     */\n    private createTxnId;\n}\nexport {};\n"},{name:"@airgap/beacon-transport-matrix/dist/esm/matrix-client/MatrixClientEventEmitter.d.ts",dts:"import { EventEmitter } from './EventEmitter';\nimport { MatrixStateStore, MatrixStateUpdate } from './MatrixClientStore';\nexport declare class MatrixClientEventEmitter extends EventEmitter {\n    private readonly eventEmitProviders;\n    /**\n     * This method is called every time the state is changed\n     *\n     * @param _oldState\n     * @param _newState\n     * @param stateChange\n     */\n    onStateChanged(_oldState: MatrixStateStore, _newState: MatrixStateStore, stateChange: Partial<MatrixStateUpdate>): void;\n    /**\n     * Emit the message if we have listeners registered for that type\n     *\n     * @param eventType\n     * @param object\n     */\n    private emitIfEvent;\n    /**\n     * Emit a client event\n     *\n     * @param eventType\n     * @param content\n     */\n    private emitClientEvent;\n    /**\n     * Check if event is an invite\n     *\n     * @param stateChange\n     */\n    private isInvite;\n    /**\n     * Emit an invite\n     *\n     * @param eventType\n     * @param stateChange\n     */\n    private emitInvite;\n    /**\n     * Check if event is a message\n     *\n     * @param stateChange\n     */\n    private isMessage;\n    /**\n     * Emit an event to all rooms\n     *\n     * @param eventType\n     * @param stateChange\n     */\n    private emitMessage;\n}\n"},{name:"@airgap/beacon-transport-matrix/dist/esm/matrix-client/MatrixClientStore.d.ts",dts:"import { MatrixRoom } from './models/MatrixRoom';\nimport { Storage } from '@airgap/beacon-types';\ntype OnStateChangedListener = (oldState: MatrixStateStore, newState: MatrixStateStore, stateChange: Partial<MatrixStateUpdate>) => void;\nexport interface MatrixState {\n    isRunning: boolean;\n    userId: string | undefined;\n    deviceId: string | undefined;\n    txnNo: number;\n    accessToken: string | undefined;\n    syncToken: string | undefined;\n    pollingTimeout: number | undefined;\n    pollingRetries: number;\n    rooms: MatrixRoom[] | Record<string, MatrixRoom>;\n}\nexport interface MatrixStateStore extends MatrixState {\n    rooms: Record<string, MatrixRoom>;\n}\nexport interface MatrixStateUpdate extends MatrixState {\n    rooms: MatrixRoom[];\n}\n/**\n * The class managing the local state of matrix\n */\nexport declare class MatrixClientStore {\n    private readonly storage;\n    /**\n     * The state of the matrix client\n     */\n    private state;\n    /**\n     * Listeners that will be called when the state changes\n     */\n    private readonly onStateChangedListeners;\n    /**\n     * A promise that resolves once the client is ready\n     */\n    private waitReadyPromise;\n    constructor(storage: Storage);\n    /**\n     * Get an item from the state\n     *\n     * @param key\n     */\n    get<T extends keyof MatrixStateStore>(key: T): MatrixStateStore[T];\n    /**\n     * Get the room from an ID or room instance\n     *\n     * @param roomOrId\n     */\n    getRoom(roomOrId: string | MatrixRoom): MatrixRoom;\n    /**\n     * Update the state with a partial state\n     *\n     * @param stateUpdate\n     */\n    update(stateUpdate: Partial<MatrixStateUpdate>): Promise<void>;\n    /**\n     * Register listeners that are called once the state has changed\n     *\n     * @param listener\n     * @param subscribed\n     */\n    onStateChanged(listener: OnStateChangedListener, ...subscribed: (keyof MatrixState)[]): void;\n    /**\n     * A promise that resolves once the client is ready\n     */\n    private waitReady;\n    /**\n     * Read state from storage\n     */\n    private initFromStorage;\n    /**\n     * Prepare data before persisting it in storage\n     *\n     * @param toStore\n     */\n    private prepareData;\n    /**\n     * Persist state in storage\n     *\n     * @param stateUpdate\n     */\n    private updateStorage;\n    /**\n     * Set the state\n     *\n     * @param partialState\n     */\n    private setState;\n    /**\n     * Merge room records and eliminate duplicates\n     *\n     * @param oldRooms\n     * @param _newRooms\n     */\n    private mergeRooms;\n    /**\n     * Notify listeners of state changes\n     *\n     * @param oldState\n     * @param newState\n     * @param stateChange\n     */\n    private notifyListeners;\n}\nexport {};\n"},{name:"@airgap/beacon-transport-matrix/dist/esm/matrix-client/MatrixHttpClient.d.ts",dts:"import { MatrixRequest, MatrixRequestParams } from './models/api/MatrixRequest';\ninterface HttpOptions {\n    accessToken?: string;\n}\n/**\n * Handling the HTTP connection to the matrix synapse node\n */\nexport declare class MatrixHttpClient {\n    private readonly baseUrl;\n    private readonly cancelTokenSource;\n    constructor(baseUrl: string);\n    /**\n     * Get data from the synapse node\n     *\n     * @param endpoint\n     * @param options\n     */\n    get<T>(endpoint: string, params?: MatrixRequestParams<T>, options?: HttpOptions): Promise<T>;\n    /**\n     * Post data to the synapse node\n     *\n     * @param endpoint\n     * @param body\n     * @param options\n     * @param params\n     */\n    post<T>(endpoint: string, body: MatrixRequest<T>, options?: HttpOptions, params?: MatrixRequestParams<T>): Promise<T>;\n    /**\n     * Put data to the synapse node\n     *\n     * @param endpoint\n     * @param body\n     * @param options\n     * @param params\n     */\n    put<T>(endpoint: string, body: MatrixRequest<T>, options?: HttpOptions, params?: MatrixRequestParams<T>): Promise<T>;\n    cancelAllRequests(): Promise<void>;\n    /**\n     * Send a request to the synapse node\n     *\n     * @param method\n     * @param endpoint\n     * @param config\n     * @param requestParams\n     * @param data\n     */\n    private send;\n    /**\n     * Get the headers based on the options object\n     *\n     * @param options\n     */\n    private getHeaders;\n    /**\n     * Get parameters\n     *\n     * @param _params\n     */\n    private getParams;\n    /**\n     * Construct API URL\n     */\n    private apiUrl;\n}\nexport {};\n"},{name:"@airgap/beacon-transport-matrix/dist/esm/P2PTransport.d.ts",dts:"import { Transport } from '@airgap/beacon-core';\nimport { ExtendedP2PPairingResponse, Storage, StorageKey, TransportType, P2PPairingRequest, NodeDistributions } from '@airgap/beacon-types';\nimport { P2PCommunicationClient } from '@airgap/beacon-transport-matrix';\nimport { KeyPair } from '@stablelib/ed25519';\n/**\n * @internalapi\n *\n *\n */\nexport declare class P2PTransport<T extends P2PPairingRequest | ExtendedP2PPairingResponse, K extends StorageKey.TRANSPORT_P2P_PEERS_DAPP | StorageKey.TRANSPORT_P2P_PEERS_WALLET> extends Transport<T, K, P2PCommunicationClient> {\n    readonly type: TransportType;\n    constructor(name: string, keyPair: KeyPair, storage: Storage, matrixNodes: NodeDistributions, storageKey: K, iconUrl?: string, appUrl?: string);\n    static isAvailable(): Promise<boolean>;\n    connect(): Promise<void>;\n    disconnect(): Promise<void>;\n    startOpenChannelListener(): Promise<void>;\n    getPairingRequestInfo(): Promise<P2PPairingRequest>;\n    listen(publicKey: string): Promise<void>;\n}\n"},{name:"@airgap/beacon-transport-matrix/dist/esm/index.d.ts",dts:"export { P2PCommunicationClient } from './communication-client/P2PCommunicationClient';\nexport { P2PTransport } from './P2PTransport';\n"},{name:"@airgap/beacon-transport-postmessage/PostMessageClient.d.ts",dts:"import { MessageBasedClient } from '@airgap/beacon-core';\nimport { ConnectionContext, ExtendedPostMessagePairingResponse, EncryptedExtensionMessage, PostMessagePairingRequest } from '@airgap/beacon-types';\n/**\n * @internalapi\n *\n *\n */\nexport declare class PostMessageClient extends MessageBasedClient {\n    protected readonly activeListeners: Map<string, (message: EncryptedExtensionMessage, context: ConnectionContext) => void>;\n    init(): Promise<void>;\n    listenForEncryptedMessage(senderPublicKey: string, messageCallback: (message: string, context: ConnectionContext) => void): Promise<void>;\n    sendMessage(message: string, peer: PostMessagePairingRequest | ExtendedPostMessagePairingResponse): Promise<void>;\n    listenForChannelOpening(messageCallback: (pairingResponse: ExtendedPostMessagePairingResponse) => void): Promise<void>;\n    sendPairingRequest(id: string): Promise<void>;\n    isChannelOpenMessage(message: any): Promise<boolean>;\n    private subscribeToMessages;\n}\n"},{name:"@airgap/beacon-transport-postmessage/PostMessageTransport.d.ts",dts:"import { PostMessagePairingRequest, ExtendedPostMessagePairingResponse, Extension, StorageKey, TransportType } from '@airgap/beacon-types';\nimport { Storage } from '@airgap/beacon-types';\nimport { Transport } from '@airgap/beacon-core';\nimport { PostMessageClient } from './PostMessageClient';\nimport { KeyPair } from '@stablelib/ed25519';\n/**\n * @internalapi\n *\n *\n */\nexport declare class PostMessageTransport<T extends PostMessagePairingRequest | ExtendedPostMessagePairingResponse, K extends StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET> extends Transport<T, K, PostMessageClient> {\n    readonly type: TransportType;\n    constructor(name: string, keyPair: KeyPair, storage: Storage, storageKey: K);\n    static isAvailable(): Promise<boolean>;\n    static getAvailableExtensions(): Promise<Extension[]>;\n    private static listenForExtensions;\n    connect(): Promise<void>;\n    startOpenChannelListener(): Promise<void>;\n    getPairingRequestInfo(): Promise<PostMessagePairingRequest>;\n    listen(publicKey: string): Promise<void>;\n}\n"},{name:"@airgap/beacon-transport-postmessage/index.d.ts",dts:"export { PostMessageTransport } from './PostMessageTransport';\n"},{name:"@airgap/beacon-transport-postmessage/dist/esm/PostMessageClient.d.ts",dts:"import { MessageBasedClient } from '@airgap/beacon-core';\nimport { ConnectionContext, ExtendedPostMessagePairingResponse, EncryptedExtensionMessage, PostMessagePairingRequest } from '@airgap/beacon-types';\n/**\n * @internalapi\n *\n *\n */\nexport declare class PostMessageClient extends MessageBasedClient {\n    protected readonly activeListeners: Map<string, (message: EncryptedExtensionMessage, context: ConnectionContext) => void>;\n    init(): Promise<void>;\n    listenForEncryptedMessage(senderPublicKey: string, messageCallback: (message: string, context: ConnectionContext) => void): Promise<void>;\n    sendMessage(message: string, peer: PostMessagePairingRequest | ExtendedPostMessagePairingResponse): Promise<void>;\n    listenForChannelOpening(messageCallback: (pairingResponse: ExtendedPostMessagePairingResponse) => void): Promise<void>;\n    sendPairingRequest(id: string): Promise<void>;\n    isChannelOpenMessage(message: any): Promise<boolean>;\n    private subscribeToMessages;\n}\n"},{name:"@airgap/beacon-transport-postmessage/dist/esm/PostMessageTransport.d.ts",dts:"import { PostMessagePairingRequest, ExtendedPostMessagePairingResponse, Extension, StorageKey, TransportType } from '@airgap/beacon-types';\nimport { Storage } from '@airgap/beacon-types';\nimport { Transport } from '@airgap/beacon-core';\nimport { PostMessageClient } from './PostMessageClient';\nimport { KeyPair } from '@stablelib/ed25519';\n/**\n * @internalapi\n *\n *\n */\nexport declare class PostMessageTransport<T extends PostMessagePairingRequest | ExtendedPostMessagePairingResponse, K extends StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP | StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET> extends Transport<T, K, PostMessageClient> {\n    readonly type: TransportType;\n    constructor(name: string, keyPair: KeyPair, storage: Storage, storageKey: K);\n    static isAvailable(): Promise<boolean>;\n    static getAvailableExtensions(): Promise<Extension[]>;\n    private static listenForExtensions;\n    connect(): Promise<void>;\n    startOpenChannelListener(): Promise<void>;\n    getPairingRequestInfo(): Promise<PostMessagePairingRequest>;\n    listen(publicKey: string): Promise<void>;\n}\n"},{name:"@airgap/beacon-transport-postmessage/dist/esm/index.d.ts",dts:"export { PostMessageTransport } from './PostMessageTransport';\n"},{name:"@airgap/beacon-transport-walletconnect/communication-client/WalletConnectCommunicationClient.d.ts",dts:'import { CommunicationClient, WCStorage } from \'@airgap/beacon-core\';\nimport Client from \'@walletconnect/sign-client\';\nimport { SessionTypes, SignClientTypes } from \'@walletconnect/types\';\nimport { ExtendedWalletConnectPairingRequest, ExtendedWalletConnectPairingResponse, NetworkType, OperationRequest, PermissionRequest, SignPayloadRequest } from \'@airgap/beacon-types\';\nexport interface PermissionScopeParam {\n    networks: NetworkType[];\n    methods: PermissionScopeMethods[];\n    events?: PermissionScopeEvents[];\n}\nexport declare enum PermissionScopeMethods {\n    GET_ACCOUNTS = "tezos_getAccounts",\n    OPERATION_REQUEST = "tezos_send",\n    SIGN = "tezos_sign"\n}\nexport declare enum PermissionScopeEvents {\n    CHAIN_CHANGED = "chainChanged",\n    ACCOUNTS_CHANGED = "accountsChanged",\n    REQUEST_ACKNOWLEDGED = "requestAcknowledged"\n}\nexport declare class WalletConnectCommunicationClient extends CommunicationClient {\n    private wcOptions;\n    private isLeader;\n    protected readonly activeListeners: Map<string, (message: string) => void>;\n    protected readonly channelOpeningListeners: Map<string, (pairingResponse: ExtendedWalletConnectPairingResponse) => void>;\n    private static instance;\n    signClient: Client | undefined;\n    storage: WCStorage;\n    private session;\n    private activeAccountOrPbk;\n    private activeNetwork;\n    readonly disconnectionEvents: Set<string>;\n    private pingInterval;\n    /**\n     * this queue stores each active message id\n     * [0] newest message\n     * [length - 1] oldest message\n     */\n    private messageIds;\n    /**\n     * Tracks the last time session extension was attempted (Unix timestamp in seconds)\n     * Used to prevent duplicate re-extension attempts that can cause relay conflicts\n     */\n    private lastExtensionAttempt;\n    constructor(wcOptions: {\n        network: NetworkType;\n        opts: SignClientTypes.Options;\n    }, isLeader: Function);\n    static getInstance(wcOptions: {\n        network: NetworkType;\n        opts: SignClientTypes.Options;\n    }, isLeader: Function): WalletConnectCommunicationClient;\n    private getTopicFromSession;\n    listenForEncryptedMessage(senderPublicKey: string, messageCallback: (message: string) => void): Promise<void>;\n    listenForChannelOpening(messageCallback: (pairingResponse: ExtendedWalletConnectPairingResponse) => void): Promise<void>;\n    /**\n     * WC Sign client doesn\'t sync between intances, meaning that a dApp signClient instance state may\n     * differ from a wallet state\n     */\n    private refreshState;\n    private clearEvents;\n    private onStorageMessageHandler;\n    private onStorageErrorHandler;\n    unsubscribeFromEncryptedMessages(): Promise<void>;\n    unsubscribeFromEncryptedMessage(_senderPublicKey: string): Promise<void>;\n    closeSignClient(): Promise<void>;\n    private ping;\n    private checkWalletReadiness;\n    sendMessage(_message: string, _peer?: any): Promise<void>;\n    private fetchAccounts;\n    private notifyListenersWithPermissionResponse;\n    requestPermissions(message: PermissionRequest): Promise<void>;\n    /**\n     * @description Once the session is establish, send payload to be approved and signed by the wallet.\n     * @error MissingRequiredScope is thrown if permission to sign payload was not granted\n     */\n    signPayload(signPayloadRequest: SignPayloadRequest): Promise<void>;\n    /**\n     * @description Once the session is established, send Tezos operations to be approved, signed and inject by the wallet.\n     * @error MissingRequiredScope is thrown if permission to send operation was not granted\n     */\n    sendOperations(operationRequest: OperationRequest): Promise<void>;\n    private isMobileSesion;\n    /**\n     * Function used to fix appSwitching with web wallets when pairing through \'Other wallet flow\'\n     * @param session the newly created session\n     */\n    private updateStorageWallet;\n    init(forceNewConnection?: boolean): Promise<{\n        uri: string;\n        topic: string;\n    } | undefined>;\n    close(): Promise<void>;\n    private subscribeToSessionEvents;\n    private acknowledgeRequest;\n    private updateActiveAccount;\n    private disconnect;\n    private onSessionClosed;\n    getPairingRequestInfo(): Promise<ExtendedWalletConnectPairingRequest>;\n    private closePairings;\n    private closeSessions;\n    private openSession;\n    private permissionScopeParamsToNamespaces;\n    private validateReceivedNamespace;\n    private validateMethods;\n    private validateEvents;\n    private validateAccounts;\n    closeActiveSession(account: string, notify?: boolean): Promise<void>;\n    private validateNetworkAndAccount;\n    /**\n     * @description Access the active network\n     * @error ActiveNetworkUnspecified thorwn when there are multiple Tezos networks in the session and none is set as the active one\n     */\n    getActiveNetwork(): string;\n    private setDefaultAccountAndNetwork;\n    /**\n     * @description Return all connected accounts from the active session\n     * @error NotConnected if no active session\n     */\n    getAccounts(): string[];\n    /**\n     * @description Return all networks from the namespace of the active session\n     * @error NotConnected if no active session\n     */\n    getNetworks(): string[];\n    private getTezosNamespace;\n    private getPermittedMethods;\n    private getPermittedNetwork;\n    private getTezosRequiredNamespace;\n    private notifyListeners;\n    currentSession(): SessionTypes.Struct | undefined;\n    private tryConnectToRelayer;\n    private getSignClient;\n    private getSession;\n    /**\n     * @description Access the public key hash (or public key) of the active account\n     * @error ActiveAccountUnspecified thrown when there are multiple Tezos account in the session and none is set as the active one\n     */\n    getAccountOrPK(): Promise<string>;\n    private clearState;\n    /**\n     * @description Checks if session is close to expiry and extends it if needed\n     * Extends session by 7 days if it will expire within 24 hours\n     * Uses defensive error handling to prevent relay message conflicts (TrustWallet issue)\n     */\n    private checkAndExtendSession;\n    /**\n     * @description Validates if a restored session is still valid and usable\n     * @param session The session to validate\n     * @returns true if session is valid, false if stale/expired\n     */\n    private isSessionValid;\n    /**\n     * @description Cleans up a stale session by disconnecting and removing it\n     * @param session The stale session to cleanup\n     */\n    private cleanupStaleSession;\n}\n'},{name:"@airgap/beacon-transport-walletconnect/WalletConnectTransport.d.ts",dts:"import { KeyPair } from '@stablelib/ed25519';\nimport { WalletConnectCommunicationClient } from './communication-client/WalletConnectCommunicationClient';\nimport { Storage, ExtendedWalletConnectPairingResponse, StorageKey, WalletConnectPairingRequest, NetworkType, TransportType } from '@airgap/beacon-types';\nimport { Transport } from '@airgap/beacon-core';\nimport { SignClientTypes } from '@walletconnect/types';\nimport { ExposedPromise } from '@airgap/beacon-utils';\n/**\n * @internalapi\n *\n *\n */\nexport declare class WalletConnectTransport<T extends WalletConnectPairingRequest | ExtendedWalletConnectPairingResponse, K extends StorageKey.TRANSPORT_WALLETCONNECT_PEERS_DAPP> extends Transport<T, K, WalletConnectCommunicationClient> {\n    private wcOptions;\n    private isLeader;\n    readonly type: TransportType;\n    protected isReady: ExposedPromise<boolean, unknown>;\n    constructor(name: string, _keyPair: KeyPair, storage: Storage, storageKey: K, wcOptions: {\n        network: NetworkType;\n        opts: SignClientTypes.Options;\n    }, isLeader: Function);\n    static isAvailable(): Promise<boolean>;\n    /**\n     * Returns a promise that blocks the execution flow when awaited if the transport hasn't resolved yet; otherwise, it returns true.\n     */\n    waitForResolution(): Promise<boolean>;\n    connect(): Promise<void>;\n    wasDisconnectedByWallet(): boolean;\n    closeClient(): void;\n    hasPairings(): Promise<boolean>;\n    hasSessions(): Promise<boolean>;\n    /**\n     * Forcefully updates any DApps running on the same session\n     * Typical use case: localStorage changes to reflect to indexDB\n     * @param type the message type\n     */\n    forceUpdate(type: string): void;\n    getPeers(): Promise<T[]>;\n    disconnect(): Promise<void>;\n    startOpenChannelListener(): Promise<void>;\n    doClientCleanup(): Promise<void>;\n    getPairingRequestInfo(): Promise<any>;\n    listen(publicKey: string): Promise<void>;\n}\n"},{name:"@airgap/beacon-transport-walletconnect/error.d.ts",dts:"import { PermissionScopeMethods } from './communication-client/WalletConnectCommunicationClient';\n/**\n *  @category Error\n *  @description Error that indicates the wallet returned an invalid namespace\n */\nexport declare class InvalidReceivedSessionNamespace extends Error {\n    messageWc: string;\n    codeWc: number;\n    data?: string | string[] | undefined;\n    name: string;\n    constructor(messageWc: string, codeWc: number, type: 'invalid' | 'incomplete', data?: string | string[] | undefined);\n}\n/**\n *  @category Error\n *  @description Error that indicates there is no active session\n */\nexport declare class NotConnected extends Error {\n    name: string;\n    constructor();\n}\n/**\n *  @category Error\n *  @description Error that indicates the session is invalid\n */\nexport declare class InvalidSession extends Error {\n    name: string;\n    constructor(message: string);\n}\n/**\n *  @category Error\n *  @description Error that indicates missing required permission scopes\n */\nexport declare class MissingRequiredScope extends Error {\n    requiredScopes: PermissionScopeMethods | string;\n    name: string;\n    constructor(requiredScopes: PermissionScopeMethods | string);\n}\n/**\n *  @category Error\n *  @description Error that indicates the active network is not specified\n */\nexport declare class ActiveNetworkUnspecified extends Error {\n    name: string;\n    constructor();\n}\n/**\n *  @category Error\n *  @description Error that indicates the active account is not specified\n */\nexport declare class ActiveAccountUnspecified extends Error {\n    name: string;\n    constructor();\n}\n/**\n *  @category Error\n *  @description Error that indicates the combination pkh-network is not part of the active session\n */\nexport declare class InvalidNetworkOrAccount extends Error {\n    network: string;\n    pkh: string;\n    name: string;\n    constructor(network: string, pkh: string);\n}\n"},{name:"@airgap/beacon-transport-walletconnect/index.d.ts",dts:"export { WalletConnectTransport } from './WalletConnectTransport';\nexport { WalletConnectCommunicationClient } from './communication-client/WalletConnectCommunicationClient';\n"},{name:"@airgap/beacon-transport-walletconnect/dist/esm/communication-client/WalletConnectCommunicationClient.d.ts",dts:'import { CommunicationClient, WCStorage } from \'@airgap/beacon-core\';\nimport Client from \'@walletconnect/sign-client\';\nimport { SessionTypes, SignClientTypes } from \'@walletconnect/types\';\nimport { ExtendedWalletConnectPairingRequest, ExtendedWalletConnectPairingResponse, NetworkType, OperationRequest, PermissionRequest, SignPayloadRequest } from \'@airgap/beacon-types\';\nexport interface PermissionScopeParam {\n    networks: NetworkType[];\n    methods: PermissionScopeMethods[];\n    events?: PermissionScopeEvents[];\n}\nexport declare enum PermissionScopeMethods {\n    GET_ACCOUNTS = "tezos_getAccounts",\n    OPERATION_REQUEST = "tezos_send",\n    SIGN = "tezos_sign"\n}\nexport declare enum PermissionScopeEvents {\n    CHAIN_CHANGED = "chainChanged",\n    ACCOUNTS_CHANGED = "accountsChanged",\n    REQUEST_ACKNOWLEDGED = "requestAcknowledged"\n}\nexport declare class WalletConnectCommunicationClient extends CommunicationClient {\n    private wcOptions;\n    private isLeader;\n    protected readonly activeListeners: Map<string, (message: string) => void>;\n    protected readonly channelOpeningListeners: Map<string, (pairingResponse: ExtendedWalletConnectPairingResponse) => void>;\n    private static instance;\n    signClient: Client | undefined;\n    storage: WCStorage;\n    private session;\n    private activeAccountOrPbk;\n    private activeNetwork;\n    readonly disconnectionEvents: Set<string>;\n    private pingInterval;\n    /**\n     * this queue stores each active message id\n     * [0] newest message\n     * [length - 1] oldest message\n     */\n    private messageIds;\n    /**\n     * Tracks the last time session extension was attempted (Unix timestamp in seconds)\n     * Used to prevent duplicate re-extension attempts that can cause relay conflicts\n     */\n    private lastExtensionAttempt;\n    constructor(wcOptions: {\n        network: NetworkType;\n        opts: SignClientTypes.Options;\n    }, isLeader: Function);\n    static getInstance(wcOptions: {\n        network: NetworkType;\n        opts: SignClientTypes.Options;\n    }, isLeader: Function): WalletConnectCommunicationClient;\n    private getTopicFromSession;\n    listenForEncryptedMessage(senderPublicKey: string, messageCallback: (message: string) => void): Promise<void>;\n    listenForChannelOpening(messageCallback: (pairingResponse: ExtendedWalletConnectPairingResponse) => void): Promise<void>;\n    /**\n     * WC Sign client doesn\'t sync between intances, meaning that a dApp signClient instance state may\n     * differ from a wallet state\n     */\n    private refreshState;\n    private clearEvents;\n    private onStorageMessageHandler;\n    private onStorageErrorHandler;\n    unsubscribeFromEncryptedMessages(): Promise<void>;\n    unsubscribeFromEncryptedMessage(_senderPublicKey: string): Promise<void>;\n    closeSignClient(): Promise<void>;\n    private ping;\n    private checkWalletReadiness;\n    sendMessage(_message: string, _peer?: any): Promise<void>;\n    private fetchAccounts;\n    private notifyListenersWithPermissionResponse;\n    requestPermissions(message: PermissionRequest): Promise<void>;\n    /**\n     * @description Once the session is establish, send payload to be approved and signed by the wallet.\n     * @error MissingRequiredScope is thrown if permission to sign payload was not granted\n     */\n    signPayload(signPayloadRequest: SignPayloadRequest): Promise<void>;\n    /**\n     * @description Once the session is established, send Tezos operations to be approved, signed and inject by the wallet.\n     * @error MissingRequiredScope is thrown if permission to send operation was not granted\n     */\n    sendOperations(operationRequest: OperationRequest): Promise<void>;\n    private isMobileSesion;\n    /**\n     * Function used to fix appSwitching with web wallets when pairing through \'Other wallet flow\'\n     * @param session the newly created session\n     */\n    private updateStorageWallet;\n    init(forceNewConnection?: boolean): Promise<{\n        uri: string;\n        topic: string;\n    } | undefined>;\n    close(): Promise<void>;\n    private subscribeToSessionEvents;\n    private acknowledgeRequest;\n    private updateActiveAccount;\n    private disconnect;\n    private onSessionClosed;\n    getPairingRequestInfo(): Promise<ExtendedWalletConnectPairingRequest>;\n    private closePairings;\n    private closeSessions;\n    private openSession;\n    private permissionScopeParamsToNamespaces;\n    private validateReceivedNamespace;\n    private validateMethods;\n    private validateEvents;\n    private validateAccounts;\n    closeActiveSession(account: string, notify?: boolean): Promise<void>;\n    private validateNetworkAndAccount;\n    /**\n     * @description Access the active network\n     * @error ActiveNetworkUnspecified thorwn when there are multiple Tezos networks in the session and none is set as the active one\n     */\n    getActiveNetwork(): string;\n    private setDefaultAccountAndNetwork;\n    /**\n     * @description Return all connected accounts from the active session\n     * @error NotConnected if no active session\n     */\n    getAccounts(): string[];\n    /**\n     * @description Return all networks from the namespace of the active session\n     * @error NotConnected if no active session\n     */\n    getNetworks(): string[];\n    private getTezosNamespace;\n    private getPermittedMethods;\n    private getPermittedNetwork;\n    private getTezosRequiredNamespace;\n    private notifyListeners;\n    currentSession(): SessionTypes.Struct | undefined;\n    private tryConnectToRelayer;\n    private getSignClient;\n    private getSession;\n    /**\n     * @description Access the public key hash (or public key) of the active account\n     * @error ActiveAccountUnspecified thrown when there are multiple Tezos account in the session and none is set as the active one\n     */\n    getAccountOrPK(): Promise<string>;\n    private clearState;\n    /**\n     * @description Checks if session is close to expiry and extends it if needed\n     * Extends session by 7 days if it will expire within 24 hours\n     * Uses defensive error handling to prevent relay message conflicts (TrustWallet issue)\n     */\n    private checkAndExtendSession;\n    /**\n     * @description Validates if a restored session is still valid and usable\n     * @param session The session to validate\n     * @returns true if session is valid, false if stale/expired\n     */\n    private isSessionValid;\n    /**\n     * @description Cleans up a stale session by disconnecting and removing it\n     * @param session The stale session to cleanup\n     */\n    private cleanupStaleSession;\n}\n'},{name:"@airgap/beacon-transport-walletconnect/dist/esm/WalletConnectTransport.d.ts",dts:"import { KeyPair } from '@stablelib/ed25519';\nimport { WalletConnectCommunicationClient } from './communication-client/WalletConnectCommunicationClient';\nimport { Storage, ExtendedWalletConnectPairingResponse, StorageKey, WalletConnectPairingRequest, NetworkType, TransportType } from '@airgap/beacon-types';\nimport { Transport } from '@airgap/beacon-core';\nimport { SignClientTypes } from '@walletconnect/types';\nimport { ExposedPromise } from '@airgap/beacon-utils';\n/**\n * @internalapi\n *\n *\n */\nexport declare class WalletConnectTransport<T extends WalletConnectPairingRequest | ExtendedWalletConnectPairingResponse, K extends StorageKey.TRANSPORT_WALLETCONNECT_PEERS_DAPP> extends Transport<T, K, WalletConnectCommunicationClient> {\n    private wcOptions;\n    private isLeader;\n    readonly type: TransportType;\n    protected isReady: ExposedPromise<boolean, unknown>;\n    constructor(name: string, _keyPair: KeyPair, storage: Storage, storageKey: K, wcOptions: {\n        network: NetworkType;\n        opts: SignClientTypes.Options;\n    }, isLeader: Function);\n    static isAvailable(): Promise<boolean>;\n    /**\n     * Returns a promise that blocks the execution flow when awaited if the transport hasn't resolved yet; otherwise, it returns true.\n     */\n    waitForResolution(): Promise<boolean>;\n    connect(): Promise<void>;\n    wasDisconnectedByWallet(): boolean;\n    closeClient(): void;\n    hasPairings(): Promise<boolean>;\n    hasSessions(): Promise<boolean>;\n    /**\n     * Forcefully updates any DApps running on the same session\n     * Typical use case: localStorage changes to reflect to indexDB\n     * @param type the message type\n     */\n    forceUpdate(type: string): void;\n    getPeers(): Promise<T[]>;\n    disconnect(): Promise<void>;\n    startOpenChannelListener(): Promise<void>;\n    doClientCleanup(): Promise<void>;\n    getPairingRequestInfo(): Promise<any>;\n    listen(publicKey: string): Promise<void>;\n}\n"},{name:"@airgap/beacon-transport-walletconnect/dist/esm/error.d.ts",dts:"import { PermissionScopeMethods } from './communication-client/WalletConnectCommunicationClient';\n/**\n *  @category Error\n *  @description Error that indicates the wallet returned an invalid namespace\n */\nexport declare class InvalidReceivedSessionNamespace extends Error {\n    messageWc: string;\n    codeWc: number;\n    data?: string | string[] | undefined;\n    name: string;\n    constructor(messageWc: string, codeWc: number, type: 'invalid' | 'incomplete', data?: string | string[] | undefined);\n}\n/**\n *  @category Error\n *  @description Error that indicates there is no active session\n */\nexport declare class NotConnected extends Error {\n    name: string;\n    constructor();\n}\n/**\n *  @category Error\n *  @description Error that indicates the session is invalid\n */\nexport declare class InvalidSession extends Error {\n    name: string;\n    constructor(message: string);\n}\n/**\n *  @category Error\n *  @description Error that indicates missing required permission scopes\n */\nexport declare class MissingRequiredScope extends Error {\n    requiredScopes: PermissionScopeMethods | string;\n    name: string;\n    constructor(requiredScopes: PermissionScopeMethods | string);\n}\n/**\n *  @category Error\n *  @description Error that indicates the active network is not specified\n */\nexport declare class ActiveNetworkUnspecified extends Error {\n    name: string;\n    constructor();\n}\n/**\n *  @category Error\n *  @description Error that indicates the active account is not specified\n */\nexport declare class ActiveAccountUnspecified extends Error {\n    name: string;\n    constructor();\n}\n/**\n *  @category Error\n *  @description Error that indicates the combination pkh-network is not part of the active session\n */\nexport declare class InvalidNetworkOrAccount extends Error {\n    network: string;\n    pkh: string;\n    name: string;\n    constructor(network: string, pkh: string);\n}\n"},{name:"@airgap/beacon-transport-walletconnect/dist/esm/index.d.ts",dts:"export { WalletConnectTransport } from './WalletConnectTransport';\nexport { WalletConnectCommunicationClient } from './communication-client/WalletConnectCommunicationClient';\n"},{name:"@airgap/beacon-types/types/beacon/messages/AcknowledgeResponse.d.ts",dts:"import { BeaconBaseMessage, BeaconMessageType } from '@airgap/beacon-types';\n/**\n * @category Message\n */\nexport interface AcknowledgeResponse extends BeaconBaseMessage {\n    type: BeaconMessageType.Acknowledge;\n}\n"},{name:"@airgap/beacon-types/types/beacon/messages/BeaconRequestInputMessage.d.ts",dts:"import { Optional } from '@airgap/beacon-types';\nimport { PermissionRequest, OperationRequest, SignPayloadRequest, ProofOfEventChallengeRequest, SimulatedProofOfEventChallengeRequest, BroadcastRequest } from '@airgap/beacon-types';\n/**\n * @internalapi\n * @category DApp\n */\nexport type IgnoredRequestInputProperties = 'id' | 'senderId' | 'version';\n/**\n * @internalapi\n * @category DApp\n */\nexport type PermissionRequestInput = Optional<PermissionRequest, IgnoredRequestInputProperties>;\n/**\n * @internalapi\n * @category DApp\n */\nexport type ProofOfEventChallengeRequestInput = Optional<ProofOfEventChallengeRequest, IgnoredRequestInputProperties>;\n/**\n * @internalapi\n * @category DApp\n */\nexport type SimulatedProofOfEventChallengeRequestInput = Optional<SimulatedProofOfEventChallengeRequest, IgnoredRequestInputProperties>;\n/**\n * @internalapi\n * @category DApp\n */\nexport type OperationRequestInput = Optional<OperationRequest, IgnoredRequestInputProperties>;\n/**\n * @internalapi\n * @category DApp\n */\nexport type SignPayloadRequestInput = Optional<SignPayloadRequest, IgnoredRequestInputProperties>;\n/**\n * @internalapi\n * @category DApp\n */\n/**\n * @internalapi\n * @category DApp\n */\nexport type BroadcastRequestInput = Optional<BroadcastRequest, IgnoredRequestInputProperties>;\n/**\n * @internalapi\n * @category DApp\n */\nexport type BeaconRequestInputMessage = PermissionRequestInput | OperationRequestInput | SignPayloadRequestInput | BroadcastRequestInput | ProofOfEventChallengeRequestInput | SimulatedProofOfEventChallengeRequestInput;\n"},{name:"@airgap/beacon-types/types/beacon/messages/BeaconRequestOutputMessage.d.ts",dts:"import { Optional, ProofOfEventChallengeRequest, SimulatedProofOfEventChallengeRequest } from '@airgap/beacon-types';\nimport { AppMetadata, PermissionRequest, OperationRequest, SignPayloadRequest, BroadcastRequest } from '@airgap/beacon-types';\n/**\n * @category Wallet\n */\nexport type IgnoredRequestOutputProperties = 'version';\n/**\n * @category Wallet\n */\nexport interface ExtraResponseOutputProperties {\n    appMetadata: AppMetadata;\n}\n/**\n * @category Wallet\n */\nexport type PermissionRequestOutput = Optional<PermissionRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n/**\n * @category Wallet\n */\nexport type ProofOfEventChallengeRequestOutput = Optional<ProofOfEventChallengeRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n/**\n * @category Wallet\n */\nexport type SimulatedProofOfEventChallengeRequestOutput = Optional<SimulatedProofOfEventChallengeRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n/**\n * @category Wallet\n */\nexport type OperationRequestOutput = Optional<OperationRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n/**\n * @category Wallet\n */\nexport type SignPayloadRequestOutput = Optional<SignPayloadRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n/**\n * @category Wallet\n */\n/**\n * @category Wallet\n */\nexport type BroadcastRequestOutput = Optional<BroadcastRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n/**\n * @internalapi\n * @category Wallet\n */\nexport type BeaconRequestOutputMessage = PermissionRequestOutput | OperationRequestOutput | SignPayloadRequestOutput | BroadcastRequestOutput | ProofOfEventChallengeRequestOutput | SimulatedProofOfEventChallengeRequestOutput;\n"},{name:"@airgap/beacon-types/types/beacon/messages/BeaconResponseInputMessage.d.ts",dts:"import { Optional, ProofOfEventChallengeResponse, SimulatedProofOfEventChallengeResponse } from '@airgap/beacon-types';\nimport { PermissionResponse, OperationResponse, SignPayloadResponse, BroadcastResponse, AcknowledgeResponse, ErrorResponse } from '@airgap/beacon-types';\n/**\n * @category Wallet\n */\nexport type IgnoredResponseInputProperties = 'senderId' | 'version';\n/**\n * @category Wallet\n */\nexport type PermissionResponseInput = Optional<PermissionResponse, IgnoredResponseInputProperties | 'appMetadata'>;\n/**\n * @category Wallet\n */\nexport type ProofOfEventChallengeResponseInput = Optional<ProofOfEventChallengeResponse, IgnoredResponseInputProperties>;\n/**\n * @category Wallet\n */\nexport type SimulatedProofOfEventChallengeResponseInput = Optional<SimulatedProofOfEventChallengeResponse, IgnoredResponseInputProperties>;\n/**\n * @category Wallet\n */\nexport type OperationResponseInput = Optional<OperationResponse, IgnoredResponseInputProperties>;\n/**\n * @category Wallet\n */\nexport type SignPayloadResponseInput = Optional<SignPayloadResponse, IgnoredResponseInputProperties>;\n/**\n * @category Wallet\n */\n/**\n * @category Wallet\n */\nexport type BroadcastResponseInput = Optional<BroadcastResponse, IgnoredResponseInputProperties>;\n/**\n * @category Wallet\n */\nexport type AcknowledgeResponseInput = Optional<AcknowledgeResponse, IgnoredResponseInputProperties>;\n/**\n * @category Wallet\n */\nexport type ErrorResponseInput = Optional<ErrorResponse, IgnoredResponseInputProperties>;\n/**\n * @internalapi\n * @category Wallet\n */\nexport type BeaconResponseInputMessage = PermissionResponseInput | OperationResponseInput | SignPayloadResponseInput | BroadcastResponseInput | AcknowledgeResponseInput | ErrorResponseInput | ProofOfEventChallengeResponseInput | SimulatedProofOfEventChallengeResponseInput;\n"},{name:"@airgap/beacon-types/types/beacon/messages/BeaconResponseOutputMessage.d.ts",dts:"import { PermissionResponse, OperationResponse, SignPayloadResponse, BroadcastResponse, AccountInfo, ProofOfEventChallengeResponse, SimulatedProofOfEventChallengeResponse } from '@airgap/beacon-types';\n/**\n * @category DApp\n */\nexport type IgnoredResponseOutputProperties = 'id' | 'version' | 'type';\n/**\n * @category DApp\n */\nexport type PermissionResponseOutput = PermissionResponse & {\n    address: string;\n    accountInfo: AccountInfo;\n    walletKey?: string | undefined;\n};\n/**\n * @category DApp\n */\nexport type ProofOfEventChallengeResponseOutput = ProofOfEventChallengeResponse;\n/**\n * @category DApp\n */\nexport type SimulatedProofOfEventChallengeResponseOutput = SimulatedProofOfEventChallengeResponse;\n/**\n * @category DApp\n */\nexport type OperationResponseOutput = OperationResponse;\n/**\n * @category DApp\n */\nexport type SignPayloadResponseOutput = SignPayloadResponse;\n/**\n * @category DApp\n */\n/**\n * @category DApp\n */\nexport type BroadcastResponseOutput = BroadcastResponse;\n/**\n * @internalapi\n * @category DApp\n */\nexport type BeaconResponseOutputMessage = PermissionResponseOutput | OperationResponseOutput | SignPayloadResponseOutput | BroadcastResponseOutput | ProofOfEventChallengeResponseOutput | SimulatedProofOfEventChallengeResponseOutput;\n"},{name:"@airgap/beacon-types/types/beacon/messages/BroadcastRequest.d.ts",dts:"import { BeaconBaseMessage, BeaconMessageType, Network } from '@airgap/beacon-types';\n/**\n * @category Message\n */\nexport interface BroadcastRequest extends BeaconBaseMessage {\n    type: BeaconMessageType.BroadcastRequest;\n    network: Network;\n    signedTransaction: string;\n}\n"},{name:"@airgap/beacon-types/types/beacon/messages/BroadcastResponse.d.ts",dts:"import { BeaconBaseMessage, BeaconMessageType } from '@airgap/beacon-types';\n/**\n * @category Message\n */\nexport interface BroadcastResponse extends BeaconBaseMessage {\n    type: BeaconMessageType.BroadcastResponse;\n    transactionHash: string;\n}\n"},{name:"@airgap/beacon-types/types/beacon/messages/ChangeAccountRequest.d.ts",dts:"import { BeaconBaseMessage, BeaconMessageType, Network, PermissionScope, Threshold } from '@airgap/beacon-types';\nimport { Notification } from '../../Notification';\nexport interface ChangeAccountRequest extends BeaconBaseMessage {\n    type: BeaconMessageType.ChangeAccountRequest;\n    address?: string;\n    walletType: 'implicit' | 'abstracted_account';\n    verificationType?: 'proof_of_event';\n    publicKey?: string;\n    network: Network;\n    scopes: PermissionScope[];\n    threshold?: Threshold;\n    notification?: Notification;\n}\n"},{name:"@airgap/beacon-types/types/beacon/messages/DisconnectMessage.d.ts",dts:"import { BeaconBaseMessage, BeaconMessageType } from '@airgap/beacon-types';\n/**\n * @category Message\n */\nexport interface DisconnectMessage extends BeaconBaseMessage {\n    type: BeaconMessageType.Disconnect;\n}\n"},{name:"@airgap/beacon-types/types/beacon/messages/EncryptPayloadRequest.d.ts",dts:"/**\n * @category Message\n */\n"},{name:"@airgap/beacon-types/types/beacon/messages/EncryptPayloadResponse.d.ts",dts:"/**\n * @category Message\n */\n"},{name:"@airgap/beacon-types/types/beacon/messages/ErrorResponse.d.ts",dts:"import { BeaconBaseMessage, BeaconErrorType, BeaconMessageType } from '@airgap/beacon-types';\n/**\n * @category Message\n */\nexport interface ErrorResponse extends BeaconBaseMessage {\n    type: BeaconMessageType.Error;\n    errorType: BeaconErrorType;\n    errorData?: any;\n}\n"},{name:"@airgap/beacon-types/types/beacon/messages/OperationRequest.d.ts",dts:"import { BeaconBaseMessage, BeaconMessageType, Network } from '@airgap/beacon-types';\nimport { PartialTezosOperation } from '../../tezos/PartialTezosOperation';\n/**\n * @category Message\n */\nexport interface OperationRequest extends BeaconBaseMessage {\n    type: BeaconMessageType.OperationRequest;\n    network: Network;\n    operationDetails: PartialTezosOperation[];\n    sourceAddress: string;\n}\n"},{name:"@airgap/beacon-types/types/beacon/messages/OperationResponse.d.ts",dts:"import { BeaconBaseMessage, BeaconMessageType } from '@airgap/beacon-types';\n/**\n * @category Message\n */\nexport interface OperationResponse extends BeaconBaseMessage {\n    type: BeaconMessageType.OperationResponse;\n    transactionHash: string;\n}\n"},{name:"@airgap/beacon-types/types/beacon/messages/PermissionRequest.d.ts",dts:"import { BeaconBaseMessage, BeaconMessageType, PermissionScope, AppMetadata, Network } from '@airgap/beacon-types';\n/**\n * @category Message\n */\nexport interface PermissionRequest extends BeaconBaseMessage {\n    type: BeaconMessageType.PermissionRequest;\n    appMetadata: AppMetadata;\n    network: Network;\n    scopes: PermissionScope[];\n}\n"},{name:"@airgap/beacon-types/types/beacon/messages/PermissionResponse.d.ts",dts:"import { AppMetadata, BeaconBaseMessage, BeaconMessageType, Network, PermissionScope, Threshold } from '@airgap/beacon-types';\nimport { Notification } from '../../Notification';\n/**\n * @category Message\n */\nexport interface PermissionResponse extends BeaconBaseMessage {\n    address?: string;\n    walletType: 'implicit' | 'abstracted_account';\n    verificationType?: 'proof_of_event';\n    type: BeaconMessageType.PermissionResponse;\n    appMetadata: AppMetadata;\n    publicKey?: string;\n    network: Network;\n    scopes: PermissionScope[];\n    threshold?: Threshold;\n    notification?: Notification;\n}\n"},{name:"@airgap/beacon-types/types/beacon/messages/ProofOfEventChallengeRequest.d.ts",dts:"import { BeaconBaseMessage, BeaconMessageType } from '@airgap/beacon-types';\nexport interface ProofOfEventChallengeRequest extends BeaconBaseMessage {\n    type: BeaconMessageType.ProofOfEventChallengeRequest;\n    payload: string;\n    contractAddress: string;\n}\n"},{name:"@airgap/beacon-types/types/beacon/messages/ProofOfEventChallengeResponse.d.ts",dts:"import { BeaconBaseMessage, BeaconMessageType } from '@airgap/beacon-types';\nexport interface ProofOfEventChallengeResponse extends BeaconBaseMessage {\n    type: BeaconMessageType.ProofOfEventChallengeResponse;\n    payloadHash: string;\n    isAccepted: boolean;\n}\n"},{name:"@airgap/beacon-types/types/beacon/messages/SignPayloadRequest.d.ts",dts:"import { BeaconBaseMessage, BeaconMessageType, SigningType } from '@airgap/beacon-types';\n/**\n * @category Message\n */\nexport interface SignPayloadRequest extends BeaconBaseMessage {\n    type: BeaconMessageType.SignPayloadRequest;\n    signingType: SigningType;\n    payload: string;\n    sourceAddress: string;\n}\n"},{name:"@airgap/beacon-types/types/beacon/messages/SignPayloadResponse.d.ts",dts:"import { BeaconBaseMessage, BeaconMessageType, SigningType } from '@airgap/beacon-types';\n/**\n * @category Message\n */\nexport interface SignPayloadResponse extends BeaconBaseMessage {\n    type: BeaconMessageType.SignPayloadResponse;\n    signingType: SigningType;\n    signature: string;\n}\n"},{name:"@airgap/beacon-types/types/beacon/messages/SimulatedProofOfEventChallengeRequest.d.ts",dts:"import { BeaconBaseMessage, BeaconMessageType } from '@airgap/beacon-types';\nexport interface SimulatedProofOfEventChallengeRequest extends BeaconBaseMessage {\n    type: BeaconMessageType.SimulatedProofOfEventChallengeRequest;\n    payload: string;\n    contractAddress: string;\n}\n"},{name:"@airgap/beacon-types/types/beacon/messages/SimulatedProofOfEventChallengeResponse.d.ts",dts:"import { BeaconBaseMessage, BeaconMessageType } from '@airgap/beacon-types';\nexport interface SimulatedProofOfEventChallengeResponse extends BeaconBaseMessage {\n    type: BeaconMessageType.SimulatedProofOfEventChallengeResponse;\n    operationsList: string;\n    errorMessage: string;\n}\n"},{name:"@airgap/beacon-types/types/beacon/AppMetadata.d.ts",dts:"export interface AppMetadata {\n    senderId: string;\n    name: string;\n    icon?: string;\n}\n"},{name:"@airgap/beacon-types/types/beacon/BeaconBaseMessage.d.ts",dts:"import { BeaconMessageType } from '@airgap/beacon-types';\n/**\n * @category Message\n */\nexport interface BeaconBaseMessage {\n    type: BeaconMessageType;\n    version: string;\n    id: string;\n    senderId: string;\n}\n"},{name:"@airgap/beacon-types/types/beacon/BeaconMessage.d.ts",dts:"import { PermissionResponse, PermissionRequest, OperationRequest, OperationResponse, SignPayloadRequest, SignPayloadResponse, BroadcastRequest, BroadcastResponse, AcknowledgeResponse, DisconnectMessage, ErrorResponse, ProofOfEventChallengeRequest, ProofOfEventChallengeResponse, SimulatedProofOfEventChallengeRequest, SimulatedProofOfEventChallengeResponse, ChangeAccountRequest } from '@airgap/beacon-types';\n/**\n * @internalapi\n */\nexport type BeaconMessage = PermissionRequest | PermissionResponse | ProofOfEventChallengeRequest | ProofOfEventChallengeResponse | SimulatedProofOfEventChallengeRequest | SimulatedProofOfEventChallengeResponse | OperationRequest | OperationResponse | SignPayloadRequest | SignPayloadResponse | BroadcastRequest | BroadcastResponse | AcknowledgeResponse | DisconnectMessage | ErrorResponse | ChangeAccountRequest;\n"},{name:"@airgap/beacon-types/types/beacon/BeaconMessageType.d.ts",dts:'export declare enum BeaconMessageType {\n    BlockchainRequest = "blockchain_request",\n    PermissionRequest = "permission_request",\n    SignPayloadRequest = "sign_payload_request",\n    OperationRequest = "operation_request",\n    BroadcastRequest = "broadcast_request",\n    ChangeAccountRequest = "change_account_request",\n    BlockchainResponse = "blockchain_response",\n    PermissionResponse = "permission_response",\n    SignPayloadResponse = "sign_payload_response",\n    ProofOfEventChallengeRequest = "proof_of_event_challenge_request",\n    ProofOfEventChallengeResponse = "proof_of_event_challenge_response",\n    SimulatedProofOfEventChallengeRequest = "simulated_proof_of_event_challenge_request",\n    SimulatedProofOfEventChallengeResponse = "simulated_proof_of_event_challenge_response",\n    OperationResponse = "operation_response",\n    BroadcastResponse = "broadcast_response",\n    Acknowledge = "acknowledge",\n    Disconnect = "disconnect",\n    Error = "error"\n}\n'},{name:"@airgap/beacon-types/types/beacon/BeaconRequestMessage.d.ts",dts:"import { PermissionRequest, OperationRequest, SignPayloadRequest, BroadcastRequest, ProofOfEventChallengeRequest, SimulatedProofOfEventChallengeRequest } from '@airgap/beacon-types';\n/**\n * @internalapi\n */\nexport type BeaconRequestMessage = PermissionRequest | OperationRequest | SignPayloadRequest | BroadcastRequest | ProofOfEventChallengeRequest | SimulatedProofOfEventChallengeRequest;\n"},{name:"@airgap/beacon-types/types/beacon/BeaconResponseMessage.d.ts",dts:"import { PermissionResponse, OperationResponse, SignPayloadResponse, BroadcastResponse } from '@airgap/beacon-types';\nimport { ErrorResponse } from './messages/ErrorResponse';\n/**\n * @internalapi\n */\nexport type BeaconResponseMessage = PermissionResponse | OperationResponse | SignPayloadResponse | BroadcastResponse | ErrorResponse;\n"},{name:"@airgap/beacon-types/types/beacon/Network.d.ts",dts:"import { NetworkType } from '@airgap/beacon-types';\nexport interface Network {\n    type: NetworkType;\n    name?: string;\n    rpcUrl?: string;\n}\n"},{name:"@airgap/beacon-types/types/beacon/NetworkType.d.ts",dts:'export declare enum NetworkType {\n    MAINNET = "mainnet",\n    GHOSTNET = "ghostnet",// Long running testnet\n    WEEKLYNET = "weeklynet",// Testnet, resets every week\n    DAILYNET = "dailynet",// Testnet, resets every day\n    DELPHINET = "delphinet",\n    EDONET = "edonet",\n    FLORENCENET = "florencenet",\n    GRANADANET = "granadanet",\n    HANGZHOUNET = "hangzhounet",\n    ITHACANET = "ithacanet",\n    JAKARTANET = "jakartanet",\n    KATHMANDUNET = "kathmandunet",\n    LIMANET = "limanet",\n    MUMBAINET = "mumbainet",\n    NAIROBINET = "nairobinet",\n    OXFORDNET = "oxfordnet",\n    PARISNET = "parisnet",\n    QUEBECNET = "quebecnet",\n    RIONET = "rionet",\n    SEOULNET = "seoulnet",\n    SHADOWNET = "shadownet",\n    CUSTOM = "custom"\n}\n'},{name:"@airgap/beacon-types/types/beacon/PermissionScope.d.ts",dts:'export declare enum PermissionScope {\n    SIGN = "sign",// Allows the DApp to send requests to sign arbitrary payload\n    OPERATION_REQUEST = "operation_request",// Allows the DApp to send requests to sign and broadcast Tezos Operations\n    ENCRYPT = "encrypt",// Allows the DApp to send encryption and decryption requests\n    NOTIFICATION = "notification",// Allows the DApp to send push notifications to the Wallet\n    THRESHOLD = "threshold"\n}\n'},{name:"@airgap/beacon-types/types/beacon/SigningType.d.ts",dts:'export declare enum SigningType {\n    RAW = "raw",// Arbitrary payload (string), which will be hashed before signing\n    OPERATION = "operation",// "03" prefix\n    MICHELINE = "micheline"\n}\n'},{name:"@airgap/beacon-types/types/beacon/Threshold.d.ts",dts:"export interface Threshold {\n    amount: string;\n    timeframe: string;\n}\n"},{name:"@airgap/beacon-types/types/beaconV3/PermissionRequest.d.ts",dts:"import { AccountInfo, AppMetadata, BeaconMessageType, ConnectionContext, WalletInfo, ExtensionApp, DesktopApp, WebApp, App } from '@airgap/beacon-types';\nexport interface ResponseInput {\n    request: BlockchainMessage;\n    account: AccountInfo;\n    output: BeaconMessageWrapper<BeaconBaseMessage>;\n    blockExplorer: any;\n    connectionContext: ConnectionContext;\n    walletInfo: WalletInfo;\n}\nexport interface Blockchain {\n    readonly identifier: string;\n    validateRequest(input: BlockchainMessage): Promise<void>;\n    handleResponse(input: ResponseInput): Promise<void>;\n    getWalletLists(): Promise<{\n        extensionList: ExtensionApp[];\n        desktopList: DesktopApp[];\n        webList: WebApp[];\n        iOSList: App[];\n    }>;\n    getAccountInfosFromPermissionResponse(permissionResponse: PermissionResponseV3): Promise<{\n        accountId: string;\n        address: string;\n        publicKey: string;\n    }[]>;\n}\nexport interface BeaconMessageWrapper<T extends BeaconBaseMessage> {\n    id: string;\n    version: string;\n    senderId: string;\n    message: T;\n}\nexport interface BeaconBaseMessage {\n    type: unknown;\n}\nexport interface BlockchainMessage<T extends string = string> {\n    blockchainIdentifier: T;\n    type: unknown;\n    blockchainData: unknown;\n}\nexport interface PermissionRequestV3<T extends string = string> extends BlockchainMessage<T> {\n    blockchainIdentifier: T;\n    type: BeaconMessageType.PermissionRequest;\n    blockchainData: {\n        appMetadata: AppMetadata;\n        scopes: string[];\n    };\n}\nexport interface PermissionResponseV3<T extends string = string> extends BlockchainMessage<T> {\n    blockchainIdentifier: T;\n    type: BeaconMessageType.PermissionResponse;\n    blockchainData: {\n        appMetadata: AppMetadata;\n        scopes: string[];\n    };\n}\nexport interface BlockchainRequestV3<T extends string = string> extends BlockchainMessage<T> {\n    blockchainIdentifier: T;\n    type: BeaconMessageType.BlockchainRequest;\n    accountId: string;\n    blockchainData: {\n        type: string;\n        scope: string;\n    };\n}\nexport interface BlockchainResponseV3<T extends string = string> extends BlockchainMessage<T> {\n    blockchainIdentifier: T;\n    type: BeaconMessageType.BlockchainResponse;\n    blockchainData: unknown;\n}\nexport interface BlockchainErrorResponse<T extends string = string> extends BlockchainMessage<T> {\n    blockchainIdentifier: T;\n    type: BeaconMessageType.Error;\n    error: {\n        type: unknown;\n        data?: unknown;\n    };\n    description?: string;\n}\nexport interface AcknowledgeMessage extends BeaconBaseMessage {\n    type: BeaconMessageType.Acknowledge;\n}\nexport interface DisconnectMessage extends BeaconBaseMessage {\n    type: BeaconMessageType.Disconnect;\n}\n"},{name:"@airgap/beacon-types/types/storage/Storage.d.ts",dts:"import { StorageKey, StorageKeyReturnType } from '@airgap/beacon-types';\n/**\n * @internalapi\n *\n * The storage used in the SDK\n */\nexport declare abstract class Storage {\n    /**\n     * Returns a promise that resolves to true if the storage option is available on this platform.\n     */\n    static isSupported(): Promise<boolean>;\n    /**\n     * Gets a value from storage and returns it\n     *\n     * @param key The storage key\n     */\n    abstract get<K extends StorageKey>(key: K): Promise<StorageKeyReturnType[K]>;\n    /**\n     * Sets a value in the storage and persist it\n     *\n     * @param key The storage key\n     * @param value The value to be persisted\n     */\n    abstract set<K extends StorageKey>(key: K, value: StorageKeyReturnType[K]): Promise<void>;\n    /**\n     * Delete a key from storage\n     *\n     * @param key The storage key\n     */\n    abstract delete<K extends StorageKey>(key: K): Promise<void>;\n    /**\n     * This event will fire if the storage was modified by someone else, eg. on another tab\n     *\n     * @param callback The callback to be called when a storage value changes\n     */\n    abstract subscribeToStorageChanged(callback: (arg: {\n        eventType: 'storageCleared' | 'entryModified';\n        key: string | null;\n        oldValue: string | null;\n        newValue: string | null;\n    }) => {}): Promise<void>;\n    /**\n     * Get the key with the internal prefix\n     *\n     * @param key the storage key\n     */\n    abstract getPrefixedKey<K extends StorageKey>(key: K): string;\n}\n"},{name:"@airgap/beacon-types/types/storage/StorageKey.d.ts",dts:'/**\n * @internalapi\n */\nexport declare enum StorageKey {\n    TRANSPORT_P2P_PEERS_DAPP = "beacon:communication-peers-dapp",\n    TRANSPORT_P2P_PEERS_WALLET = "beacon:communication-peers-wallet",\n    TRANSPORT_POSTMESSAGE_PEERS_DAPP = "beacon:postmessage-peers-dapp",\n    TRANSPORT_POSTMESSAGE_PEERS_WALLET = "beacon:postmessage-peers-wallet",\n    TRANSPORT_WALLETCONNECT_PEERS_DAPP = "beacon:walletconnect-peers-dapp",\n    LAST_SELECTED_WALLET = "beacon:last-selected-wallet",\n    ACCOUNTS = "beacon:accounts",\n    ACTIVE_ACCOUNT = "beacon:active-account",\n    PUSH_TOKENS = "beacon:push-tokens",\n    BEACON_SDK_SECRET_SEED = "beacon:sdk-secret-seed",\n    BEACON_LAST_ERROR = "beacon:beacon-last-error",\n    APP_METADATA_LIST = "beacon:app-metadata-list",\n    PERMISSION_LIST = "beacon:permissions",\n    ONGOING_PROOF_OF_EVENT_CHALLENGES = "beacon:ongoing-proof-of-event-challenges",\n    BEACON_SDK_VERSION = "beacon:sdk_version",\n    MATRIX_PRESERVED_STATE = "beacon:sdk-matrix-preserved-state",\n    MATRIX_PEER_ROOM_IDS = "beacon:matrix-peer-rooms",\n    MATRIX_SELECTED_NODE = "beacon:matrix-selected-node",\n    MULTI_NODE_SETUP_DONE = "beacon:multi-node-setup",\n    USER_ID = "beacon:user-id",\n    ENABLE_METRICS = "beacon:enable_metrics",\n    WC_INIT_ERROR = "beacon:wc-init-error",\n    WC_2_CORE_PAIRING = "wc@2:core:0.3:pairing",\n    WC_2_CLIENT_SESSION = "wc@2:client:0.3:session",\n    WC_2_CORE_KEYCHAIN = "wc@2:core:0.3:keychain",\n    WC_2_CORE_MESSAGES = "wc@2:core:0.3:messages",\n    WC_2_CLIENT_PROPOSAL = "wc@2:client:0.3:proposal",\n    WC_2_CORE_SUBSCRIPTION = "wc@2:core:0.3:subscription",\n    WC_2_CORE_HISTORY = "wc@2:core:0.3:history",\n    WC_2_CORE_EXPIRER = "wc@2:core:0.3:expirer"\n}\n'},{name:"@airgap/beacon-types/types/storage/StorageKeyReturnDefaults.d.ts",dts:"import { StorageKey } from './StorageKey';\nimport { StorageKeyReturnType } from './StorageKeyReturnType';\n/**\n * @internalapi\n */\nexport type StorageKeyReturnDefaults = {\n    [key in StorageKey]: StorageKeyReturnType[key];\n};\n/**\n * @internalapi\n */\nexport declare const defaultValues: StorageKeyReturnDefaults;\n"},{name:"@airgap/beacon-types/types/storage/StorageKeyReturnType.d.ts",dts:"import { StorageKey, AccountInfo, AccountIdentifier, P2PPairingRequest, AppMetadata, PermissionInfo, ExtendedWalletConnectPairingResponse, RequestProofOfEventChallengeInput } from '../..';\nimport { ExtendedP2PPairingResponse } from '../P2PPairingResponse';\nimport { PostMessagePairingRequest } from '../PostMessagePairingRequest';\nimport { ExtendedPostMessagePairingResponse } from '../PostMessagePairingResponse';\nimport { PushToken } from '../PushToken';\n/**\n * @internalapi\n */\nexport interface StorageKeyReturnType {\n    [StorageKey.TRANSPORT_P2P_PEERS_DAPP]: P2PPairingRequest[];\n    [StorageKey.TRANSPORT_P2P_PEERS_WALLET]: ExtendedP2PPairingResponse[];\n    [StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP]: PostMessagePairingRequest[];\n    [StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET]: ExtendedPostMessagePairingResponse[];\n    [StorageKey.TRANSPORT_WALLETCONNECT_PEERS_DAPP]: ExtendedWalletConnectPairingResponse[];\n    [StorageKey.LAST_SELECTED_WALLET]: {\n        key: string;\n        name: string;\n        type: 'extension' | 'mobile' | 'web' | 'desktop';\n        icon: string;\n        url?: string;\n    } | undefined;\n    [StorageKey.ACCOUNTS]: AccountInfo[];\n    [StorageKey.ACTIVE_ACCOUNT]: AccountIdentifier | undefined;\n    [StorageKey.PUSH_TOKENS]: PushToken[];\n    [StorageKey.BEACON_SDK_SECRET_SEED]: string | undefined;\n    [StorageKey.BEACON_LAST_ERROR]: string | undefined;\n    [StorageKey.APP_METADATA_LIST]: AppMetadata[];\n    [StorageKey.PERMISSION_LIST]: PermissionInfo[];\n    [StorageKey.ONGOING_PROOF_OF_EVENT_CHALLENGES]: ({\n        contractAddress: string;\n        accountIdentifier: string;\n    } & RequestProofOfEventChallengeInput)[];\n    [StorageKey.BEACON_SDK_VERSION]: string | undefined;\n    [StorageKey.MATRIX_PRESERVED_STATE]: {\n        [key: string]: unknown;\n    };\n    [StorageKey.MATRIX_PEER_ROOM_IDS]: {\n        [key: string]: string | undefined;\n    };\n    [StorageKey.MATRIX_SELECTED_NODE]: string | undefined;\n    [StorageKey.MULTI_NODE_SETUP_DONE]: boolean | undefined;\n    [StorageKey.USER_ID]: string | undefined;\n    [StorageKey.ENABLE_METRICS]: boolean | undefined;\n    [StorageKey.WC_INIT_ERROR]: string | undefined;\n    [StorageKey.WC_2_CLIENT_SESSION]: string | undefined;\n    [StorageKey.WC_2_CORE_PAIRING]: string | undefined;\n    [StorageKey.WC_2_CORE_KEYCHAIN]: string | undefined;\n    [StorageKey.WC_2_CORE_MESSAGES]: string | undefined;\n    [StorageKey.WC_2_CLIENT_PROPOSAL]: string | undefined;\n    [StorageKey.WC_2_CORE_SUBSCRIPTION]: string | undefined;\n    [StorageKey.WC_2_CORE_HISTORY]: string | undefined;\n    [StorageKey.WC_2_CORE_EXPIRER]: string | undefined;\n}\n"},{name:"@airgap/beacon-types/types/tezos/operations/ActivateAccount.d.ts",dts:"import { TezosBaseOperation, TezosOperationType } from '../../..';\n/**\n * @internalapi\n * @category Tezos\n */\nexport interface TezosActivateAccountOperation extends TezosBaseOperation {\n    kind: TezosOperationType.ACTIVATE_ACCOUNT;\n    pkh: string;\n    secret: string;\n}\n"},{name:"@airgap/beacon-types/types/tezos/operations/Attestation.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosAttestationOperation extends TezosBaseOperation {\n    kind: TezosOperationType.ATTESTATION;\n    level: number;\n    slot?: number;\n    round?: number;\n    block_payload_hash?: string;\n}\n"},{name:"@airgap/beacon-types/types/tezos/operations/AttestationWithDal.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosAttestationWithDalOperation extends TezosBaseOperation {\n    kind: TezosOperationType.ATTESTATION_WITH_DAL;\n    slot: number;\n    level: number;\n    round: number;\n    block_payload_hash: string;\n    dal_attestation: string;\n}\n"},{name:"@airgap/beacon-types/types/tezos/operations/AttestationsAggregate.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosPreAttestationsAggregateOperation extends TezosBaseOperation {\n    kind: TezosOperationType.ATTESTATIONS_AGGREGATE;\n    consensus_content: {\n        level: number;\n        round: number;\n        block_payload_hash: string;\n    };\n    committee: {\n        slot: number;\n        dal_attestation?: string;\n    }[];\n}\n"},{name:"@airgap/beacon-types/types/tezos/operations/Ballot.d.ts",dts:"import { TezosBaseOperation, TezosOperationType } from '../../..';\n/**\n * @internalapi\n * @category Tezos\n */\nexport interface TezosBallotOperation extends TezosBaseOperation {\n    kind: TezosOperationType.BALLOT;\n    source: string;\n    period: number;\n    proposal: string;\n    ballot: 'nay' | 'yay' | 'pass';\n}\n"},{name:"@airgap/beacon-types/types/tezos/operations/DalEntrapmentEvidence.d.ts",dts:"import { InlinedAttestation } from '../InlinedAttestation';\nimport { TezosOperationType } from '../OperationTypes';\nexport interface TezosDalPublishCommitmentOperation {\n    kind: TezosOperationType.DAL_ENTRAPMENT_EVIDENCE;\n    attestation: InlinedAttestation;\n    consensus_slot: number;\n    slot_index: number;\n    shard_with_proof: {\n        shard: (number | string[])[];\n        proof: string;\n    };\n}\n"},{name:"@airgap/beacon-types/types/tezos/operations/DalPublishCommitment.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nexport interface TezosDalPublishCommitmentOperation {\n    kind: TezosOperationType.DAL_PUBLISH_COMMITMENT;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    slot_header: {\n        slot_index: number;\n        commitment: string;\n        commitment_proof: string;\n    };\n}\n"},{name:"@airgap/beacon-types/types/tezos/operations/Delegation.d.ts",dts:"import { TezosBaseOperation, TezosOperationType } from '../../..';\n/**\n * @internalapi\n * @category Tezos\n */\nexport interface TezosDelegationOperation extends TezosBaseOperation {\n    kind: TezosOperationType.DELEGATION;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    delegate?: string;\n}\n"},{name:"@airgap/beacon-types/types/tezos/operations/DoubleAttestationEvidence.d.ts",dts:"import { InlinedAttestation } from '../InlinedAttestation';\nimport { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosDoubleAttestationEvidenceOperation extends TezosBaseOperation {\n    kind: TezosOperationType.DOUBLE_ATTESTATION_EVIDENCE;\n    op1: InlinedAttestation;\n    op2: InlinedAttestation;\n    slot?: number;\n}\n"},{name:"@airgap/beacon-types/types/tezos/operations/DoubleBakingEvidence.d.ts",dts:"import { TezosBaseOperation, TezosOperationType, TezosBlockHeader } from '../../..';\n/**\n * @internalapi\n * @category Tezos\n */\nexport interface TezosDoubleBakingEvidenceOperation extends TezosBaseOperation {\n    kind: TezosOperationType.DOUBLE_BAKING_EVIDENCE;\n    bh1: TezosBlockHeader;\n    bh2: TezosBlockHeader;\n}\n"},{name:"@airgap/beacon-types/types/tezos/operations/DoubleConsensusOperationEvidence.d.ts",dts:"import { InlinedAttestation } from '../InlinedAttestation';\nimport { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosUpdateConsensusKeyOperation extends TezosBaseOperation {\n    kind: TezosOperationType.DOUBLE_CONSENSUS_OPERATION_EVIDENCE;\n    slot: number;\n    op1: InlinedAttestation;\n    op2: InlinedAttestation;\n}\n"},{name:"@airgap/beacon-types/types/tezos/operations/DoubleEndorsementEvidence.d.ts",dts:"import { TezosBaseOperation, TezosOperationType } from '../../..';\nexport interface InlinedEndorsement {\n    branch: string;\n    operations: InlinedEndorsementContents;\n    signature?: string;\n}\nexport interface InlinedEndorsementContents extends TezosBaseOperation {\n    kind: TezosOperationType.ENDORSEMENT;\n    level: string;\n    slot?: number;\n    round?: number;\n    block_payload_hash?: string;\n}\n/**\n * @internalapi\n * @category Tezos\n */\nexport interface TezosDoubleEndorsementEvidenceOperation extends TezosBaseOperation {\n    kind: TezosOperationType.DOUBLE_ENDORSEMENT_EVIDENCE;\n    op1: InlinedEndorsement;\n    op2: InlinedEndorsement;\n    slot?: number;\n}\n"},{name:"@airgap/beacon-types/types/tezos/operations/DoublePreAttestationEvidence.d.ts",dts:"import { InlinedPreattestation } from '../InlinedPreattestation';\nimport { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosDoublePreAttestationEvidenceOperation extends TezosBaseOperation {\n    kind: TezosOperationType.DOUBLE_PREATTESTATION_EVIDENCE;\n    op1: InlinedPreattestation;\n    op2: InlinedPreattestation;\n}\n"},{name:"@airgap/beacon-types/types/tezos/operations/DoublePreEndorsementEvidence.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosDoublePreEndorsementEvidenceOperation extends TezosBaseOperation {\n    kind: TezosOperationType.DOUBLE_PREENDORSEMENT_EVIDENCE;\n    op1: InlinedPreEndorsement;\n    op2: InlinedPreEndorsement;\n}\nexport interface InlinedPreEndorsement {\n    branch: string;\n    operations: InlinedPreEndorsementContents;\n    signature?: string;\n}\nexport interface InlinedPreEndorsementContents {\n    kind: TezosOperationType.PREENDORSEMENT;\n    slot: number;\n    level: number;\n    round: number;\n    block_payload_hash: string;\n}\n"},{name:"@airgap/beacon-types/types/tezos/operations/DrainDelegate.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosDrainDelegateOperation extends TezosBaseOperation {\n    kind: TezosOperationType.DRAIN_DELEGATE;\n    consensus_key: string;\n    delegate: string;\n    destination: string;\n}\n"},{name:"@airgap/beacon-types/types/tezos/operations/Endorsement.d.ts",dts:"import { TezosBaseOperation, TezosOperationType } from '../../..';\n/**\n * @internalapi\n * @category Tezos\n */\nexport interface TezosEndorsementOperation extends TezosBaseOperation {\n    kind: TezosOperationType.ENDORSEMENT;\n    level: string;\n    slot?: number;\n    round?: number;\n    block_payload_hash?: string;\n}\n"},{name:"@airgap/beacon-types/types/tezos/operations/EndorsementWithDal.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosEndorsementWithDalOperation extends TezosBaseOperation {\n    kind: TezosOperationType.ENDORSEMENT_WITH_DAL;\n    slot: number;\n    level: number;\n    round: number;\n    block_payload_hash: string;\n    dal_attestation: string;\n}\n"},{name:"@airgap/beacon-types/types/tezos/operations/FailingNoop.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosFailingNoopOperation extends TezosBaseOperation {\n    kind: TezosOperationType.FAILING_NOOP;\n    arbitrary: string;\n}\n"},{name:"@airgap/beacon-types/types/tezos/operations/IncreasePaidStorage.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosIncreasePaidStorageOperation extends TezosBaseOperation {\n    kind: TezosOperationType.INCREASE_PAID_STORAGE;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    amount: string;\n    destination: string;\n}\n"},{name:"@airgap/beacon-types/types/tezos/operations/Origination.d.ts",dts:"import { TezosBaseOperation, TezosOperationType } from '../../..';\nimport { ScriptedContracts } from '../common';\n/**\n * @internalapi\n * @category Tezos\n */\nexport interface TezosOriginationOperation extends TezosBaseOperation {\n    kind: TezosOperationType.ORIGINATION;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    balance: string;\n    delegate?: string;\n    script?: ScriptedContracts;\n}\n"},{name:"@airgap/beacon-types/types/tezos/operations/PreAttestation.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosPreAttestationOperation extends TezosBaseOperation {\n    kind: TezosOperationType.PREATTESTATION;\n    slot: number;\n    level: number;\n    round: number;\n    block_payload_hash: string;\n}\n"},{name:"@airgap/beacon-types/types/tezos/operations/PreAttestationsAggregate.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosPreAttestationsAggregateOperation extends TezosBaseOperation {\n    kind: TezosOperationType.PREATTESTATIONS_AGGREGATE;\n    consensus_content: {\n        level: number;\n        round: number;\n        block_payload_hash: string;\n    };\n    committee: number[];\n}\n"},{name:"@airgap/beacon-types/types/tezos/operations/PreEndorsement.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosPreEndorsementOperation extends TezosBaseOperation {\n    kind: TezosOperationType.PREENDORSEMENT;\n    slot: number;\n    level: number;\n    round: number;\n    block_payload_hash: string;\n}\n"},{name:"@airgap/beacon-types/types/tezos/operations/Proposal.d.ts",dts:"import { TezosBaseOperation, TezosOperationType } from '../../..';\n/**\n * @internalapi\n * @category Tezos\n */\nexport interface TezosProposalOperation extends TezosBaseOperation {\n    kind: TezosOperationType.PROPOSALS;\n    source: string;\n    period: string;\n    proposals: string[];\n}\n"},{name:"@airgap/beacon-types/types/tezos/operations/RegisterGlobalConstant.d.ts",dts:"import { MichelineMichelsonV1Expression } from '../MichelineMichelsonV1Expression';\nimport { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosRegisterGlobalConstantOperation extends TezosBaseOperation {\n    kind: TezosOperationType.REGISTER_GLOBAL_CONSTANT;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    value: MichelineMichelsonV1Expression;\n}\n"},{name:"@airgap/beacon-types/types/tezos/operations/Reveal.d.ts",dts:"import { TezosBaseOperation, TezosOperationType } from '../../..';\n/**\n * @internalapi\n * @category Tezos\n */\nexport interface TezosRevealOperation extends TezosBaseOperation {\n    kind: TezosOperationType.REVEAL;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    public_key: string;\n    proof?: string;\n}\n"},{name:"@airgap/beacon-types/types/tezos/operations/SeedNonceRevelation.d.ts",dts:"import { TezosBaseOperation, TezosOperationType } from '../../..';\n/**\n * @internalapi\n * @category Tezos\n */\nexport interface TezosSeedNonceRevelationOperation extends TezosBaseOperation {\n    kind: TezosOperationType.SEED_NONCE_REVELATION;\n    level: number;\n    nonce: string;\n}\n"},{name:"@airgap/beacon-types/types/tezos/operations/SetDepositsLimit.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosSetDepositsLimitOperation extends TezosBaseOperation {\n    kind: TezosOperationType.SET_DEPOSITS_LIMIT;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    limit?: string;\n}\n"},{name:"@airgap/beacon-types/types/tezos/operations/SmartRollupAddMessages.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosSmartRollupAddMessagesOperation extends TezosBaseOperation {\n    kind: TezosOperationType.SMART_ROLLUP_ADD_MESSAGES;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    message: string[];\n}\n"},{name:"@airgap/beacon-types/types/tezos/operations/SmartRollupCement.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosSmartRollupCementOperation extends TezosBaseOperation {\n    kind: TezosOperationType.SMART_ROLLUP_CEMENT;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    rollup: string;\n    commitment: string;\n}\n"},{name:"@airgap/beacon-types/types/tezos/operations/SmartRollupExecuteOutboxMessage.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosSmartRollupExecuteOutboxMessageOperation extends TezosBaseOperation {\n    kind: TezosOperationType.SMART_ROLLUP_EXECUTE_OUTBOX_MESSAGE;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    rollup: string;\n    cemented_commitment: string;\n    output_proof: string;\n}\n"},{name:"@airgap/beacon-types/types/tezos/operations/SmartRollupOriginate.d.ts",dts:"import { MichelineMichelsonV1Expression } from '../MichelineMichelsonV1Expression';\nimport { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nimport { PvmKind } from '../common';\nexport interface TezosSmartRollupOriginateOperation extends TezosBaseOperation {\n    kind: TezosOperationType.SMART_ROLLUP_ORIGINATE;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    pvm_kind: PvmKind;\n    kernel: string;\n    parameters_ty: MichelineMichelsonV1Expression;\n    whitelist?: string[];\n}\n"},{name:"@airgap/beacon-types/types/tezos/operations/SmartRollupPublish.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nimport { SmartRollupPublishCommitment } from '../common';\nexport interface TezosSmartRollupPublishOperation extends TezosBaseOperation {\n    kind: TezosOperationType.SMART_ROLLUP_PUBLISH;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    rollup: string;\n    commitment: SmartRollupPublishCommitment;\n}\n"},{name:"@airgap/beacon-types/types/tezos/operations/SmartRollupRecoverBond.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosSmartRollupRecoverBondOperation extends TezosBaseOperation {\n    kind: TezosOperationType.SMART_ROLLUP_RECOVER_BOND;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    rollup: string;\n    staker: string;\n}\n"},{name:"@airgap/beacon-types/types/tezos/operations/SmartRollupRefute.d.ts",dts:'import { TezosOperationType } from \'../OperationTypes\';\nimport { TezosBaseOperation } from \'../TezosBaseOperation\';\nexport interface TezosSmartRollupRefuteOperation extends TezosBaseOperation {\n    kind: TezosOperationType.SMART_ROLLUP_REFUTE;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    rollup: string;\n    opponent: string;\n    refutation: SmartRollupRefutation;\n}\nexport type SmartRollupRefutation = SmartRollupRefutationStart | SmartRollupRefutationMove;\nexport interface SmartRollupRefutationStart {\n    refutation_kind: SmartRollupRefutationOptions.START;\n    player_commitment_hash: string;\n    opponent_commitment_hash: string;\n}\nexport interface SmartRollupRefutationMove {\n    refutation_kind: SmartRollupRefutationOptions.MOVE;\n    choice: string;\n    step: SmartRollupRefutationMoveStep;\n}\nexport declare enum SmartRollupRefutationOptions {\n    START = "start",\n    MOVE = "move"\n}\nexport type SmartRollupRefutationMoveStep = SmartRollupRefutationMoveStepDissection[] | SmartRollupRefutationMoveStepProof;\nexport type SmartRollupGameStatus = SmartRollupRefuteGameStatusOptions.ONGOING | SmartRollupRefuteGameStatusEnded;\nexport interface SmartRollupRefutationMoveStepDissection {\n    state?: string;\n    tick: number;\n}\nexport interface SmartRollupRefutationMoveStepProof {\n    pvm_step: string;\n    input_proof?: SmartRollupRefutationMoveInputProof;\n}\nexport declare enum SmartRollupRefuteGameStatusOptions {\n    ONGOING = "ongoing",\n    ENDED = "ended"\n}\nexport interface SmartRollupRefuteGameStatusEnded {\n    result: SmartRollupRefuteGameStatusResult;\n}\nexport type SmartRollupRefutationMoveInputProof = SmartRollupRefutationMoveInputProofInbox | SmartRollupRefutationMoveInputProofReveal | SmartRollupRefutationMoveInputProofFirstInput;\nexport type SmartRollupRefuteGameStatusResult = SmartRollupRefuteGameEndedResultLoser | SmartRollupRefuteGameEndedResultDraw;\nexport interface SmartRollupRefutationMoveInputProofInbox {\n    input_proof_kind: SmartRollupInputProofKind.INBOX_PROOF;\n    level: number;\n    message_counter: string;\n    serialized_proof: string;\n}\nexport interface SmartRollupRefutationMoveInputProofReveal {\n    input_proof_kind: SmartRollupInputProofKind.REVEAL_PROOF;\n    reveal_proof: SmartRollupRefuteRevealProofOptions;\n}\nexport interface SmartRollupRefutationMoveInputProofFirstInput {\n    input_proof_kind: SmartRollupInputProofKind.FIRST_INPUT;\n}\nexport interface SmartRollupRefuteGameEndedResultLoser {\n    kind: SmartRollupRefuteGameEndedPlayerOutcomes.LOSER;\n    reason: SmartRollupRefuteGameEndedReason;\n    player: string;\n}\nexport interface SmartRollupRefuteGameEndedResultDraw {\n    kind: SmartRollupRefuteGameEndedPlayerOutcomes.DRAW;\n}\nexport declare enum SmartRollupInputProofKind {\n    INBOX_PROOF = "inbox_proof",\n    REVEAL_PROOF = "reveal_proof",\n    FIRST_INPUT = "first_input"\n}\nexport type SmartRollupRefuteRevealProofOptions = SmartRollupRefuteRevealProofRaw | SmartRollupRefuteRevealProofMetadata | SmartRollupRefuteRevealProofDalPage;\nexport declare enum SmartRollupRefuteGameEndedPlayerOutcomes {\n    LOSER = "loser",\n    DRAW = "draw"\n}\nexport declare enum SmartRollupRefuteGameEndedReason {\n    CONFLICT_RESOLVED = "conflict_resolved",\n    TIMEOUT = "timeout"\n}\nexport declare enum SmartRollupRefuteRevealProofKind {\n    RAW_DATA_PROOF = "raw_data_proof",\n    METADATA_PROOF = "metadata_proof",\n    DAL_PAGE_PROOF = "dal_page_proof"\n}\nexport interface SmartRollupRefuteRevealProofRaw {\n    reveal_proof_kind: SmartRollupRefuteRevealProofKind.RAW_DATA_PROOF;\n    raw_data: string;\n}\nexport interface SmartRollupRefuteRevealProofMetadata {\n    reveal_proof_kind: SmartRollupRefuteRevealProofKind.METADATA_PROOF;\n}\nexport interface SmartRollupRefuteRevealProofDalPage {\n    reveal_proof_kind: SmartRollupRefuteRevealProofKind.DAL_PAGE_PROOF;\n    dal_page_id: {\n        published_level: number;\n        slot_index: number;\n        page_index: number;\n    };\n    dal_proof: string;\n}\n'},{name:"@airgap/beacon-types/types/tezos/operations/SmartRollupTimeout.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosSmartRollupTimeoutOperation extends TezosBaseOperation {\n    kind: TezosOperationType.SMART_ROLLUP_TIMEOUT;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    rollup: string;\n    stakers: SmartRollupTimeoutStakers;\n}\nexport interface SmartRollupTimeoutStakers {\n    alice: string;\n    bob: string;\n}\n"},{name:"@airgap/beacon-types/types/tezos/operations/Transaction.d.ts",dts:"import { TezosBaseOperation, TezosOperationType, TezosTransactionParameters } from '../../..';\n/**\n * @internalapi\n * @category Tezos\n */\nexport interface TezosTransactionOperation extends TezosBaseOperation {\n    kind: TezosOperationType.TRANSACTION;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    amount: string;\n    destination: string;\n    parameters?: TezosTransactionParameters;\n}\n"},{name:"@airgap/beacon-types/types/tezos/operations/TransferTicket.d.ts",dts:"import { MichelineMichelsonV1Expression } from '../MichelineMichelsonV1Expression';\nimport { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosTransferTicketOperation extends TezosBaseOperation {\n    kind: TezosOperationType.TRANSFER_TICKET;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    ticket_contents: MichelineMichelsonV1Expression;\n    ticket_ty: MichelineMichelsonV1Expression;\n    ticket_ticketer: string;\n    ticket_amount: string;\n    destination: string;\n    entrypoint: string;\n}\n"},{name:"@airgap/beacon-types/types/tezos/operations/UpdateCompanionKey.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosUpdateConsensusKeyOperation extends TezosBaseOperation {\n    kind: TezosOperationType.UPDATE_COMPANION_KEY;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    pk: string;\n    proof?: string;\n}\n"},{name:"@airgap/beacon-types/types/tezos/operations/UpdateConsensusKey.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosUpdateConsensusKeyOperation extends TezosBaseOperation {\n    kind: TezosOperationType.UPDATE_CONSENSUS_KEY;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    pk: string;\n    proof?: string;\n}\n"},{name:"@airgap/beacon-types/types/tezos/operations/VdfRevelation.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosVdfRevelationOperation extends TezosBaseOperation {\n    kind: TezosOperationType.VDF_REVELATION;\n    solution: string[];\n}\n"},{name:"@airgap/beacon-types/types/tezos/InlinedAttestation.d.ts",dts:"import { TezosOperationType } from './OperationTypes';\nexport interface InlinedAttestation {\n    branch: string;\n    operations: InlinedAttestationContents;\n    signature?: string;\n}\nexport interface InlinedAttestationContents {\n    kind: InlinedAttestationKindEnum;\n    slot?: number;\n    round?: number;\n    block_payload_hash?: string;\n    level: number;\n}\nexport type InlinedAttestationKindEnum = TezosOperationType.ATTESTATION;\n"},{name:"@airgap/beacon-types/types/tezos/InlinedPreattestation.d.ts",dts:"import { TezosOperationType } from './OperationTypes';\nexport interface InlinedPreattestation {\n    branch: string;\n    operations: InlinedPreattestationContents;\n    signature?: string;\n}\nexport interface InlinedPreattestationContents {\n    kind: TezosOperationType.PREATTESTATION;\n    slot: number;\n    level: number;\n    round: number;\n    block_payload_hash: string;\n}\n"},{name:"@airgap/beacon-types/types/tezos/MichelineMichelsonV1Expression.d.ts",dts:"import { MichelsonPrimitives } from '../..';\n/**\n * @internalapi\n * @category Tezos\n */\nexport type MichelineMichelsonV1Expression = {\n    int: string;\n} | {\n    string: string;\n} | {\n    bytes: string;\n} | MichelineMichelsonV1Expression[] | {\n    prim: MichelsonPrimitives;\n    args?: MichelineMichelsonV1Expression[];\n    annots?: string[];\n};\n"},{name:"@airgap/beacon-types/types/tezos/MichelsonPrimitives.d.ts",dts:"/**\n * @internalapi\n * @category Tezos\n */\nexport type MichelsonPrimitives = 'ADD' | 'IF_NONE' | 'SWAP' | 'set' | 'nat' | 'CHECK_SIGNATURE' | 'IF_LEFT' | 'LAMBDA' | 'Elt' | 'CREATE_CONTRACT' | 'NEG' | 'big_map' | 'map' | 'or' | 'BLAKE2B' | 'bytes' | 'SHA256' | 'SET_DELEGATE' | 'CONTRACT' | 'LSL' | 'SUB' | 'IMPLICIT_ACCOUNT' | 'PACK' | 'list' | 'PAIR' | 'Right' | 'contract' | 'GT' | 'LEFT' | 'STEPS_TO_QUOTA' | 'storage' | 'TRANSFER_TOKENS' | 'CDR' | 'SLICE' | 'PUSH' | 'False' | 'SHA512' | 'CHAIN_ID' | 'BALANCE' | 'signature' | 'DUG' | 'SELF' | 'EMPTY_BIG_MAP' | 'LSR' | 'OR' | 'XOR' | 'lambda' | 'COMPARE' | 'key' | 'option' | 'Unit' | 'Some' | 'UNPACK' | 'NEQ' | 'INT' | 'pair' | 'AMOUNT' | 'DIP' | 'ABS' | 'ISNAT' | 'EXEC' | 'NOW' | 'LOOP' | 'chain_id' | 'string' | 'MEM' | 'MAP' | 'None' | 'address' | 'CONCAT' | 'EMPTY_SET' | 'MUL' | 'LOOP_LEFT' | 'timestamp' | 'LT' | 'UPDATE' | 'DUP' | 'SOURCE' | 'mutez' | 'SENDER' | 'IF_CONS' | 'RIGHT' | 'CAR' | 'CONS' | 'LE' | 'NONE' | 'IF' | 'SOME' | 'GET' | 'Left' | 'CAST' | 'int' | 'SIZE' | 'key_hash' | 'unit' | 'DROP' | 'EMPTY_MAP' | 'NIL' | 'DIG' | 'APPLY' | 'bool' | 'RENAME' | 'operation' | 'True' | 'FAILWITH' | 'parameter' | 'HASH_KEY' | 'EQ' | 'NOT' | 'UNIT' | 'Pair' | 'ADDRESS' | 'EDIV' | 'CREATE_ACCOUNT' | 'GE' | 'ITER' | 'code' | 'AND';\n"},{name:"@airgap/beacon-types/types/tezos/OperationTypes.d.ts",dts:'/**\n * @publicapi\n * @category Tezos\n */\nexport declare enum TezosOperationType {\n    ACTIVATE_ACCOUNT = "activate_account",\n    ATTESTATION = "attestation",\n    ATTESTATIONS_AGGREGATE = "attestations_aggregate",\n    ATTESTATION_WITH_DAL = "attestation_with_dal",\n    BALLOT = "ballot",\n    DAL_PUBLISH_COMMITMENT = "dal_publish_commitment",\n    DELEGATION = "delegation",\n    DRAIN_DELEGATE = "drain_delegate",\n    DOUBLE_ATTESTATION_EVIDENCE = "double_attestation_evidence",\n    DOUBLE_BAKING_EVIDENCE = "double_baking_evidence",\n    DOUBLE_ENDORSEMENT_EVIDENCE = "double_endorsement_evidence",\n    DOUBLE_PREATTESTATION_EVIDENCE = "double_preattestation_evidence",\n    DOUBLE_PREENDORSEMENT_EVIDENCE = "double_preendorsement_evidence",\n    ENDORSEMENT = "endorsement",\n    ENDORSEMENT_WITH_DAL = "endorsement_with_dal",\n    EVENT = "event",\n    FAILING_NOOP = "failing_noop",\n    INCREASE_PAID_STORAGE = "increase_paid_storage",\n    ORIGINATION = "origination",\n    PREATTESTATION = "preattestation",\n    PREATTESTATIONS_AGGREGATE = "preattestations_aggregate",\n    PREENDORSEMENT = "preendorsement",\n    PROPOSALS = "proposals",\n    REGISTER_GLOBAL_CONSTANT = "register_global_constant",\n    REVEAL = "reveal",\n    SEED_NONCE_REVELATION = "seed_nonce_revelation",\n    SET_DEPOSITS_LIMIT = "set_deposits_limit",\n    SMART_ROLLUP_ADD_MESSAGES = "smart_rollup_add_messages",\n    SMART_ROLLUP_CEMENT = "smart_rollup_cement",\n    SMART_ROLLUP_EXECUTE_OUTBOX_MESSAGE = "smart_rollup_execute_outbox_message",\n    SMART_ROLLUP_ORIGINATE = "smart_rollup_originate",\n    SMART_ROLLUP_PUBLISH = "smart_rollup_publish",\n    SMART_ROLLUP_RECOVER_BOND = "smart_rollup_recover_bond",\n    SMART_ROLLUP_REFUTE = "smart_rollup_refute",\n    SMART_ROLLUP_TIMEOUT = "smart_rollup_timeout",\n    TICKET_UPDATES = "ticket_updates",\n    TRANSACTION = "transaction",\n    TRANSFER_TICKET = "transfer_ticket",\n    UPDATE_CONSENSUS_KEY = "update_consensus_key",\n    UPDATE_COMPANION_KEY = "update_companion_key",\n    VDF_REVELATION = "vdf_revelation",\n    DOUBLE_CONSENSUS_OPERATION_EVIDENCE = "double_consensus_operation_evidence",\n    DAL_ENTRAPMENT_EVIDENCE = "dal_entrapment_evidence"\n}\n'},{name:"@airgap/beacon-types/types/tezos/PartialTezosOperation.d.ts",dts:"import { Optional, TezosAttestationOperation, TezosAttestationWithDalOperation, TezosDoubleAttestationEvidenceOperation, TezosDoublePreAttestationEvidenceOperation, TezosDoublePreEndorsementEvidenceOperation, TezosDrainDelegateOperation, TezosEndorsementWithDalOperation, TezosFailingNoopOperation, TezosIncreasePaidStorageOperation, TezosPreAttestationOperation, TezosRegisterGlobalConstantOperation, TezosSetDepositsLimitOperation, TezosSmartRollupAddMessagesOperation, TezosSmartRollupCementOperation, TezosSmartRollupExecuteOutboxMessageOperation, TezosSmartRollupOriginateOperation, TezosSmartRollupPublishOperation, TezosSmartRollupRecoverBondOperation, TezosSmartRollupRefuteOperation, TezosTransferTicketOperation, TezosUpdateConsensusKeyOperation, TezosVdfRevelationOperation } from '@airgap/beacon-types';\nimport { TezosActivateAccountOperation } from './operations/ActivateAccount';\nimport { TezosBallotOperation } from './operations/Ballot';\nimport { TezosDelegationOperation } from './operations/Delegation';\nimport { TezosDoubleBakingEvidenceOperation } from './operations/DoubleBakingEvidence';\nimport { TezosEndorsementOperation } from './operations/Endorsement';\nimport { TezosOriginationOperation } from './operations/Origination';\nimport { TezosProposalOperation } from './operations/Proposal';\nimport { TezosRevealOperation } from './operations/Reveal';\nimport { TezosSeedNonceRevelationOperation } from './operations/SeedNonceRevelation';\nimport { TezosTransactionOperation } from './operations/Transaction';\nimport { TezosPreEndorsementOperation } from './operations/PreEndorsement';\nimport { TezosDalPublishCommitmentOperation } from './operations/DalPublishCommitment';\n/**\n * @publicapi\n * @category Tezos\n */\nexport type omittedProperties = 'source' | 'fee' | 'counter' | 'gas_limit' | 'storage_limit';\n/**\n * @internalapi\n * @category Tezos\n */\nexport type PartialTezosDelegationOperation = Optional<TezosDelegationOperation, omittedProperties>;\n/**\n * @internalapi\n * @category Tezos\n */\nexport type PartialTezosOriginationOperation = Optional<TezosOriginationOperation, omittedProperties>;\n/**\n * @internalapi\n * @category Tezos\n */\nexport type PartialTezosRevealOperation = Optional<TezosRevealOperation, omittedProperties>;\n/**\n * @internalapi\n * @category Tezos\n */\nexport type PartialTezosTransactionOperation = Optional<TezosTransactionOperation, omittedProperties>;\n/**\n * @internalapi\n * @category Tezos\n */\nexport type PartialTezosSetDepositsLimitOperation = Optional<TezosSetDepositsLimitOperation, omittedProperties>;\n/**\n * @internalapi\n * @category Tezos\n */\nexport type PartialTezosRegisterGlobalConstantOperation = Optional<TezosRegisterGlobalConstantOperation, omittedProperties>;\n/**\n * @internalapi\n * @category Tezos\n */\nexport type PartialTezosTransferTicketOperation = Optional<TezosTransferTicketOperation, omittedProperties>;\n/**\n * @internalapi\n * @category Tezos\n */\nexport type PartialTezosIncreasePaidStorageOperation = Optional<TezosIncreasePaidStorageOperation, omittedProperties>;\n/**\n * @internalapi\n * @category Tezos\n */\nexport type PartialTezosUpdateConsensusKeyOperation = Optional<TezosUpdateConsensusKeyOperation, omittedProperties>;\n/**\n * @internalapi\n * @category Tezos\n */\nexport type PartialTezosSmartRollupOriginateOperation = Optional<TezosSmartRollupOriginateOperation, omittedProperties>;\n/**\n * @internalapi\n * @category Tezos\n */\nexport type PartialTezosSmartRollupAddMessagesOperation = Optional<TezosSmartRollupAddMessagesOperation, omittedProperties>;\n/**\n * @internalapi\n * @category Tezos\n */\nexport type PartialTezosSmartRollupExecuteOutboxMessageOperation = Optional<TezosSmartRollupExecuteOutboxMessageOperation, omittedProperties>;\n/**\n * @internalapi\n * @category Tezos\n */\nexport type PartialTezosSmartRollupPublishOperation = Optional<TezosSmartRollupPublishOperation, omittedProperties>;\n/**\n * @internalapi\n * @category Tezos\n */\nexport type PartialTezosSmartRollupCementOperation = Optional<TezosSmartRollupCementOperation, omittedProperties>;\n/**\n * @internalapi\n * @category Tezos\n */\nexport type PartialTezosSmartRollupRecoverBondOperation = Optional<TezosSmartRollupRecoverBondOperation, omittedProperties>;\n/**\n * @internalapi\n * @category Tezos\n */\nexport type PartialTezosSmartRollupRefuteOperation = Optional<TezosSmartRollupRefuteOperation, omittedProperties>;\n/**\n * @internalapi\n * @category Tezos\n */\nexport type PartialTezosSmartRollupTimeoutOperation = Optional<TezosSmartRollupRefuteOperation, omittedProperties>;\nexport type PartialTezosDalPublishCommitmentOperation = Optional<TezosDalPublishCommitmentOperation, omittedProperties>;\n/**\n * @publicapi\n * @category Tezos\n */\nexport type PartialTezosOperation = TezosActivateAccountOperation | TezosBallotOperation | PartialTezosDelegationOperation | TezosDoubleBakingEvidenceOperation | TezosEndorsementOperation | PartialTezosOriginationOperation | TezosProposalOperation | PartialTezosRevealOperation | TezosSeedNonceRevelationOperation | PartialTezosTransactionOperation | TezosAttestationOperation | TezosPreAttestationOperation | TezosPreEndorsementOperation | PartialTezosSetDepositsLimitOperation | TezosDoublePreAttestationEvidenceOperation | TezosDoublePreEndorsementEvidenceOperation | TezosAttestationWithDalOperation | TezosEndorsementWithDalOperation | TezosDoubleAttestationEvidenceOperation | TezosFailingNoopOperation | PartialTezosRegisterGlobalConstantOperation | PartialTezosTransferTicketOperation | PartialTezosIncreasePaidStorageOperation | PartialTezosUpdateConsensusKeyOperation | TezosDrainDelegateOperation | TezosVdfRevelationOperation | PartialTezosSmartRollupOriginateOperation | PartialTezosSmartRollupAddMessagesOperation | PartialTezosSmartRollupExecuteOutboxMessageOperation | PartialTezosSmartRollupPublishOperation | PartialTezosSmartRollupCementOperation | PartialTezosSmartRollupRecoverBondOperation | PartialTezosSmartRollupRefuteOperation | PartialTezosSmartRollupTimeoutOperation | PartialTezosDalPublishCommitmentOperation;\n"},{name:"@airgap/beacon-types/types/tezos/TezosBaseOperation.d.ts",dts:"import { TezosOperationType } from '../..';\n/**\n * @internalapi\n * @category Tezos\n */\nexport interface TezosBaseOperation {\n    kind: TezosOperationType;\n}\n"},{name:"@airgap/beacon-types/types/tezos/TezosBlockHeader.d.ts",dts:"/**\n * @internalapi\n * @category Tezos\n */\nexport interface TezosBlockHeader {\n    level: number;\n    proto: number;\n    predecessor: string;\n    timestamp: Date | string;\n    validation_pass: number;\n    operations_hash: string;\n    fitness: string[];\n    context: string;\n    payload_hash?: string;\n    payload_round?: number;\n    priority?: number;\n    proof_of_work_nonce: string;\n    seed_nonce_hash?: string;\n    liquidity_baking_toggle_vote?: 'on' | 'off' | 'pass';\n    adaptive_issuance_vote?: 'on' | 'off' | 'pass';\n    liquidity_baking_escape_vote?: boolean | 'on' | 'off' | 'pass';\n    signature: string;\n}\n"},{name:"@airgap/beacon-types/types/tezos/TezosOperation.d.ts",dts:"import { TezosActivateAccountOperation, TezosBallotOperation, TezosDelegationOperation, TezosDoubleBakingEvidenceOperation, TezosEndorsementOperation, TezosOriginationOperation, TezosProposalOperation, TezosRevealOperation, TezosSeedNonceRevelationOperation, TezosTransactionOperation } from '../..';\n/**\n * @internalapi\n * @category Tezos\n */\nexport type TezosOperation = TezosActivateAccountOperation | TezosBallotOperation | TezosDelegationOperation | TezosDoubleBakingEvidenceOperation | TezosEndorsementOperation | TezosOriginationOperation | TezosProposalOperation | TezosRevealOperation | TezosSeedNonceRevelationOperation | TezosTransactionOperation;\n"},{name:"@airgap/beacon-types/types/tezos/TezosTransactionParameters.d.ts",dts:"import { MichelineMichelsonV1Expression } from './MichelineMichelsonV1Expression';\n/**\n * @internalapi\n * @category Tezos\n */\nexport interface TezosTransactionParameters {\n    entrypoint: 'default' | 'root' | 'do' | 'set_delegate' | 'remove_delegate' | 'deposit' | 'stake' | 'unstake' | 'finalize_unstake' | 'set_delegate_parameters' | string;\n    value: MichelineMichelsonV1Expression;\n}\n"},{name:"@airgap/beacon-types/types/tezos/common.d.ts",dts:'import { MichelineMichelsonV1Expression } from \'./MichelineMichelsonV1Expression\';\nimport { TezosOperationType } from \'./OperationTypes\';\nexport type MetadataBalanceUpdatesKindEnum = \'contract\' | \'freezer\' | \'accumulator\' | \'burned\' | \'commitment\' | \'minted\' | \'staking\';\nexport type MetadataBalanceUpdatesOriginEnum = \'block\' | \'migration\' | \'subsidy\' | \'simulation\' | \'delayed_operation\';\nexport type MetadataBalanceUpdatesCategoryEnum = METADATA_BALANCE_UPDATES_CATEGORY;\nexport declare enum METADATA_BALANCE_UPDATES_CATEGORY {\n    BAKING_BONUSES = "baking bonuses",\n    BAKING_REWARDS = "baking rewards",\n    BLOCK_FEES = "block fees",\n    BONDS = "bonds",\n    BOOTSTRAP = "bootstrap",\n    BURNED = "burned",\n    COMMITMENT = "commitment",\n    DELEGATE_DENOMINATOR = "delegate_denominator",\n    DELEGATOR_NUMERATOR = "delegator_numerator",\n    DEPOSITS = "deposits",\n    ENDORSING_REWARDS = "endorsing rewards",\n    INVOICE = "invoice",\n    LOST_ENDORSING_REWARDS = "lost endorsing rewards",\n    MINTED = "minted",\n    NONCE_REVELATION_REWARDS = "nonce revelation rewards",\n    PUNISHMENTS = "punishments",\n    SMART_ROLLUP_REFUTATION_PUNISHMENTS = "smart_rollup_refutation_punishments",\n    SMART_ROLLUP_REFUTATION_REWARDS = "smart_rollup_refutation_rewards",\n    STORAGE_FEES = "storage fees",\n    SUBSIDY = "subsidy",\n    UNSTAKED_DEPOSITS = "unstaked_deposits"\n}\nexport type FrozenStaker = SingleStaker | SharedStaker | Baker;\nexport type Staker = SingleStaker | SharedStaker;\nexport interface SingleStaker {\n    contract: string;\n    delegate: string;\n}\nexport interface SharedStaker {\n    delegate: string;\n}\nexport interface Baker {\n    baker: string;\n}\nexport type BondId = {\n    smart_rollup: string;\n};\nexport type InternalOperationResultKindEnum = TezosOperationType.TRANSACTION | TezosOperationType.ORIGINATION | TezosOperationType.DELEGATION | TezosOperationType.EVENT;\nexport interface TransactionOperationParameter {\n    entrypoint: string;\n    value: MichelineMichelsonV1Expression;\n}\nexport interface ScriptedContracts {\n    code: MichelineMichelsonV1Expression[];\n    storage: MichelineMichelsonV1Expression;\n}\nexport type ContractBigMapDiff = ContractBigMapDiffItem[];\nexport interface ContractBigMapDiffItem {\n    key_hash?: string;\n    key?: MichelineMichelsonV1Expression;\n    value?: MichelineMichelsonV1Expression;\n    action?: DiffActionEnum;\n    big_map?: string;\n    source_big_map?: string;\n    destination_big_map?: string;\n    key_type?: MichelineMichelsonV1Expression;\n    value_type?: MichelineMichelsonV1Expression;\n}\nexport type DiffActionEnum = \'update\' | \'remove\' | \'copy\' | \'alloc\';\nexport type LazyStorageDiff = LazyStorageDiffBigMap | LazyStorageDiffSaplingState;\nexport interface LazyStorageDiffBigMap {\n    kind: \'big_map\';\n    id: string;\n    diff: LazyStorageDiffBigMapItems;\n}\nexport interface LazyStorageDiffSaplingState {\n    kind: \'sapling_state\';\n    id: string;\n    diff: LazyStorageDiffSaplingStateItems;\n}\nexport interface LazyStorageDiffBigMapItems {\n    action: DiffActionEnum;\n    updates?: LazyStorageDiffUpdatesBigMap[];\n    source?: string;\n    key_type?: MichelineMichelsonV1Expression;\n    value_type?: MichelineMichelsonV1Expression;\n}\nexport interface LazyStorageDiffUpdatesBigMap {\n    key_hash: string;\n    key: MichelineMichelsonV1Expression;\n    value?: MichelineMichelsonV1Expression;\n}\nexport interface LazyStorageDiffSaplingStateItems {\n    action: DiffActionEnum;\n    updates?: LazyStorageDiffUpdatesSaplingState;\n    source?: string;\n    memo_size?: number;\n}\nexport interface LazyStorageDiffUpdatesSaplingState {\n    commitments_and_ciphertexts: CommitmentsAndCiphertexts[];\n    nullifiers: string[];\n}\nexport type CommitmentsAndCiphertexts = [string, SaplingTransactionCiphertext];\nexport interface SaplingTransactionCiphertext {\n    cv: string;\n    epk: string;\n    payload_enc: string;\n    nonce_enc: string;\n    payload_out: string;\n    nonce_out: string;\n}\nexport declare enum PvmKind {\n    WASM2 = "wasm_2_0_0",\n    ARITH = "arith",\n    RISCV = "riscv"\n}\nexport interface SmartRollupPublishCommitment {\n    compressed_state: string;\n    inbox_level: number;\n    predecessor: string;\n    number_of_ticks: string;\n}\n'},{name:"@airgap/beacon-types/types/transport/TransportStatus.d.ts",dts:'export declare enum TransportStatus {\n    NOT_CONNECTED = "NOT_CONNECTED",\n    CONNECTING = "CONNECTING",\n    CONNECTED = "CONNECTED",\n    SECONDARY_TAB_CONNECTED = "SECONDARY_TAB_CONNECTED"\n}\n'},{name:"@airgap/beacon-types/types/transport/TransportType.d.ts",dts:'/**\n * @internalapi\n */\nexport declare enum TransportType {\n    CHROME_MESSAGE = "chrome_message",\n    WALLETCONNECT = "walletconnect",\n    POST_MESSAGE = "post_message",\n    LEDGER = "ledger",\n    P2P = "p2p"\n}\n'},{name:"@airgap/beacon-types/types/utils/Optional.d.ts",dts:"export type Optional<T, K extends keyof T> = Partial<T> & Omit<T, K>;\n"},{name:"@airgap/beacon-types/types/AccountInfo.d.ts",dts:"import { PermissionEntity } from './PermissionEntity';\nimport { Notification } from './Notification';\nimport { Origin } from './Origin';\nexport type AccountIdentifier = string;\nexport interface AccountInfo extends PermissionEntity {\n    accountIdentifier: AccountIdentifier;\n    senderId: string;\n    origin: {\n        type: Origin;\n        id: string;\n    };\n    walletKey?: string;\n    publicKey?: string;\n    connectedAt: number;\n    notification?: Notification;\n    hasVerifiedChallenge?: boolean;\n    walletType: 'implicit' | 'abstracted_account';\n    verificationType?: 'proof_of_event';\n}\n"},{name:"@airgap/beacon-types/types/AnalyticsInterface.d.ts",dts:"export interface AnalyticsInterface {\n    track(trigger: 'click' | 'event', section: string, label: string, data?: Record<string, any>): void;\n}\n"},{name:"@airgap/beacon-types/types/BeaconErrorType.d.ts",dts:'export declare enum BeaconErrorType {\n    /**\n     * {@link BroadcastBeaconError}\n     *\n     * Will be returned if the user chooses that the transaction is broadcast but there is an error (eg. node not available).\n     *\n     * Returned by: Broadcast | Operation Request\n     */\n    BROADCAST_ERROR = "BROADCAST_ERROR",\n    /**\n     * {@link NetworkNotSupportedBeaconError}\n     *\n     * Will be returned if the selected network is not supported by the wallet / extension.\n     *\n     * Returned by: Permission\n     */\n    NETWORK_NOT_SUPPORTED = "NETWORK_NOT_SUPPORTED",\n    /**\n     * {@link NoAddressBeaconError}\n     *\n     * Will be returned if there is no address present for the protocol / network requested.\n     *\n     * Returned by: Permission\n     */\n    NO_ADDRESS_ERROR = "NO_ADDRESS_ERROR",\n    /**\n     * {@link NoPrivateKeyBeaconError}\n     *\n     * Will be returned if the private key matching the sourceAddress could not be found.\n     *\n     * Returned by: Sign\n     */\n    NO_PRIVATE_KEY_FOUND_ERROR = "NO_PRIVATE_KEY_FOUND_ERROR",\n    /**\n     * {@link NotGrantedBeaconError}\n     *\n     * Will be returned if the signature was blocked // (Not needed?) Permission: Will be returned if the permissions requested by the App were not granted.\n     *\n     * Returned by: Sign\n     */\n    NOT_GRANTED_ERROR = "NOT_GRANTED_ERROR",\n    /**\n     * {@link ParametersInvalidBeaconError}\n     *\n     * Will be returned if any of the parameters are invalid.\n     *\n     * Returned by: Operation Request\n     */\n    PARAMETERS_INVALID_ERROR = "PARAMETERS_INVALID_ERROR",\n    /**\n     * {@link TooManyOperationsBeaconError}\n     *\n     * Will be returned if too many operations were in the request and they were not able to fit into a single operation group.\n     *\n     * Returned by: Operation Request\n     */\n    TOO_MANY_OPERATIONS = "TOO_MANY_OPERATIONS",\n    /**\n     * {@link TransactionInvalidBeaconError}\n     *\n     * Will be returned if the transaction is not parsable or is rejected by the node.\n     *\n     * Returned by: Broadcast\n     */\n    TRANSACTION_INVALID_ERROR = "TRANSACTION_INVALID_ERROR",\n    /**\n     * {@link SignatureTypeNotSupportedBeaconError}\n     *\n     * Will be returned if the signing type is not supported.\n     *\n     * Returned by: Sign\n     */\n    SIGNATURE_TYPE_NOT_SUPPORTED = "SIGNATURE_TYPE_NOT_SUPPORTED",\n    /**\n     * {@link AbortedBeaconError}\n     *\n     * Will be returned if the request was aborted by the user or the wallet.\n     *\n     * Returned by: Permission | Operation Request | Sign Request | Broadcast\n     */\n    ABORTED_ERROR = "ABORTED_ERROR",\n    /**\n     * {@link UnknownBeaconError}\n     *\n     * Used as a wildcard if an unexpected error occured.\n     *\n     * Returned by: Permission | Operation Request | Sign Request | Broadcast\n     */\n    UNKNOWN_ERROR = "UNKNOWN_ERROR"\n}\n'},{name:"@airgap/beacon-types/types/ColorMode.d.ts",dts:'export declare enum ColorMode {\n    LIGHT = "light",\n    DARK = "dark"\n}\n'},{name:"@airgap/beacon-types/types/ConnectionContext.d.ts",dts:'import { Origin } from "./Origin";\n/**\n * @internalapi\n */\nexport interface ConnectionContext {\n    origin: Origin;\n    id: string;\n    extras?: {\n        sender: chrome.runtime.MessageSender;\n        sendResponse(response?: unknown): void;\n    };\n}\n'},{name:"@airgap/beacon-types/types/EncryptionOperation.d.ts",dts:""},{name:"@airgap/beacon-types/types/EncryptionType.d.ts",dts:""},{name:"@airgap/beacon-types/types/Extension.d.ts",dts:"export interface Extension {\n    id: string;\n    name: string;\n    shortName?: string;\n    iconUrl?: string;\n    color?: string;\n}\n"},{name:"@airgap/beacon-types/types/ExtensionMessage.d.ts",dts:'import { ExtensionMessageTarget } from "./ExtensionMessageTarget";\n/**\n * @internalapi\n */\nexport interface ExtensionMessage<T, U = unknown> {\n    target: ExtensionMessageTarget;\n    targetId?: string;\n    sender?: U;\n    payload: T;\n}\n/**\n * @internalapi\n */\nexport interface EncryptedExtensionMessage<U = unknown> {\n    target: ExtensionMessageTarget;\n    targetId?: string;\n    sender?: U;\n    encryptedPayload: string;\n}\n'},{name:"@airgap/beacon-types/types/ExtensionMessageTarget.d.ts",dts:'/**\n * @internalapi\n */\nexport declare enum ExtensionMessageTarget {\n    BACKGROUND = "toBackground",\n    PAGE = "toPage",\n    EXTENSION = "toExtension"\n}\n'},{name:"@airgap/beacon-types/types/Notification.d.ts",dts:"export interface Notification {\n    version: number;\n    apiUrl: string;\n    token: string;\n}\n"},{name:"@airgap/beacon-types/types/Origin.d.ts",dts:'/**\n * @internalapi\n */\nexport declare enum Origin {\n    WEBSITE = "website",\n    EXTENSION = "extension",\n    P2P = "p2p",\n    WALLETCONNECT = "walletconnect"\n}\n'},{name:"@airgap/beacon-types/types/P2PPairingRequest.d.ts",dts:"import { ExtendedPeerInfo, PeerInfo } from './PeerInfo';\n/**\n * @internalapi\n */\nexport declare class P2PPairingRequest implements PeerInfo {\n    readonly type: string;\n    relayServer: string;\n    id: string;\n    name: string;\n    icon?: string | undefined;\n    appUrl?: string | undefined;\n    publicKey: string;\n    version: string;\n    constructor(id: string, name: string, publicKey: string, version: string, relayServer: string, icon?: string, appUrl?: string);\n}\n/**\n * @internalapi\n */\nexport declare class ExtendedP2PPairingRequest extends P2PPairingRequest implements ExtendedPeerInfo {\n    senderId: string;\n    constructor(id: string, name: string, publicKey: string, version: string, relayServer: string, senderId: string, icon?: string, appUrl?: string);\n}\n"},{name:"@airgap/beacon-types/types/P2PPairingResponse.d.ts",dts:"import { ExtendedPeerInfo, PeerInfo } from './PeerInfo';\n/**\n * @internalapi\n */\nexport declare class P2PPairingResponse implements PeerInfo {\n    readonly type: string;\n    relayServer: string;\n    id: string;\n    name: string;\n    icon?: string | undefined;\n    appUrl?: string | undefined;\n    publicKey: string;\n    version: string;\n    constructor(id: string, name: string, publicKey: string, version: string, relayServer: string, icon?: string, appUrl?: string);\n}\n/**\n * @internalapi\n */\nexport declare class ExtendedP2PPairingResponse extends P2PPairingResponse implements ExtendedPeerInfo {\n    senderId: string;\n    constructor(id: string, name: string, publicKey: string, version: string, relayServer: string, senderId: string, icon?: string, appUrl?: string);\n}\n"},{name:"@airgap/beacon-types/types/PeerInfo.d.ts",dts:"export interface PeerInfo {\n    id: string;\n    name: string;\n    type: string;\n    icon?: string;\n    appUrl?: string;\n    publicKey: string;\n    version: string;\n}\nexport interface ExtendedPeerInfo extends PeerInfo {\n    senderId: string;\n}\nexport type PeerInfoType = PeerInfo | ExtendedPeerInfo;\n"},{name:"@airgap/beacon-types/types/PermissionEntity.d.ts",dts:"import { Network } from './beacon/Network';\nimport { PermissionScope } from './beacon/PermissionScope';\nimport { Threshold } from './beacon/Threshold';\nexport interface PermissionEntity {\n    address: string;\n    network: Network;\n    scopes: PermissionScope[];\n    threshold?: Threshold;\n}\n"},{name:"@airgap/beacon-types/types/PermissionInfo.d.ts",dts:"import { AppMetadata } from './beacon/AppMetadata';\nimport { PermissionEntity } from './PermissionEntity';\nexport interface PermissionInfo extends PermissionEntity {\n    accountIdentifier: string;\n    senderId: string;\n    appMetadata: AppMetadata;\n    website: string;\n    publicKey?: string;\n    connectedAt: number;\n}\n"},{name:"@airgap/beacon-types/types/PostMessagePairingRequest.d.ts",dts:"import { ExtendedPeerInfo, PeerInfo } from './PeerInfo';\n/**\n * @internalapi\n */\nexport declare class PostMessagePairingRequest implements PeerInfo {\n    readonly type: string;\n    id: string;\n    name: string;\n    icon?: string | undefined;\n    appUrl?: string | undefined;\n    publicKey: string;\n    version: string;\n    constructor(id: string, name: string, publicKey: string, version: string, icon?: string, appUrl?: string);\n}\n/**\n * @internalapi\n */\nexport declare class ExtendedPostMessagePairingRequest extends PostMessagePairingRequest implements ExtendedPeerInfo {\n    senderId: string;\n    constructor(id: string, name: string, publicKey: string, version: string, senderId: string, icon?: string, appUrl?: string);\n}\n"},{name:"@airgap/beacon-types/types/PostMessagePairingResponse.d.ts",dts:"import { ExtendedPeerInfo, PeerInfo } from './PeerInfo';\n/**\n * @internalapi\n */\nexport declare class PostMessagePairingResponse implements PeerInfo {\n    readonly type: string;\n    id: string;\n    name: string;\n    icon?: string | undefined;\n    appUrl?: string | undefined;\n    publicKey: string;\n    version: string;\n    constructor(id: string, name: string, publicKey: string, version: string, icon?: string, appUrl?: string);\n}\n/**\n * @internalapi\n */\nexport declare class ExtendedPostMessagePairingResponse extends PostMessagePairingResponse implements ExtendedPeerInfo {\n    senderId: string;\n    extensionId: string;\n    constructor(id: string, name: string, publicKey: string, version: string, senderId: string, extensionId: string, icon?: string, appUrl?: string);\n}\n"},{name:"@airgap/beacon-types/types/PushToken.d.ts",dts:"export interface PushToken {\n    publicKey: string;\n    backendUrl: string;\n    accessToken: string;\n    managementToken: string;\n}\n"},{name:"@airgap/beacon-types/types/Regions.d.ts",dts:'/**\n * Geographic region where a beacon node is located. This list can be changed in the future to be more specific, but for now it should cover most general areas.\n */\nexport declare enum Regions {\n    EUROPE_EAST = "europe-east",\n    EUROPE_WEST = "europe-west",\n    NORTH_AMERICA_EAST = "north-america-east",\n    NORTH_AMERICA_WEST = "north-america-west",\n    CENTRAL_AMERICA = "central-america",\n    SOUTH_AMERICA = "south-america",\n    ASIA_EAST = "asia-east",\n    ASIA_WEST = "asia-west",\n    AFRICA = "africa",\n    AUSTRALIA = "australia"\n}\nexport type NodeDistributions = Record<Regions | string, string[]>;\n'},{name:"@airgap/beacon-types/types/RequestBroadcastInput.d.ts",dts:'import { Network } from "./beacon/Network";\n/**\n * @category DApp\n */\nexport interface RequestBroadcastInput {\n    /**\n     * @deprecated You should now specify the network in the constructor of the DAppClient\n     */\n    network?: Network;\n    signedTransaction: string;\n}\n'},{name:"@airgap/beacon-types/types/RequestEncryptPayloadInput.d.ts",dts:"/**\n * @category DApp\n */\n"},{name:"@airgap/beacon-types/types/RequestOperationInput.d.ts",dts:"import { PartialTezosOperation } from './tezos/PartialTezosOperation';\n/**\n * @category DApp\n */\nexport interface RequestOperationInput {\n    operationDetails: PartialTezosOperation[];\n}\n"},{name:"@airgap/beacon-types/types/RequestPermissionInput.d.ts",dts:"import { PermissionScope } from './beacon/PermissionScope';\n/**\n * @category DApp\n */\nexport interface RequestPermissionInput {\n    scopes?: PermissionScope[];\n}\n"},{name:"@airgap/beacon-types/types/RequestProofOfEventChallengeInput.d.ts",dts:"/**\n * @category DApp\n */\nexport interface RequestProofOfEventChallengeInput {\n    payload: string;\n}\n"},{name:"@airgap/beacon-types/types/RequestSignPayloadInput.d.ts",dts:"import { SigningType } from './beacon/SigningType';\n/**\n * @category DApp\n */\nexport interface RequestSignPayloadInput {\n    signingType?: SigningType;\n    payload: string;\n    sourceAddress?: string;\n}\n"},{name:"@airgap/beacon-types/types/RequestSimulatedProofOfEventChallengeInput.d.ts",dts:"/**\n * @category DApp\n */\nexport interface RequestSimulatedProofOfEventChallengeInput {\n    /** A custom payload than should be emitted by the list of operations returned by the dapp*/\n    payload: string;\n}\n"},{name:"@airgap/beacon-types/types/WalletConnectPairingRequest.d.ts",dts:"import { ExtendedPeerInfo, PeerInfo } from './PeerInfo';\n/**\n * @internalapi\n */\nexport declare class WalletConnectPairingRequest implements PeerInfo {\n    readonly type: string;\n    uri: string;\n    id: string;\n    name: string;\n    icon?: string | undefined;\n    appUrl?: string | undefined;\n    publicKey: string;\n    version: string;\n    constructor(id: string, name: string, publicKey: string, version: string, uri: string, icon?: string, appUrl?: string);\n}\n/**\n * @internalapi\n */\nexport declare class ExtendedWalletConnectPairingRequest extends WalletConnectPairingRequest implements ExtendedPeerInfo {\n    senderId: string;\n    constructor(id: string, name: string, publicKey: string, version: string, senderId: string, uri: string, icon?: string, appUrl?: string);\n}\n"},{name:"@airgap/beacon-types/types/WalletConnectPairingResponse.d.ts",dts:"import { PeerInfo } from './PeerInfo';\n/**\n * @internalapi\n */\nexport declare class WalletConnectPairingResponse implements PeerInfo {\n    readonly type: string;\n    id: string;\n    name: string;\n    icon?: string | undefined;\n    appUrl?: string | undefined;\n    publicKey: string;\n    version: string;\n    constructor(id: string, name: string, publicKey: string, version: string, icon?: string, appUrl?: string);\n}\n/**\n * @internalapi\n */\nexport declare class ExtendedWalletConnectPairingResponse extends WalletConnectPairingResponse {\n    senderId: string;\n    extensionId: string;\n    constructor(id: string, name: string, publicKey: string, version: string, senderId: string, extensionId: string, icon?: string, appUrl?: string);\n}\n"},{name:"@airgap/beacon-types/types/WalletInfo.d.ts",dts:"export interface WalletInfo {\n    name: string;\n    type?: 'extension' | 'mobile' | 'web' | 'desktop';\n    icon?: string;\n    deeplink?: string;\n}\n"},{name:"@airgap/beacon-types/types/ui.d.ts",dts:"import { NetworkType } from './beacon/NetworkType';\nexport interface AppBase {\n    key: string;\n    name: string;\n    shortName: string;\n    color: string;\n    logo: string;\n    supportedInteractionStandards?: ('wallet_connect' | 'beacon')[];\n}\nexport interface ExtensionApp extends AppBase {\n    id: string;\n    link: string;\n}\nexport interface WebApp extends AppBase {\n    links: {\n        [NetworkType.MAINNET]: string;\n        [NetworkType.GHOSTNET]?: string;\n        [NetworkType.WEEKLYNET]?: string;\n        [NetworkType.DAILYNET]?: string;\n        [NetworkType.DELPHINET]?: string;\n        [NetworkType.EDONET]?: string;\n        [NetworkType.FLORENCENET]?: string;\n        [NetworkType.GRANADANET]?: string;\n        [NetworkType.HANGZHOUNET]?: string;\n        [NetworkType.ITHACANET]?: string;\n        [NetworkType.JAKARTANET]?: string;\n        [NetworkType.KATHMANDUNET]?: string;\n        [NetworkType.LIMANET]?: string;\n        [NetworkType.MUMBAINET]?: string;\n        [NetworkType.NAIROBINET]?: string;\n        [NetworkType.OXFORDNET]?: string;\n        [NetworkType.PARISNET]?: string;\n        [NetworkType.QUEBECNET]?: string;\n        [NetworkType.RIONET]?: string;\n        [NetworkType.SEOULNET]?: string;\n        [NetworkType.SHADOWNET]?: string;\n        [NetworkType.CUSTOM]?: string;\n    };\n}\nexport interface DesktopApp extends AppBase {\n    deepLink: string;\n    downloadLink: string;\n}\nexport interface App extends AppBase {\n    universalLink: string;\n    deepLink?: string;\n}\n"},{name:"@airgap/beacon-types/index.d.ts",dts:"/**\n * General docs\n * @module public\n */\nimport { AppMetadata } from './types/beacon/AppMetadata';\nimport { PermissionRequest } from './types/beacon/messages/PermissionRequest';\nimport { ProofOfEventChallengeRequest } from './types/beacon/messages/ProofOfEventChallengeRequest';\nimport { ProofOfEventChallengeResponse } from './types/beacon/messages/ProofOfEventChallengeResponse';\nimport { SimulatedProofOfEventChallengeRequest } from './types/beacon/messages/SimulatedProofOfEventChallengeRequest';\nimport { SimulatedProofOfEventChallengeResponse } from './types/beacon/messages/SimulatedProofOfEventChallengeResponse';\nimport { Network } from './types/beacon/Network';\nimport { BeaconBaseMessage } from './types/beacon/BeaconBaseMessage';\nimport { BeaconMessageType } from './types/beacon/BeaconMessageType';\nimport { PermissionScope } from './types/beacon/PermissionScope';\nimport { PermissionResponse } from './types/beacon/messages/PermissionResponse';\nimport { OperationRequest } from './types/beacon/messages/OperationRequest';\nimport { OperationResponse } from './types/beacon/messages/OperationResponse';\nimport { SignPayloadRequest } from './types/beacon/messages/SignPayloadRequest';\nimport { SignPayloadResponse } from './types/beacon/messages/SignPayloadResponse';\nimport { BroadcastRequest } from './types/beacon/messages/BroadcastRequest';\nimport { BroadcastResponse } from './types/beacon/messages/BroadcastResponse';\nimport { NetworkType } from './types/beacon/NetworkType';\nimport { TezosBaseOperation } from './types/tezos/TezosBaseOperation';\nimport { TezosOperationType } from './types/tezos/OperationTypes';\nimport { TezosActivateAccountOperation } from './types/tezos/operations/ActivateAccount';\nimport { TezosBallotOperation } from './types/tezos/operations/Ballot';\nimport { TezosDelegationOperation } from './types/tezos/operations/Delegation';\nimport { TezosDoubleBakingEvidenceOperation } from './types/tezos/operations/DoubleBakingEvidence';\nimport { TezosBlockHeader } from './types/tezos/TezosBlockHeader';\nimport { TezosDoubleEndorsementEvidenceOperation } from './types/tezos/operations/DoubleEndorsementEvidence';\nimport { TezosEndorsementOperation } from './types/tezos/operations/Endorsement';\nimport { TezosOriginationOperation } from './types/tezos/operations/Origination';\nimport { TezosProposalOperation } from './types/tezos/operations/Proposal';\nimport { TezosRevealOperation } from './types/tezos/operations/Reveal';\nimport { TezosSeedNonceRevelationOperation } from './types/tezos/operations/SeedNonceRevelation';\nimport { TezosTransactionOperation } from './types/tezos/operations/Transaction';\nimport { MichelineMichelsonV1Expression } from './types/tezos/MichelineMichelsonV1Expression';\nimport { MichelsonPrimitives } from './types/tezos/MichelsonPrimitives';\nimport { TezosTransactionParameters } from './types/tezos/TezosTransactionParameters';\nimport { Origin } from './types/Origin';\nimport { AccountInfo, AccountIdentifier } from './types/AccountInfo';\nimport { EncryptedExtensionMessage, ExtensionMessage } from './types/ExtensionMessage';\nimport { ExtensionMessageTarget } from './types/ExtensionMessageTarget';\nimport { TezosOperation } from './types/tezos/TezosOperation';\nimport { BeaconErrorType } from './types/BeaconErrorType';\nimport { ErrorResponse } from './types/beacon/messages/ErrorResponse';\nimport { TransportStatus } from './types/transport/TransportStatus';\nimport { TransportType } from './types/transport/TransportType';\nimport { Storage } from './types/storage/Storage';\nimport { StorageKey } from './types/storage/StorageKey';\nimport { defaultValues, StorageKeyReturnDefaults } from './types/storage/StorageKeyReturnDefaults';\nimport { StorageKeyReturnType } from './types/storage/StorageKeyReturnType';\nimport { ExtendedP2PPairingRequest, P2PPairingRequest } from './types/P2PPairingRequest';\nimport { BeaconMessage } from './types/beacon/BeaconMessage';\nimport { RequestPermissionInput } from './types/RequestPermissionInput';\nimport { RequestProofOfEventChallengeInput } from './types/RequestProofOfEventChallengeInput';\nimport { RequestSimulatedProofOfEventChallengeInput } from './types/RequestSimulatedProofOfEventChallengeInput';\nimport { RequestSignPayloadInput } from './types/RequestSignPayloadInput';\nimport { RequestOperationInput } from './types/RequestOperationInput';\nimport { RequestBroadcastInput } from './types/RequestBroadcastInput';\nimport { PermissionResponseInput, SignPayloadResponseInput, OperationResponseInput, BroadcastResponseInput, BeaconResponseInputMessage, AcknowledgeResponseInput, ErrorResponseInput, IgnoredResponseInputProperties } from './types/beacon/messages/BeaconResponseInputMessage';\nimport { PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, BeaconResponseOutputMessage, ProofOfEventChallengeResponseOutput, SimulatedProofOfEventChallengeResponseOutput } from './types/beacon/messages/BeaconResponseOutputMessage';\nimport { PermissionRequestInput, SignPayloadRequestInput, OperationRequestInput, BroadcastRequestInput, BeaconRequestInputMessage, IgnoredRequestInputProperties, ProofOfEventChallengeRequestInput, SimulatedProofOfEventChallengeRequestInput } from './types/beacon/messages/BeaconRequestInputMessage';\nimport { PermissionRequestOutput, SignPayloadRequestOutput, OperationRequestOutput, BroadcastRequestOutput, BeaconRequestOutputMessage, ProofOfEventChallengeRequestOutput, SimulatedProofOfEventChallengeRequestOutput } from './types/beacon/messages/BeaconRequestOutputMessage';\nimport { PermissionInfo } from './types/PermissionInfo';\nimport { ConnectionContext } from './types/ConnectionContext';\nimport { Threshold } from './types/beacon/Threshold';\nimport { PartialTezosTransactionOperation, PartialTezosOperation, PartialTezosDelegationOperation, PartialTezosOriginationOperation, PartialTezosRevealOperation, PartialTezosSmartRollupOriginateOperation, PartialTezosSmartRollupAddMessagesOperation, PartialTezosSmartRollupExecuteOutboxMessageOperation, PartialTezosSmartRollupPublishOperation, PartialTezosSmartRollupCementOperation, PartialTezosSmartRollupRecoverBondOperation, PartialTezosSmartRollupRefuteOperation, PartialTezosSmartRollupTimeoutOperation, PartialTezosDalPublishCommitmentOperation, PartialTezosIncreasePaidStorageOperation, PartialTezosRegisterGlobalConstantOperation, PartialTezosTransferTicketOperation, PartialTezosUpdateConsensusKeyOperation, PartialTezosSetDepositsLimitOperation } from './types/tezos/PartialTezosOperation';\nimport { ExtendedPeerInfo, PeerInfo, PeerInfoType } from './types/PeerInfo';\nimport { AcknowledgeResponse } from './types/beacon/messages/AcknowledgeResponse';\nimport { DisconnectMessage } from './types/beacon/messages/DisconnectMessage';\nimport { SigningType } from './types/beacon/SigningType';\nimport { ExtendedP2PPairingResponse, P2PPairingResponse } from './types/P2PPairingResponse';\nimport { ExtendedPostMessagePairingRequest, PostMessagePairingRequest } from './types/PostMessagePairingRequest';\nimport { ExtendedWalletConnectPairingResponse, WalletConnectPairingResponse } from './types/WalletConnectPairingResponse';\nimport { ExtendedWalletConnectPairingRequest, WalletConnectPairingRequest } from './types/WalletConnectPairingRequest';\nimport { ExtendedPostMessagePairingResponse, PostMessagePairingResponse } from './types/PostMessagePairingResponse';\nimport { BeaconRequestMessage } from './types/beacon/BeaconRequestMessage';\nimport { BeaconResponseMessage } from './types/beacon/BeaconResponseMessage';\nimport { ColorMode } from './types/ColorMode';\nimport { Optional } from './types/utils/Optional';\nimport { Extension } from './types/Extension';\nimport { PermissionEntity } from './types/PermissionEntity';\nimport { WalletInfo } from './types/WalletInfo';\nimport { ChangeAccountRequest } from './types/beacon/messages/ChangeAccountRequest';\nimport { TezosAttestationOperation } from './types/tezos/operations/Attestation';\nimport { TezosAttestationWithDalOperation } from './types/tezos/operations/AttestationWithDal';\nimport { TezosDoubleAttestationEvidenceOperation } from './types/tezos/operations/DoubleAttestationEvidence';\nimport { TezosDoublePreEndorsementEvidenceOperation } from './types/tezos/operations/DoublePreEndorsementEvidence';\nimport { TezosDrainDelegateOperation } from './types/tezos/operations/DrainDelegate';\nimport { TezosEndorsementWithDalOperation } from './types/tezos/operations/EndorsementWithDal';\nimport { TezosFailingNoopOperation } from './types/tezos/operations/FailingNoop';\nimport { TezosIncreasePaidStorageOperation } from './types/tezos/operations/IncreasePaidStorage';\nimport { TezosPreAttestationOperation } from './types/tezos/operations/PreAttestation';\nimport { TezosPreEndorsementOperation } from './types/tezos/operations/PreEndorsement';\nimport { TezosRegisterGlobalConstantOperation } from './types/tezos/operations/RegisterGlobalConstant';\nimport { TezosSetDepositsLimitOperation } from './types/tezos/operations/SetDepositsLimit';\nimport { TezosSmartRollupAddMessagesOperation } from './types/tezos/operations/SmartRollupAddMessages';\nimport { TezosSmartRollupExecuteOutboxMessageOperation } from './types/tezos/operations/SmartRollupExecuteOutboxMessage';\nimport { TezosSmartRollupPublishOperation } from './types/tezos/operations/SmartRollupPublish';\nimport { TezosSmartRollupRecoverBondOperation } from './types/tezos/operations/SmartRollupRecoverBond';\nimport { TezosSmartRollupRefuteOperation } from './types/tezos/operations/SmartRollupRefute';\nimport { TezosSmartRollupTimeoutOperation } from './types/tezos/operations/SmartRollupTimeout';\nimport { TezosTransferTicketOperation } from './types/tezos/operations/TransferTicket';\nimport { TezosUpdateConsensusKeyOperation } from './types/tezos/operations/UpdateConsensusKey';\nimport { TezosVdfRevelationOperation } from './types/tezos/operations/VdfRevelation';\nimport { TezosDoublePreAttestationEvidenceOperation } from './types/tezos/operations/DoublePreAttestationEvidence';\nimport { TezosSmartRollupCementOperation } from './types/tezos/operations/SmartRollupCement';\nimport { TezosSmartRollupOriginateOperation } from './types/tezos/operations/SmartRollupOriginate';\nimport { TezosDalPublishCommitmentOperation } from './types/tezos/operations/DalPublishCommitment';\nexport * from './types/AnalyticsInterface';\nexport * from './types/beaconV3/PermissionRequest';\nexport * from './types/ui';\nexport * from './types/Regions';\nexport { TezosBaseOperation, TezosOperationType, TezosBlockHeader, MichelineMichelsonV1Expression, MichelsonPrimitives, TezosTransactionParameters, TezosOperation };\nexport { TezosActivateAccountOperation, TezosBallotOperation, TezosDelegationOperation, TezosDoubleBakingEvidenceOperation, TezosDoubleEndorsementEvidenceOperation, TezosEndorsementOperation, TezosOriginationOperation, TezosProposalOperation, TezosRevealOperation, TezosSeedNonceRevelationOperation, TezosTransactionOperation, PartialTezosOperation, PartialTezosTransactionOperation, PartialTezosDelegationOperation, PartialTezosOriginationOperation, PartialTezosRevealOperation, PartialTezosSmartRollupOriginateOperation, PartialTezosSmartRollupAddMessagesOperation, PartialTezosSmartRollupExecuteOutboxMessageOperation, PartialTezosSmartRollupPublishOperation, PartialTezosSmartRollupCementOperation, PartialTezosSmartRollupRecoverBondOperation, PartialTezosSmartRollupRefuteOperation, PartialTezosSmartRollupTimeoutOperation, PartialTezosDalPublishCommitmentOperation, PartialTezosRegisterGlobalConstantOperation, PartialTezosTransferTicketOperation, PartialTezosIncreasePaidStorageOperation, PartialTezosUpdateConsensusKeyOperation, PartialTezosSetDepositsLimitOperation, TezosAttestationOperation, TezosPreAttestationOperation, TezosPreEndorsementOperation, TezosSetDepositsLimitOperation, TezosDoublePreAttestationEvidenceOperation, TezosDoublePreEndorsementEvidenceOperation, TezosAttestationWithDalOperation, TezosEndorsementWithDalOperation, TezosDoubleAttestationEvidenceOperation, TezosFailingNoopOperation, TezosRegisterGlobalConstantOperation, TezosTransferTicketOperation, TezosIncreasePaidStorageOperation, TezosUpdateConsensusKeyOperation, TezosDrainDelegateOperation, TezosVdfRevelationOperation, TezosSmartRollupOriginateOperation, TezosSmartRollupAddMessagesOperation, TezosSmartRollupExecuteOutboxMessageOperation, TezosSmartRollupPublishOperation, TezosSmartRollupCementOperation, TezosSmartRollupRecoverBondOperation, TezosSmartRollupRefuteOperation, TezosSmartRollupTimeoutOperation, TezosDalPublishCommitmentOperation };\nexport { AccountIdentifier, AppMetadata, Network, NetworkType, BeaconMessage, PermissionRequest, PermissionResponse, OperationRequest, OperationResponse, SignPayloadRequest, SignPayloadResponse, BroadcastRequest, BroadcastResponse, ChangeAccountRequest, AcknowledgeResponse, DisconnectMessage, BeaconBaseMessage, BeaconMessageType, PermissionScope, Origin, AccountInfo, Threshold, SigningType, ExtensionMessageTarget, ExtensionMessage, Extension, EncryptedExtensionMessage, RequestPermissionInput, RequestProofOfEventChallengeInput, RequestSimulatedProofOfEventChallengeInput, RequestSignPayloadInput, RequestOperationInput, RequestBroadcastInput, PermissionInfo, PermissionEntity, ProofOfEventChallengeRequest, ProofOfEventChallengeResponse, SimulatedProofOfEventChallengeRequest, SimulatedProofOfEventChallengeResponse };\nexport { PermissionResponseInput, SignPayloadResponseInput, OperationResponseInput, BroadcastResponseInput, AcknowledgeResponseInput, ErrorResponseInput, PermissionResponseOutput, ProofOfEventChallengeResponseOutput, SimulatedProofOfEventChallengeResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, PermissionRequestInput, SignPayloadRequestInput, ProofOfEventChallengeRequestInput, SimulatedProofOfEventChallengeRequestInput, OperationRequestInput, BroadcastRequestInput, PermissionRequestOutput, SignPayloadRequestOutput, ProofOfEventChallengeRequestOutput, SimulatedProofOfEventChallengeRequestOutput, OperationRequestOutput, BroadcastRequestOutput, BeaconRequestInputMessage, BeaconRequestOutputMessage, BeaconResponseInputMessage, BeaconResponseOutputMessage, BeaconRequestMessage, BeaconResponseMessage };\nexport { BeaconErrorType, ErrorResponse };\nexport { TransportStatus, TransportType };\nexport { Storage, StorageKey, StorageKeyReturnDefaults, StorageKeyReturnType };\nexport { PeerInfo, ExtendedPeerInfo, PeerInfoType, PostMessagePairingRequest, PostMessagePairingResponse, ExtendedPostMessagePairingRequest, ExtendedPostMessagePairingResponse, P2PPairingRequest, P2PPairingResponse, ExtendedP2PPairingRequest, ExtendedP2PPairingResponse, WalletConnectPairingResponse, WalletConnectPairingRequest, ExtendedWalletConnectPairingRequest, ExtendedWalletConnectPairingResponse };\nexport { IgnoredResponseInputProperties, IgnoredRequestInputProperties, defaultValues };\nexport { ConnectionContext, ColorMode, WalletInfo };\nexport { PushToken } from './types/PushToken';\nexport { Optional };\n"},{name:"@airgap/beacon-types/dist/esm/types/beacon/messages/AcknowledgeResponse.d.ts",dts:"import { BeaconBaseMessage, BeaconMessageType } from '@airgap/beacon-types';\n/**\n * @category Message\n */\nexport interface AcknowledgeResponse extends BeaconBaseMessage {\n    type: BeaconMessageType.Acknowledge;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/beacon/messages/BeaconRequestInputMessage.d.ts",dts:"import { Optional } from '@airgap/beacon-types';\nimport { PermissionRequest, OperationRequest, SignPayloadRequest, ProofOfEventChallengeRequest, SimulatedProofOfEventChallengeRequest, BroadcastRequest } from '@airgap/beacon-types';\n/**\n * @internalapi\n * @category DApp\n */\nexport type IgnoredRequestInputProperties = 'id' | 'senderId' | 'version';\n/**\n * @internalapi\n * @category DApp\n */\nexport type PermissionRequestInput = Optional<PermissionRequest, IgnoredRequestInputProperties>;\n/**\n * @internalapi\n * @category DApp\n */\nexport type ProofOfEventChallengeRequestInput = Optional<ProofOfEventChallengeRequest, IgnoredRequestInputProperties>;\n/**\n * @internalapi\n * @category DApp\n */\nexport type SimulatedProofOfEventChallengeRequestInput = Optional<SimulatedProofOfEventChallengeRequest, IgnoredRequestInputProperties>;\n/**\n * @internalapi\n * @category DApp\n */\nexport type OperationRequestInput = Optional<OperationRequest, IgnoredRequestInputProperties>;\n/**\n * @internalapi\n * @category DApp\n */\nexport type SignPayloadRequestInput = Optional<SignPayloadRequest, IgnoredRequestInputProperties>;\n/**\n * @internalapi\n * @category DApp\n */\n/**\n * @internalapi\n * @category DApp\n */\nexport type BroadcastRequestInput = Optional<BroadcastRequest, IgnoredRequestInputProperties>;\n/**\n * @internalapi\n * @category DApp\n */\nexport type BeaconRequestInputMessage = PermissionRequestInput | OperationRequestInput | SignPayloadRequestInput | BroadcastRequestInput | ProofOfEventChallengeRequestInput | SimulatedProofOfEventChallengeRequestInput;\n"},{name:"@airgap/beacon-types/dist/esm/types/beacon/messages/BeaconRequestOutputMessage.d.ts",dts:"import { Optional, ProofOfEventChallengeRequest, SimulatedProofOfEventChallengeRequest } from '@airgap/beacon-types';\nimport { AppMetadata, PermissionRequest, OperationRequest, SignPayloadRequest, BroadcastRequest } from '@airgap/beacon-types';\n/**\n * @category Wallet\n */\nexport type IgnoredRequestOutputProperties = 'version';\n/**\n * @category Wallet\n */\nexport interface ExtraResponseOutputProperties {\n    appMetadata: AppMetadata;\n}\n/**\n * @category Wallet\n */\nexport type PermissionRequestOutput = Optional<PermissionRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n/**\n * @category Wallet\n */\nexport type ProofOfEventChallengeRequestOutput = Optional<ProofOfEventChallengeRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n/**\n * @category Wallet\n */\nexport type SimulatedProofOfEventChallengeRequestOutput = Optional<SimulatedProofOfEventChallengeRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n/**\n * @category Wallet\n */\nexport type OperationRequestOutput = Optional<OperationRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n/**\n * @category Wallet\n */\nexport type SignPayloadRequestOutput = Optional<SignPayloadRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n/**\n * @category Wallet\n */\n/**\n * @category Wallet\n */\nexport type BroadcastRequestOutput = Optional<BroadcastRequest, IgnoredRequestOutputProperties> & ExtraResponseOutputProperties;\n/**\n * @internalapi\n * @category Wallet\n */\nexport type BeaconRequestOutputMessage = PermissionRequestOutput | OperationRequestOutput | SignPayloadRequestOutput | BroadcastRequestOutput | ProofOfEventChallengeRequestOutput | SimulatedProofOfEventChallengeRequestOutput;\n"},{name:"@airgap/beacon-types/dist/esm/types/beacon/messages/BeaconResponseInputMessage.d.ts",dts:"import { Optional, ProofOfEventChallengeResponse, SimulatedProofOfEventChallengeResponse } from '@airgap/beacon-types';\nimport { PermissionResponse, OperationResponse, SignPayloadResponse, BroadcastResponse, AcknowledgeResponse, ErrorResponse } from '@airgap/beacon-types';\n/**\n * @category Wallet\n */\nexport type IgnoredResponseInputProperties = 'senderId' | 'version';\n/**\n * @category Wallet\n */\nexport type PermissionResponseInput = Optional<PermissionResponse, IgnoredResponseInputProperties | 'appMetadata'>;\n/**\n * @category Wallet\n */\nexport type ProofOfEventChallengeResponseInput = Optional<ProofOfEventChallengeResponse, IgnoredResponseInputProperties>;\n/**\n * @category Wallet\n */\nexport type SimulatedProofOfEventChallengeResponseInput = Optional<SimulatedProofOfEventChallengeResponse, IgnoredResponseInputProperties>;\n/**\n * @category Wallet\n */\nexport type OperationResponseInput = Optional<OperationResponse, IgnoredResponseInputProperties>;\n/**\n * @category Wallet\n */\nexport type SignPayloadResponseInput = Optional<SignPayloadResponse, IgnoredResponseInputProperties>;\n/**\n * @category Wallet\n */\n/**\n * @category Wallet\n */\nexport type BroadcastResponseInput = Optional<BroadcastResponse, IgnoredResponseInputProperties>;\n/**\n * @category Wallet\n */\nexport type AcknowledgeResponseInput = Optional<AcknowledgeResponse, IgnoredResponseInputProperties>;\n/**\n * @category Wallet\n */\nexport type ErrorResponseInput = Optional<ErrorResponse, IgnoredResponseInputProperties>;\n/**\n * @internalapi\n * @category Wallet\n */\nexport type BeaconResponseInputMessage = PermissionResponseInput | OperationResponseInput | SignPayloadResponseInput | BroadcastResponseInput | AcknowledgeResponseInput | ErrorResponseInput | ProofOfEventChallengeResponseInput | SimulatedProofOfEventChallengeResponseInput;\n"},{name:"@airgap/beacon-types/dist/esm/types/beacon/messages/BeaconResponseOutputMessage.d.ts",dts:"import { PermissionResponse, OperationResponse, SignPayloadResponse, BroadcastResponse, AccountInfo, ProofOfEventChallengeResponse, SimulatedProofOfEventChallengeResponse } from '@airgap/beacon-types';\n/**\n * @category DApp\n */\nexport type IgnoredResponseOutputProperties = 'id' | 'version' | 'type';\n/**\n * @category DApp\n */\nexport type PermissionResponseOutput = PermissionResponse & {\n    address: string;\n    accountInfo: AccountInfo;\n    walletKey?: string | undefined;\n};\n/**\n * @category DApp\n */\nexport type ProofOfEventChallengeResponseOutput = ProofOfEventChallengeResponse;\n/**\n * @category DApp\n */\nexport type SimulatedProofOfEventChallengeResponseOutput = SimulatedProofOfEventChallengeResponse;\n/**\n * @category DApp\n */\nexport type OperationResponseOutput = OperationResponse;\n/**\n * @category DApp\n */\nexport type SignPayloadResponseOutput = SignPayloadResponse;\n/**\n * @category DApp\n */\n/**\n * @category DApp\n */\nexport type BroadcastResponseOutput = BroadcastResponse;\n/**\n * @internalapi\n * @category DApp\n */\nexport type BeaconResponseOutputMessage = PermissionResponseOutput | OperationResponseOutput | SignPayloadResponseOutput | BroadcastResponseOutput | ProofOfEventChallengeResponseOutput | SimulatedProofOfEventChallengeResponseOutput;\n"},{name:"@airgap/beacon-types/dist/esm/types/beacon/messages/BroadcastRequest.d.ts",dts:"import { BeaconBaseMessage, BeaconMessageType, Network } from '@airgap/beacon-types';\n/**\n * @category Message\n */\nexport interface BroadcastRequest extends BeaconBaseMessage {\n    type: BeaconMessageType.BroadcastRequest;\n    network: Network;\n    signedTransaction: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/beacon/messages/BroadcastResponse.d.ts",dts:"import { BeaconBaseMessage, BeaconMessageType } from '@airgap/beacon-types';\n/**\n * @category Message\n */\nexport interface BroadcastResponse extends BeaconBaseMessage {\n    type: BeaconMessageType.BroadcastResponse;\n    transactionHash: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/beacon/messages/ChangeAccountRequest.d.ts",dts:"import { BeaconBaseMessage, BeaconMessageType, Network, PermissionScope, Threshold } from '@airgap/beacon-types';\nimport { Notification } from '../../Notification';\nexport interface ChangeAccountRequest extends BeaconBaseMessage {\n    type: BeaconMessageType.ChangeAccountRequest;\n    address?: string;\n    walletType: 'implicit' | 'abstracted_account';\n    verificationType?: 'proof_of_event';\n    publicKey?: string;\n    network: Network;\n    scopes: PermissionScope[];\n    threshold?: Threshold;\n    notification?: Notification;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/beacon/messages/DisconnectMessage.d.ts",dts:"import { BeaconBaseMessage, BeaconMessageType } from '@airgap/beacon-types';\n/**\n * @category Message\n */\nexport interface DisconnectMessage extends BeaconBaseMessage {\n    type: BeaconMessageType.Disconnect;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/beacon/messages/EncryptPayloadRequest.d.ts",dts:"/**\n * @category Message\n */\n"},{name:"@airgap/beacon-types/dist/esm/types/beacon/messages/EncryptPayloadResponse.d.ts",dts:"/**\n * @category Message\n */\n"},{name:"@airgap/beacon-types/dist/esm/types/beacon/messages/ErrorResponse.d.ts",dts:"import { BeaconBaseMessage, BeaconErrorType, BeaconMessageType } from '@airgap/beacon-types';\n/**\n * @category Message\n */\nexport interface ErrorResponse extends BeaconBaseMessage {\n    type: BeaconMessageType.Error;\n    errorType: BeaconErrorType;\n    errorData?: any;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/beacon/messages/OperationRequest.d.ts",dts:"import { BeaconBaseMessage, BeaconMessageType, Network } from '@airgap/beacon-types';\nimport { PartialTezosOperation } from '../../tezos/PartialTezosOperation';\n/**\n * @category Message\n */\nexport interface OperationRequest extends BeaconBaseMessage {\n    type: BeaconMessageType.OperationRequest;\n    network: Network;\n    operationDetails: PartialTezosOperation[];\n    sourceAddress: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/beacon/messages/OperationResponse.d.ts",dts:"import { BeaconBaseMessage, BeaconMessageType } from '@airgap/beacon-types';\n/**\n * @category Message\n */\nexport interface OperationResponse extends BeaconBaseMessage {\n    type: BeaconMessageType.OperationResponse;\n    transactionHash: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/beacon/messages/PermissionRequest.d.ts",dts:"import { BeaconBaseMessage, BeaconMessageType, PermissionScope, AppMetadata, Network } from '@airgap/beacon-types';\n/**\n * @category Message\n */\nexport interface PermissionRequest extends BeaconBaseMessage {\n    type: BeaconMessageType.PermissionRequest;\n    appMetadata: AppMetadata;\n    network: Network;\n    scopes: PermissionScope[];\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/beacon/messages/PermissionResponse.d.ts",dts:"import { AppMetadata, BeaconBaseMessage, BeaconMessageType, Network, PermissionScope, Threshold } from '@airgap/beacon-types';\nimport { Notification } from '../../Notification';\n/**\n * @category Message\n */\nexport interface PermissionResponse extends BeaconBaseMessage {\n    address?: string;\n    walletType: 'implicit' | 'abstracted_account';\n    verificationType?: 'proof_of_event';\n    type: BeaconMessageType.PermissionResponse;\n    appMetadata: AppMetadata;\n    publicKey?: string;\n    network: Network;\n    scopes: PermissionScope[];\n    threshold?: Threshold;\n    notification?: Notification;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/beacon/messages/ProofOfEventChallengeRequest.d.ts",dts:"import { BeaconBaseMessage, BeaconMessageType } from '@airgap/beacon-types';\nexport interface ProofOfEventChallengeRequest extends BeaconBaseMessage {\n    type: BeaconMessageType.ProofOfEventChallengeRequest;\n    payload: string;\n    contractAddress: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/beacon/messages/ProofOfEventChallengeResponse.d.ts",dts:"import { BeaconBaseMessage, BeaconMessageType } from '@airgap/beacon-types';\nexport interface ProofOfEventChallengeResponse extends BeaconBaseMessage {\n    type: BeaconMessageType.ProofOfEventChallengeResponse;\n    payloadHash: string;\n    isAccepted: boolean;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/beacon/messages/SignPayloadRequest.d.ts",dts:"import { BeaconBaseMessage, BeaconMessageType, SigningType } from '@airgap/beacon-types';\n/**\n * @category Message\n */\nexport interface SignPayloadRequest extends BeaconBaseMessage {\n    type: BeaconMessageType.SignPayloadRequest;\n    signingType: SigningType;\n    payload: string;\n    sourceAddress: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/beacon/messages/SignPayloadResponse.d.ts",dts:"import { BeaconBaseMessage, BeaconMessageType, SigningType } from '@airgap/beacon-types';\n/**\n * @category Message\n */\nexport interface SignPayloadResponse extends BeaconBaseMessage {\n    type: BeaconMessageType.SignPayloadResponse;\n    signingType: SigningType;\n    signature: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/beacon/messages/SimulatedProofOfEventChallengeRequest.d.ts",dts:"import { BeaconBaseMessage, BeaconMessageType } from '@airgap/beacon-types';\nexport interface SimulatedProofOfEventChallengeRequest extends BeaconBaseMessage {\n    type: BeaconMessageType.SimulatedProofOfEventChallengeRequest;\n    payload: string;\n    contractAddress: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/beacon/messages/SimulatedProofOfEventChallengeResponse.d.ts",dts:"import { BeaconBaseMessage, BeaconMessageType } from '@airgap/beacon-types';\nexport interface SimulatedProofOfEventChallengeResponse extends BeaconBaseMessage {\n    type: BeaconMessageType.SimulatedProofOfEventChallengeResponse;\n    operationsList: string;\n    errorMessage: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/beacon/AppMetadata.d.ts",dts:"export interface AppMetadata {\n    senderId: string;\n    name: string;\n    icon?: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/beacon/BeaconBaseMessage.d.ts",dts:"import { BeaconMessageType } from '@airgap/beacon-types';\n/**\n * @category Message\n */\nexport interface BeaconBaseMessage {\n    type: BeaconMessageType;\n    version: string;\n    id: string;\n    senderId: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/beacon/BeaconMessage.d.ts",dts:"import { PermissionResponse, PermissionRequest, OperationRequest, OperationResponse, SignPayloadRequest, SignPayloadResponse, BroadcastRequest, BroadcastResponse, AcknowledgeResponse, DisconnectMessage, ErrorResponse, ProofOfEventChallengeRequest, ProofOfEventChallengeResponse, SimulatedProofOfEventChallengeRequest, SimulatedProofOfEventChallengeResponse, ChangeAccountRequest } from '@airgap/beacon-types';\n/**\n * @internalapi\n */\nexport type BeaconMessage = PermissionRequest | PermissionResponse | ProofOfEventChallengeRequest | ProofOfEventChallengeResponse | SimulatedProofOfEventChallengeRequest | SimulatedProofOfEventChallengeResponse | OperationRequest | OperationResponse | SignPayloadRequest | SignPayloadResponse | BroadcastRequest | BroadcastResponse | AcknowledgeResponse | DisconnectMessage | ErrorResponse | ChangeAccountRequest;\n"},{name:"@airgap/beacon-types/dist/esm/types/beacon/BeaconMessageType.d.ts",dts:'export declare enum BeaconMessageType {\n    BlockchainRequest = "blockchain_request",\n    PermissionRequest = "permission_request",\n    SignPayloadRequest = "sign_payload_request",\n    OperationRequest = "operation_request",\n    BroadcastRequest = "broadcast_request",\n    ChangeAccountRequest = "change_account_request",\n    BlockchainResponse = "blockchain_response",\n    PermissionResponse = "permission_response",\n    SignPayloadResponse = "sign_payload_response",\n    ProofOfEventChallengeRequest = "proof_of_event_challenge_request",\n    ProofOfEventChallengeResponse = "proof_of_event_challenge_response",\n    SimulatedProofOfEventChallengeRequest = "simulated_proof_of_event_challenge_request",\n    SimulatedProofOfEventChallengeResponse = "simulated_proof_of_event_challenge_response",\n    OperationResponse = "operation_response",\n    BroadcastResponse = "broadcast_response",\n    Acknowledge = "acknowledge",\n    Disconnect = "disconnect",\n    Error = "error"\n}\n'},{name:"@airgap/beacon-types/dist/esm/types/beacon/BeaconRequestMessage.d.ts",dts:"import { PermissionRequest, OperationRequest, SignPayloadRequest, BroadcastRequest, ProofOfEventChallengeRequest, SimulatedProofOfEventChallengeRequest } from '@airgap/beacon-types';\n/**\n * @internalapi\n */\nexport type BeaconRequestMessage = PermissionRequest | OperationRequest | SignPayloadRequest | BroadcastRequest | ProofOfEventChallengeRequest | SimulatedProofOfEventChallengeRequest;\n"},{name:"@airgap/beacon-types/dist/esm/types/beacon/BeaconResponseMessage.d.ts",dts:"import { PermissionResponse, OperationResponse, SignPayloadResponse, BroadcastResponse } from '@airgap/beacon-types';\nimport { ErrorResponse } from './messages/ErrorResponse';\n/**\n * @internalapi\n */\nexport type BeaconResponseMessage = PermissionResponse | OperationResponse | SignPayloadResponse | BroadcastResponse | ErrorResponse;\n"},{name:"@airgap/beacon-types/dist/esm/types/beacon/Network.d.ts",dts:"import { NetworkType } from '@airgap/beacon-types';\nexport interface Network {\n    type: NetworkType;\n    name?: string;\n    rpcUrl?: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/beacon/NetworkType.d.ts",dts:'export declare enum NetworkType {\n    MAINNET = "mainnet",\n    GHOSTNET = "ghostnet",// Long running testnet\n    WEEKLYNET = "weeklynet",// Testnet, resets every week\n    DAILYNET = "dailynet",// Testnet, resets every day\n    DELPHINET = "delphinet",\n    EDONET = "edonet",\n    FLORENCENET = "florencenet",\n    GRANADANET = "granadanet",\n    HANGZHOUNET = "hangzhounet",\n    ITHACANET = "ithacanet",\n    JAKARTANET = "jakartanet",\n    KATHMANDUNET = "kathmandunet",\n    LIMANET = "limanet",\n    MUMBAINET = "mumbainet",\n    NAIROBINET = "nairobinet",\n    OXFORDNET = "oxfordnet",\n    PARISNET = "parisnet",\n    QUEBECNET = "quebecnet",\n    RIONET = "rionet",\n    SEOULNET = "seoulnet",\n    SHADOWNET = "shadownet",\n    CUSTOM = "custom"\n}\n'},{name:"@airgap/beacon-types/dist/esm/types/beacon/PermissionScope.d.ts",dts:'export declare enum PermissionScope {\n    SIGN = "sign",// Allows the DApp to send requests to sign arbitrary payload\n    OPERATION_REQUEST = "operation_request",// Allows the DApp to send requests to sign and broadcast Tezos Operations\n    ENCRYPT = "encrypt",// Allows the DApp to send encryption and decryption requests\n    NOTIFICATION = "notification",// Allows the DApp to send push notifications to the Wallet\n    THRESHOLD = "threshold"\n}\n'},{name:"@airgap/beacon-types/dist/esm/types/beacon/SigningType.d.ts",dts:'export declare enum SigningType {\n    RAW = "raw",// Arbitrary payload (string), which will be hashed before signing\n    OPERATION = "operation",// "03" prefix\n    MICHELINE = "micheline"\n}\n'},{name:"@airgap/beacon-types/dist/esm/types/beacon/Threshold.d.ts",dts:"export interface Threshold {\n    amount: string;\n    timeframe: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/beaconV3/PermissionRequest.d.ts",dts:"import { AccountInfo, AppMetadata, BeaconMessageType, ConnectionContext, WalletInfo, ExtensionApp, DesktopApp, WebApp, App } from '@airgap/beacon-types';\nexport interface ResponseInput {\n    request: BlockchainMessage;\n    account: AccountInfo;\n    output: BeaconMessageWrapper<BeaconBaseMessage>;\n    blockExplorer: any;\n    connectionContext: ConnectionContext;\n    walletInfo: WalletInfo;\n}\nexport interface Blockchain {\n    readonly identifier: string;\n    validateRequest(input: BlockchainMessage): Promise<void>;\n    handleResponse(input: ResponseInput): Promise<void>;\n    getWalletLists(): Promise<{\n        extensionList: ExtensionApp[];\n        desktopList: DesktopApp[];\n        webList: WebApp[];\n        iOSList: App[];\n    }>;\n    getAccountInfosFromPermissionResponse(permissionResponse: PermissionResponseV3): Promise<{\n        accountId: string;\n        address: string;\n        publicKey: string;\n    }[]>;\n}\nexport interface BeaconMessageWrapper<T extends BeaconBaseMessage> {\n    id: string;\n    version: string;\n    senderId: string;\n    message: T;\n}\nexport interface BeaconBaseMessage {\n    type: unknown;\n}\nexport interface BlockchainMessage<T extends string = string> {\n    blockchainIdentifier: T;\n    type: unknown;\n    blockchainData: unknown;\n}\nexport interface PermissionRequestV3<T extends string = string> extends BlockchainMessage<T> {\n    blockchainIdentifier: T;\n    type: BeaconMessageType.PermissionRequest;\n    blockchainData: {\n        appMetadata: AppMetadata;\n        scopes: string[];\n    };\n}\nexport interface PermissionResponseV3<T extends string = string> extends BlockchainMessage<T> {\n    blockchainIdentifier: T;\n    type: BeaconMessageType.PermissionResponse;\n    blockchainData: {\n        appMetadata: AppMetadata;\n        scopes: string[];\n    };\n}\nexport interface BlockchainRequestV3<T extends string = string> extends BlockchainMessage<T> {\n    blockchainIdentifier: T;\n    type: BeaconMessageType.BlockchainRequest;\n    accountId: string;\n    blockchainData: {\n        type: string;\n        scope: string;\n    };\n}\nexport interface BlockchainResponseV3<T extends string = string> extends BlockchainMessage<T> {\n    blockchainIdentifier: T;\n    type: BeaconMessageType.BlockchainResponse;\n    blockchainData: unknown;\n}\nexport interface BlockchainErrorResponse<T extends string = string> extends BlockchainMessage<T> {\n    blockchainIdentifier: T;\n    type: BeaconMessageType.Error;\n    error: {\n        type: unknown;\n        data?: unknown;\n    };\n    description?: string;\n}\nexport interface AcknowledgeMessage extends BeaconBaseMessage {\n    type: BeaconMessageType.Acknowledge;\n}\nexport interface DisconnectMessage extends BeaconBaseMessage {\n    type: BeaconMessageType.Disconnect;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/storage/Storage.d.ts",dts:"import { StorageKey, StorageKeyReturnType } from '@airgap/beacon-types';\n/**\n * @internalapi\n *\n * The storage used in the SDK\n */\nexport declare abstract class Storage {\n    /**\n     * Returns a promise that resolves to true if the storage option is available on this platform.\n     */\n    static isSupported(): Promise<boolean>;\n    /**\n     * Gets a value from storage and returns it\n     *\n     * @param key The storage key\n     */\n    abstract get<K extends StorageKey>(key: K): Promise<StorageKeyReturnType[K]>;\n    /**\n     * Sets a value in the storage and persist it\n     *\n     * @param key The storage key\n     * @param value The value to be persisted\n     */\n    abstract set<K extends StorageKey>(key: K, value: StorageKeyReturnType[K]): Promise<void>;\n    /**\n     * Delete a key from storage\n     *\n     * @param key The storage key\n     */\n    abstract delete<K extends StorageKey>(key: K): Promise<void>;\n    /**\n     * This event will fire if the storage was modified by someone else, eg. on another tab\n     *\n     * @param callback The callback to be called when a storage value changes\n     */\n    abstract subscribeToStorageChanged(callback: (arg: {\n        eventType: 'storageCleared' | 'entryModified';\n        key: string | null;\n        oldValue: string | null;\n        newValue: string | null;\n    }) => {}): Promise<void>;\n    /**\n     * Get the key with the internal prefix\n     *\n     * @param key the storage key\n     */\n    abstract getPrefixedKey<K extends StorageKey>(key: K): string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/storage/StorageKey.d.ts",dts:'/**\n * @internalapi\n */\nexport declare enum StorageKey {\n    TRANSPORT_P2P_PEERS_DAPP = "beacon:communication-peers-dapp",\n    TRANSPORT_P2P_PEERS_WALLET = "beacon:communication-peers-wallet",\n    TRANSPORT_POSTMESSAGE_PEERS_DAPP = "beacon:postmessage-peers-dapp",\n    TRANSPORT_POSTMESSAGE_PEERS_WALLET = "beacon:postmessage-peers-wallet",\n    TRANSPORT_WALLETCONNECT_PEERS_DAPP = "beacon:walletconnect-peers-dapp",\n    LAST_SELECTED_WALLET = "beacon:last-selected-wallet",\n    ACCOUNTS = "beacon:accounts",\n    ACTIVE_ACCOUNT = "beacon:active-account",\n    PUSH_TOKENS = "beacon:push-tokens",\n    BEACON_SDK_SECRET_SEED = "beacon:sdk-secret-seed",\n    BEACON_LAST_ERROR = "beacon:beacon-last-error",\n    APP_METADATA_LIST = "beacon:app-metadata-list",\n    PERMISSION_LIST = "beacon:permissions",\n    ONGOING_PROOF_OF_EVENT_CHALLENGES = "beacon:ongoing-proof-of-event-challenges",\n    BEACON_SDK_VERSION = "beacon:sdk_version",\n    MATRIX_PRESERVED_STATE = "beacon:sdk-matrix-preserved-state",\n    MATRIX_PEER_ROOM_IDS = "beacon:matrix-peer-rooms",\n    MATRIX_SELECTED_NODE = "beacon:matrix-selected-node",\n    MULTI_NODE_SETUP_DONE = "beacon:multi-node-setup",\n    USER_ID = "beacon:user-id",\n    ENABLE_METRICS = "beacon:enable_metrics",\n    WC_INIT_ERROR = "beacon:wc-init-error",\n    WC_2_CORE_PAIRING = "wc@2:core:0.3:pairing",\n    WC_2_CLIENT_SESSION = "wc@2:client:0.3:session",\n    WC_2_CORE_KEYCHAIN = "wc@2:core:0.3:keychain",\n    WC_2_CORE_MESSAGES = "wc@2:core:0.3:messages",\n    WC_2_CLIENT_PROPOSAL = "wc@2:client:0.3:proposal",\n    WC_2_CORE_SUBSCRIPTION = "wc@2:core:0.3:subscription",\n    WC_2_CORE_HISTORY = "wc@2:core:0.3:history",\n    WC_2_CORE_EXPIRER = "wc@2:core:0.3:expirer"\n}\n'},{name:"@airgap/beacon-types/dist/esm/types/storage/StorageKeyReturnDefaults.d.ts",dts:"import { StorageKey } from './StorageKey';\nimport { StorageKeyReturnType } from './StorageKeyReturnType';\n/**\n * @internalapi\n */\nexport type StorageKeyReturnDefaults = {\n    [key in StorageKey]: StorageKeyReturnType[key];\n};\n/**\n * @internalapi\n */\nexport declare const defaultValues: StorageKeyReturnDefaults;\n"},{name:"@airgap/beacon-types/dist/esm/types/storage/StorageKeyReturnType.d.ts",dts:"import { StorageKey, AccountInfo, AccountIdentifier, P2PPairingRequest, AppMetadata, PermissionInfo, ExtendedWalletConnectPairingResponse, RequestProofOfEventChallengeInput } from '../..';\nimport { ExtendedP2PPairingResponse } from '../P2PPairingResponse';\nimport { PostMessagePairingRequest } from '../PostMessagePairingRequest';\nimport { ExtendedPostMessagePairingResponse } from '../PostMessagePairingResponse';\nimport { PushToken } from '../PushToken';\n/**\n * @internalapi\n */\nexport interface StorageKeyReturnType {\n    [StorageKey.TRANSPORT_P2P_PEERS_DAPP]: P2PPairingRequest[];\n    [StorageKey.TRANSPORT_P2P_PEERS_WALLET]: ExtendedP2PPairingResponse[];\n    [StorageKey.TRANSPORT_POSTMESSAGE_PEERS_DAPP]: PostMessagePairingRequest[];\n    [StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET]: ExtendedPostMessagePairingResponse[];\n    [StorageKey.TRANSPORT_WALLETCONNECT_PEERS_DAPP]: ExtendedWalletConnectPairingResponse[];\n    [StorageKey.LAST_SELECTED_WALLET]: {\n        key: string;\n        name: string;\n        type: 'extension' | 'mobile' | 'web' | 'desktop';\n        icon: string;\n        url?: string;\n    } | undefined;\n    [StorageKey.ACCOUNTS]: AccountInfo[];\n    [StorageKey.ACTIVE_ACCOUNT]: AccountIdentifier | undefined;\n    [StorageKey.PUSH_TOKENS]: PushToken[];\n    [StorageKey.BEACON_SDK_SECRET_SEED]: string | undefined;\n    [StorageKey.BEACON_LAST_ERROR]: string | undefined;\n    [StorageKey.APP_METADATA_LIST]: AppMetadata[];\n    [StorageKey.PERMISSION_LIST]: PermissionInfo[];\n    [StorageKey.ONGOING_PROOF_OF_EVENT_CHALLENGES]: ({\n        contractAddress: string;\n        accountIdentifier: string;\n    } & RequestProofOfEventChallengeInput)[];\n    [StorageKey.BEACON_SDK_VERSION]: string | undefined;\n    [StorageKey.MATRIX_PRESERVED_STATE]: {\n        [key: string]: unknown;\n    };\n    [StorageKey.MATRIX_PEER_ROOM_IDS]: {\n        [key: string]: string | undefined;\n    };\n    [StorageKey.MATRIX_SELECTED_NODE]: string | undefined;\n    [StorageKey.MULTI_NODE_SETUP_DONE]: boolean | undefined;\n    [StorageKey.USER_ID]: string | undefined;\n    [StorageKey.ENABLE_METRICS]: boolean | undefined;\n    [StorageKey.WC_INIT_ERROR]: string | undefined;\n    [StorageKey.WC_2_CLIENT_SESSION]: string | undefined;\n    [StorageKey.WC_2_CORE_PAIRING]: string | undefined;\n    [StorageKey.WC_2_CORE_KEYCHAIN]: string | undefined;\n    [StorageKey.WC_2_CORE_MESSAGES]: string | undefined;\n    [StorageKey.WC_2_CLIENT_PROPOSAL]: string | undefined;\n    [StorageKey.WC_2_CORE_SUBSCRIPTION]: string | undefined;\n    [StorageKey.WC_2_CORE_HISTORY]: string | undefined;\n    [StorageKey.WC_2_CORE_EXPIRER]: string | undefined;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/operations/ActivateAccount.d.ts",dts:"import { TezosBaseOperation, TezosOperationType } from '../../..';\n/**\n * @internalapi\n * @category Tezos\n */\nexport interface TezosActivateAccountOperation extends TezosBaseOperation {\n    kind: TezosOperationType.ACTIVATE_ACCOUNT;\n    pkh: string;\n    secret: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/operations/Attestation.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosAttestationOperation extends TezosBaseOperation {\n    kind: TezosOperationType.ATTESTATION;\n    level: number;\n    slot?: number;\n    round?: number;\n    block_payload_hash?: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/operations/AttestationWithDal.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosAttestationWithDalOperation extends TezosBaseOperation {\n    kind: TezosOperationType.ATTESTATION_WITH_DAL;\n    slot: number;\n    level: number;\n    round: number;\n    block_payload_hash: string;\n    dal_attestation: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/operations/AttestationsAggregate.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosPreAttestationsAggregateOperation extends TezosBaseOperation {\n    kind: TezosOperationType.ATTESTATIONS_AGGREGATE;\n    consensus_content: {\n        level: number;\n        round: number;\n        block_payload_hash: string;\n    };\n    committee: {\n        slot: number;\n        dal_attestation?: string;\n    }[];\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/operations/Ballot.d.ts",dts:"import { TezosBaseOperation, TezosOperationType } from '../../..';\n/**\n * @internalapi\n * @category Tezos\n */\nexport interface TezosBallotOperation extends TezosBaseOperation {\n    kind: TezosOperationType.BALLOT;\n    source: string;\n    period: number;\n    proposal: string;\n    ballot: 'nay' | 'yay' | 'pass';\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/operations/DalEntrapmentEvidence.d.ts",dts:"import { InlinedAttestation } from '../InlinedAttestation';\nimport { TezosOperationType } from '../OperationTypes';\nexport interface TezosDalPublishCommitmentOperation {\n    kind: TezosOperationType.DAL_ENTRAPMENT_EVIDENCE;\n    attestation: InlinedAttestation;\n    consensus_slot: number;\n    slot_index: number;\n    shard_with_proof: {\n        shard: (number | string[])[];\n        proof: string;\n    };\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/operations/DalPublishCommitment.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nexport interface TezosDalPublishCommitmentOperation {\n    kind: TezosOperationType.DAL_PUBLISH_COMMITMENT;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    slot_header: {\n        slot_index: number;\n        commitment: string;\n        commitment_proof: string;\n    };\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/operations/Delegation.d.ts",dts:"import { TezosBaseOperation, TezosOperationType } from '../../..';\n/**\n * @internalapi\n * @category Tezos\n */\nexport interface TezosDelegationOperation extends TezosBaseOperation {\n    kind: TezosOperationType.DELEGATION;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    delegate?: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/operations/DoubleAttestationEvidence.d.ts",dts:"import { InlinedAttestation } from '../InlinedAttestation';\nimport { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosDoubleAttestationEvidenceOperation extends TezosBaseOperation {\n    kind: TezosOperationType.DOUBLE_ATTESTATION_EVIDENCE;\n    op1: InlinedAttestation;\n    op2: InlinedAttestation;\n    slot?: number;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/operations/DoubleBakingEvidence.d.ts",dts:"import { TezosBaseOperation, TezosOperationType, TezosBlockHeader } from '../../..';\n/**\n * @internalapi\n * @category Tezos\n */\nexport interface TezosDoubleBakingEvidenceOperation extends TezosBaseOperation {\n    kind: TezosOperationType.DOUBLE_BAKING_EVIDENCE;\n    bh1: TezosBlockHeader;\n    bh2: TezosBlockHeader;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/operations/DoubleConsensusOperationEvidence.d.ts",dts:"import { InlinedAttestation } from '../InlinedAttestation';\nimport { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosUpdateConsensusKeyOperation extends TezosBaseOperation {\n    kind: TezosOperationType.DOUBLE_CONSENSUS_OPERATION_EVIDENCE;\n    slot: number;\n    op1: InlinedAttestation;\n    op2: InlinedAttestation;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/operations/DoubleEndorsementEvidence.d.ts",dts:"import { TezosBaseOperation, TezosOperationType } from '../../..';\nexport interface InlinedEndorsement {\n    branch: string;\n    operations: InlinedEndorsementContents;\n    signature?: string;\n}\nexport interface InlinedEndorsementContents extends TezosBaseOperation {\n    kind: TezosOperationType.ENDORSEMENT;\n    level: string;\n    slot?: number;\n    round?: number;\n    block_payload_hash?: string;\n}\n/**\n * @internalapi\n * @category Tezos\n */\nexport interface TezosDoubleEndorsementEvidenceOperation extends TezosBaseOperation {\n    kind: TezosOperationType.DOUBLE_ENDORSEMENT_EVIDENCE;\n    op1: InlinedEndorsement;\n    op2: InlinedEndorsement;\n    slot?: number;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/operations/DoublePreAttestationEvidence.d.ts",dts:"import { InlinedPreattestation } from '../InlinedPreattestation';\nimport { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosDoublePreAttestationEvidenceOperation extends TezosBaseOperation {\n    kind: TezosOperationType.DOUBLE_PREATTESTATION_EVIDENCE;\n    op1: InlinedPreattestation;\n    op2: InlinedPreattestation;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/operations/DoublePreEndorsementEvidence.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosDoublePreEndorsementEvidenceOperation extends TezosBaseOperation {\n    kind: TezosOperationType.DOUBLE_PREENDORSEMENT_EVIDENCE;\n    op1: InlinedPreEndorsement;\n    op2: InlinedPreEndorsement;\n}\nexport interface InlinedPreEndorsement {\n    branch: string;\n    operations: InlinedPreEndorsementContents;\n    signature?: string;\n}\nexport interface InlinedPreEndorsementContents {\n    kind: TezosOperationType.PREENDORSEMENT;\n    slot: number;\n    level: number;\n    round: number;\n    block_payload_hash: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/operations/DrainDelegate.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosDrainDelegateOperation extends TezosBaseOperation {\n    kind: TezosOperationType.DRAIN_DELEGATE;\n    consensus_key: string;\n    delegate: string;\n    destination: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/operations/Endorsement.d.ts",dts:"import { TezosBaseOperation, TezosOperationType } from '../../..';\n/**\n * @internalapi\n * @category Tezos\n */\nexport interface TezosEndorsementOperation extends TezosBaseOperation {\n    kind: TezosOperationType.ENDORSEMENT;\n    level: string;\n    slot?: number;\n    round?: number;\n    block_payload_hash?: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/operations/EndorsementWithDal.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosEndorsementWithDalOperation extends TezosBaseOperation {\n    kind: TezosOperationType.ENDORSEMENT_WITH_DAL;\n    slot: number;\n    level: number;\n    round: number;\n    block_payload_hash: string;\n    dal_attestation: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/operations/FailingNoop.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosFailingNoopOperation extends TezosBaseOperation {\n    kind: TezosOperationType.FAILING_NOOP;\n    arbitrary: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/operations/IncreasePaidStorage.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosIncreasePaidStorageOperation extends TezosBaseOperation {\n    kind: TezosOperationType.INCREASE_PAID_STORAGE;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    amount: string;\n    destination: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/operations/Origination.d.ts",dts:"import { TezosBaseOperation, TezosOperationType } from '../../..';\nimport { ScriptedContracts } from '../common';\n/**\n * @internalapi\n * @category Tezos\n */\nexport interface TezosOriginationOperation extends TezosBaseOperation {\n    kind: TezosOperationType.ORIGINATION;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    balance: string;\n    delegate?: string;\n    script?: ScriptedContracts;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/operations/PreAttestation.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosPreAttestationOperation extends TezosBaseOperation {\n    kind: TezosOperationType.PREATTESTATION;\n    slot: number;\n    level: number;\n    round: number;\n    block_payload_hash: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/operations/PreAttestationsAggregate.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosPreAttestationsAggregateOperation extends TezosBaseOperation {\n    kind: TezosOperationType.PREATTESTATIONS_AGGREGATE;\n    consensus_content: {\n        level: number;\n        round: number;\n        block_payload_hash: string;\n    };\n    committee: number[];\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/operations/PreEndorsement.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosPreEndorsementOperation extends TezosBaseOperation {\n    kind: TezosOperationType.PREENDORSEMENT;\n    slot: number;\n    level: number;\n    round: number;\n    block_payload_hash: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/operations/Proposal.d.ts",dts:"import { TezosBaseOperation, TezosOperationType } from '../../..';\n/**\n * @internalapi\n * @category Tezos\n */\nexport interface TezosProposalOperation extends TezosBaseOperation {\n    kind: TezosOperationType.PROPOSALS;\n    source: string;\n    period: string;\n    proposals: string[];\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/operations/RegisterGlobalConstant.d.ts",dts:"import { MichelineMichelsonV1Expression } from '../MichelineMichelsonV1Expression';\nimport { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosRegisterGlobalConstantOperation extends TezosBaseOperation {\n    kind: TezosOperationType.REGISTER_GLOBAL_CONSTANT;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    value: MichelineMichelsonV1Expression;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/operations/Reveal.d.ts",dts:"import { TezosBaseOperation, TezosOperationType } from '../../..';\n/**\n * @internalapi\n * @category Tezos\n */\nexport interface TezosRevealOperation extends TezosBaseOperation {\n    kind: TezosOperationType.REVEAL;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    public_key: string;\n    proof?: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/operations/SeedNonceRevelation.d.ts",dts:"import { TezosBaseOperation, TezosOperationType } from '../../..';\n/**\n * @internalapi\n * @category Tezos\n */\nexport interface TezosSeedNonceRevelationOperation extends TezosBaseOperation {\n    kind: TezosOperationType.SEED_NONCE_REVELATION;\n    level: number;\n    nonce: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/operations/SetDepositsLimit.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosSetDepositsLimitOperation extends TezosBaseOperation {\n    kind: TezosOperationType.SET_DEPOSITS_LIMIT;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    limit?: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/operations/SmartRollupAddMessages.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosSmartRollupAddMessagesOperation extends TezosBaseOperation {\n    kind: TezosOperationType.SMART_ROLLUP_ADD_MESSAGES;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    message: string[];\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/operations/SmartRollupCement.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosSmartRollupCementOperation extends TezosBaseOperation {\n    kind: TezosOperationType.SMART_ROLLUP_CEMENT;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    rollup: string;\n    commitment: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/operations/SmartRollupExecuteOutboxMessage.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosSmartRollupExecuteOutboxMessageOperation extends TezosBaseOperation {\n    kind: TezosOperationType.SMART_ROLLUP_EXECUTE_OUTBOX_MESSAGE;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    rollup: string;\n    cemented_commitment: string;\n    output_proof: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/operations/SmartRollupOriginate.d.ts",dts:"import { MichelineMichelsonV1Expression } from '../MichelineMichelsonV1Expression';\nimport { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nimport { PvmKind } from '../common';\nexport interface TezosSmartRollupOriginateOperation extends TezosBaseOperation {\n    kind: TezosOperationType.SMART_ROLLUP_ORIGINATE;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    pvm_kind: PvmKind;\n    kernel: string;\n    parameters_ty: MichelineMichelsonV1Expression;\n    whitelist?: string[];\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/operations/SmartRollupPublish.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nimport { SmartRollupPublishCommitment } from '../common';\nexport interface TezosSmartRollupPublishOperation extends TezosBaseOperation {\n    kind: TezosOperationType.SMART_ROLLUP_PUBLISH;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    rollup: string;\n    commitment: SmartRollupPublishCommitment;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/operations/SmartRollupRecoverBond.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosSmartRollupRecoverBondOperation extends TezosBaseOperation {\n    kind: TezosOperationType.SMART_ROLLUP_RECOVER_BOND;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    rollup: string;\n    staker: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/operations/SmartRollupRefute.d.ts",dts:'import { TezosOperationType } from \'../OperationTypes\';\nimport { TezosBaseOperation } from \'../TezosBaseOperation\';\nexport interface TezosSmartRollupRefuteOperation extends TezosBaseOperation {\n    kind: TezosOperationType.SMART_ROLLUP_REFUTE;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    rollup: string;\n    opponent: string;\n    refutation: SmartRollupRefutation;\n}\nexport type SmartRollupRefutation = SmartRollupRefutationStart | SmartRollupRefutationMove;\nexport interface SmartRollupRefutationStart {\n    refutation_kind: SmartRollupRefutationOptions.START;\n    player_commitment_hash: string;\n    opponent_commitment_hash: string;\n}\nexport interface SmartRollupRefutationMove {\n    refutation_kind: SmartRollupRefutationOptions.MOVE;\n    choice: string;\n    step: SmartRollupRefutationMoveStep;\n}\nexport declare enum SmartRollupRefutationOptions {\n    START = "start",\n    MOVE = "move"\n}\nexport type SmartRollupRefutationMoveStep = SmartRollupRefutationMoveStepDissection[] | SmartRollupRefutationMoveStepProof;\nexport type SmartRollupGameStatus = SmartRollupRefuteGameStatusOptions.ONGOING | SmartRollupRefuteGameStatusEnded;\nexport interface SmartRollupRefutationMoveStepDissection {\n    state?: string;\n    tick: number;\n}\nexport interface SmartRollupRefutationMoveStepProof {\n    pvm_step: string;\n    input_proof?: SmartRollupRefutationMoveInputProof;\n}\nexport declare enum SmartRollupRefuteGameStatusOptions {\n    ONGOING = "ongoing",\n    ENDED = "ended"\n}\nexport interface SmartRollupRefuteGameStatusEnded {\n    result: SmartRollupRefuteGameStatusResult;\n}\nexport type SmartRollupRefutationMoveInputProof = SmartRollupRefutationMoveInputProofInbox | SmartRollupRefutationMoveInputProofReveal | SmartRollupRefutationMoveInputProofFirstInput;\nexport type SmartRollupRefuteGameStatusResult = SmartRollupRefuteGameEndedResultLoser | SmartRollupRefuteGameEndedResultDraw;\nexport interface SmartRollupRefutationMoveInputProofInbox {\n    input_proof_kind: SmartRollupInputProofKind.INBOX_PROOF;\n    level: number;\n    message_counter: string;\n    serialized_proof: string;\n}\nexport interface SmartRollupRefutationMoveInputProofReveal {\n    input_proof_kind: SmartRollupInputProofKind.REVEAL_PROOF;\n    reveal_proof: SmartRollupRefuteRevealProofOptions;\n}\nexport interface SmartRollupRefutationMoveInputProofFirstInput {\n    input_proof_kind: SmartRollupInputProofKind.FIRST_INPUT;\n}\nexport interface SmartRollupRefuteGameEndedResultLoser {\n    kind: SmartRollupRefuteGameEndedPlayerOutcomes.LOSER;\n    reason: SmartRollupRefuteGameEndedReason;\n    player: string;\n}\nexport interface SmartRollupRefuteGameEndedResultDraw {\n    kind: SmartRollupRefuteGameEndedPlayerOutcomes.DRAW;\n}\nexport declare enum SmartRollupInputProofKind {\n    INBOX_PROOF = "inbox_proof",\n    REVEAL_PROOF = "reveal_proof",\n    FIRST_INPUT = "first_input"\n}\nexport type SmartRollupRefuteRevealProofOptions = SmartRollupRefuteRevealProofRaw | SmartRollupRefuteRevealProofMetadata | SmartRollupRefuteRevealProofDalPage;\nexport declare enum SmartRollupRefuteGameEndedPlayerOutcomes {\n    LOSER = "loser",\n    DRAW = "draw"\n}\nexport declare enum SmartRollupRefuteGameEndedReason {\n    CONFLICT_RESOLVED = "conflict_resolved",\n    TIMEOUT = "timeout"\n}\nexport declare enum SmartRollupRefuteRevealProofKind {\n    RAW_DATA_PROOF = "raw_data_proof",\n    METADATA_PROOF = "metadata_proof",\n    DAL_PAGE_PROOF = "dal_page_proof"\n}\nexport interface SmartRollupRefuteRevealProofRaw {\n    reveal_proof_kind: SmartRollupRefuteRevealProofKind.RAW_DATA_PROOF;\n    raw_data: string;\n}\nexport interface SmartRollupRefuteRevealProofMetadata {\n    reveal_proof_kind: SmartRollupRefuteRevealProofKind.METADATA_PROOF;\n}\nexport interface SmartRollupRefuteRevealProofDalPage {\n    reveal_proof_kind: SmartRollupRefuteRevealProofKind.DAL_PAGE_PROOF;\n    dal_page_id: {\n        published_level: number;\n        slot_index: number;\n        page_index: number;\n    };\n    dal_proof: string;\n}\n'},{name:"@airgap/beacon-types/dist/esm/types/tezos/operations/SmartRollupTimeout.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosSmartRollupTimeoutOperation extends TezosBaseOperation {\n    kind: TezosOperationType.SMART_ROLLUP_TIMEOUT;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    rollup: string;\n    stakers: SmartRollupTimeoutStakers;\n}\nexport interface SmartRollupTimeoutStakers {\n    alice: string;\n    bob: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/operations/Transaction.d.ts",dts:"import { TezosBaseOperation, TezosOperationType, TezosTransactionParameters } from '../../..';\n/**\n * @internalapi\n * @category Tezos\n */\nexport interface TezosTransactionOperation extends TezosBaseOperation {\n    kind: TezosOperationType.TRANSACTION;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    amount: string;\n    destination: string;\n    parameters?: TezosTransactionParameters;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/operations/TransferTicket.d.ts",dts:"import { MichelineMichelsonV1Expression } from '../MichelineMichelsonV1Expression';\nimport { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosTransferTicketOperation extends TezosBaseOperation {\n    kind: TezosOperationType.TRANSFER_TICKET;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    ticket_contents: MichelineMichelsonV1Expression;\n    ticket_ty: MichelineMichelsonV1Expression;\n    ticket_ticketer: string;\n    ticket_amount: string;\n    destination: string;\n    entrypoint: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/operations/UpdateCompanionKey.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosUpdateConsensusKeyOperation extends TezosBaseOperation {\n    kind: TezosOperationType.UPDATE_COMPANION_KEY;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    pk: string;\n    proof?: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/operations/UpdateConsensusKey.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosUpdateConsensusKeyOperation extends TezosBaseOperation {\n    kind: TezosOperationType.UPDATE_CONSENSUS_KEY;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    pk: string;\n    proof?: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/operations/VdfRevelation.d.ts",dts:"import { TezosOperationType } from '../OperationTypes';\nimport { TezosBaseOperation } from '../TezosBaseOperation';\nexport interface TezosVdfRevelationOperation extends TezosBaseOperation {\n    kind: TezosOperationType.VDF_REVELATION;\n    solution: string[];\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/InlinedAttestation.d.ts",dts:"import { TezosOperationType } from './OperationTypes';\nexport interface InlinedAttestation {\n    branch: string;\n    operations: InlinedAttestationContents;\n    signature?: string;\n}\nexport interface InlinedAttestationContents {\n    kind: InlinedAttestationKindEnum;\n    slot?: number;\n    round?: number;\n    block_payload_hash?: string;\n    level: number;\n}\nexport type InlinedAttestationKindEnum = TezosOperationType.ATTESTATION;\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/InlinedPreattestation.d.ts",dts:"import { TezosOperationType } from './OperationTypes';\nexport interface InlinedPreattestation {\n    branch: string;\n    operations: InlinedPreattestationContents;\n    signature?: string;\n}\nexport interface InlinedPreattestationContents {\n    kind: TezosOperationType.PREATTESTATION;\n    slot: number;\n    level: number;\n    round: number;\n    block_payload_hash: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/MichelineMichelsonV1Expression.d.ts",dts:"import { MichelsonPrimitives } from '../..';\n/**\n * @internalapi\n * @category Tezos\n */\nexport type MichelineMichelsonV1Expression = {\n    int: string;\n} | {\n    string: string;\n} | {\n    bytes: string;\n} | MichelineMichelsonV1Expression[] | {\n    prim: MichelsonPrimitives;\n    args?: MichelineMichelsonV1Expression[];\n    annots?: string[];\n};\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/MichelsonPrimitives.d.ts",dts:"/**\n * @internalapi\n * @category Tezos\n */\nexport type MichelsonPrimitives = 'ADD' | 'IF_NONE' | 'SWAP' | 'set' | 'nat' | 'CHECK_SIGNATURE' | 'IF_LEFT' | 'LAMBDA' | 'Elt' | 'CREATE_CONTRACT' | 'NEG' | 'big_map' | 'map' | 'or' | 'BLAKE2B' | 'bytes' | 'SHA256' | 'SET_DELEGATE' | 'CONTRACT' | 'LSL' | 'SUB' | 'IMPLICIT_ACCOUNT' | 'PACK' | 'list' | 'PAIR' | 'Right' | 'contract' | 'GT' | 'LEFT' | 'STEPS_TO_QUOTA' | 'storage' | 'TRANSFER_TOKENS' | 'CDR' | 'SLICE' | 'PUSH' | 'False' | 'SHA512' | 'CHAIN_ID' | 'BALANCE' | 'signature' | 'DUG' | 'SELF' | 'EMPTY_BIG_MAP' | 'LSR' | 'OR' | 'XOR' | 'lambda' | 'COMPARE' | 'key' | 'option' | 'Unit' | 'Some' | 'UNPACK' | 'NEQ' | 'INT' | 'pair' | 'AMOUNT' | 'DIP' | 'ABS' | 'ISNAT' | 'EXEC' | 'NOW' | 'LOOP' | 'chain_id' | 'string' | 'MEM' | 'MAP' | 'None' | 'address' | 'CONCAT' | 'EMPTY_SET' | 'MUL' | 'LOOP_LEFT' | 'timestamp' | 'LT' | 'UPDATE' | 'DUP' | 'SOURCE' | 'mutez' | 'SENDER' | 'IF_CONS' | 'RIGHT' | 'CAR' | 'CONS' | 'LE' | 'NONE' | 'IF' | 'SOME' | 'GET' | 'Left' | 'CAST' | 'int' | 'SIZE' | 'key_hash' | 'unit' | 'DROP' | 'EMPTY_MAP' | 'NIL' | 'DIG' | 'APPLY' | 'bool' | 'RENAME' | 'operation' | 'True' | 'FAILWITH' | 'parameter' | 'HASH_KEY' | 'EQ' | 'NOT' | 'UNIT' | 'Pair' | 'ADDRESS' | 'EDIV' | 'CREATE_ACCOUNT' | 'GE' | 'ITER' | 'code' | 'AND';\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/OperationTypes.d.ts",dts:'/**\n * @publicapi\n * @category Tezos\n */\nexport declare enum TezosOperationType {\n    ACTIVATE_ACCOUNT = "activate_account",\n    ATTESTATION = "attestation",\n    ATTESTATIONS_AGGREGATE = "attestations_aggregate",\n    ATTESTATION_WITH_DAL = "attestation_with_dal",\n    BALLOT = "ballot",\n    DAL_PUBLISH_COMMITMENT = "dal_publish_commitment",\n    DELEGATION = "delegation",\n    DRAIN_DELEGATE = "drain_delegate",\n    DOUBLE_ATTESTATION_EVIDENCE = "double_attestation_evidence",\n    DOUBLE_BAKING_EVIDENCE = "double_baking_evidence",\n    DOUBLE_ENDORSEMENT_EVIDENCE = "double_endorsement_evidence",\n    DOUBLE_PREATTESTATION_EVIDENCE = "double_preattestation_evidence",\n    DOUBLE_PREENDORSEMENT_EVIDENCE = "double_preendorsement_evidence",\n    ENDORSEMENT = "endorsement",\n    ENDORSEMENT_WITH_DAL = "endorsement_with_dal",\n    EVENT = "event",\n    FAILING_NOOP = "failing_noop",\n    INCREASE_PAID_STORAGE = "increase_paid_storage",\n    ORIGINATION = "origination",\n    PREATTESTATION = "preattestation",\n    PREATTESTATIONS_AGGREGATE = "preattestations_aggregate",\n    PREENDORSEMENT = "preendorsement",\n    PROPOSALS = "proposals",\n    REGISTER_GLOBAL_CONSTANT = "register_global_constant",\n    REVEAL = "reveal",\n    SEED_NONCE_REVELATION = "seed_nonce_revelation",\n    SET_DEPOSITS_LIMIT = "set_deposits_limit",\n    SMART_ROLLUP_ADD_MESSAGES = "smart_rollup_add_messages",\n    SMART_ROLLUP_CEMENT = "smart_rollup_cement",\n    SMART_ROLLUP_EXECUTE_OUTBOX_MESSAGE = "smart_rollup_execute_outbox_message",\n    SMART_ROLLUP_ORIGINATE = "smart_rollup_originate",\n    SMART_ROLLUP_PUBLISH = "smart_rollup_publish",\n    SMART_ROLLUP_RECOVER_BOND = "smart_rollup_recover_bond",\n    SMART_ROLLUP_REFUTE = "smart_rollup_refute",\n    SMART_ROLLUP_TIMEOUT = "smart_rollup_timeout",\n    TICKET_UPDATES = "ticket_updates",\n    TRANSACTION = "transaction",\n    TRANSFER_TICKET = "transfer_ticket",\n    UPDATE_CONSENSUS_KEY = "update_consensus_key",\n    UPDATE_COMPANION_KEY = "update_companion_key",\n    VDF_REVELATION = "vdf_revelation",\n    DOUBLE_CONSENSUS_OPERATION_EVIDENCE = "double_consensus_operation_evidence",\n    DAL_ENTRAPMENT_EVIDENCE = "dal_entrapment_evidence"\n}\n'},{name:"@airgap/beacon-types/dist/esm/types/tezos/PartialTezosOperation.d.ts",dts:"import { Optional, TezosAttestationOperation, TezosAttestationWithDalOperation, TezosDoubleAttestationEvidenceOperation, TezosDoublePreAttestationEvidenceOperation, TezosDoublePreEndorsementEvidenceOperation, TezosDrainDelegateOperation, TezosEndorsementWithDalOperation, TezosFailingNoopOperation, TezosIncreasePaidStorageOperation, TezosPreAttestationOperation, TezosRegisterGlobalConstantOperation, TezosSetDepositsLimitOperation, TezosSmartRollupAddMessagesOperation, TezosSmartRollupCementOperation, TezosSmartRollupExecuteOutboxMessageOperation, TezosSmartRollupOriginateOperation, TezosSmartRollupPublishOperation, TezosSmartRollupRecoverBondOperation, TezosSmartRollupRefuteOperation, TezosTransferTicketOperation, TezosUpdateConsensusKeyOperation, TezosVdfRevelationOperation } from '@airgap/beacon-types';\nimport { TezosActivateAccountOperation } from './operations/ActivateAccount';\nimport { TezosBallotOperation } from './operations/Ballot';\nimport { TezosDelegationOperation } from './operations/Delegation';\nimport { TezosDoubleBakingEvidenceOperation } from './operations/DoubleBakingEvidence';\nimport { TezosEndorsementOperation } from './operations/Endorsement';\nimport { TezosOriginationOperation } from './operations/Origination';\nimport { TezosProposalOperation } from './operations/Proposal';\nimport { TezosRevealOperation } from './operations/Reveal';\nimport { TezosSeedNonceRevelationOperation } from './operations/SeedNonceRevelation';\nimport { TezosTransactionOperation } from './operations/Transaction';\nimport { TezosPreEndorsementOperation } from './operations/PreEndorsement';\nimport { TezosDalPublishCommitmentOperation } from './operations/DalPublishCommitment';\n/**\n * @publicapi\n * @category Tezos\n */\nexport type omittedProperties = 'source' | 'fee' | 'counter' | 'gas_limit' | 'storage_limit';\n/**\n * @internalapi\n * @category Tezos\n */\nexport type PartialTezosDelegationOperation = Optional<TezosDelegationOperation, omittedProperties>;\n/**\n * @internalapi\n * @category Tezos\n */\nexport type PartialTezosOriginationOperation = Optional<TezosOriginationOperation, omittedProperties>;\n/**\n * @internalapi\n * @category Tezos\n */\nexport type PartialTezosRevealOperation = Optional<TezosRevealOperation, omittedProperties>;\n/**\n * @internalapi\n * @category Tezos\n */\nexport type PartialTezosTransactionOperation = Optional<TezosTransactionOperation, omittedProperties>;\n/**\n * @internalapi\n * @category Tezos\n */\nexport type PartialTezosSetDepositsLimitOperation = Optional<TezosSetDepositsLimitOperation, omittedProperties>;\n/**\n * @internalapi\n * @category Tezos\n */\nexport type PartialTezosRegisterGlobalConstantOperation = Optional<TezosRegisterGlobalConstantOperation, omittedProperties>;\n/**\n * @internalapi\n * @category Tezos\n */\nexport type PartialTezosTransferTicketOperation = Optional<TezosTransferTicketOperation, omittedProperties>;\n/**\n * @internalapi\n * @category Tezos\n */\nexport type PartialTezosIncreasePaidStorageOperation = Optional<TezosIncreasePaidStorageOperation, omittedProperties>;\n/**\n * @internalapi\n * @category Tezos\n */\nexport type PartialTezosUpdateConsensusKeyOperation = Optional<TezosUpdateConsensusKeyOperation, omittedProperties>;\n/**\n * @internalapi\n * @category Tezos\n */\nexport type PartialTezosSmartRollupOriginateOperation = Optional<TezosSmartRollupOriginateOperation, omittedProperties>;\n/**\n * @internalapi\n * @category Tezos\n */\nexport type PartialTezosSmartRollupAddMessagesOperation = Optional<TezosSmartRollupAddMessagesOperation, omittedProperties>;\n/**\n * @internalapi\n * @category Tezos\n */\nexport type PartialTezosSmartRollupExecuteOutboxMessageOperation = Optional<TezosSmartRollupExecuteOutboxMessageOperation, omittedProperties>;\n/**\n * @internalapi\n * @category Tezos\n */\nexport type PartialTezosSmartRollupPublishOperation = Optional<TezosSmartRollupPublishOperation, omittedProperties>;\n/**\n * @internalapi\n * @category Tezos\n */\nexport type PartialTezosSmartRollupCementOperation = Optional<TezosSmartRollupCementOperation, omittedProperties>;\n/**\n * @internalapi\n * @category Tezos\n */\nexport type PartialTezosSmartRollupRecoverBondOperation = Optional<TezosSmartRollupRecoverBondOperation, omittedProperties>;\n/**\n * @internalapi\n * @category Tezos\n */\nexport type PartialTezosSmartRollupRefuteOperation = Optional<TezosSmartRollupRefuteOperation, omittedProperties>;\n/**\n * @internalapi\n * @category Tezos\n */\nexport type PartialTezosSmartRollupTimeoutOperation = Optional<TezosSmartRollupRefuteOperation, omittedProperties>;\nexport type PartialTezosDalPublishCommitmentOperation = Optional<TezosDalPublishCommitmentOperation, omittedProperties>;\n/**\n * @publicapi\n * @category Tezos\n */\nexport type PartialTezosOperation = TezosActivateAccountOperation | TezosBallotOperation | PartialTezosDelegationOperation | TezosDoubleBakingEvidenceOperation | TezosEndorsementOperation | PartialTezosOriginationOperation | TezosProposalOperation | PartialTezosRevealOperation | TezosSeedNonceRevelationOperation | PartialTezosTransactionOperation | TezosAttestationOperation | TezosPreAttestationOperation | TezosPreEndorsementOperation | PartialTezosSetDepositsLimitOperation | TezosDoublePreAttestationEvidenceOperation | TezosDoublePreEndorsementEvidenceOperation | TezosAttestationWithDalOperation | TezosEndorsementWithDalOperation | TezosDoubleAttestationEvidenceOperation | TezosFailingNoopOperation | PartialTezosRegisterGlobalConstantOperation | PartialTezosTransferTicketOperation | PartialTezosIncreasePaidStorageOperation | PartialTezosUpdateConsensusKeyOperation | TezosDrainDelegateOperation | TezosVdfRevelationOperation | PartialTezosSmartRollupOriginateOperation | PartialTezosSmartRollupAddMessagesOperation | PartialTezosSmartRollupExecuteOutboxMessageOperation | PartialTezosSmartRollupPublishOperation | PartialTezosSmartRollupCementOperation | PartialTezosSmartRollupRecoverBondOperation | PartialTezosSmartRollupRefuteOperation | PartialTezosSmartRollupTimeoutOperation | PartialTezosDalPublishCommitmentOperation;\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/TezosBaseOperation.d.ts",dts:"import { TezosOperationType } from '../..';\n/**\n * @internalapi\n * @category Tezos\n */\nexport interface TezosBaseOperation {\n    kind: TezosOperationType;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/TezosBlockHeader.d.ts",dts:"/**\n * @internalapi\n * @category Tezos\n */\nexport interface TezosBlockHeader {\n    level: number;\n    proto: number;\n    predecessor: string;\n    timestamp: Date | string;\n    validation_pass: number;\n    operations_hash: string;\n    fitness: string[];\n    context: string;\n    payload_hash?: string;\n    payload_round?: number;\n    priority?: number;\n    proof_of_work_nonce: string;\n    seed_nonce_hash?: string;\n    liquidity_baking_toggle_vote?: 'on' | 'off' | 'pass';\n    adaptive_issuance_vote?: 'on' | 'off' | 'pass';\n    liquidity_baking_escape_vote?: boolean | 'on' | 'off' | 'pass';\n    signature: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/TezosOperation.d.ts",dts:"import { TezosActivateAccountOperation, TezosBallotOperation, TezosDelegationOperation, TezosDoubleBakingEvidenceOperation, TezosEndorsementOperation, TezosOriginationOperation, TezosProposalOperation, TezosRevealOperation, TezosSeedNonceRevelationOperation, TezosTransactionOperation } from '../..';\n/**\n * @internalapi\n * @category Tezos\n */\nexport type TezosOperation = TezosActivateAccountOperation | TezosBallotOperation | TezosDelegationOperation | TezosDoubleBakingEvidenceOperation | TezosEndorsementOperation | TezosOriginationOperation | TezosProposalOperation | TezosRevealOperation | TezosSeedNonceRevelationOperation | TezosTransactionOperation;\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/TezosTransactionParameters.d.ts",dts:"import { MichelineMichelsonV1Expression } from './MichelineMichelsonV1Expression';\n/**\n * @internalapi\n * @category Tezos\n */\nexport interface TezosTransactionParameters {\n    entrypoint: 'default' | 'root' | 'do' | 'set_delegate' | 'remove_delegate' | 'deposit' | 'stake' | 'unstake' | 'finalize_unstake' | 'set_delegate_parameters' | string;\n    value: MichelineMichelsonV1Expression;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/tezos/common.d.ts",dts:'import { MichelineMichelsonV1Expression } from \'./MichelineMichelsonV1Expression\';\nimport { TezosOperationType } from \'./OperationTypes\';\nexport type MetadataBalanceUpdatesKindEnum = \'contract\' | \'freezer\' | \'accumulator\' | \'burned\' | \'commitment\' | \'minted\' | \'staking\';\nexport type MetadataBalanceUpdatesOriginEnum = \'block\' | \'migration\' | \'subsidy\' | \'simulation\' | \'delayed_operation\';\nexport type MetadataBalanceUpdatesCategoryEnum = METADATA_BALANCE_UPDATES_CATEGORY;\nexport declare enum METADATA_BALANCE_UPDATES_CATEGORY {\n    BAKING_BONUSES = "baking bonuses",\n    BAKING_REWARDS = "baking rewards",\n    BLOCK_FEES = "block fees",\n    BONDS = "bonds",\n    BOOTSTRAP = "bootstrap",\n    BURNED = "burned",\n    COMMITMENT = "commitment",\n    DELEGATE_DENOMINATOR = "delegate_denominator",\n    DELEGATOR_NUMERATOR = "delegator_numerator",\n    DEPOSITS = "deposits",\n    ENDORSING_REWARDS = "endorsing rewards",\n    INVOICE = "invoice",\n    LOST_ENDORSING_REWARDS = "lost endorsing rewards",\n    MINTED = "minted",\n    NONCE_REVELATION_REWARDS = "nonce revelation rewards",\n    PUNISHMENTS = "punishments",\n    SMART_ROLLUP_REFUTATION_PUNISHMENTS = "smart_rollup_refutation_punishments",\n    SMART_ROLLUP_REFUTATION_REWARDS = "smart_rollup_refutation_rewards",\n    STORAGE_FEES = "storage fees",\n    SUBSIDY = "subsidy",\n    UNSTAKED_DEPOSITS = "unstaked_deposits"\n}\nexport type FrozenStaker = SingleStaker | SharedStaker | Baker;\nexport type Staker = SingleStaker | SharedStaker;\nexport interface SingleStaker {\n    contract: string;\n    delegate: string;\n}\nexport interface SharedStaker {\n    delegate: string;\n}\nexport interface Baker {\n    baker: string;\n}\nexport type BondId = {\n    smart_rollup: string;\n};\nexport type InternalOperationResultKindEnum = TezosOperationType.TRANSACTION | TezosOperationType.ORIGINATION | TezosOperationType.DELEGATION | TezosOperationType.EVENT;\nexport interface TransactionOperationParameter {\n    entrypoint: string;\n    value: MichelineMichelsonV1Expression;\n}\nexport interface ScriptedContracts {\n    code: MichelineMichelsonV1Expression[];\n    storage: MichelineMichelsonV1Expression;\n}\nexport type ContractBigMapDiff = ContractBigMapDiffItem[];\nexport interface ContractBigMapDiffItem {\n    key_hash?: string;\n    key?: MichelineMichelsonV1Expression;\n    value?: MichelineMichelsonV1Expression;\n    action?: DiffActionEnum;\n    big_map?: string;\n    source_big_map?: string;\n    destination_big_map?: string;\n    key_type?: MichelineMichelsonV1Expression;\n    value_type?: MichelineMichelsonV1Expression;\n}\nexport type DiffActionEnum = \'update\' | \'remove\' | \'copy\' | \'alloc\';\nexport type LazyStorageDiff = LazyStorageDiffBigMap | LazyStorageDiffSaplingState;\nexport interface LazyStorageDiffBigMap {\n    kind: \'big_map\';\n    id: string;\n    diff: LazyStorageDiffBigMapItems;\n}\nexport interface LazyStorageDiffSaplingState {\n    kind: \'sapling_state\';\n    id: string;\n    diff: LazyStorageDiffSaplingStateItems;\n}\nexport interface LazyStorageDiffBigMapItems {\n    action: DiffActionEnum;\n    updates?: LazyStorageDiffUpdatesBigMap[];\n    source?: string;\n    key_type?: MichelineMichelsonV1Expression;\n    value_type?: MichelineMichelsonV1Expression;\n}\nexport interface LazyStorageDiffUpdatesBigMap {\n    key_hash: string;\n    key: MichelineMichelsonV1Expression;\n    value?: MichelineMichelsonV1Expression;\n}\nexport interface LazyStorageDiffSaplingStateItems {\n    action: DiffActionEnum;\n    updates?: LazyStorageDiffUpdatesSaplingState;\n    source?: string;\n    memo_size?: number;\n}\nexport interface LazyStorageDiffUpdatesSaplingState {\n    commitments_and_ciphertexts: CommitmentsAndCiphertexts[];\n    nullifiers: string[];\n}\nexport type CommitmentsAndCiphertexts = [string, SaplingTransactionCiphertext];\nexport interface SaplingTransactionCiphertext {\n    cv: string;\n    epk: string;\n    payload_enc: string;\n    nonce_enc: string;\n    payload_out: string;\n    nonce_out: string;\n}\nexport declare enum PvmKind {\n    WASM2 = "wasm_2_0_0",\n    ARITH = "arith",\n    RISCV = "riscv"\n}\nexport interface SmartRollupPublishCommitment {\n    compressed_state: string;\n    inbox_level: number;\n    predecessor: string;\n    number_of_ticks: string;\n}\n'},{name:"@airgap/beacon-types/dist/esm/types/transport/TransportStatus.d.ts",dts:'export declare enum TransportStatus {\n    NOT_CONNECTED = "NOT_CONNECTED",\n    CONNECTING = "CONNECTING",\n    CONNECTED = "CONNECTED",\n    SECONDARY_TAB_CONNECTED = "SECONDARY_TAB_CONNECTED"\n}\n'},{name:"@airgap/beacon-types/dist/esm/types/transport/TransportType.d.ts",dts:'/**\n * @internalapi\n */\nexport declare enum TransportType {\n    CHROME_MESSAGE = "chrome_message",\n    WALLETCONNECT = "walletconnect",\n    POST_MESSAGE = "post_message",\n    LEDGER = "ledger",\n    P2P = "p2p"\n}\n'},{name:"@airgap/beacon-types/dist/esm/types/utils/Optional.d.ts",dts:"export type Optional<T, K extends keyof T> = Partial<T> & Omit<T, K>;\n"},{name:"@airgap/beacon-types/dist/esm/types/AccountInfo.d.ts",dts:"import { PermissionEntity } from './PermissionEntity';\nimport { Notification } from './Notification';\nimport { Origin } from './Origin';\nexport type AccountIdentifier = string;\nexport interface AccountInfo extends PermissionEntity {\n    accountIdentifier: AccountIdentifier;\n    senderId: string;\n    origin: {\n        type: Origin;\n        id: string;\n    };\n    walletKey?: string;\n    publicKey?: string;\n    connectedAt: number;\n    notification?: Notification;\n    hasVerifiedChallenge?: boolean;\n    walletType: 'implicit' | 'abstracted_account';\n    verificationType?: 'proof_of_event';\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/AnalyticsInterface.d.ts",dts:"export interface AnalyticsInterface {\n    track(trigger: 'click' | 'event', section: string, label: string, data?: Record<string, any>): void;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/BeaconErrorType.d.ts",dts:'export declare enum BeaconErrorType {\n    /**\n     * {@link BroadcastBeaconError}\n     *\n     * Will be returned if the user chooses that the transaction is broadcast but there is an error (eg. node not available).\n     *\n     * Returned by: Broadcast | Operation Request\n     */\n    BROADCAST_ERROR = "BROADCAST_ERROR",\n    /**\n     * {@link NetworkNotSupportedBeaconError}\n     *\n     * Will be returned if the selected network is not supported by the wallet / extension.\n     *\n     * Returned by: Permission\n     */\n    NETWORK_NOT_SUPPORTED = "NETWORK_NOT_SUPPORTED",\n    /**\n     * {@link NoAddressBeaconError}\n     *\n     * Will be returned if there is no address present for the protocol / network requested.\n     *\n     * Returned by: Permission\n     */\n    NO_ADDRESS_ERROR = "NO_ADDRESS_ERROR",\n    /**\n     * {@link NoPrivateKeyBeaconError}\n     *\n     * Will be returned if the private key matching the sourceAddress could not be found.\n     *\n     * Returned by: Sign\n     */\n    NO_PRIVATE_KEY_FOUND_ERROR = "NO_PRIVATE_KEY_FOUND_ERROR",\n    /**\n     * {@link NotGrantedBeaconError}\n     *\n     * Will be returned if the signature was blocked // (Not needed?) Permission: Will be returned if the permissions requested by the App were not granted.\n     *\n     * Returned by: Sign\n     */\n    NOT_GRANTED_ERROR = "NOT_GRANTED_ERROR",\n    /**\n     * {@link ParametersInvalidBeaconError}\n     *\n     * Will be returned if any of the parameters are invalid.\n     *\n     * Returned by: Operation Request\n     */\n    PARAMETERS_INVALID_ERROR = "PARAMETERS_INVALID_ERROR",\n    /**\n     * {@link TooManyOperationsBeaconError}\n     *\n     * Will be returned if too many operations were in the request and they were not able to fit into a single operation group.\n     *\n     * Returned by: Operation Request\n     */\n    TOO_MANY_OPERATIONS = "TOO_MANY_OPERATIONS",\n    /**\n     * {@link TransactionInvalidBeaconError}\n     *\n     * Will be returned if the transaction is not parsable or is rejected by the node.\n     *\n     * Returned by: Broadcast\n     */\n    TRANSACTION_INVALID_ERROR = "TRANSACTION_INVALID_ERROR",\n    /**\n     * {@link SignatureTypeNotSupportedBeaconError}\n     *\n     * Will be returned if the signing type is not supported.\n     *\n     * Returned by: Sign\n     */\n    SIGNATURE_TYPE_NOT_SUPPORTED = "SIGNATURE_TYPE_NOT_SUPPORTED",\n    /**\n     * {@link AbortedBeaconError}\n     *\n     * Will be returned if the request was aborted by the user or the wallet.\n     *\n     * Returned by: Permission | Operation Request | Sign Request | Broadcast\n     */\n    ABORTED_ERROR = "ABORTED_ERROR",\n    /**\n     * {@link UnknownBeaconError}\n     *\n     * Used as a wildcard if an unexpected error occured.\n     *\n     * Returned by: Permission | Operation Request | Sign Request | Broadcast\n     */\n    UNKNOWN_ERROR = "UNKNOWN_ERROR"\n}\n'},{name:"@airgap/beacon-types/dist/esm/types/ColorMode.d.ts",dts:'export declare enum ColorMode {\n    LIGHT = "light",\n    DARK = "dark"\n}\n'},{name:"@airgap/beacon-types/dist/esm/types/ConnectionContext.d.ts",dts:'import { Origin } from "./Origin";\n/**\n * @internalapi\n */\nexport interface ConnectionContext {\n    origin: Origin;\n    id: string;\n    extras?: {\n        sender: chrome.runtime.MessageSender;\n        sendResponse(response?: unknown): void;\n    };\n}\n'},{name:"@airgap/beacon-types/dist/esm/types/EncryptionOperation.d.ts",dts:""},{name:"@airgap/beacon-types/dist/esm/types/EncryptionType.d.ts",dts:""},{name:"@airgap/beacon-types/dist/esm/types/Extension.d.ts",dts:"export interface Extension {\n    id: string;\n    name: string;\n    shortName?: string;\n    iconUrl?: string;\n    color?: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/ExtensionMessage.d.ts",dts:'import { ExtensionMessageTarget } from "./ExtensionMessageTarget";\n/**\n * @internalapi\n */\nexport interface ExtensionMessage<T, U = unknown> {\n    target: ExtensionMessageTarget;\n    targetId?: string;\n    sender?: U;\n    payload: T;\n}\n/**\n * @internalapi\n */\nexport interface EncryptedExtensionMessage<U = unknown> {\n    target: ExtensionMessageTarget;\n    targetId?: string;\n    sender?: U;\n    encryptedPayload: string;\n}\n'},{name:"@airgap/beacon-types/dist/esm/types/ExtensionMessageTarget.d.ts",dts:'/**\n * @internalapi\n */\nexport declare enum ExtensionMessageTarget {\n    BACKGROUND = "toBackground",\n    PAGE = "toPage",\n    EXTENSION = "toExtension"\n}\n'},{name:"@airgap/beacon-types/dist/esm/types/Notification.d.ts",dts:"export interface Notification {\n    version: number;\n    apiUrl: string;\n    token: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/Origin.d.ts",dts:'/**\n * @internalapi\n */\nexport declare enum Origin {\n    WEBSITE = "website",\n    EXTENSION = "extension",\n    P2P = "p2p",\n    WALLETCONNECT = "walletconnect"\n}\n'},{name:"@airgap/beacon-types/dist/esm/types/P2PPairingRequest.d.ts",dts:"import { ExtendedPeerInfo, PeerInfo } from './PeerInfo';\n/**\n * @internalapi\n */\nexport declare class P2PPairingRequest implements PeerInfo {\n    readonly type: string;\n    relayServer: string;\n    id: string;\n    name: string;\n    icon?: string | undefined;\n    appUrl?: string | undefined;\n    publicKey: string;\n    version: string;\n    constructor(id: string, name: string, publicKey: string, version: string, relayServer: string, icon?: string, appUrl?: string);\n}\n/**\n * @internalapi\n */\nexport declare class ExtendedP2PPairingRequest extends P2PPairingRequest implements ExtendedPeerInfo {\n    senderId: string;\n    constructor(id: string, name: string, publicKey: string, version: string, relayServer: string, senderId: string, icon?: string, appUrl?: string);\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/P2PPairingResponse.d.ts",dts:"import { ExtendedPeerInfo, PeerInfo } from './PeerInfo';\n/**\n * @internalapi\n */\nexport declare class P2PPairingResponse implements PeerInfo {\n    readonly type: string;\n    relayServer: string;\n    id: string;\n    name: string;\n    icon?: string | undefined;\n    appUrl?: string | undefined;\n    publicKey: string;\n    version: string;\n    constructor(id: string, name: string, publicKey: string, version: string, relayServer: string, icon?: string, appUrl?: string);\n}\n/**\n * @internalapi\n */\nexport declare class ExtendedP2PPairingResponse extends P2PPairingResponse implements ExtendedPeerInfo {\n    senderId: string;\n    constructor(id: string, name: string, publicKey: string, version: string, relayServer: string, senderId: string, icon?: string, appUrl?: string);\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/PeerInfo.d.ts",dts:"export interface PeerInfo {\n    id: string;\n    name: string;\n    type: string;\n    icon?: string;\n    appUrl?: string;\n    publicKey: string;\n    version: string;\n}\nexport interface ExtendedPeerInfo extends PeerInfo {\n    senderId: string;\n}\nexport type PeerInfoType = PeerInfo | ExtendedPeerInfo;\n"},{name:"@airgap/beacon-types/dist/esm/types/PermissionEntity.d.ts",dts:"import { Network } from './beacon/Network';\nimport { PermissionScope } from './beacon/PermissionScope';\nimport { Threshold } from './beacon/Threshold';\nexport interface PermissionEntity {\n    address: string;\n    network: Network;\n    scopes: PermissionScope[];\n    threshold?: Threshold;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/PermissionInfo.d.ts",dts:"import { AppMetadata } from './beacon/AppMetadata';\nimport { PermissionEntity } from './PermissionEntity';\nexport interface PermissionInfo extends PermissionEntity {\n    accountIdentifier: string;\n    senderId: string;\n    appMetadata: AppMetadata;\n    website: string;\n    publicKey?: string;\n    connectedAt: number;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/PostMessagePairingRequest.d.ts",dts:"import { ExtendedPeerInfo, PeerInfo } from './PeerInfo';\n/**\n * @internalapi\n */\nexport declare class PostMessagePairingRequest implements PeerInfo {\n    readonly type: string;\n    id: string;\n    name: string;\n    icon?: string | undefined;\n    appUrl?: string | undefined;\n    publicKey: string;\n    version: string;\n    constructor(id: string, name: string, publicKey: string, version: string, icon?: string, appUrl?: string);\n}\n/**\n * @internalapi\n */\nexport declare class ExtendedPostMessagePairingRequest extends PostMessagePairingRequest implements ExtendedPeerInfo {\n    senderId: string;\n    constructor(id: string, name: string, publicKey: string, version: string, senderId: string, icon?: string, appUrl?: string);\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/PostMessagePairingResponse.d.ts",dts:"import { ExtendedPeerInfo, PeerInfo } from './PeerInfo';\n/**\n * @internalapi\n */\nexport declare class PostMessagePairingResponse implements PeerInfo {\n    readonly type: string;\n    id: string;\n    name: string;\n    icon?: string | undefined;\n    appUrl?: string | undefined;\n    publicKey: string;\n    version: string;\n    constructor(id: string, name: string, publicKey: string, version: string, icon?: string, appUrl?: string);\n}\n/**\n * @internalapi\n */\nexport declare class ExtendedPostMessagePairingResponse extends PostMessagePairingResponse implements ExtendedPeerInfo {\n    senderId: string;\n    extensionId: string;\n    constructor(id: string, name: string, publicKey: string, version: string, senderId: string, extensionId: string, icon?: string, appUrl?: string);\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/PushToken.d.ts",dts:"export interface PushToken {\n    publicKey: string;\n    backendUrl: string;\n    accessToken: string;\n    managementToken: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/Regions.d.ts",dts:'/**\n * Geographic region where a beacon node is located. This list can be changed in the future to be more specific, but for now it should cover most general areas.\n */\nexport declare enum Regions {\n    EUROPE_EAST = "europe-east",\n    EUROPE_WEST = "europe-west",\n    NORTH_AMERICA_EAST = "north-america-east",\n    NORTH_AMERICA_WEST = "north-america-west",\n    CENTRAL_AMERICA = "central-america",\n    SOUTH_AMERICA = "south-america",\n    ASIA_EAST = "asia-east",\n    ASIA_WEST = "asia-west",\n    AFRICA = "africa",\n    AUSTRALIA = "australia"\n}\nexport type NodeDistributions = Record<Regions | string, string[]>;\n'},{name:"@airgap/beacon-types/dist/esm/types/RequestBroadcastInput.d.ts",dts:'import { Network } from "./beacon/Network";\n/**\n * @category DApp\n */\nexport interface RequestBroadcastInput {\n    /**\n     * @deprecated You should now specify the network in the constructor of the DAppClient\n     */\n    network?: Network;\n    signedTransaction: string;\n}\n'},{name:"@airgap/beacon-types/dist/esm/types/RequestEncryptPayloadInput.d.ts",dts:"/**\n * @category DApp\n */\n"},{name:"@airgap/beacon-types/dist/esm/types/RequestOperationInput.d.ts",dts:"import { PartialTezosOperation } from './tezos/PartialTezosOperation';\n/**\n * @category DApp\n */\nexport interface RequestOperationInput {\n    operationDetails: PartialTezosOperation[];\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/RequestPermissionInput.d.ts",dts:"import { PermissionScope } from './beacon/PermissionScope';\n/**\n * @category DApp\n */\nexport interface RequestPermissionInput {\n    scopes?: PermissionScope[];\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/RequestProofOfEventChallengeInput.d.ts",dts:"/**\n * @category DApp\n */\nexport interface RequestProofOfEventChallengeInput {\n    payload: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/RequestSignPayloadInput.d.ts",dts:"import { SigningType } from './beacon/SigningType';\n/**\n * @category DApp\n */\nexport interface RequestSignPayloadInput {\n    signingType?: SigningType;\n    payload: string;\n    sourceAddress?: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/RequestSimulatedProofOfEventChallengeInput.d.ts",dts:"/**\n * @category DApp\n */\nexport interface RequestSimulatedProofOfEventChallengeInput {\n    /** A custom payload than should be emitted by the list of operations returned by the dapp*/\n    payload: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/WalletConnectPairingRequest.d.ts",dts:"import { ExtendedPeerInfo, PeerInfo } from './PeerInfo';\n/**\n * @internalapi\n */\nexport declare class WalletConnectPairingRequest implements PeerInfo {\n    readonly type: string;\n    uri: string;\n    id: string;\n    name: string;\n    icon?: string | undefined;\n    appUrl?: string | undefined;\n    publicKey: string;\n    version: string;\n    constructor(id: string, name: string, publicKey: string, version: string, uri: string, icon?: string, appUrl?: string);\n}\n/**\n * @internalapi\n */\nexport declare class ExtendedWalletConnectPairingRequest extends WalletConnectPairingRequest implements ExtendedPeerInfo {\n    senderId: string;\n    constructor(id: string, name: string, publicKey: string, version: string, senderId: string, uri: string, icon?: string, appUrl?: string);\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/WalletConnectPairingResponse.d.ts",dts:"import { PeerInfo } from './PeerInfo';\n/**\n * @internalapi\n */\nexport declare class WalletConnectPairingResponse implements PeerInfo {\n    readonly type: string;\n    id: string;\n    name: string;\n    icon?: string | undefined;\n    appUrl?: string | undefined;\n    publicKey: string;\n    version: string;\n    constructor(id: string, name: string, publicKey: string, version: string, icon?: string, appUrl?: string);\n}\n/**\n * @internalapi\n */\nexport declare class ExtendedWalletConnectPairingResponse extends WalletConnectPairingResponse {\n    senderId: string;\n    extensionId: string;\n    constructor(id: string, name: string, publicKey: string, version: string, senderId: string, extensionId: string, icon?: string, appUrl?: string);\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/WalletInfo.d.ts",dts:"export interface WalletInfo {\n    name: string;\n    type?: 'extension' | 'mobile' | 'web' | 'desktop';\n    icon?: string;\n    deeplink?: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/types/ui.d.ts",dts:"import { NetworkType } from './beacon/NetworkType';\nexport interface AppBase {\n    key: string;\n    name: string;\n    shortName: string;\n    color: string;\n    logo: string;\n    supportedInteractionStandards?: ('wallet_connect' | 'beacon')[];\n}\nexport interface ExtensionApp extends AppBase {\n    id: string;\n    link: string;\n}\nexport interface WebApp extends AppBase {\n    links: {\n        [NetworkType.MAINNET]: string;\n        [NetworkType.GHOSTNET]?: string;\n        [NetworkType.WEEKLYNET]?: string;\n        [NetworkType.DAILYNET]?: string;\n        [NetworkType.DELPHINET]?: string;\n        [NetworkType.EDONET]?: string;\n        [NetworkType.FLORENCENET]?: string;\n        [NetworkType.GRANADANET]?: string;\n        [NetworkType.HANGZHOUNET]?: string;\n        [NetworkType.ITHACANET]?: string;\n        [NetworkType.JAKARTANET]?: string;\n        [NetworkType.KATHMANDUNET]?: string;\n        [NetworkType.LIMANET]?: string;\n        [NetworkType.MUMBAINET]?: string;\n        [NetworkType.NAIROBINET]?: string;\n        [NetworkType.OXFORDNET]?: string;\n        [NetworkType.PARISNET]?: string;\n        [NetworkType.QUEBECNET]?: string;\n        [NetworkType.RIONET]?: string;\n        [NetworkType.SEOULNET]?: string;\n        [NetworkType.SHADOWNET]?: string;\n        [NetworkType.CUSTOM]?: string;\n    };\n}\nexport interface DesktopApp extends AppBase {\n    deepLink: string;\n    downloadLink: string;\n}\nexport interface App extends AppBase {\n    universalLink: string;\n    deepLink?: string;\n}\n"},{name:"@airgap/beacon-types/dist/esm/index.d.ts",dts:"/**\n * General docs\n * @module public\n */\nimport { AppMetadata } from './types/beacon/AppMetadata';\nimport { PermissionRequest } from './types/beacon/messages/PermissionRequest';\nimport { ProofOfEventChallengeRequest } from './types/beacon/messages/ProofOfEventChallengeRequest';\nimport { ProofOfEventChallengeResponse } from './types/beacon/messages/ProofOfEventChallengeResponse';\nimport { SimulatedProofOfEventChallengeRequest } from './types/beacon/messages/SimulatedProofOfEventChallengeRequest';\nimport { SimulatedProofOfEventChallengeResponse } from './types/beacon/messages/SimulatedProofOfEventChallengeResponse';\nimport { Network } from './types/beacon/Network';\nimport { BeaconBaseMessage } from './types/beacon/BeaconBaseMessage';\nimport { BeaconMessageType } from './types/beacon/BeaconMessageType';\nimport { PermissionScope } from './types/beacon/PermissionScope';\nimport { PermissionResponse } from './types/beacon/messages/PermissionResponse';\nimport { OperationRequest } from './types/beacon/messages/OperationRequest';\nimport { OperationResponse } from './types/beacon/messages/OperationResponse';\nimport { SignPayloadRequest } from './types/beacon/messages/SignPayloadRequest';\nimport { SignPayloadResponse } from './types/beacon/messages/SignPayloadResponse';\nimport { BroadcastRequest } from './types/beacon/messages/BroadcastRequest';\nimport { BroadcastResponse } from './types/beacon/messages/BroadcastResponse';\nimport { NetworkType } from './types/beacon/NetworkType';\nimport { TezosBaseOperation } from './types/tezos/TezosBaseOperation';\nimport { TezosOperationType } from './types/tezos/OperationTypes';\nimport { TezosActivateAccountOperation } from './types/tezos/operations/ActivateAccount';\nimport { TezosBallotOperation } from './types/tezos/operations/Ballot';\nimport { TezosDelegationOperation } from './types/tezos/operations/Delegation';\nimport { TezosDoubleBakingEvidenceOperation } from './types/tezos/operations/DoubleBakingEvidence';\nimport { TezosBlockHeader } from './types/tezos/TezosBlockHeader';\nimport { TezosDoubleEndorsementEvidenceOperation } from './types/tezos/operations/DoubleEndorsementEvidence';\nimport { TezosEndorsementOperation } from './types/tezos/operations/Endorsement';\nimport { TezosOriginationOperation } from './types/tezos/operations/Origination';\nimport { TezosProposalOperation } from './types/tezos/operations/Proposal';\nimport { TezosRevealOperation } from './types/tezos/operations/Reveal';\nimport { TezosSeedNonceRevelationOperation } from './types/tezos/operations/SeedNonceRevelation';\nimport { TezosTransactionOperation } from './types/tezos/operations/Transaction';\nimport { MichelineMichelsonV1Expression } from './types/tezos/MichelineMichelsonV1Expression';\nimport { MichelsonPrimitives } from './types/tezos/MichelsonPrimitives';\nimport { TezosTransactionParameters } from './types/tezos/TezosTransactionParameters';\nimport { Origin } from './types/Origin';\nimport { AccountInfo, AccountIdentifier } from './types/AccountInfo';\nimport { EncryptedExtensionMessage, ExtensionMessage } from './types/ExtensionMessage';\nimport { ExtensionMessageTarget } from './types/ExtensionMessageTarget';\nimport { TezosOperation } from './types/tezos/TezosOperation';\nimport { BeaconErrorType } from './types/BeaconErrorType';\nimport { ErrorResponse } from './types/beacon/messages/ErrorResponse';\nimport { TransportStatus } from './types/transport/TransportStatus';\nimport { TransportType } from './types/transport/TransportType';\nimport { Storage } from './types/storage/Storage';\nimport { StorageKey } from './types/storage/StorageKey';\nimport { defaultValues, StorageKeyReturnDefaults } from './types/storage/StorageKeyReturnDefaults';\nimport { StorageKeyReturnType } from './types/storage/StorageKeyReturnType';\nimport { ExtendedP2PPairingRequest, P2PPairingRequest } from './types/P2PPairingRequest';\nimport { BeaconMessage } from './types/beacon/BeaconMessage';\nimport { RequestPermissionInput } from './types/RequestPermissionInput';\nimport { RequestProofOfEventChallengeInput } from './types/RequestProofOfEventChallengeInput';\nimport { RequestSimulatedProofOfEventChallengeInput } from './types/RequestSimulatedProofOfEventChallengeInput';\nimport { RequestSignPayloadInput } from './types/RequestSignPayloadInput';\nimport { RequestOperationInput } from './types/RequestOperationInput';\nimport { RequestBroadcastInput } from './types/RequestBroadcastInput';\nimport { PermissionResponseInput, SignPayloadResponseInput, OperationResponseInput, BroadcastResponseInput, BeaconResponseInputMessage, AcknowledgeResponseInput, ErrorResponseInput, IgnoredResponseInputProperties } from './types/beacon/messages/BeaconResponseInputMessage';\nimport { PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, BeaconResponseOutputMessage, ProofOfEventChallengeResponseOutput, SimulatedProofOfEventChallengeResponseOutput } from './types/beacon/messages/BeaconResponseOutputMessage';\nimport { PermissionRequestInput, SignPayloadRequestInput, OperationRequestInput, BroadcastRequestInput, BeaconRequestInputMessage, IgnoredRequestInputProperties, ProofOfEventChallengeRequestInput, SimulatedProofOfEventChallengeRequestInput } from './types/beacon/messages/BeaconRequestInputMessage';\nimport { PermissionRequestOutput, SignPayloadRequestOutput, OperationRequestOutput, BroadcastRequestOutput, BeaconRequestOutputMessage, ProofOfEventChallengeRequestOutput, SimulatedProofOfEventChallengeRequestOutput } from './types/beacon/messages/BeaconRequestOutputMessage';\nimport { PermissionInfo } from './types/PermissionInfo';\nimport { ConnectionContext } from './types/ConnectionContext';\nimport { Threshold } from './types/beacon/Threshold';\nimport { PartialTezosTransactionOperation, PartialTezosOperation, PartialTezosDelegationOperation, PartialTezosOriginationOperation, PartialTezosRevealOperation, PartialTezosSmartRollupOriginateOperation, PartialTezosSmartRollupAddMessagesOperation, PartialTezosSmartRollupExecuteOutboxMessageOperation, PartialTezosSmartRollupPublishOperation, PartialTezosSmartRollupCementOperation, PartialTezosSmartRollupRecoverBondOperation, PartialTezosSmartRollupRefuteOperation, PartialTezosSmartRollupTimeoutOperation, PartialTezosDalPublishCommitmentOperation, PartialTezosIncreasePaidStorageOperation, PartialTezosRegisterGlobalConstantOperation, PartialTezosTransferTicketOperation, PartialTezosUpdateConsensusKeyOperation, PartialTezosSetDepositsLimitOperation } from './types/tezos/PartialTezosOperation';\nimport { ExtendedPeerInfo, PeerInfo, PeerInfoType } from './types/PeerInfo';\nimport { AcknowledgeResponse } from './types/beacon/messages/AcknowledgeResponse';\nimport { DisconnectMessage } from './types/beacon/messages/DisconnectMessage';\nimport { SigningType } from './types/beacon/SigningType';\nimport { ExtendedP2PPairingResponse, P2PPairingResponse } from './types/P2PPairingResponse';\nimport { ExtendedPostMessagePairingRequest, PostMessagePairingRequest } from './types/PostMessagePairingRequest';\nimport { ExtendedWalletConnectPairingResponse, WalletConnectPairingResponse } from './types/WalletConnectPairingResponse';\nimport { ExtendedWalletConnectPairingRequest, WalletConnectPairingRequest } from './types/WalletConnectPairingRequest';\nimport { ExtendedPostMessagePairingResponse, PostMessagePairingResponse } from './types/PostMessagePairingResponse';\nimport { BeaconRequestMessage } from './types/beacon/BeaconRequestMessage';\nimport { BeaconResponseMessage } from './types/beacon/BeaconResponseMessage';\nimport { ColorMode } from './types/ColorMode';\nimport { Optional } from './types/utils/Optional';\nimport { Extension } from './types/Extension';\nimport { PermissionEntity } from './types/PermissionEntity';\nimport { WalletInfo } from './types/WalletInfo';\nimport { ChangeAccountRequest } from './types/beacon/messages/ChangeAccountRequest';\nimport { TezosAttestationOperation } from './types/tezos/operations/Attestation';\nimport { TezosAttestationWithDalOperation } from './types/tezos/operations/AttestationWithDal';\nimport { TezosDoubleAttestationEvidenceOperation } from './types/tezos/operations/DoubleAttestationEvidence';\nimport { TezosDoublePreEndorsementEvidenceOperation } from './types/tezos/operations/DoublePreEndorsementEvidence';\nimport { TezosDrainDelegateOperation } from './types/tezos/operations/DrainDelegate';\nimport { TezosEndorsementWithDalOperation } from './types/tezos/operations/EndorsementWithDal';\nimport { TezosFailingNoopOperation } from './types/tezos/operations/FailingNoop';\nimport { TezosIncreasePaidStorageOperation } from './types/tezos/operations/IncreasePaidStorage';\nimport { TezosPreAttestationOperation } from './types/tezos/operations/PreAttestation';\nimport { TezosPreEndorsementOperation } from './types/tezos/operations/PreEndorsement';\nimport { TezosRegisterGlobalConstantOperation } from './types/tezos/operations/RegisterGlobalConstant';\nimport { TezosSetDepositsLimitOperation } from './types/tezos/operations/SetDepositsLimit';\nimport { TezosSmartRollupAddMessagesOperation } from './types/tezos/operations/SmartRollupAddMessages';\nimport { TezosSmartRollupExecuteOutboxMessageOperation } from './types/tezos/operations/SmartRollupExecuteOutboxMessage';\nimport { TezosSmartRollupPublishOperation } from './types/tezos/operations/SmartRollupPublish';\nimport { TezosSmartRollupRecoverBondOperation } from './types/tezos/operations/SmartRollupRecoverBond';\nimport { TezosSmartRollupRefuteOperation } from './types/tezos/operations/SmartRollupRefute';\nimport { TezosSmartRollupTimeoutOperation } from './types/tezos/operations/SmartRollupTimeout';\nimport { TezosTransferTicketOperation } from './types/tezos/operations/TransferTicket';\nimport { TezosUpdateConsensusKeyOperation } from './types/tezos/operations/UpdateConsensusKey';\nimport { TezosVdfRevelationOperation } from './types/tezos/operations/VdfRevelation';\nimport { TezosDoublePreAttestationEvidenceOperation } from './types/tezos/operations/DoublePreAttestationEvidence';\nimport { TezosSmartRollupCementOperation } from './types/tezos/operations/SmartRollupCement';\nimport { TezosSmartRollupOriginateOperation } from './types/tezos/operations/SmartRollupOriginate';\nimport { TezosDalPublishCommitmentOperation } from './types/tezos/operations/DalPublishCommitment';\nexport * from './types/AnalyticsInterface';\nexport * from './types/beaconV3/PermissionRequest';\nexport * from './types/ui';\nexport * from './types/Regions';\nexport { TezosBaseOperation, TezosOperationType, TezosBlockHeader, MichelineMichelsonV1Expression, MichelsonPrimitives, TezosTransactionParameters, TezosOperation };\nexport { TezosActivateAccountOperation, TezosBallotOperation, TezosDelegationOperation, TezosDoubleBakingEvidenceOperation, TezosDoubleEndorsementEvidenceOperation, TezosEndorsementOperation, TezosOriginationOperation, TezosProposalOperation, TezosRevealOperation, TezosSeedNonceRevelationOperation, TezosTransactionOperation, PartialTezosOperation, PartialTezosTransactionOperation, PartialTezosDelegationOperation, PartialTezosOriginationOperation, PartialTezosRevealOperation, PartialTezosSmartRollupOriginateOperation, PartialTezosSmartRollupAddMessagesOperation, PartialTezosSmartRollupExecuteOutboxMessageOperation, PartialTezosSmartRollupPublishOperation, PartialTezosSmartRollupCementOperation, PartialTezosSmartRollupRecoverBondOperation, PartialTezosSmartRollupRefuteOperation, PartialTezosSmartRollupTimeoutOperation, PartialTezosDalPublishCommitmentOperation, PartialTezosRegisterGlobalConstantOperation, PartialTezosTransferTicketOperation, PartialTezosIncreasePaidStorageOperation, PartialTezosUpdateConsensusKeyOperation, PartialTezosSetDepositsLimitOperation, TezosAttestationOperation, TezosPreAttestationOperation, TezosPreEndorsementOperation, TezosSetDepositsLimitOperation, TezosDoublePreAttestationEvidenceOperation, TezosDoublePreEndorsementEvidenceOperation, TezosAttestationWithDalOperation, TezosEndorsementWithDalOperation, TezosDoubleAttestationEvidenceOperation, TezosFailingNoopOperation, TezosRegisterGlobalConstantOperation, TezosTransferTicketOperation, TezosIncreasePaidStorageOperation, TezosUpdateConsensusKeyOperation, TezosDrainDelegateOperation, TezosVdfRevelationOperation, TezosSmartRollupOriginateOperation, TezosSmartRollupAddMessagesOperation, TezosSmartRollupExecuteOutboxMessageOperation, TezosSmartRollupPublishOperation, TezosSmartRollupCementOperation, TezosSmartRollupRecoverBondOperation, TezosSmartRollupRefuteOperation, TezosSmartRollupTimeoutOperation, TezosDalPublishCommitmentOperation };\nexport { AccountIdentifier, AppMetadata, Network, NetworkType, BeaconMessage, PermissionRequest, PermissionResponse, OperationRequest, OperationResponse, SignPayloadRequest, SignPayloadResponse, BroadcastRequest, BroadcastResponse, ChangeAccountRequest, AcknowledgeResponse, DisconnectMessage, BeaconBaseMessage, BeaconMessageType, PermissionScope, Origin, AccountInfo, Threshold, SigningType, ExtensionMessageTarget, ExtensionMessage, Extension, EncryptedExtensionMessage, RequestPermissionInput, RequestProofOfEventChallengeInput, RequestSimulatedProofOfEventChallengeInput, RequestSignPayloadInput, RequestOperationInput, RequestBroadcastInput, PermissionInfo, PermissionEntity, ProofOfEventChallengeRequest, ProofOfEventChallengeResponse, SimulatedProofOfEventChallengeRequest, SimulatedProofOfEventChallengeResponse };\nexport { PermissionResponseInput, SignPayloadResponseInput, OperationResponseInput, BroadcastResponseInput, AcknowledgeResponseInput, ErrorResponseInput, PermissionResponseOutput, ProofOfEventChallengeResponseOutput, SimulatedProofOfEventChallengeResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, PermissionRequestInput, SignPayloadRequestInput, ProofOfEventChallengeRequestInput, SimulatedProofOfEventChallengeRequestInput, OperationRequestInput, BroadcastRequestInput, PermissionRequestOutput, SignPayloadRequestOutput, ProofOfEventChallengeRequestOutput, SimulatedProofOfEventChallengeRequestOutput, OperationRequestOutput, BroadcastRequestOutput, BeaconRequestInputMessage, BeaconRequestOutputMessage, BeaconResponseInputMessage, BeaconResponseOutputMessage, BeaconRequestMessage, BeaconResponseMessage };\nexport { BeaconErrorType, ErrorResponse };\nexport { TransportStatus, TransportType };\nexport { Storage, StorageKey, StorageKeyReturnDefaults, StorageKeyReturnType };\nexport { PeerInfo, ExtendedPeerInfo, PeerInfoType, PostMessagePairingRequest, PostMessagePairingResponse, ExtendedPostMessagePairingRequest, ExtendedPostMessagePairingResponse, P2PPairingRequest, P2PPairingResponse, ExtendedP2PPairingRequest, ExtendedP2PPairingResponse, WalletConnectPairingResponse, WalletConnectPairingRequest, ExtendedWalletConnectPairingRequest, ExtendedWalletConnectPairingResponse };\nexport { IgnoredResponseInputProperties, IgnoredRequestInputProperties, defaultValues };\nexport { ConnectionContext, ColorMode, WalletInfo };\nexport { PushToken } from './types/PushToken';\nexport { Optional };\n"},{name:"@airgap/beacon-ui/components/alert/index.d.ts",dts:"import React from 'react';\nimport { AlertProps } from '../../ui/common';\ndeclare const Alert: React.FC<React.PropsWithChildren<AlertProps>>;\nexport default Alert;\n"},{name:"@airgap/beacon-ui/components/bug-report-form/index.d.ts",dts:"import React from 'react';\ndeclare const BugReportForm: React.FC<{\n    onSubmit: () => void;\n}>;\nexport default BugReportForm;\n"},{name:"@airgap/beacon-ui/components/button-icon/button-icon.d.ts",dts:"import React from 'react';\nimport './button-icon.css';\ninterface ButtonIconProps {\n    onClick?: () => void;\n    children: React.ReactNode;\n    className?: string;\n}\nexport declare const ButtonIcon: React.FC<ButtonIconProps>;\nexport {};\n"},{name:"@airgap/beacon-ui/components/icons/index.d.ts",dts:'interface IconProps {\n    style?: any;\n}\nexport declare function CloseIcon(props: IconProps): import("react/jsx-runtime").JSX.Element;\nexport declare function LeftIcon(props: IconProps): import("react/jsx-runtime").JSX.Element;\nexport declare function LogoIcon(props: IconProps): import("react/jsx-runtime").JSX.Element;\nexport declare function QRCodeIcon(): import("react/jsx-runtime").JSX.Element;\nexport {};\n'},{name:"@airgap/beacon-ui/components/info/index.d.ts",dts:"import React from 'react';\nimport { InfoProps } from '../../ui/common';\ndeclare const Info: React.FC<InfoProps>;\nexport default Info;\n"},{name:"@airgap/beacon-ui/components/loader/index.d.ts",dts:'import "./styles.css";\ndeclare const Loader: () => import("react/jsx-runtime").JSX.Element;\nexport default Loader;\n'},{name:"@airgap/beacon-ui/components/pair-other/index.d.ts",dts:"import React from 'react';\nimport { PairOtherProps } from '../../ui/common';\ndeclare const PairOther: React.FC<PairOtherProps>;\nexport default PairOther;\n"},{name:"@airgap/beacon-ui/components/qr/index.d.ts",dts:"import React from 'react';\nimport { QRProps } from 'src/ui/common';\ndeclare const QR: React.FC<QRProps>;\nexport default QR;\n"},{name:"@airgap/beacon-ui/components/toast/hooks/useDrag.d.ts",dts:"declare const useDrag: (handler: (state: {\n    offset: [number, number];\n}) => void) => () => {\n    onMouseDown: (e: React.MouseEvent) => void;\n};\nexport default useDrag;\n"},{name:"@airgap/beacon-ui/components/toast/index.d.ts",dts:"import React from 'react';\nimport { ToastProps } from '../../ui/common';\ndeclare const Toast: React.FC<ToastProps>;\nexport default Toast;\n"},{name:"@airgap/beacon-ui/components/top-wallets/index.d.ts",dts:"import React from 'react';\nimport { TopWalletsProps } from 'src/ui/common';\ndeclare const TopWallets: React.FC<TopWalletsProps>;\nexport default TopWallets;\n"},{name:"@airgap/beacon-ui/components/wallet/index.d.ts",dts:"import React from 'react';\nimport { WalletProps } from 'src/ui/common';\ndeclare const Wallet: React.FC<WalletProps>;\nexport default Wallet;\n"},{name:"@airgap/beacon-ui/components/wallets/index.d.ts",dts:"import React from 'react';\nimport { WalletsProps } from 'src/ui/common';\ndeclare const Wallets: React.FC<WalletsProps>;\nexport default Wallets;\n"},{name:"@airgap/beacon-ui/components/pairing.d.ts",dts:'import { DesktopApp, App, ExtensionApp, WebApp } from \'@airgap/beacon-types\';\nexport declare const getDesktopList: () => DesktopApp[];\nexport declare const setDesktopList: (desktopList: DesktopApp[]) => void;\nexport declare const getExtensionList: () => ExtensionApp[];\nexport declare const setExtensionList: (extensionList: ExtensionApp[]) => void;\nexport declare const getWebList: () => WebApp[];\nexport declare const setWebList: (webList: WebApp[]) => void;\nexport declare const getiOSList: () => App[];\nexport declare const setiOSList: (iosList: App[]) => void;\nexport declare enum Platform {\n    DESKTOP = 0,\n    IOS = 1,\n    ANDROID = 2\n}\nexport declare enum WalletType {\n    IOS = "ios",\n    ANDROID = "android",\n    EXTENSION = "extension",\n    DESKTOP = "desktop",\n    WEB = "web"\n}\nexport interface PairingAlertWallet {\n    key: string;\n    name: string;\n    shortName?: string;\n    color?: string;\n    logo?: string;\n    enabled: boolean;\n    clickHandler(): void;\n}\nexport interface PairingAlertButton {\n    title: string;\n    text: string;\n    clickHandler(): void;\n}\nexport interface PairingAlertList {\n    title: string;\n    type: WalletType;\n    wallets: PairingAlertWallet[];\n}\nexport interface PairingAlertInfo {\n    walletLists: PairingAlertList[];\n    buttons: PairingAlertButton[];\n}\nexport type StatusUpdateHandler = (walletType: WalletType, app?: PairingAlertWallet, keepOpen?: boolean) => void;\n/**\n * @internalapi\n *\n */\nexport declare class Pairing {\n}\n'},{name:"@airgap/beacon-ui/ui/alert/components/info-alert/index.d.ts",dts:"import { ConfigurableAlertProps } from '../../../common';\ndeclare const InfoAlert: ({ title, body, data, open, onClose, closeOnBackdropClick }: ConfigurableAlertProps) => import(\"react/jsx-runtime\").JSX.Element;\nexport default InfoAlert;\n"},{name:"@airgap/beacon-ui/ui/alert/components/pairing-alert/components/mobile-pairing/utils/suffix-map.d.ts",dts:"declare const suffixMap: Map<string, string>;\nexport default suffixMap;\n"},{name:"@airgap/beacon-ui/ui/alert/components/pairing-alert/components/mobile-pairing/index.d.ts",dts:"declare const MobilePairing: React.FC<any>;\nexport default MobilePairing;\n"},{name:"@airgap/beacon-ui/ui/alert/components/pairing-alert/components/qr-code/index.d.ts",dts:"import { QRCodeProps } from '../../../../../common';\ndeclare const QRCode: React.FC<QRCodeProps>;\nexport default QRCode;\n"},{name:"@airgap/beacon-ui/ui/alert/components/pairing-alert/components/wc-init-error/index.d.ts",dts:"import { WCInitErrorProps } from '../../../../../common';\ndeclare const WCInitError: React.FC<WCInitErrorProps>;\nexport default WCInitError;\n"},{name:"@airgap/beacon-ui/ui/alert/components/pairing-alert/index.d.ts",dts:"import { ConfigurableAlertProps } from '../../../common';\ndeclare const PairingAlert: React.FC<ConfigurableAlertProps>;\nexport default PairingAlert;\n"},{name:"@airgap/beacon-ui/ui/alert/hooks/useConnect.d.ts",dts:"import { MergedWallet } from '../../../utils/wallets';\nimport { AlertConfig, AlertState } from '../../common';\ndeclare const useConnect: (isMobile: boolean, wcPayload: Promise<string>, p2pPayload: Promise<string>, postPayload: Promise<string>, wallets: Map<string, MergedWallet>, onCloseHandler: Function) => readonly [MergedWallet | undefined, boolean, string | undefined, AlertState, boolean, boolean, boolean, (id: string, config: AlertConfig) => Promise<void>, (config: AlertConfig, wallet: MergedWallet) => Promise<void>, (wallet: MergedWallet) => Promise<void>, () => void, () => Promise<void>, () => void, () => Promise<void>, () => void, (newState: AlertState) => void, (uri: string) => void, () => void, (show: boolean) => void, (isLoading: boolean) => void];\nexport default useConnect;\n"},{name:"@airgap/beacon-ui/ui/alert/hooks/useIsMobile.d.ts",dts:"declare const useIsMobile: (breakpoint?: number) => boolean;\nexport default useIsMobile;\n"},{name:"@airgap/beacon-ui/ui/alert/hooks/useSubstrateWallets.d.ts",dts:"import { NetworkType } from '@airgap/beacon-types';\ndeclare const useSubstrateWallets: (networkType?: NetworkType, featuredWallets?: string[]) => Map<string, import(\"../../../utils/wallets\").MergedWallet>;\nexport default useSubstrateWallets;\n"},{name:"@airgap/beacon-ui/ui/alert/hooks/useWallets.d.ts",dts:"import { NetworkType } from '@airgap/beacon-types';\ndeclare const useWallets: (networkType?: NetworkType, featuredWallets?: string[]) => Map<string, import(\"../../../utils/wallets\").MergedWallet>;\nexport default useWallets;\n"},{name:"@airgap/beacon-ui/ui/alert/alert-templates.d.ts",dts:"export declare const alertTemplates: {\n    default: {\n        css: string;\n    };\n    pair: {\n        css: string;\n    };\n};\n"},{name:"@airgap/beacon-ui/ui/alert/getDefautlLogo.d.ts",dts:"export default function getDefaultLogo(): string;\n"},{name:"@airgap/beacon-ui/ui/alert/index.d.ts",dts:"import { AlertConfig } from '../common';\ndeclare const openAlert: (config: AlertConfig) => void;\ndeclare const openBugReport: () => void;\ndeclare const closeAlert: () => void;\n/**\n * @deprecated use `closeAlert` instead\n */\ndeclare const closeAlerts: () => void;\nexport { openAlert, openBugReport, closeAlert, closeAlerts };\n"},{name:"@airgap/beacon-ui/ui/alert/substrate-wallet-lists.d.ts",dts:"import { App, DesktopApp, ExtensionApp, WebApp } from '@airgap/beacon-types';\nexport declare const extensionList: ExtensionApp[];\nexport declare const desktopList: DesktopApp[];\nexport declare const webList: WebApp[];\nexport declare const iOSList: App[];\n"},{name:"@airgap/beacon-ui/ui/alert/wallet-lists.d.ts",dts:"import { App, DesktopApp, ExtensionApp, WebApp } from '@airgap/beacon-types';\nexport declare const extensionList: ExtensionApp[];\nexport declare const desktopList: DesktopApp[];\nexport declare const webList: WebApp[];\nexport declare const iOSList: App[];\n"},{name:"@airgap/beacon-ui/ui/toast/index.d.ts",dts:"import { ToastConfig } from '../common';\ndeclare const openToast: (config: ToastConfig) => void;\ndeclare const closeToast: () => void;\nexport { closeToast, openToast };\n"},{name:"@airgap/beacon-ui/ui/toast/toast-templates.d.ts",dts:"export declare const toastTemplates: {\n    default: {\n        css: string;\n    };\n};\n"},{name:"@airgap/beacon-ui/ui/common.d.ts",dts:"import { NetworkType, AnalyticsInterface, WalletInfo } from '@airgap/beacon-types';\nimport { MergedWallet } from '../utils/wallets';\nexport declare enum AlertState {\n    TOP_WALLETS = \"top-wallets\",\n    WALLETS = \"wallets\",\n    INSTALL = \"install\",\n    BUG_REPORT = \"bug-report\",\n    QR = \"qr\"\n}\nexport interface AlertButton {\n    text: string;\n    style?: 'solid' | 'outline';\n    actionCallback?(): Promise<void>;\n}\nexport interface AlertConfig {\n    title: string;\n    body?: string;\n    data?: string;\n    timer?: number;\n    buttons?: AlertButton[];\n    pairingPayload?: PairingPayload;\n    closeButtonCallback?: () => void;\n    disclaimerText?: string;\n    analytics?: AnalyticsInterface;\n    featuredWallets?: string[];\n    openBugReport?: boolean;\n    substratePairing?: boolean;\n}\nexport interface ConfigurableAlertProps extends Omit<AlertConfig, 'closeButtonCallback'> {\n    open: boolean;\n    onClose: () => void;\n    closeOnBackdropClick: boolean;\n}\nexport interface AlertProps {\n    open: boolean;\n    showMore?: boolean;\n    extraContent?: any;\n    loading?: boolean;\n    onCloseClick: () => void;\n    onClickShowMore?: () => void;\n    onBackClick?: () => void;\n    closeOnBackdropClick: boolean;\n}\nexport interface PairingPayload {\n    p2pSyncCode: Promise<string>;\n    postmessageSyncCode: Promise<string>;\n    walletConnectSyncCode: Promise<string>;\n    networkType: NetworkType;\n}\nexport interface PairOtherProps {\n    walletList: MergedWallet[];\n    p2pPayload: Promise<string>;\n    wcPayload: Promise<string>;\n    onClickLearnMore: () => void;\n}\nexport interface QRProps {\n    isWalletConnect: boolean;\n    isMobile: boolean;\n    walletName: string;\n    code: string;\n    onClickLearnMore?: () => void;\n    onClickQrCode?: () => void;\n}\nexport interface QRCodeProps {\n    wallet?: MergedWallet;\n    isWCWorking: boolean;\n    isMobile: boolean;\n    qrCode?: string;\n    defaultPairing: Promise<string>;\n    handleUpdateState: (state: AlertState) => void;\n    handleIsLoading: (isLoading: boolean) => void;\n}\nexport interface WCInitErrorProps {\n    title: string;\n    handleUpdateState: (state: AlertState) => void;\n}\nexport interface InfoProps {\n    title: string;\n    description?: string;\n    data?: string;\n    icon?: any;\n    border?: boolean;\n    iconBadge?: boolean;\n    bigIcon?: boolean;\n    buttons?: {\n        label: string;\n        type: 'primary' | 'secondary';\n        onClick: () => void;\n    }[];\n    downloadLink?: {\n        url: string;\n        label: string;\n    };\n    onShowQRCodeClick?: (() => void) | (() => Promise<void>);\n}\nexport interface TopWalletsProps {\n    wallets: MergedWallet[];\n    onClickWallet: (id: string) => void;\n    onClickLearnMore: () => void;\n    otherWallets?: {\n        images: string[];\n        onClick: () => void;\n    };\n    disabled?: boolean;\n    isMobile: boolean;\n}\nexport interface WalletProps {\n    name: string;\n    image: string;\n    description?: string;\n    small?: boolean;\n    mobile?: boolean;\n    onClick: () => void;\n    tags?: string[];\n    disabled?: boolean;\n}\nexport interface WalletsProps {\n    wallets: MergedWallet[];\n    onClickWallet: (id: string) => void;\n    onClickOther: () => void;\n    isMobile: boolean;\n    small?: boolean;\n    disabled?: boolean;\n}\nexport interface ToastAction {\n    text: string;\n    isBold?: boolean;\n    actionText?: string;\n    actionLogo?: 'external';\n    actionCallback?(): Promise<void>;\n}\nexport interface ToastConfig {\n    body: string;\n    timer?: number;\n    forceNew?: boolean;\n    state: 'prepare' | 'loading' | 'acknowledge' | 'finished';\n    actions?: ToastAction[];\n    walletInfo?: WalletInfo;\n    openWalletAction?(): Promise<void>;\n}\nexport interface ToastProps {\n    label: string;\n    open: boolean;\n    onClickClose: () => void;\n    actions?: {\n        text: string;\n        isBold?: boolean;\n        actionText?: string;\n        actionCallback?: () => void;\n    }[];\n    walletInfo?: {\n        deeplink?: string;\n        icon?: string;\n        name: string;\n        type?: string;\n    };\n    openWalletAction?: () => void;\n}\n"},{name:"@airgap/beacon-ui/utils/colorMode.d.ts",dts:"import { ColorMode } from '@airgap/beacon-types';\nexport declare const setColorMode: (mode: ColorMode) => void;\nexport declare const getColorMode: () => ColorMode;\n"},{name:"@airgap/beacon-ui/utils/get-tzip10-link.d.ts",dts:"export declare const getTzip10Link: (url: string, payload: string) => string;\n"},{name:"@airgap/beacon-ui/utils/platform.d.ts",dts:"export declare const testUserAgent: (win: Window, expr: RegExp) => boolean;\nexport declare const isMobile: (win: Window) => boolean;\nexport declare const isBrowser: (win: Window) => boolean;\nexport declare const isPrivacyBrowser: (win: Window) => boolean;\nexport declare const isIOS: (win: Window) => boolean;\nexport declare const isAndroid: (win: Window) => boolean;\nexport declare const isTwBrowser: (win: Window) => boolean;\nexport declare const isDesktop: (win: Window) => boolean;\nexport declare const isMobileOS: (win: Window) => boolean;\nexport declare const currentOS: () => string;\nexport declare const currentBrowser: () => string;\n"},{name:"@airgap/beacon-ui/utils/qr.d.ts",dts:"/**\n * Convert data to a QR code\n *\n * @param payload The data to be encoded as a QR code\n * @param type How the QR code will be encoded\n */\nexport declare const getQrData: (payload: string, height?: number, width?: number) => string;\n"},{name:"@airgap/beacon-ui/utils/subject.d.ts",dts:"export interface Subscription {\n    unsubscribe: () => void;\n}\nexport declare class Subject<T> {\n    private subscribers;\n    subscribe(callback: (value: T) => void): Subscription;\n    private unsubscribe;\n    next(value: T): void;\n}\n"},{name:"@airgap/beacon-ui/utils/wallets.d.ts",dts:"export interface Wallet {\n    id: string;\n    key: string;\n    name: string;\n    image: string;\n    description: string;\n    type: string;\n    link: string;\n    supportedInteractionStandards?: ('wallet_connect' | 'beacon')[];\n    deepLink?: string;\n}\nexport interface MergedWallet {\n    id: string;\n    firefoxId?: string;\n    key: string;\n    name: string;\n    image: string;\n    descriptions: string[];\n    types: string[];\n    links: string[];\n    supportedInteractionStandards?: ('wallet_connect' | 'beacon')[];\n    tags?: string[];\n    deepLink?: string;\n}\nexport declare enum OSLink {\n    WEB = 0,\n    IOS = 1,\n    DESKTOP = 2,\n    EXTENSION = 3\n}\nexport declare function parseWallets(wallets: Wallet[]): Wallet[];\nexport declare function arrangeTopWallets(arr: MergedWallet[], walletIds: string[]): MergedWallet[];\nexport declare function mergeWallets(wallets: Wallet[]): MergedWallet[];\n"},{name:"@airgap/beacon-ui/index.d.ts",dts:"export { openAlert, openBugReport, closeAlert, closeAlerts } from './ui/alert';\nexport type { AlertButton, AlertConfig, ToastAction } from './ui/common';\nexport { Pairing, setDesktopList, setExtensionList, setWebList, setiOSList, getDesktopList, getExtensionList, getWebList, getiOSList } from './components/pairing';\nexport { closeToast, openToast } from './ui/toast';\nexport { getColorMode, setColorMode } from './utils/colorMode';\nexport { isMobile, isMobileOS, isBrowser, isDesktop, isAndroid, isIOS, currentBrowser, currentOS } from './utils/platform';\n"},{name:"@airgap/beacon-ui/dist/components/alert/index.d.ts",dts:"import React from 'react';\nimport { AlertProps } from '../../ui/common';\ndeclare const Alert: React.FC<React.PropsWithChildren<AlertProps>>;\nexport default Alert;\n"},{name:"@airgap/beacon-ui/dist/components/bug-report-form/index.d.ts",dts:"import React from 'react';\ndeclare const BugReportForm: React.FC<{\n    onSubmit: () => void;\n}>;\nexport default BugReportForm;\n"},{name:"@airgap/beacon-ui/dist/components/button-icon/button-icon.d.ts",dts:"import React from 'react';\nimport './button-icon.css';\ninterface ButtonIconProps {\n    onClick?: () => void;\n    children: React.ReactNode;\n    className?: string;\n}\nexport declare const ButtonIcon: React.FC<ButtonIconProps>;\nexport {};\n"},{name:"@airgap/beacon-ui/dist/components/icons/index.d.ts",dts:'interface IconProps {\n    style?: any;\n}\nexport declare function CloseIcon(props: IconProps): import("react/jsx-runtime").JSX.Element;\nexport declare function LeftIcon(props: IconProps): import("react/jsx-runtime").JSX.Element;\nexport declare function LogoIcon(props: IconProps): import("react/jsx-runtime").JSX.Element;\nexport declare function QRCodeIcon(): import("react/jsx-runtime").JSX.Element;\nexport {};\n'},{name:"@airgap/beacon-ui/dist/components/info/index.d.ts",dts:"import React from 'react';\nimport { InfoProps } from '../../ui/common';\ndeclare const Info: React.FC<InfoProps>;\nexport default Info;\n"},{name:"@airgap/beacon-ui/dist/components/loader/index.d.ts",dts:'import "./styles.css";\ndeclare const Loader: () => import("react/jsx-runtime").JSX.Element;\nexport default Loader;\n'},{name:"@airgap/beacon-ui/dist/components/pair-other/index.d.ts",dts:"import React from 'react';\nimport { PairOtherProps } from '../../ui/common';\ndeclare const PairOther: React.FC<PairOtherProps>;\nexport default PairOther;\n"},{name:"@airgap/beacon-ui/dist/components/qr/index.d.ts",dts:"import React from 'react';\nimport { QRProps } from 'src/ui/common';\ndeclare const QR: React.FC<QRProps>;\nexport default QR;\n"},{name:"@airgap/beacon-ui/dist/components/toast/hooks/useDrag.d.ts",dts:"declare const useDrag: (handler: (state: {\n    offset: [number, number];\n}) => void) => () => {\n    onMouseDown: (e: React.MouseEvent) => void;\n};\nexport default useDrag;\n"},{name:"@airgap/beacon-ui/dist/components/toast/index.d.ts",dts:"import React from 'react';\nimport { ToastProps } from '../../ui/common';\ndeclare const Toast: React.FC<ToastProps>;\nexport default Toast;\n"},{name:"@airgap/beacon-ui/dist/components/top-wallets/index.d.ts",dts:"import React from 'react';\nimport { TopWalletsProps } from 'src/ui/common';\ndeclare const TopWallets: React.FC<TopWalletsProps>;\nexport default TopWallets;\n"},{name:"@airgap/beacon-ui/dist/components/wallet/index.d.ts",dts:"import React from 'react';\nimport { WalletProps } from 'src/ui/common';\ndeclare const Wallet: React.FC<WalletProps>;\nexport default Wallet;\n"},{name:"@airgap/beacon-ui/dist/components/wallets/index.d.ts",dts:"import React from 'react';\nimport { WalletsProps } from 'src/ui/common';\ndeclare const Wallets: React.FC<WalletsProps>;\nexport default Wallets;\n"},{name:"@airgap/beacon-ui/dist/components/pairing.d.ts",dts:'import { DesktopApp, App, ExtensionApp, WebApp } from \'@airgap/beacon-types\';\nexport declare const getDesktopList: () => DesktopApp[];\nexport declare const setDesktopList: (desktopList: DesktopApp[]) => void;\nexport declare const getExtensionList: () => ExtensionApp[];\nexport declare const setExtensionList: (extensionList: ExtensionApp[]) => void;\nexport declare const getWebList: () => WebApp[];\nexport declare const setWebList: (webList: WebApp[]) => void;\nexport declare const getiOSList: () => App[];\nexport declare const setiOSList: (iosList: App[]) => void;\nexport declare enum Platform {\n    DESKTOP = 0,\n    IOS = 1,\n    ANDROID = 2\n}\nexport declare enum WalletType {\n    IOS = "ios",\n    ANDROID = "android",\n    EXTENSION = "extension",\n    DESKTOP = "desktop",\n    WEB = "web"\n}\nexport interface PairingAlertWallet {\n    key: string;\n    name: string;\n    shortName?: string;\n    color?: string;\n    logo?: string;\n    enabled: boolean;\n    clickHandler(): void;\n}\nexport interface PairingAlertButton {\n    title: string;\n    text: string;\n    clickHandler(): void;\n}\nexport interface PairingAlertList {\n    title: string;\n    type: WalletType;\n    wallets: PairingAlertWallet[];\n}\nexport interface PairingAlertInfo {\n    walletLists: PairingAlertList[];\n    buttons: PairingAlertButton[];\n}\nexport type StatusUpdateHandler = (walletType: WalletType, app?: PairingAlertWallet, keepOpen?: boolean) => void;\n/**\n * @internalapi\n *\n */\nexport declare class Pairing {\n}\n'},{name:"@airgap/beacon-ui/dist/esm/components/alert/index.d.ts",dts:"import React from 'react';\nimport { AlertProps } from '../../ui/common';\ndeclare const Alert: React.FC<React.PropsWithChildren<AlertProps>>;\nexport default Alert;\n"},{name:"@airgap/beacon-ui/dist/esm/components/bug-report-form/index.d.ts",dts:"import React from 'react';\ndeclare const BugReportForm: React.FC<{\n    onSubmit: () => void;\n}>;\nexport default BugReportForm;\n"},{name:"@airgap/beacon-ui/dist/esm/components/button-icon/button-icon.d.ts",dts:"import React from 'react';\nimport './button-icon.css';\ninterface ButtonIconProps {\n    onClick?: () => void;\n    children: React.ReactNode;\n    className?: string;\n}\nexport declare const ButtonIcon: React.FC<ButtonIconProps>;\nexport {};\n"},{name:"@airgap/beacon-ui/dist/esm/components/icons/index.d.ts",dts:'interface IconProps {\n    style?: any;\n}\nexport declare function CloseIcon(props: IconProps): import("react/jsx-runtime").JSX.Element;\nexport declare function LeftIcon(props: IconProps): import("react/jsx-runtime").JSX.Element;\nexport declare function LogoIcon(props: IconProps): import("react/jsx-runtime").JSX.Element;\nexport declare function QRCodeIcon(): import("react/jsx-runtime").JSX.Element;\nexport {};\n'},{name:"@airgap/beacon-ui/dist/esm/components/info/index.d.ts",dts:"import React from 'react';\nimport { InfoProps } from '../../ui/common';\ndeclare const Info: React.FC<InfoProps>;\nexport default Info;\n"},{name:"@airgap/beacon-ui/dist/esm/components/loader/index.d.ts",dts:'import "./styles.css";\ndeclare const Loader: () => import("react/jsx-runtime").JSX.Element;\nexport default Loader;\n'},{name:"@airgap/beacon-ui/dist/esm/components/pair-other/index.d.ts",dts:"import React from 'react';\nimport { PairOtherProps } from '../../ui/common';\ndeclare const PairOther: React.FC<PairOtherProps>;\nexport default PairOther;\n"},{name:"@airgap/beacon-ui/dist/esm/components/qr/index.d.ts",dts:"import React from 'react';\nimport { QRProps } from 'src/ui/common';\ndeclare const QR: React.FC<QRProps>;\nexport default QR;\n"},{name:"@airgap/beacon-ui/dist/esm/components/toast/hooks/useDrag.d.ts",dts:"declare const useDrag: (handler: (state: {\n    offset: [number, number];\n}) => void) => () => {\n    onMouseDown: (e: React.MouseEvent) => void;\n};\nexport default useDrag;\n"},{name:"@airgap/beacon-ui/dist/esm/components/toast/index.d.ts",dts:"import React from 'react';\nimport { ToastProps } from '../../ui/common';\ndeclare const Toast: React.FC<ToastProps>;\nexport default Toast;\n"},{name:"@airgap/beacon-ui/dist/esm/components/top-wallets/index.d.ts",dts:"import React from 'react';\nimport { TopWalletsProps } from 'src/ui/common';\ndeclare const TopWallets: React.FC<TopWalletsProps>;\nexport default TopWallets;\n"},{name:"@airgap/beacon-ui/dist/esm/components/wallet/index.d.ts",dts:"import React from 'react';\nimport { WalletProps } from 'src/ui/common';\ndeclare const Wallet: React.FC<WalletProps>;\nexport default Wallet;\n"},{name:"@airgap/beacon-ui/dist/esm/components/wallets/index.d.ts",dts:"import React from 'react';\nimport { WalletsProps } from 'src/ui/common';\ndeclare const Wallets: React.FC<WalletsProps>;\nexport default Wallets;\n"},{name:"@airgap/beacon-ui/dist/esm/components/pairing.d.ts",dts:'import { DesktopApp, App, ExtensionApp, WebApp } from \'@airgap/beacon-types\';\nexport declare const getDesktopList: () => DesktopApp[];\nexport declare const setDesktopList: (desktopList: DesktopApp[]) => void;\nexport declare const getExtensionList: () => ExtensionApp[];\nexport declare const setExtensionList: (extensionList: ExtensionApp[]) => void;\nexport declare const getWebList: () => WebApp[];\nexport declare const setWebList: (webList: WebApp[]) => void;\nexport declare const getiOSList: () => App[];\nexport declare const setiOSList: (iosList: App[]) => void;\nexport declare enum Platform {\n    DESKTOP = 0,\n    IOS = 1,\n    ANDROID = 2\n}\nexport declare enum WalletType {\n    IOS = "ios",\n    ANDROID = "android",\n    EXTENSION = "extension",\n    DESKTOP = "desktop",\n    WEB = "web"\n}\nexport interface PairingAlertWallet {\n    key: string;\n    name: string;\n    shortName?: string;\n    color?: string;\n    logo?: string;\n    enabled: boolean;\n    clickHandler(): void;\n}\nexport interface PairingAlertButton {\n    title: string;\n    text: string;\n    clickHandler(): void;\n}\nexport interface PairingAlertList {\n    title: string;\n    type: WalletType;\n    wallets: PairingAlertWallet[];\n}\nexport interface PairingAlertInfo {\n    walletLists: PairingAlertList[];\n    buttons: PairingAlertButton[];\n}\nexport type StatusUpdateHandler = (walletType: WalletType, app?: PairingAlertWallet, keepOpen?: boolean) => void;\n/**\n * @internalapi\n *\n */\nexport declare class Pairing {\n}\n'},{name:"@airgap/beacon-ui/dist/esm/ui/alert/components/info-alert/index.d.ts",dts:"import { ConfigurableAlertProps } from '../../../common';\ndeclare const InfoAlert: ({ title, body, data, open, onClose, closeOnBackdropClick }: ConfigurableAlertProps) => import(\"react/jsx-runtime\").JSX.Element;\nexport default InfoAlert;\n"},{name:"@airgap/beacon-ui/dist/esm/ui/alert/components/pairing-alert/components/mobile-pairing/utils/suffix-map.d.ts",dts:"declare const suffixMap: Map<string, string>;\nexport default suffixMap;\n"},{name:"@airgap/beacon-ui/dist/esm/ui/alert/components/pairing-alert/components/mobile-pairing/index.d.ts",dts:"declare const MobilePairing: React.FC<any>;\nexport default MobilePairing;\n"},{name:"@airgap/beacon-ui/dist/esm/ui/alert/components/pairing-alert/components/qr-code/index.d.ts",dts:"import { QRCodeProps } from '../../../../../common';\ndeclare const QRCode: React.FC<QRCodeProps>;\nexport default QRCode;\n"},{name:"@airgap/beacon-ui/dist/esm/ui/alert/components/pairing-alert/components/wc-init-error/index.d.ts",dts:"import { WCInitErrorProps } from '../../../../../common';\ndeclare const WCInitError: React.FC<WCInitErrorProps>;\nexport default WCInitError;\n"},{name:"@airgap/beacon-ui/dist/esm/ui/alert/components/pairing-alert/index.d.ts",dts:"import { ConfigurableAlertProps } from '../../../common';\ndeclare const PairingAlert: React.FC<ConfigurableAlertProps>;\nexport default PairingAlert;\n"},{name:"@airgap/beacon-ui/dist/esm/ui/alert/hooks/useConnect.d.ts",dts:"import { MergedWallet } from '../../../utils/wallets';\nimport { AlertConfig, AlertState } from '../../common';\ndeclare const useConnect: (isMobile: boolean, wcPayload: Promise<string>, p2pPayload: Promise<string>, postPayload: Promise<string>, wallets: Map<string, MergedWallet>, onCloseHandler: Function) => readonly [MergedWallet | undefined, boolean, string | undefined, AlertState, boolean, boolean, boolean, (id: string, config: AlertConfig) => Promise<void>, (config: AlertConfig, wallet: MergedWallet) => Promise<void>, (wallet: MergedWallet) => Promise<void>, () => void, () => Promise<void>, () => void, () => Promise<void>, () => void, (newState: AlertState) => void, (uri: string) => void, () => void, (show: boolean) => void, (isLoading: boolean) => void];\nexport default useConnect;\n"},{name:"@airgap/beacon-ui/dist/esm/ui/alert/hooks/useIsMobile.d.ts",dts:"declare const useIsMobile: (breakpoint?: number) => boolean;\nexport default useIsMobile;\n"},{name:"@airgap/beacon-ui/dist/esm/ui/alert/hooks/useSubstrateWallets.d.ts",dts:"import { NetworkType } from '@airgap/beacon-types';\ndeclare const useSubstrateWallets: (networkType?: NetworkType, featuredWallets?: string[]) => Map<string, import(\"../../../utils/wallets\").MergedWallet>;\nexport default useSubstrateWallets;\n"},{name:"@airgap/beacon-ui/dist/esm/ui/alert/hooks/useWallets.d.ts",dts:"import { NetworkType } from '@airgap/beacon-types';\ndeclare const useWallets: (networkType?: NetworkType, featuredWallets?: string[]) => Map<string, import(\"../../../utils/wallets\").MergedWallet>;\nexport default useWallets;\n"},{name:"@airgap/beacon-ui/dist/esm/ui/alert/alert-templates.d.ts",dts:"export declare const alertTemplates: {\n    default: {\n        css: string;\n    };\n    pair: {\n        css: string;\n    };\n};\n"},{name:"@airgap/beacon-ui/dist/esm/ui/alert/getDefautlLogo.d.ts",dts:"export default function getDefaultLogo(): string;\n"},{name:"@airgap/beacon-ui/dist/esm/ui/alert/index.d.ts",dts:"import { AlertConfig } from '../common';\ndeclare const openAlert: (config: AlertConfig) => void;\ndeclare const openBugReport: () => void;\ndeclare const closeAlert: () => void;\n/**\n * @deprecated use `closeAlert` instead\n */\ndeclare const closeAlerts: () => void;\nexport { openAlert, openBugReport, closeAlert, closeAlerts };\n"},{name:"@airgap/beacon-ui/dist/esm/ui/alert/substrate-wallet-lists.d.ts",dts:"import { App, DesktopApp, ExtensionApp, WebApp } from '@airgap/beacon-types';\nexport declare const extensionList: ExtensionApp[];\nexport declare const desktopList: DesktopApp[];\nexport declare const webList: WebApp[];\nexport declare const iOSList: App[];\n"},{name:"@airgap/beacon-ui/dist/esm/ui/alert/wallet-lists.d.ts",dts:"import { App, DesktopApp, ExtensionApp, WebApp } from '@airgap/beacon-types';\nexport declare const extensionList: ExtensionApp[];\nexport declare const desktopList: DesktopApp[];\nexport declare const webList: WebApp[];\nexport declare const iOSList: App[];\n"},{name:"@airgap/beacon-ui/dist/esm/ui/toast/index.d.ts",dts:"import { ToastConfig } from '../common';\ndeclare const openToast: (config: ToastConfig) => void;\ndeclare const closeToast: () => void;\nexport { closeToast, openToast };\n"},{name:"@airgap/beacon-ui/dist/esm/ui/toast/toast-templates.d.ts",dts:"export declare const toastTemplates: {\n    default: {\n        css: string;\n    };\n};\n"},{name:"@airgap/beacon-ui/dist/esm/ui/common.d.ts",dts:"import { NetworkType, AnalyticsInterface, WalletInfo } from '@airgap/beacon-types';\nimport { MergedWallet } from '../utils/wallets';\nexport declare enum AlertState {\n    TOP_WALLETS = \"top-wallets\",\n    WALLETS = \"wallets\",\n    INSTALL = \"install\",\n    BUG_REPORT = \"bug-report\",\n    QR = \"qr\"\n}\nexport interface AlertButton {\n    text: string;\n    style?: 'solid' | 'outline';\n    actionCallback?(): Promise<void>;\n}\nexport interface AlertConfig {\n    title: string;\n    body?: string;\n    data?: string;\n    timer?: number;\n    buttons?: AlertButton[];\n    pairingPayload?: PairingPayload;\n    closeButtonCallback?: () => void;\n    disclaimerText?: string;\n    analytics?: AnalyticsInterface;\n    featuredWallets?: string[];\n    openBugReport?: boolean;\n    substratePairing?: boolean;\n}\nexport interface ConfigurableAlertProps extends Omit<AlertConfig, 'closeButtonCallback'> {\n    open: boolean;\n    onClose: () => void;\n    closeOnBackdropClick: boolean;\n}\nexport interface AlertProps {\n    open: boolean;\n    showMore?: boolean;\n    extraContent?: any;\n    loading?: boolean;\n    onCloseClick: () => void;\n    onClickShowMore?: () => void;\n    onBackClick?: () => void;\n    closeOnBackdropClick: boolean;\n}\nexport interface PairingPayload {\n    p2pSyncCode: Promise<string>;\n    postmessageSyncCode: Promise<string>;\n    walletConnectSyncCode: Promise<string>;\n    networkType: NetworkType;\n}\nexport interface PairOtherProps {\n    walletList: MergedWallet[];\n    p2pPayload: Promise<string>;\n    wcPayload: Promise<string>;\n    onClickLearnMore: () => void;\n}\nexport interface QRProps {\n    isWalletConnect: boolean;\n    isMobile: boolean;\n    walletName: string;\n    code: string;\n    onClickLearnMore?: () => void;\n    onClickQrCode?: () => void;\n}\nexport interface QRCodeProps {\n    wallet?: MergedWallet;\n    isWCWorking: boolean;\n    isMobile: boolean;\n    qrCode?: string;\n    defaultPairing: Promise<string>;\n    handleUpdateState: (state: AlertState) => void;\n    handleIsLoading: (isLoading: boolean) => void;\n}\nexport interface WCInitErrorProps {\n    title: string;\n    handleUpdateState: (state: AlertState) => void;\n}\nexport interface InfoProps {\n    title: string;\n    description?: string;\n    data?: string;\n    icon?: any;\n    border?: boolean;\n    iconBadge?: boolean;\n    bigIcon?: boolean;\n    buttons?: {\n        label: string;\n        type: 'primary' | 'secondary';\n        onClick: () => void;\n    }[];\n    downloadLink?: {\n        url: string;\n        label: string;\n    };\n    onShowQRCodeClick?: (() => void) | (() => Promise<void>);\n}\nexport interface TopWalletsProps {\n    wallets: MergedWallet[];\n    onClickWallet: (id: string) => void;\n    onClickLearnMore: () => void;\n    otherWallets?: {\n        images: string[];\n        onClick: () => void;\n    };\n    disabled?: boolean;\n    isMobile: boolean;\n}\nexport interface WalletProps {\n    name: string;\n    image: string;\n    description?: string;\n    small?: boolean;\n    mobile?: boolean;\n    onClick: () => void;\n    tags?: string[];\n    disabled?: boolean;\n}\nexport interface WalletsProps {\n    wallets: MergedWallet[];\n    onClickWallet: (id: string) => void;\n    onClickOther: () => void;\n    isMobile: boolean;\n    small?: boolean;\n    disabled?: boolean;\n}\nexport interface ToastAction {\n    text: string;\n    isBold?: boolean;\n    actionText?: string;\n    actionLogo?: 'external';\n    actionCallback?(): Promise<void>;\n}\nexport interface ToastConfig {\n    body: string;\n    timer?: number;\n    forceNew?: boolean;\n    state: 'prepare' | 'loading' | 'acknowledge' | 'finished';\n    actions?: ToastAction[];\n    walletInfo?: WalletInfo;\n    openWalletAction?(): Promise<void>;\n}\nexport interface ToastProps {\n    label: string;\n    open: boolean;\n    onClickClose: () => void;\n    actions?: {\n        text: string;\n        isBold?: boolean;\n        actionText?: string;\n        actionCallback?: () => void;\n    }[];\n    walletInfo?: {\n        deeplink?: string;\n        icon?: string;\n        name: string;\n        type?: string;\n    };\n    openWalletAction?: () => void;\n}\n"},{name:"@airgap/beacon-ui/dist/esm/utils/colorMode.d.ts",dts:"import { ColorMode } from '@airgap/beacon-types';\nexport declare const setColorMode: (mode: ColorMode) => void;\nexport declare const getColorMode: () => ColorMode;\n"},{name:"@airgap/beacon-ui/dist/esm/utils/get-tzip10-link.d.ts",dts:"export declare const getTzip10Link: (url: string, payload: string) => string;\n"},{name:"@airgap/beacon-ui/dist/esm/utils/platform.d.ts",dts:"export declare const testUserAgent: (win: Window, expr: RegExp) => boolean;\nexport declare const isMobile: (win: Window) => boolean;\nexport declare const isBrowser: (win: Window) => boolean;\nexport declare const isPrivacyBrowser: (win: Window) => boolean;\nexport declare const isIOS: (win: Window) => boolean;\nexport declare const isAndroid: (win: Window) => boolean;\nexport declare const isTwBrowser: (win: Window) => boolean;\nexport declare const isDesktop: (win: Window) => boolean;\nexport declare const isMobileOS: (win: Window) => boolean;\nexport declare const currentOS: () => string;\nexport declare const currentBrowser: () => string;\n"},{name:"@airgap/beacon-ui/dist/esm/utils/qr.d.ts",dts:"/**\n * Convert data to a QR code\n *\n * @param payload The data to be encoded as a QR code\n * @param type How the QR code will be encoded\n */\nexport declare const getQrData: (payload: string, height?: number, width?: number) => string;\n"},{name:"@airgap/beacon-ui/dist/esm/utils/subject.d.ts",dts:"export interface Subscription {\n    unsubscribe: () => void;\n}\nexport declare class Subject<T> {\n    private subscribers;\n    subscribe(callback: (value: T) => void): Subscription;\n    private unsubscribe;\n    next(value: T): void;\n}\n"},{name:"@airgap/beacon-ui/dist/esm/utils/wallets.d.ts",dts:"export interface Wallet {\n    id: string;\n    key: string;\n    name: string;\n    image: string;\n    description: string;\n    type: string;\n    link: string;\n    supportedInteractionStandards?: ('wallet_connect' | 'beacon')[];\n    deepLink?: string;\n}\nexport interface MergedWallet {\n    id: string;\n    firefoxId?: string;\n    key: string;\n    name: string;\n    image: string;\n    descriptions: string[];\n    types: string[];\n    links: string[];\n    supportedInteractionStandards?: ('wallet_connect' | 'beacon')[];\n    tags?: string[];\n    deepLink?: string;\n}\nexport declare enum OSLink {\n    WEB = 0,\n    IOS = 1,\n    DESKTOP = 2,\n    EXTENSION = 3\n}\nexport declare function parseWallets(wallets: Wallet[]): Wallet[];\nexport declare function arrangeTopWallets(arr: MergedWallet[], walletIds: string[]): MergedWallet[];\nexport declare function mergeWallets(wallets: Wallet[]): MergedWallet[];\n"},{name:"@airgap/beacon-ui/dist/esm/index.d.ts",dts:"export { openAlert, openBugReport, closeAlert, closeAlerts } from './ui/alert';\nexport type { AlertButton, AlertConfig, ToastAction } from './ui/common';\nexport { Pairing, setDesktopList, setExtensionList, setWebList, setiOSList, getDesktopList, getExtensionList, getWebList, getiOSList } from './components/pairing';\nexport { closeToast, openToast } from './ui/toast';\nexport { getColorMode, setColorMode } from './utils/colorMode';\nexport { isMobile, isMobileOS, isBrowser, isDesktop, isAndroid, isIOS, currentBrowser, currentOS } from './utils/platform';\n"},{name:"@airgap/beacon-ui/dist/ui/alert/components/info-alert/index.d.ts",dts:"import { ConfigurableAlertProps } from '../../../common';\ndeclare const InfoAlert: ({ title, body, data, open, onClose, closeOnBackdropClick }: ConfigurableAlertProps) => import(\"react/jsx-runtime\").JSX.Element;\nexport default InfoAlert;\n"},{name:"@airgap/beacon-ui/dist/ui/alert/components/pairing-alert/components/mobile-pairing/utils/suffix-map.d.ts",dts:"declare const suffixMap: Map<string, string>;\nexport default suffixMap;\n"},{name:"@airgap/beacon-ui/dist/ui/alert/components/pairing-alert/components/mobile-pairing/index.d.ts",dts:"declare const MobilePairing: React.FC<any>;\nexport default MobilePairing;\n"},{name:"@airgap/beacon-ui/dist/ui/alert/components/pairing-alert/components/qr-code/index.d.ts",dts:"import { QRCodeProps } from '../../../../../common';\ndeclare const QRCode: React.FC<QRCodeProps>;\nexport default QRCode;\n"},{name:"@airgap/beacon-ui/dist/ui/alert/components/pairing-alert/components/wc-init-error/index.d.ts",dts:"import { WCInitErrorProps } from '../../../../../common';\ndeclare const WCInitError: React.FC<WCInitErrorProps>;\nexport default WCInitError;\n"},{name:"@airgap/beacon-ui/dist/ui/alert/components/pairing-alert/index.d.ts",dts:"import { ConfigurableAlertProps } from '../../../common';\ndeclare const PairingAlert: React.FC<ConfigurableAlertProps>;\nexport default PairingAlert;\n"},{name:"@airgap/beacon-ui/dist/ui/alert/hooks/useConnect.d.ts",dts:"import { MergedWallet } from '../../../utils/wallets';\nimport { AlertConfig, AlertState } from '../../common';\ndeclare const useConnect: (isMobile: boolean, wcPayload: Promise<string>, p2pPayload: Promise<string>, postPayload: Promise<string>, wallets: Map<string, MergedWallet>, onCloseHandler: Function) => readonly [MergedWallet | undefined, boolean, string | undefined, AlertState, boolean, boolean, boolean, (id: string, config: AlertConfig) => Promise<void>, (config: AlertConfig, wallet: MergedWallet) => Promise<void>, (wallet: MergedWallet) => Promise<void>, () => void, () => Promise<void>, () => void, () => Promise<void>, () => void, (newState: AlertState) => void, (uri: string) => void, () => void, (show: boolean) => void, (isLoading: boolean) => void];\nexport default useConnect;\n"},{name:"@airgap/beacon-ui/dist/ui/alert/hooks/useIsMobile.d.ts",dts:"declare const useIsMobile: (breakpoint?: number) => boolean;\nexport default useIsMobile;\n"},{name:"@airgap/beacon-ui/dist/ui/alert/hooks/useSubstrateWallets.d.ts",dts:"import { NetworkType } from '@airgap/beacon-types';\ndeclare const useSubstrateWallets: (networkType?: NetworkType, featuredWallets?: string[]) => Map<string, import(\"../../../utils/wallets\").MergedWallet>;\nexport default useSubstrateWallets;\n"},{name:"@airgap/beacon-ui/dist/ui/alert/hooks/useWallets.d.ts",dts:"import { NetworkType } from '@airgap/beacon-types';\ndeclare const useWallets: (networkType?: NetworkType, featuredWallets?: string[]) => Map<string, import(\"../../../utils/wallets\").MergedWallet>;\nexport default useWallets;\n"},{name:"@airgap/beacon-ui/dist/ui/alert/alert-templates.d.ts",dts:"export declare const alertTemplates: {\n    default: {\n        css: string;\n    };\n    pair: {\n        css: string;\n    };\n};\n"},{name:"@airgap/beacon-ui/dist/ui/alert/getDefautlLogo.d.ts",dts:"export default function getDefaultLogo(): string;\n"},{name:"@airgap/beacon-ui/dist/ui/alert/index.d.ts",dts:"import { AlertConfig } from '../common';\ndeclare const openAlert: (config: AlertConfig) => void;\ndeclare const openBugReport: () => void;\ndeclare const closeAlert: () => void;\n/**\n * @deprecated use `closeAlert` instead\n */\ndeclare const closeAlerts: () => void;\nexport { openAlert, openBugReport, closeAlert, closeAlerts };\n"},{name:"@airgap/beacon-ui/dist/ui/alert/substrate-wallet-lists.d.ts",dts:"import { App, DesktopApp, ExtensionApp, WebApp } from '@airgap/beacon-types';\nexport declare const extensionList: ExtensionApp[];\nexport declare const desktopList: DesktopApp[];\nexport declare const webList: WebApp[];\nexport declare const iOSList: App[];\n"},{name:"@airgap/beacon-ui/dist/ui/alert/wallet-lists.d.ts",dts:"import { App, DesktopApp, ExtensionApp, WebApp } from '@airgap/beacon-types';\nexport declare const extensionList: ExtensionApp[];\nexport declare const desktopList: DesktopApp[];\nexport declare const webList: WebApp[];\nexport declare const iOSList: App[];\n"},{name:"@airgap/beacon-ui/dist/ui/toast/index.d.ts",dts:"import { ToastConfig } from '../common';\ndeclare const openToast: (config: ToastConfig) => void;\ndeclare const closeToast: () => void;\nexport { closeToast, openToast };\n"},{name:"@airgap/beacon-ui/dist/ui/toast/toast-templates.d.ts",dts:"export declare const toastTemplates: {\n    default: {\n        css: string;\n    };\n};\n"},{name:"@airgap/beacon-ui/dist/ui/common.d.ts",dts:"import { NetworkType, AnalyticsInterface, WalletInfo } from '@airgap/beacon-types';\nimport { MergedWallet } from '../utils/wallets';\nexport declare enum AlertState {\n    TOP_WALLETS = \"top-wallets\",\n    WALLETS = \"wallets\",\n    INSTALL = \"install\",\n    BUG_REPORT = \"bug-report\",\n    QR = \"qr\"\n}\nexport interface AlertButton {\n    text: string;\n    style?: 'solid' | 'outline';\n    actionCallback?(): Promise<void>;\n}\nexport interface AlertConfig {\n    title: string;\n    body?: string;\n    data?: string;\n    timer?: number;\n    buttons?: AlertButton[];\n    pairingPayload?: PairingPayload;\n    closeButtonCallback?: () => void;\n    disclaimerText?: string;\n    analytics?: AnalyticsInterface;\n    featuredWallets?: string[];\n    openBugReport?: boolean;\n    substratePairing?: boolean;\n}\nexport interface ConfigurableAlertProps extends Omit<AlertConfig, 'closeButtonCallback'> {\n    open: boolean;\n    onClose: () => void;\n    closeOnBackdropClick: boolean;\n}\nexport interface AlertProps {\n    open: boolean;\n    showMore?: boolean;\n    extraContent?: any;\n    loading?: boolean;\n    onCloseClick: () => void;\n    onClickShowMore?: () => void;\n    onBackClick?: () => void;\n    closeOnBackdropClick: boolean;\n}\nexport interface PairingPayload {\n    p2pSyncCode: Promise<string>;\n    postmessageSyncCode: Promise<string>;\n    walletConnectSyncCode: Promise<string>;\n    networkType: NetworkType;\n}\nexport interface PairOtherProps {\n    walletList: MergedWallet[];\n    p2pPayload: Promise<string>;\n    wcPayload: Promise<string>;\n    onClickLearnMore: () => void;\n}\nexport interface QRProps {\n    isWalletConnect: boolean;\n    isMobile: boolean;\n    walletName: string;\n    code: string;\n    onClickLearnMore?: () => void;\n    onClickQrCode?: () => void;\n}\nexport interface QRCodeProps {\n    wallet?: MergedWallet;\n    isWCWorking: boolean;\n    isMobile: boolean;\n    qrCode?: string;\n    defaultPairing: Promise<string>;\n    handleUpdateState: (state: AlertState) => void;\n    handleIsLoading: (isLoading: boolean) => void;\n}\nexport interface WCInitErrorProps {\n    title: string;\n    handleUpdateState: (state: AlertState) => void;\n}\nexport interface InfoProps {\n    title: string;\n    description?: string;\n    data?: string;\n    icon?: any;\n    border?: boolean;\n    iconBadge?: boolean;\n    bigIcon?: boolean;\n    buttons?: {\n        label: string;\n        type: 'primary' | 'secondary';\n        onClick: () => void;\n    }[];\n    downloadLink?: {\n        url: string;\n        label: string;\n    };\n    onShowQRCodeClick?: (() => void) | (() => Promise<void>);\n}\nexport interface TopWalletsProps {\n    wallets: MergedWallet[];\n    onClickWallet: (id: string) => void;\n    onClickLearnMore: () => void;\n    otherWallets?: {\n        images: string[];\n        onClick: () => void;\n    };\n    disabled?: boolean;\n    isMobile: boolean;\n}\nexport interface WalletProps {\n    name: string;\n    image: string;\n    description?: string;\n    small?: boolean;\n    mobile?: boolean;\n    onClick: () => void;\n    tags?: string[];\n    disabled?: boolean;\n}\nexport interface WalletsProps {\n    wallets: MergedWallet[];\n    onClickWallet: (id: string) => void;\n    onClickOther: () => void;\n    isMobile: boolean;\n    small?: boolean;\n    disabled?: boolean;\n}\nexport interface ToastAction {\n    text: string;\n    isBold?: boolean;\n    actionText?: string;\n    actionLogo?: 'external';\n    actionCallback?(): Promise<void>;\n}\nexport interface ToastConfig {\n    body: string;\n    timer?: number;\n    forceNew?: boolean;\n    state: 'prepare' | 'loading' | 'acknowledge' | 'finished';\n    actions?: ToastAction[];\n    walletInfo?: WalletInfo;\n    openWalletAction?(): Promise<void>;\n}\nexport interface ToastProps {\n    label: string;\n    open: boolean;\n    onClickClose: () => void;\n    actions?: {\n        text: string;\n        isBold?: boolean;\n        actionText?: string;\n        actionCallback?: () => void;\n    }[];\n    walletInfo?: {\n        deeplink?: string;\n        icon?: string;\n        name: string;\n        type?: string;\n    };\n    openWalletAction?: () => void;\n}\n"},{name:"@airgap/beacon-ui/dist/utils/colorMode.d.ts",dts:"import { ColorMode } from '@airgap/beacon-types';\nexport declare const setColorMode: (mode: ColorMode) => void;\nexport declare const getColorMode: () => ColorMode;\n"},{name:"@airgap/beacon-ui/dist/utils/get-tzip10-link.d.ts",dts:"export declare const getTzip10Link: (url: string, payload: string) => string;\n"},{name:"@airgap/beacon-ui/dist/utils/platform.d.ts",dts:"export declare const testUserAgent: (win: Window, expr: RegExp) => boolean;\nexport declare const isMobile: (win: Window) => boolean;\nexport declare const isBrowser: (win: Window) => boolean;\nexport declare const isPrivacyBrowser: (win: Window) => boolean;\nexport declare const isIOS: (win: Window) => boolean;\nexport declare const isAndroid: (win: Window) => boolean;\nexport declare const isTwBrowser: (win: Window) => boolean;\nexport declare const isDesktop: (win: Window) => boolean;\nexport declare const isMobileOS: (win: Window) => boolean;\nexport declare const currentOS: () => string;\nexport declare const currentBrowser: () => string;\n"},{name:"@airgap/beacon-ui/dist/utils/qr.d.ts",dts:"/**\n * Convert data to a QR code\n *\n * @param payload The data to be encoded as a QR code\n * @param type How the QR code will be encoded\n */\nexport declare const getQrData: (payload: string, height?: number, width?: number) => string;\n"},{name:"@airgap/beacon-ui/dist/utils/subject.d.ts",dts:"export interface Subscription {\n    unsubscribe: () => void;\n}\nexport declare class Subject<T> {\n    private subscribers;\n    subscribe(callback: (value: T) => void): Subscription;\n    private unsubscribe;\n    next(value: T): void;\n}\n"},{name:"@airgap/beacon-ui/dist/utils/wallets.d.ts",dts:"export interface Wallet {\n    id: string;\n    key: string;\n    name: string;\n    image: string;\n    description: string;\n    type: string;\n    link: string;\n    supportedInteractionStandards?: ('wallet_connect' | 'beacon')[];\n    deepLink?: string;\n}\nexport interface MergedWallet {\n    id: string;\n    firefoxId?: string;\n    key: string;\n    name: string;\n    image: string;\n    descriptions: string[];\n    types: string[];\n    links: string[];\n    supportedInteractionStandards?: ('wallet_connect' | 'beacon')[];\n    tags?: string[];\n    deepLink?: string;\n}\nexport declare enum OSLink {\n    WEB = 0,\n    IOS = 1,\n    DESKTOP = 2,\n    EXTENSION = 3\n}\nexport declare function parseWallets(wallets: Wallet[]): Wallet[];\nexport declare function arrangeTopWallets(arr: MergedWallet[], walletIds: string[]): MergedWallet[];\nexport declare function mergeWallets(wallets: Wallet[]): MergedWallet[];\n"},{name:"@airgap/beacon-ui/dist/index.d.ts",dts:"export { openAlert, openBugReport, closeAlert, closeAlerts } from './ui/alert';\nexport type { AlertButton, AlertConfig, ToastAction } from './ui/common';\nexport { Pairing, setDesktopList, setExtensionList, setWebList, setiOSList, getDesktopList, getExtensionList, getWebList, getiOSList } from './components/pairing';\nexport { closeToast, openToast } from './ui/toast';\nexport { getColorMode, setColorMode } from './utils/colorMode';\nexport { isMobile, isMobileOS, isBrowser, isDesktop, isAndroid, isIOS, currentBrowser, currentOS } from './utils/platform';\n"},{name:"@airgap/beacon-utils/utils/crypto.d.ts",dts:"import { KeyPair } from '@stablelib/ed25519';\nexport declare const secretbox_NONCEBYTES = 24;\nexport declare const secretbox_MACBYTES = 16;\n/**\n * Convert a value to hex\n *\n * @param value\n */\nexport declare function toHex(value: any): string;\n/**\n * Get the hex hash of a value\n *\n * @param key\n */\nexport declare function getHexHash(key: string | Buffer | Uint8Array): Promise<string>;\n/**\n * Get a keypair from a seed\n *\n * @param seed\n */\nexport declare function getKeypairFromSeed(seed: string): Promise<KeyPair>;\n/**\n * Encrypt a message with a shared key\n *\n * @param message\n * @param sharedKey\n */\nexport declare function encryptCryptoboxPayload(message: string, sharedKey: Uint8Array): Promise<string>;\n/**\n * Decrypt a message with a shared key\n *\n * @param payload\n * @param sharedKey\n */\nexport declare function decryptCryptoboxPayload(payload: Uint8Array, sharedKey: Uint8Array): Promise<string>;\n/**\n * Encrypt a message with a public key\n *\n * @param payload\n * @param publicKey\n */\nexport declare function sealCryptobox(payload: string | Buffer, otherPublicKey: Uint8Array): Promise<string>;\n/**\n * Decrypt a message with public + private key\n *\n * @param encryptedPayload\n * @param publicKey\n * @param privateKey\n */\nexport declare function openCryptobox(encryptedPayload: string | Buffer, publicKey: Uint8Array, privateKey: Uint8Array): Promise<string>;\n/**\n * Get an address from the public key\n *\n * @param publicKey\n */\nexport declare function getAddressFromPublicKey(publicKey: string): Promise<string>;\n/**\n * Prefix the public key if it's not prefixed\n *\n * @param publicKey\n */\nexport declare function prefixPublicKey(publicKey: string): string;\n/**\n * Get the recipient string used in the matrix message\n *\n * @param recipientHash\n * @param relayServer\n */\nexport declare function recipientString(recipientHash: string, relayServer: string): string;\nexport declare const signMessage: (message: string, keypair: {\n    secretKey: Buffer;\n}) => Promise<string>;\nexport declare const isValidAddress: (address: string) => boolean;\nexport declare function encodePoeChallengePayload(payload: string): string;\n/**\n * Shallow Check (SC): Perform a superficial check to determine if the string contains a public key.\n * Do not use this function to validate the key itself.\n * @param publicKey the public key to analyze\n * @returns true if it contains a known prefix, false otherwise\n */\nexport declare function isPublicKeySC(publicKey: string): boolean;\n"},{name:"@airgap/beacon-utils/utils/exposed-promise.d.ts",dts:'export declare enum ExposedPromiseStatus {\n    PENDING = "pending",\n    RESOLVED = "resolved",\n    REJECTED = "rejected"\n}\ntype Resolve<T> = (value: T) => void;\ntype Reject<U> = (reason?: U) => void;\n/**\n * Exposed promise allow you to create a promise and then resolve it later, from the outside\n */\nexport declare class ExposedPromise<T = unknown, U = unknown> {\n    private readonly _promise;\n    private _resolve;\n    private _reject;\n    private _status;\n    private _promiseResult;\n    private _promiseError;\n    get promise(): Promise<T>;\n    get resolve(): Resolve<T>;\n    get reject(): Reject<U>;\n    get status(): ExposedPromiseStatus;\n    get promiseResult(): T | undefined;\n    get promiseError(): U | undefined;\n    constructor();\n    static resolve<T>(value: T): ExposedPromise<T>;\n    static reject<T = never, U = unknown>(reason?: U): ExposedPromise<T, U>;\n    isPending(): boolean;\n    isResolved(): boolean;\n    isRejected(): boolean;\n    isSettled(): boolean;\n}\nexport {};\n'},{name:"@airgap/beacon-utils/utils/generate-uuid.d.ts",dts:"/**\n * Generate a random GUID\n */\nexport declare function generateGUID(): Promise<string>;\n"},{name:"@airgap/beacon-utils/utils/keys.d.ts",dts:"/**\n * A helper function to improve typings of object keys\n *\n * @param obj Object\n */\nexport declare function keys<O extends object>(obj: O): (keyof O)[];\n"},{name:"@airgap/beacon-utils/index.d.ts",dts:"export { keys } from './utils/keys';\nexport { ExposedPromise, ExposedPromiseStatus } from './utils/exposed-promise';\nexport { getKeypairFromSeed, toHex, getAddressFromPublicKey, decryptCryptoboxPayload, encryptCryptoboxPayload, getHexHash, sealCryptobox, openCryptobox, recipientString, signMessage, isValidAddress, prefixPublicKey, encodePoeChallengePayload, isPublicKeySC } from './utils/crypto';\nexport { generateGUID } from './utils/generate-uuid';\nexport declare const CONTRACT_PREFIX = \"KT1\";\nexport declare const secretbox_NONCEBYTES = 24;\nexport declare const secretbox_MACBYTES = 16;\n"},{name:"@airgap/beacon-utils/dist/esm/utils/crypto.d.ts",dts:"import { KeyPair } from '@stablelib/ed25519';\nexport declare const secretbox_NONCEBYTES = 24;\nexport declare const secretbox_MACBYTES = 16;\n/**\n * Convert a value to hex\n *\n * @param value\n */\nexport declare function toHex(value: any): string;\n/**\n * Get the hex hash of a value\n *\n * @param key\n */\nexport declare function getHexHash(key: string | Buffer | Uint8Array): Promise<string>;\n/**\n * Get a keypair from a seed\n *\n * @param seed\n */\nexport declare function getKeypairFromSeed(seed: string): Promise<KeyPair>;\n/**\n * Encrypt a message with a shared key\n *\n * @param message\n * @param sharedKey\n */\nexport declare function encryptCryptoboxPayload(message: string, sharedKey: Uint8Array): Promise<string>;\n/**\n * Decrypt a message with a shared key\n *\n * @param payload\n * @param sharedKey\n */\nexport declare function decryptCryptoboxPayload(payload: Uint8Array, sharedKey: Uint8Array): Promise<string>;\n/**\n * Encrypt a message with a public key\n *\n * @param payload\n * @param publicKey\n */\nexport declare function sealCryptobox(payload: string | Buffer, otherPublicKey: Uint8Array): Promise<string>;\n/**\n * Decrypt a message with public + private key\n *\n * @param encryptedPayload\n * @param publicKey\n * @param privateKey\n */\nexport declare function openCryptobox(encryptedPayload: string | Buffer, publicKey: Uint8Array, privateKey: Uint8Array): Promise<string>;\n/**\n * Get an address from the public key\n *\n * @param publicKey\n */\nexport declare function getAddressFromPublicKey(publicKey: string): Promise<string>;\n/**\n * Prefix the public key if it's not prefixed\n *\n * @param publicKey\n */\nexport declare function prefixPublicKey(publicKey: string): string;\n/**\n * Get the recipient string used in the matrix message\n *\n * @param recipientHash\n * @param relayServer\n */\nexport declare function recipientString(recipientHash: string, relayServer: string): string;\nexport declare const signMessage: (message: string, keypair: {\n    secretKey: Buffer;\n}) => Promise<string>;\nexport declare const isValidAddress: (address: string) => boolean;\nexport declare function encodePoeChallengePayload(payload: string): string;\n/**\n * Shallow Check (SC): Perform a superficial check to determine if the string contains a public key.\n * Do not use this function to validate the key itself.\n * @param publicKey the public key to analyze\n * @returns true if it contains a known prefix, false otherwise\n */\nexport declare function isPublicKeySC(publicKey: string): boolean;\n"},{name:"@airgap/beacon-utils/dist/esm/utils/exposed-promise.d.ts",dts:'export declare enum ExposedPromiseStatus {\n    PENDING = "pending",\n    RESOLVED = "resolved",\n    REJECTED = "rejected"\n}\ntype Resolve<T> = (value: T) => void;\ntype Reject<U> = (reason?: U) => void;\n/**\n * Exposed promise allow you to create a promise and then resolve it later, from the outside\n */\nexport declare class ExposedPromise<T = unknown, U = unknown> {\n    private readonly _promise;\n    private _resolve;\n    private _reject;\n    private _status;\n    private _promiseResult;\n    private _promiseError;\n    get promise(): Promise<T>;\n    get resolve(): Resolve<T>;\n    get reject(): Reject<U>;\n    get status(): ExposedPromiseStatus;\n    get promiseResult(): T | undefined;\n    get promiseError(): U | undefined;\n    constructor();\n    static resolve<T>(value: T): ExposedPromise<T>;\n    static reject<T = never, U = unknown>(reason?: U): ExposedPromise<T, U>;\n    isPending(): boolean;\n    isResolved(): boolean;\n    isRejected(): boolean;\n    isSettled(): boolean;\n}\nexport {};\n'},{name:"@airgap/beacon-utils/dist/esm/utils/generate-uuid.d.ts",dts:"/**\n * Generate a random GUID\n */\nexport declare function generateGUID(): Promise<string>;\n"},{name:"@airgap/beacon-utils/dist/esm/utils/keys.d.ts",dts:"/**\n * A helper function to improve typings of object keys\n *\n * @param obj Object\n */\nexport declare function keys<O extends object>(obj: O): (keyof O)[];\n"},{name:"@airgap/beacon-utils/dist/esm/index.d.ts",dts:"export { keys } from './utils/keys';\nexport { ExposedPromise, ExposedPromiseStatus } from './utils/exposed-promise';\nexport { getKeypairFromSeed, toHex, getAddressFromPublicKey, decryptCryptoboxPayload, encryptCryptoboxPayload, getHexHash, sealCryptobox, openCryptobox, recipientString, signMessage, isValidAddress, prefixPublicKey, encodePoeChallengePayload, isPublicKeySC } from './utils/crypto';\nexport { generateGUID } from './utils/generate-uuid';\nexport declare const CONTRACT_PREFIX = \"KT1\";\nexport declare const secretbox_NONCEBYTES = 24;\nexport declare const secretbox_MACBYTES = 16;\n"},{name:"@airgap/beacon-wallet/client/WalletClient.d.ts",dts:"import { Client } from '@airgap/beacon-core';\nimport { ExposedPromise } from '@airgap/beacon-utils';\nimport { ConnectionContext, ExtendedP2PPairingResponse, PeerInfo, TransportType, BeaconRequestOutputMessage, BeaconResponseInputMessage, AppMetadata, PermissionInfo, PushToken } from '@airgap/beacon-types';\nimport { WalletClientOptions } from './WalletClientOptions';\n/**\n * @publicapi\n *\n * The WalletClient has to be used in the wallet. It handles all the logic related to connecting to beacon-compatible\n * dapps and handling/responding to requests.\n *\n * @category Wallet\n */\nexport declare class WalletClient extends Client {\n    /**\n     * Returns whether or not the transport is connected\n     */\n    protected readonly _isConnected: ExposedPromise<boolean>;\n    get isConnected(): Promise<boolean>;\n    private readonly permissionManager;\n    private readonly appMetadataManager;\n    /**\n     * This array stores pending requests, meaning requests we received and have not yet handled / sent a response.\n     */\n    private pendingRequests;\n    constructor(config: WalletClientOptions);\n    init(): Promise<TransportType>;\n    /**\n     * This method initiates a connection to the P2P network and registers a callback that will be called\n     * whenever a message is received.\n     *\n     * @param newMessageCallback The callback that will be invoked for every message the transport receives.\n     */\n    connect(newMessageCallback: (message: BeaconRequestOutputMessage, connectionContext: ConnectionContext) => void): Promise<void>;\n    getRegisterPushChallenge(backendUrl: string, accountPublicKey: string, oracleUrl?: string): Promise<{\n        challenge: {\n            id: string;\n            timestamp: string;\n        };\n        payloadToSign: string;\n    }>;\n    registerPush(challenge: {\n        id: string;\n        timestamp: string;\n    }, signature: string, backendUrl: string, accountPublicKey: string, protocolIdentifier: string, deviceId: string, oracleUrl?: string): Promise<PushToken>;\n    /**\n     * The method will attempt to initiate a connection using the active transport.\n     */\n    _connect(attempts?: number): Promise<void>;\n    /**\n     * This method sends a response for a specific request back to the DApp\n     *\n     * @param message The BeaconResponseMessage that will be sent back to the DApp\n     */\n    respond(message: BeaconResponseInputMessage): Promise<void>;\n    getAppMetadataList(): Promise<AppMetadata[]>;\n    getAppMetadata(senderId: string): Promise<AppMetadata | undefined>;\n    removeAppMetadata(senderId: string): Promise<void>;\n    removeAllAppMetadata(): Promise<void>;\n    getPermissions(): Promise<PermissionInfo[]>;\n    getPermission(accountIdentifier: string): Promise<PermissionInfo | undefined>;\n    removePermission(accountIdentifier: string, senderId: string): Promise<void>;\n    removeAllPermissions(): Promise<void>;\n    private getPeerInfo;\n    /**\n     * Add a new peer to the known peers\n     * @param peer The new peer to add\n     */\n    addPeer(peer: PeerInfo, sendPairingResponse?: boolean): Promise<void>;\n    removePeer(peer: ExtendedP2PPairingResponse, sendDisconnectToPeer?: boolean): Promise<void>;\n    removeAllPeers(sendDisconnectToPeers?: boolean): Promise<void>;\n    private removePermissionsForPeers;\n    /**\n     * Send an acknowledge message back to the sender\n     *\n     * @param message The message that was received\n     */\n    private sendAcknowledgeResponse;\n    /**\n     * An internal method to send a BeaconMessage to the DApp\n     *\n     * @param response Send a message back to the DApp\n     */\n    private respondToMessage;\n    private disconnect;\n}\n"},{name:"@airgap/beacon-wallet/client/WalletClientOptions.d.ts",dts:"import { NodeDistributions, Storage } from '@airgap/beacon-types';\n/**\n * @category Wallet\n */\nexport interface WalletClientOptions {\n    /**\n     * Name of the application\n     */\n    name: string;\n    /**\n     * A URL to the icon of the application\n     */\n    iconUrl?: string;\n    /**\n     * A URL to the website of the application\n     */\n    appUrl?: string;\n    /**\n     * The storage that will be used by the SDK\n     */\n    storage?: Storage;\n    /**\n     * A list of matrix nodes to connect to. If a non-empty array is passed, the default options will be overwritten.\n     * One node will be randomly selected based on the local keypair and the other nodes will be used as a fallback in case the primary node goes down.\n     *\n     * Only provide the hostname, no https:// prefix. Eg. { [Regions.EU1]: ['matrix.example.com'] }\n     */\n    matrixNodes?: NodeDistributions;\n}\n"},{name:"@airgap/beacon-wallet/interceptors/IncomingRequestInterceptor.d.ts",dts:"import { BeaconRequestOutputMessage, ConnectionContext, BeaconRequestMessage, BeaconMessageWrapper, BeaconBaseMessage } from '@airgap/beacon-types';\nimport { AppMetadataManager } from '@airgap/beacon-core';\ninterface IncomingRequestInterceptorOptions {\n    message: BeaconRequestMessage | BeaconMessageWrapper<BeaconBaseMessage>;\n    connectionInfo: ConnectionContext;\n    appMetadataManager: AppMetadataManager;\n    interceptorCallback(message: BeaconRequestOutputMessage, connectionInfo: ConnectionContext): void;\n}\n/**\n * @internalapi\n *\n * The IncomingRequestInterceptor is used in the WalletClient to intercept an incoming request and enrich it with data, like app metadata.\n */\nexport declare class IncomingRequestInterceptor {\n    /**\n     * The method that is called during the interception\n     *\n     * @param config\n     */\n    static intercept(config: IncomingRequestInterceptorOptions): Promise<void>;\n    private static getAppMetadata;\n    private static handleV2Message;\n    private static handleV3Message;\n}\nexport {};\n"},{name:"@airgap/beacon-wallet/interceptors/OutgoingResponseInterceptor.d.ts",dts:"import { AppMetadataManager, PermissionManager } from '@airgap/beacon-core';\nimport { BeaconMessage, BeaconResponseInputMessage, AppMetadata, BeaconRequestMessage, BeaconMessageWrapper, BeaconBaseMessage } from '@airgap/beacon-types';\ninterface OutgoingResponseInterceptorOptions {\n    senderId: string;\n    request: BeaconRequestMessage | BeaconMessageWrapper<BeaconBaseMessage>;\n    message: BeaconResponseInputMessage;\n    ownAppMetadata: AppMetadata;\n    permissionManager: PermissionManager;\n    appMetadataManager: AppMetadataManager;\n    interceptorCallback(message: BeaconMessage): void;\n}\n/**\n * @internalapi\n *\n * The OutgoingResponseInterceptor is used in the WalletClient to intercept an outgoing response and enrich it with data.\n */\nexport declare class OutgoingResponseInterceptor {\n    static intercept(config: OutgoingResponseInterceptorOptions): Promise<void>;\n    private static handleV3Message;\n    private static handleV2Message;\n}\nexport {};\n"},{name:"@airgap/beacon-wallet/transports/WalletP2PTransport.d.ts",dts:"import { Storage, StorageKey, P2PPairingRequest, NodeDistributions } from '@airgap/beacon-types';\nimport { P2PTransport } from '@airgap/beacon-transport-matrix';\nimport { KeyPair } from '@stablelib/ed25519';\n/**\n * @internalapi\n *\n *\n */\nexport declare class WalletP2PTransport extends P2PTransport<P2PPairingRequest, StorageKey.TRANSPORT_P2P_PEERS_WALLET> {\n    constructor(name: string, keyPair: KeyPair, storage: Storage, matrixNodes: NodeDistributions, iconUrl?: string, appUrl?: string);\n    addPeer(newPeer: P2PPairingRequest, sendPairingResponse?: boolean): Promise<void>;\n}\n"},{name:"@airgap/beacon-wallet/transports/WalletPostMessageTransport.d.ts",dts:"import { StorageKey, Storage, PostMessagePairingRequest } from '@airgap/beacon-types';\nimport { PostMessageTransport } from '@airgap/beacon-transport-postmessage';\nimport { KeyPair } from '@stablelib/ed25519';\n/**\n * @internalapi\n *\n *\n */\nexport declare class WalletPostMessageTransport extends PostMessageTransport<PostMessagePairingRequest, StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET> {\n    constructor(name: string, keyPair: KeyPair, storage: Storage);\n}\n"},{name:"@airgap/beacon-wallet/index.d.ts",dts:"export * from '@airgap/beacon-core';\nexport * from '@airgap/beacon-transport-matrix';\nexport * from '@airgap/beacon-types';\nexport * from '@airgap/beacon-utils';\nimport { WalletClient } from './client/WalletClient';\nimport { WalletClientOptions } from './client/WalletClientOptions';\nexport { WalletClient, WalletClientOptions };\n"},{name:"@airgap/beacon-wallet/dist/esm/client/WalletClient.d.ts",dts:"import { Client } from '@airgap/beacon-core';\nimport { ExposedPromise } from '@airgap/beacon-utils';\nimport { ConnectionContext, ExtendedP2PPairingResponse, PeerInfo, TransportType, BeaconRequestOutputMessage, BeaconResponseInputMessage, AppMetadata, PermissionInfo, PushToken } from '@airgap/beacon-types';\nimport { WalletClientOptions } from './WalletClientOptions';\n/**\n * @publicapi\n *\n * The WalletClient has to be used in the wallet. It handles all the logic related to connecting to beacon-compatible\n * dapps and handling/responding to requests.\n *\n * @category Wallet\n */\nexport declare class WalletClient extends Client {\n    /**\n     * Returns whether or not the transport is connected\n     */\n    protected readonly _isConnected: ExposedPromise<boolean>;\n    get isConnected(): Promise<boolean>;\n    private readonly permissionManager;\n    private readonly appMetadataManager;\n    /**\n     * This array stores pending requests, meaning requests we received and have not yet handled / sent a response.\n     */\n    private pendingRequests;\n    constructor(config: WalletClientOptions);\n    init(): Promise<TransportType>;\n    /**\n     * This method initiates a connection to the P2P network and registers a callback that will be called\n     * whenever a message is received.\n     *\n     * @param newMessageCallback The callback that will be invoked for every message the transport receives.\n     */\n    connect(newMessageCallback: (message: BeaconRequestOutputMessage, connectionContext: ConnectionContext) => void): Promise<void>;\n    getRegisterPushChallenge(backendUrl: string, accountPublicKey: string, oracleUrl?: string): Promise<{\n        challenge: {\n            id: string;\n            timestamp: string;\n        };\n        payloadToSign: string;\n    }>;\n    registerPush(challenge: {\n        id: string;\n        timestamp: string;\n    }, signature: string, backendUrl: string, accountPublicKey: string, protocolIdentifier: string, deviceId: string, oracleUrl?: string): Promise<PushToken>;\n    /**\n     * The method will attempt to initiate a connection using the active transport.\n     */\n    _connect(attempts?: number): Promise<void>;\n    /**\n     * This method sends a response for a specific request back to the DApp\n     *\n     * @param message The BeaconResponseMessage that will be sent back to the DApp\n     */\n    respond(message: BeaconResponseInputMessage): Promise<void>;\n    getAppMetadataList(): Promise<AppMetadata[]>;\n    getAppMetadata(senderId: string): Promise<AppMetadata | undefined>;\n    removeAppMetadata(senderId: string): Promise<void>;\n    removeAllAppMetadata(): Promise<void>;\n    getPermissions(): Promise<PermissionInfo[]>;\n    getPermission(accountIdentifier: string): Promise<PermissionInfo | undefined>;\n    removePermission(accountIdentifier: string, senderId: string): Promise<void>;\n    removeAllPermissions(): Promise<void>;\n    private getPeerInfo;\n    /**\n     * Add a new peer to the known peers\n     * @param peer The new peer to add\n     */\n    addPeer(peer: PeerInfo, sendPairingResponse?: boolean): Promise<void>;\n    removePeer(peer: ExtendedP2PPairingResponse, sendDisconnectToPeer?: boolean): Promise<void>;\n    removeAllPeers(sendDisconnectToPeers?: boolean): Promise<void>;\n    private removePermissionsForPeers;\n    /**\n     * Send an acknowledge message back to the sender\n     *\n     * @param message The message that was received\n     */\n    private sendAcknowledgeResponse;\n    /**\n     * An internal method to send a BeaconMessage to the DApp\n     *\n     * @param response Send a message back to the DApp\n     */\n    private respondToMessage;\n    private disconnect;\n}\n"},{name:"@airgap/beacon-wallet/dist/esm/client/WalletClientOptions.d.ts",dts:"import { NodeDistributions, Storage } from '@airgap/beacon-types';\n/**\n * @category Wallet\n */\nexport interface WalletClientOptions {\n    /**\n     * Name of the application\n     */\n    name: string;\n    /**\n     * A URL to the icon of the application\n     */\n    iconUrl?: string;\n    /**\n     * A URL to the website of the application\n     */\n    appUrl?: string;\n    /**\n     * The storage that will be used by the SDK\n     */\n    storage?: Storage;\n    /**\n     * A list of matrix nodes to connect to. If a non-empty array is passed, the default options will be overwritten.\n     * One node will be randomly selected based on the local keypair and the other nodes will be used as a fallback in case the primary node goes down.\n     *\n     * Only provide the hostname, no https:// prefix. Eg. { [Regions.EU1]: ['matrix.example.com'] }\n     */\n    matrixNodes?: NodeDistributions;\n}\n"},{name:"@airgap/beacon-wallet/dist/esm/interceptors/IncomingRequestInterceptor.d.ts",dts:"import { BeaconRequestOutputMessage, ConnectionContext, BeaconRequestMessage, BeaconMessageWrapper, BeaconBaseMessage } from '@airgap/beacon-types';\nimport { AppMetadataManager } from '@airgap/beacon-core';\ninterface IncomingRequestInterceptorOptions {\n    message: BeaconRequestMessage | BeaconMessageWrapper<BeaconBaseMessage>;\n    connectionInfo: ConnectionContext;\n    appMetadataManager: AppMetadataManager;\n    interceptorCallback(message: BeaconRequestOutputMessage, connectionInfo: ConnectionContext): void;\n}\n/**\n * @internalapi\n *\n * The IncomingRequestInterceptor is used in the WalletClient to intercept an incoming request and enrich it with data, like app metadata.\n */\nexport declare class IncomingRequestInterceptor {\n    /**\n     * The method that is called during the interception\n     *\n     * @param config\n     */\n    static intercept(config: IncomingRequestInterceptorOptions): Promise<void>;\n    private static getAppMetadata;\n    private static handleV2Message;\n    private static handleV3Message;\n}\nexport {};\n"},{name:"@airgap/beacon-wallet/dist/esm/interceptors/OutgoingResponseInterceptor.d.ts",dts:"import { AppMetadataManager, PermissionManager } from '@airgap/beacon-core';\nimport { BeaconMessage, BeaconResponseInputMessage, AppMetadata, BeaconRequestMessage, BeaconMessageWrapper, BeaconBaseMessage } from '@airgap/beacon-types';\ninterface OutgoingResponseInterceptorOptions {\n    senderId: string;\n    request: BeaconRequestMessage | BeaconMessageWrapper<BeaconBaseMessage>;\n    message: BeaconResponseInputMessage;\n    ownAppMetadata: AppMetadata;\n    permissionManager: PermissionManager;\n    appMetadataManager: AppMetadataManager;\n    interceptorCallback(message: BeaconMessage): void;\n}\n/**\n * @internalapi\n *\n * The OutgoingResponseInterceptor is used in the WalletClient to intercept an outgoing response and enrich it with data.\n */\nexport declare class OutgoingResponseInterceptor {\n    static intercept(config: OutgoingResponseInterceptorOptions): Promise<void>;\n    private static handleV3Message;\n    private static handleV2Message;\n}\nexport {};\n"},{name:"@airgap/beacon-wallet/dist/esm/transports/WalletP2PTransport.d.ts",dts:"import { Storage, StorageKey, P2PPairingRequest, NodeDistributions } from '@airgap/beacon-types';\nimport { P2PTransport } from '@airgap/beacon-transport-matrix';\nimport { KeyPair } from '@stablelib/ed25519';\n/**\n * @internalapi\n *\n *\n */\nexport declare class WalletP2PTransport extends P2PTransport<P2PPairingRequest, StorageKey.TRANSPORT_P2P_PEERS_WALLET> {\n    constructor(name: string, keyPair: KeyPair, storage: Storage, matrixNodes: NodeDistributions, iconUrl?: string, appUrl?: string);\n    addPeer(newPeer: P2PPairingRequest, sendPairingResponse?: boolean): Promise<void>;\n}\n"},{name:"@airgap/beacon-wallet/dist/esm/transports/WalletPostMessageTransport.d.ts",dts:"import { StorageKey, Storage, PostMessagePairingRequest } from '@airgap/beacon-types';\nimport { PostMessageTransport } from '@airgap/beacon-transport-postmessage';\nimport { KeyPair } from '@stablelib/ed25519';\n/**\n * @internalapi\n *\n *\n */\nexport declare class WalletPostMessageTransport extends PostMessageTransport<PostMessagePairingRequest, StorageKey.TRANSPORT_POSTMESSAGE_PEERS_WALLET> {\n    constructor(name: string, keyPair: KeyPair, storage: Storage);\n}\n"},{name:"@airgap/beacon-wallet/dist/esm/index.d.ts",dts:"export * from '@airgap/beacon-core';\nexport * from '@airgap/beacon-transport-matrix';\nexport * from '@airgap/beacon-types';\nexport * from '@airgap/beacon-utils';\nimport { WalletClient } from './client/WalletClient';\nimport { WalletClientOptions } from './client/WalletClientOptions';\nexport { WalletClient, WalletClientOptions };\n"},{name:"@taquito/beacon-wallet/dist/types/errors.d.ts",dts:"import { PermissionScope } from '@airgap/beacon-dapp';\nimport { PermissionDeniedError } from '@taquito/core';\n/**\n *  @category Error\n *  @description Error that indicates the Beacon wallet not being initialized\n */\nexport declare class BeaconWalletNotInitialized extends PermissionDeniedError {\n    constructor();\n}\n/**\n *  @category Error\n *  @description Error that indicates missing required permission scopes\n */\nexport declare class MissingRequiredScopes extends PermissionDeniedError {\n    readonly requiredScopes: PermissionScope[];\n    constructor(requiredScopes: PermissionScope[]);\n}\n"},{name:"@taquito/beacon-wallet/dist/types/taquito-beacon-wallet.d.ts",dts:"/**\n * @packageDocumentation\n * @module @taquito/beacon-wallet\n */\nimport { DAppClient, DAppClientOptions, RequestPermissionInput } from '@airgap/beacon-dapp';\nimport { WalletDelegateParams, WalletIncreasePaidStorageParams, WalletOriginateParams, WalletProvider, WalletTransferParams, WalletStakeParams, WalletUnstakeParams, WalletFinalizeUnstakeParams, WalletTransferTicketParams } from '@taquito/taquito';\nexport { VERSION } from './version';\nexport { BeaconWalletNotInitialized, MissingRequiredScopes } from './errors';\nexport declare class BeaconWallet implements WalletProvider {\n    client: DAppClient;\n    constructor(options: DAppClientOptions);\n    private validateRequiredScopesOrFail;\n    requestPermissions(request?: RequestPermissionInput): Promise<void>;\n    getPKH(): Promise<string>;\n    getPK(): Promise<string>;\n    mapTransferParamsToWalletParams(params: () => Promise<WalletTransferParams>): Promise<any>;\n    mapTransferTicketParamsToWalletParams(params: () => Promise<WalletTransferTicketParams>): Promise<any>;\n    mapStakeParamsToWalletParams(params: () => Promise<WalletStakeParams>): Promise<any>;\n    mapUnstakeParamsToWalletParams(params: () => Promise<WalletUnstakeParams>): Promise<any>;\n    mapFinalizeUnstakeParamsToWalletParams(params: () => Promise<WalletFinalizeUnstakeParams>): Promise<any>;\n    mapIncreasePaidStorageWalletParams(params: () => Promise<WalletIncreasePaidStorageParams>): Promise<any>;\n    mapOriginateParamsToWalletParams(params: () => Promise<WalletOriginateParams>): Promise<any>;\n    mapDelegateParamsToWalletParams(params: () => Promise<WalletDelegateParams>): Promise<any>;\n    formatParameters(params: any): any;\n    removeDefaultParams(params: WalletTransferParams | WalletStakeParams | WalletUnstakeParams | WalletFinalizeUnstakeParams | WalletOriginateParams | WalletDelegateParams, operatedParams: any): any;\n    sendOperations(params: any[]): Promise<string>;\n    /**\n     *\n     * @description Removes all beacon values from the storage. After using this method, this instance is no longer usable.\n     * You will have to instantiate a new BeaconWallet.\n     */\n    disconnect(): Promise<void>;\n    /**\n     *\n     * @description This method removes the active account from local storage by setting it to undefined.\n     */\n    clearActiveAccount(): Promise<void>;\n    sign(bytes: string, watermark?: Uint8Array): Promise<string>;\n    private getSigningType;\n}\n"},{name:"@taquito/beacon-wallet/dist/types/version.d.ts",dts:"export declare const VERSION: {\n    commitHash: string;\n    version: string;\n};\n"},{name:"@taquito/core/dist/types/errors.d.ts",dts:"export declare enum ValidationResult {\n    NO_PREFIX_MATCHED = 0,\n    INVALID_CHECKSUM = 1,\n    INVALID_LENGTH = 2,\n    VALID = 3,\n    PREFIX_NOT_ALLOWED = 4,\n    INVALID_ENCODING = 5,\n    OTHER = 6\n}\n/**\n *  @category Error\n *  @description Parent error class all taquito errors to extend from\n */\nexport declare class TaquitoError extends Error {\n}\n/**\n *  @category Error\n *  @description Error that indicates invalid user inputs\n */\nexport declare class ParameterValidationError extends TaquitoError {\n    readonly errorDetail?: string;\n    readonly result?: ValidationResult;\n    constructor(validationResult?: ValidationResult);\n    constructor(message?: string, errorDetail?: string | ValidationResult);\n    constructor(message?: string, validationResult?: ValidationResult, errorDetail?: string);\n}\n/**\n *  @category Error\n *  @description Error returned by RPC node\n */\nexport declare class RpcError extends TaquitoError {\n}\n/**\n *  @category Error\n *  @description Error that indicates TezosToolKit has not been configured appropriately\n */\nexport declare class TezosToolkitConfigError extends TaquitoError {\n}\n/**\n *  @category Error\n *  @description Error that indicates a requested action is not supported by Taquito\n */\nexport declare class UnsupportedActionError extends TaquitoError {\n}\n/**\n *  @category Error\n *  @description Error during a network operation\n */\nexport declare class NetworkError extends TaquitoError {\n}\n/**\n *  @category Error\n *  @description Error that indicates user attempts an action without necessary permissions\n */\nexport declare class PermissionDeniedError extends TaquitoError {\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid originated or implicit address being passed or used\n */\nexport declare class InvalidAddressError extends ParameterValidationError {\n    readonly address: string;\n    constructor(address: string, errorDetail?: string | ValidationResult);\n}\nexport declare class InvalidProofError extends ParameterValidationError {\n    readonly proof: string;\n    constructor(proof: string, errorDetail?: string | ValidationResult);\n}\nexport declare class InvalidStakingAddressError extends ParameterValidationError {\n    readonly address: string;\n    constructor(address: string, errorDetail?: string | ValidationResult);\n}\nexport declare class InvalidFinalizeUnstakeAmountError extends ParameterValidationError {\n    readonly address: string;\n    constructor(address: string, errorDetail?: string | ValidationResult);\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid block hash being passed or used\n */\nexport declare class InvalidBlockHashError extends ParameterValidationError {\n    readonly blockHash: string;\n    constructor(blockHash: string, errorDetail?: string | ValidationResult);\n}\n/**\n * @category Error\n * @description Error that indicates an invalid amount of tez being passed as a parameter\n */\nexport declare class InvalidAmountError extends ParameterValidationError {\n    readonly amount: string;\n    constructor(amount: string, errorDetail?: string | ValidationResult);\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid derivation path being passed or used\n */\nexport declare class InvalidDerivationPathError extends ParameterValidationError {\n    readonly derivationPath: string;\n    constructor(derivationPath: string, errorDetail?: string | ValidationResult);\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid hex string have been passed or used\n */\nexport declare class InvalidHexStringError extends ParameterValidationError {\n    readonly hexString: string;\n    constructor(hexString: string, errorDetail?: string | ValidationResult);\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid message being passed or used\n */\nexport declare class InvalidMessageError extends ParameterValidationError {\n    readonly msg: string;\n    constructor(msg: string, errorDetail?: string | ValidationResult);\n}\n/**\n *  @category Error\n *  @description Error that indicates invalid view parameter of a smart contract\n */\nexport declare class InvalidViewParameterError extends ParameterValidationError {\n    readonly viewName: string;\n    readonly sigs: any;\n    readonly args: any;\n    readonly cause?: any;\n    constructor(viewName: string, sigs: any, args: any, cause?: any, errorDetail?: string);\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid private key being passed or used\n */\nexport declare class InvalidKeyError extends ParameterValidationError {\n    constructor(errorDetail?: string | ValidationResult);\n}\n/**\n *  @category Error\n *  @description Error that indicates an Invalid Public Key being passed or used\n */\nexport declare class InvalidPublicKeyError extends ParameterValidationError {\n    readonly publicKey?: string | undefined;\n    constructor(publicKey?: string | undefined, errorDetail?: string | ValidationResult);\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid signature being passed or used\n */\nexport declare class InvalidSignatureError extends ParameterValidationError {\n    readonly signature: string;\n    constructor(signature: string, errorDetail?: string | ValidationResult);\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid contract address being passed or used\n */\nexport declare class InvalidContractAddressError extends ParameterValidationError {\n    readonly contractAddress: string;\n    constructor(contractAddress: string, errorDetail?: string | ValidationResult);\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid chain id being passed or used\n */\nexport declare class InvalidChainIdError extends ParameterValidationError {\n    readonly chainId: string;\n    constructor(chainId: string, errorDetail?: string | ValidationResult);\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid public key hash being passed or used\n */\nexport declare class InvalidKeyHashError extends ParameterValidationError {\n    readonly keyHash: string;\n    constructor(keyHash: string, errorDetail?: string | ValidationResult);\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid operation hash being passed or used\n */\nexport declare class InvalidOperationHashError extends ParameterValidationError {\n    readonly operationHash: string;\n    constructor(operationHash: string, errorDetail?: string | ValidationResult);\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid operation kind being passed or used\n */\nexport declare class InvalidOperationKindError extends ParameterValidationError {\n    readonly operationKind: string;\n    constructor(operationKind: string, errorDetail?: string | ValidationResult);\n}\n/**\n *  @category Error\n *  @description General error that indicates something is no longer supported and/or deprecated\n */\nexport declare class DeprecationError extends UnsupportedActionError {\n    constructor(message: string);\n}\n/**\n *  @category Error\n *  @description General error that indicates an action is prohibited or not allowed\n */\nexport declare class ProhibitedActionError extends UnsupportedActionError {\n    constructor(message: string);\n}\n/**\n *  @category Error\n *  @description Error that indicates a failure in grabbing the public key\n */\nexport declare class PublicKeyNotFoundError extends TaquitoError {\n    readonly pkh: string;\n    readonly cause?: any;\n    constructor(pkh: string, cause?: any);\n}\n"},{name:"@taquito/core/dist/types/signer-interfaces.d.ts",dts:"/**\n * @description Signer interface which is used across taquito in order to sign and inject operation\n */\nexport interface Signer {\n    /**\n     * @param op Message to sign\n     * @param magicByte Magic bytes 11 for block, 12 for preattestation, 13 for attestation, 3 for generic, 5 for the PACK format of michelson\n     * @description Sign the message and return an object with bytes, sig, prefixSig and sbytes\n     */\n    sign(op: string, magicByte?: Uint8Array): Promise<SignResult>;\n    /**\n     * @description Return the public key of the account used by the signer\n     */\n    publicKey(): Promise<string>;\n    /**\n     * @description Return the public key hash of the account used by the signer\n     */\n    publicKeyHash(): Promise<string>;\n    /**\n     * @description Optionally return the secret key of the account used by the signer\n     */\n    secretKey(): Promise<string | undefined>;\n    /**\n     * @description Sign the public key to prove possession for bls key and return an object with bytes, sig, prefixSig and sbytes\n     */\n    provePossession?(): Promise<RawSignResult>;\n}\nexport interface SignResult {\n    bytes: string;\n    sig: string;\n    prefixSig: string;\n    sbytes: string;\n}\nexport interface RawSignResult {\n    sig: string;\n    prefixSig: string;\n    rawSignature: Uint8Array;\n}\n"},{name:"@taquito/core/dist/types/taquito-core.d.ts",dts:"/**\n * @packageDocumentation\n * @module @taquito/core\n */\nexport * from './errors';\nexport * from './signer-interfaces';\n"},{name:"@taquito/core/dist/types/version.d.ts",dts:"export declare const VERSION: {\n    commitHash: string;\n    version: string;\n};\n"},{name:"@taquito/http-utils/dist/types/errors.d.ts",dts:"import { NetworkError } from '@taquito/core';\nimport { STATUS_CODE } from './status_code';\n/**\n *  @category Error\n *  @description Error that indicates a general failure in making the HTTP request\n */\nexport declare class HttpRequestFailed extends NetworkError {\n    readonly method: string;\n    readonly url: string;\n    readonly cause: Error;\n    constructor(method: string, url: string, cause: Error);\n}\n/**\n *  @category Error\n *  @description Error thrown when the endpoint returns an HTTP error to the client\n */\nexport declare class HttpResponseError extends NetworkError {\n    readonly message: string;\n    readonly status: STATUS_CODE;\n    readonly statusText: string;\n    readonly body: string;\n    readonly url: string;\n    constructor(message: string, status: STATUS_CODE, statusText: string, body: string, url: string);\n}\n/**\n *  @category Error\n *  @description Error\n */\nexport declare class HttpTimeoutError extends NetworkError {\n    readonly timeout: number;\n    readonly url: string;\n    constructor(timeout: number, url: string);\n}\n"},{name:"@taquito/http-utils/dist/types/status_code.d.ts",dts:'/**\n * Hypertext Transfer Protocol (HTTP) response status codes.\n * @see {@link https://en.wikipedia.org/wiki/List_of_HTTP_status_codes}\n */\nexport declare enum STATUS_CODE {\n    /**\n     * The server has received the request headers and the client should proceed to send the request body\n     * (in the case of a request for which a body needs to be sent; for example, a POST request).\n     * Sending a large request body to a server after a request has been rejected for inappropriate headers would be inefficient.\n     * To have a server check the request\'s headers, a client must send Expect: 100-continue as a header in its initial request\n     * and receive a 100 Continue status code in response before sending the body. The response 417 Expectation Failed indicates the request should not be continued.\n     */\n    CONTINUE = 100,\n    /**\n     * The requester has asked the server to switch protocols and the server has agreed to do so.\n     */\n    SWITCHING_PROTOCOLS = 101,\n    /**\n     * A WebDAV request may contain many sub-requests involving file operations, requiring a long time to complete the request.\n     * This code indicates that the server has received and is processing the request, but no response is available yet.\n     * This prevents the client from timing out and assuming the request was lost.\n     */\n    PROCESSING = 102,\n    /**\n     * Standard response for successful HTTP requests.\n     * The actual response will depend on the request method used.\n     * In a GET request, the response will contain an entity corresponding to the requested resource.\n     * In a POST request, the response will contain an entity describing or containing the result of the action.\n     */\n    OK = 200,\n    /**\n     * The request has been fulfilled, resulting in the creation of a new resource.\n     */\n    CREATED = 201,\n    /**\n     * The request has been accepted for processing, but the processing has not been completed.\n     * The request might or might not be eventually acted upon, and may be disallowed when processing occurs.\n     */\n    ACCEPTED = 202,\n    /**\n     * SINCE HTTP/1.1\n     * The server is a transforming proxy that received a 200 OK from its origin,\n     * but is returning a modified version of the origin\'s response.\n     */\n    NON_AUTHORITATIVE_INFORMATION = 203,\n    /**\n     * The server successfully processed the request and is not returning any content.\n     */\n    NO_CONTENT = 204,\n    /**\n     * The server successfully processed the request, but is not returning any content.\n     * Unlike a 204 response, this response requires that the requester reset the document view.\n     */\n    RESET_CONTENT = 205,\n    /**\n     * The server is delivering only part of the resource (byte serving) due to a range header sent by the client.\n     * The range header is used by HTTP clients to enable resuming of interrupted downloads,\n     * or split a download into multiple simultaneous streams.\n     */\n    PARTIAL_CONTENT = 206,\n    /**\n     * The message body that follows is an XML message and can contain a number of separate response codes,\n     * depending on how many sub-requests were made.\n     */\n    MULTI_STATUS = 207,\n    /**\n     * The members of a DAV binding have already been enumerated in a preceding part of the (multistatus) response,\n     * and are not being included again.\n     */\n    ALREADY_REPORTED = 208,\n    /**\n     * The server has fulfilled a request for the resource,\n     * and the response is a representation of the result of one or more instance-manipulations applied to the current instance.\n     */\n    IM_USED = 226,\n    /**\n     * Indicates multiple options for the resource from which the client may choose (via agent-driven content negotiation).\n     * For example, this code could be used to present multiple video format options,\n     * to list files with different filename extensions, or to suggest word-sense disambiguation.\n     */\n    MULTIPLE_CHOICES = 300,\n    /**\n     * This and all future requests should be directed to the given URI.\n     */\n    MOVED_PERMANENTLY = 301,\n    /**\n     * This is an example of industry practice contradicting the standard.\n     * The HTTP/1.0 specification (RFC 1945) required the client to perform a temporary redirect\n     * (the original describing phrase was "Moved Temporarily"), but popular browsers implemented 302\n     * with the functionality of a 303 See Other. Therefore, HTTP/1.1 added status codes 303 and 307\n     * to distinguish between the two behaviours. However, some Web applications and frameworks\n     * use the 302 status code as if it were the 303.\n     */\n    FOUND = 302,\n    /**\n     * SINCE HTTP/1.1\n     * The response to the request can be found under another URI using a GET method.\n     * When received in response to a POST (or PUT/DELETE), the client should presume that\n     * the server has received the data and should issue a redirect with a separate GET message.\n     */\n    SEE_OTHER = 303,\n    /**\n     * Indicates that the resource has not been modified since the version specified by the request headers If-Modified-Since or If-None-Match.\n     * In such case, there is no need to retransmit the resource since the client still has a previously-downloaded copy.\n     */\n    NOT_MODIFIED = 304,\n    /**\n     * SINCE HTTP/1.1\n     * The requested resource is available only through a proxy, the address for which is provided in the response.\n     * Many HTTP clients (such as Mozilla and Internet Explorer) do not correctly handle responses with this status code, primarily for security reasons.\n     */\n    USE_PROXY = 305,\n    /**\n     * No longer used. Originally meant "Subsequent requests should use the specified proxy."\n     */\n    SWITCH_PROXY = 306,\n    /**\n     * SINCE HTTP/1.1\n     * In this case, the request should be repeated with another URI; however, future requests should still use the original URI.\n     * In contrast to how 302 was historically implemented, the request method is not allowed to be changed when reissuing the original request.\n     * For example, a POST request should be repeated using another POST request.\n     */\n    TEMPORARY_REDIRECT = 307,\n    /**\n     * The request and all future requests should be repeated using another URI.\n     * 307 and 308 parallel the behaviors of 302 and 301, but do not allow the HTTP method to change.\n     * So, for example, submitting a form to a permanently redirected resource may continue smoothly.\n     */\n    PERMANENT_REDIRECT = 308,\n    /**\n     * The server cannot or will not process the request due to an apparent client error\n     * (e.g., malformed request syntax, too large size, invalid request message framing, or deceptive request routing).\n     */\n    BAD_REQUEST = 400,\n    /**\n     * Similar to 403 Forbidden, but specifically for use when authentication is required and has failed or has not yet\n     * been provided. The response must include a WWW-Authenticate header field containing a challenge applicable to the\n     * requested resource. See Basic access authentication and Digest access authentication. 401 semantically means\n     * "unauthenticated",i.e. the user does not have the necessary credentials.\n     */\n    UNAUTHORIZED = 401,\n    /**\n     * Reserved for future use. The original intention was that this code might be used as part of some form of digital\n     * cash or micro payment scheme, but that has not happened, and this code is not usually used.\n     * Google Developers API uses this status if a particular developer has exceeded the daily limit on requests.\n     */\n    PAYMENT_REQUIRED = 402,\n    /**\n     * The request was valid, but the server is refusing action.\n     * The user might not have the necessary permissions for a resource.\n     */\n    FORBIDDEN = 403,\n    /**\n     * The requested resource could not be found but may be available in the future.\n     * Subsequent requests by the client are permissible.\n     */\n    NOT_FOUND = 404,\n    /**\n     * A request method is not supported for the requested resource;\n     * for example, a GET request on a form that requires data to be presented via POST, or a PUT request on a read-only resource.\n     */\n    METHOD_NOT_ALLOWED = 405,\n    /**\n     * The requested resource is capable of generating only content not acceptable according to the Accept headers sent in the request.\n     */\n    NOT_ACCEPTABLE = 406,\n    /**\n     * The client must first authenticate itself with the proxy.\n     */\n    PROXY_AUTHENTICATION_REQUIRED = 407,\n    /**\n     * The server timed out waiting for the request.\n     * According to HTTP specifications:\n     * "The client did not produce a request within the time that the server was prepared to wait. The client MAY repeat the request without modifications at any later time."\n     */\n    REQUEST_TIMEOUT = 408,\n    /**\n     * Indicates that the request could not be processed because of conflict in the request,\n     * such as an edit conflict between multiple simultaneous updates.\n     */\n    CONFLICT = 409,\n    /**\n     * Indicates that the resource requested is no longer available and will not be available again.\n     * This should be used when a resource has been intentionally removed and the resource should be purged.\n     * Upon receiving a 410 status code, the client should not request the resource in the future.\n     * Clients such as search engines should remove the resource from their indices.\n     * Most use cases do not require clients and search engines to purge the resource, and a "404 Not Found" may be used instead.\n     */\n    GONE = 410,\n    /**\n     * The request did not specify the length of its content, which is required by the requested resource.\n     */\n    LENGTH_REQUIRED = 411,\n    /**\n     * The server does not meet one of the preconditions that the requester put on the request.\n     */\n    PRECONDITION_FAILED = 412,\n    /**\n     * The request is larger than the server is willing or able to process. Previously called "Request Entity Too Large".\n     */\n    PAYLOAD_TOO_LARGE = 413,\n    /**\n     * The URI provided was too long for the server to process. Often the result of too much data being encoded as a query-string of a GET request,\n     * in which case it should be converted to a POST request.\n     * Called "Request-URI Too Long" previously.\n     */\n    URI_TOO_LONG = 414,\n    /**\n     * The request entity has a media type which the server or resource does not support.\n     * For example, the client uploads an image as image/svg+xml, but the server requires that images use a different format.\n     */\n    UNSUPPORTED_MEDIA_TYPE = 415,\n    /**\n     * The client has asked for a portion of the file (byte serving), but the server cannot supply that portion.\n     * For example, if the client asked for a part of the file that lies beyond the end of the file.\n     * Called "Requested Range Not Satisfiable" previously.\n     */\n    RANGE_NOT_SATISFIABLE = 416,\n    /**\n     * The server cannot meet the requirements of the Expect request-header field.\n     */\n    EXPECTATION_FAILED = 417,\n    /**\n     * This code was defined in 1998 as one of the traditional IETF April Fools\' jokes, in RFC 2324, Hyper Text Coffee Pot Control Protocol,\n     * and is not expected to be implemented by actual HTTP servers. The RFC specifies this code should be returned by\n     * teapots requested to brew coffee. This HTTP status is used as an Easter egg in some websites, including Google.com.\n     */\n    I_AM_A_TEAPOT = 418,\n    /**\n     * The request was directed at a server that is not able to produce a response (for example because a connection reuse).\n     */\n    MISDIRECTED_REQUEST = 421,\n    /**\n     * The request was well-formed but was unable to be followed due to semantic errors.\n     */\n    UNPROCESSABLE_ENTITY = 422,\n    /**\n     * The resource that is being accessed is locked.\n     */\n    LOCKED = 423,\n    /**\n     * The request failed due to failure of a previous request (e.g., a PROPPATCH).\n     */\n    FAILED_DEPENDENCY = 424,\n    /**\n     * The client should switch to a different protocol such as TLS/1.0, given in the Upgrade header field.\n     */\n    UPGRADE_REQUIRED = 426,\n    /**\n     * The origin server requires the request to be conditional.\n     * Intended to prevent "the \'lost update\' problem, where a client\n     * GETs a resource\'s state, modifies it, and PUTs it back to the server,\n     * when meanwhile a third party has modified the state on the server, leading to a conflict."\n     */\n    PRECONDITION_REQUIRED = 428,\n    /**\n     * The user has sent too many requests in a given amount of time. Intended for use with rate-limiting schemes.\n     */\n    TOO_MANY_REQUESTS = 429,\n    /**\n     * The server is unwilling to process the request because either an individual header field,\n     * or all the header fields collectively, are too large.\n     */\n    REQUEST_HEADER_FIELDS_TOO_LARGE = 431,\n    /**\n     * A server operator has received a legal demand to deny access to a resource or to a set of resources\n     * that includes the requested resource. The code 451 was chosen as a reference to the novel Fahrenheit 451.\n     */\n    UNAVAILABLE_FOR_LEGAL_REASONS = 451,\n    /**\n     * A generic error message, given when an unexpected condition was encountered and no more specific message is suitable.\n     */\n    INTERNAL_SERVER_ERROR = 500,\n    /**\n     * The server either does not recognize the request method, or it lacks the ability to fulfill the request.\n     * Usually this implies future availability (e.g., a new feature of a web-service API).\n     */\n    NOT_IMPLEMENTED = 501,\n    /**\n     * The server was acting as a gateway or proxy and received an invalid response from the upstream server.\n     */\n    BAD_GATEWAY = 502,\n    /**\n     * The server is currently unavailable (because it is overloaded or down for maintenance).\n     * Generally, this is a temporary state.\n     */\n    SERVICE_UNAVAILABLE = 503,\n    /**\n     * The server was acting as a gateway or proxy and did not receive a timely response from the upstream server.\n     */\n    GATEWAY_TIMEOUT = 504,\n    /**\n     * The server does not support the HTTP protocol version used in the request\n     */\n    HTTP_VERSION_NOT_SUPPORTED = 505,\n    /**\n     * Transparent content negotiation for the request results in a circular reference.\n     */\n    VARIANT_ALSO_NEGOTIATES = 506,\n    /**\n     * The server is unable to store the representation needed to complete the request.\n     */\n    INSUFFICIENT_STORAGE = 507,\n    /**\n     * The server detected an infinite loop while processing the request.\n     */\n    LOOP_DETECTED = 508,\n    /**\n     * Further extensions to the request are required for the server to fulfill it.\n     */\n    NOT_EXTENDED = 510,\n    /**\n     * The client needs to authenticate to gain network access.\n     * Intended for use by intercepting proxies used to control access to the network (e.g., "captive portals" used\n     * to require agreement to Terms of Service before granting full Internet access via a Wi-Fi hotspot).\n     */\n    NETWORK_AUTHENTICATION_REQUIRED = 511\n}\n'},{name:"@taquito/http-utils/dist/types/taquito-http-utils.d.ts",dts:"/**\n * @packageDocumentation\n * @module @taquito/http-utils\n */\nexport * from './status_code';\nexport { VERSION } from './version';\nexport { HttpRequestFailed, HttpResponseError, HttpTimeoutError } from './errors';\ntype ObjectType = Record<string, any>;\nexport interface HttpRequestOptions {\n    url: string;\n    method?: 'GET' | 'POST';\n    timeout?: number;\n    json?: boolean;\n    query?: ObjectType;\n    headers?: {\n        [key: string]: string;\n    };\n    mimeType?: string;\n}\nexport declare class HttpBackend {\n    private timeout;\n    constructor(timeout?: number);\n    protected serialize(obj?: ObjectType): string;\n    /**\n     *\n     * @param options contains options to be passed for the HTTP request (url, method and timeout)\n     * @throws {@link HttpRequestFailed} | {@link HttpResponseError} | {@link HttpTimeoutError}\n     */\n    createRequest<T>({ url, method, timeout, query, headers, json }: HttpRequestOptions, data?: object | string): Promise<T>;\n}\n"},{name:"@taquito/http-utils/dist/types/version.d.ts",dts:"export declare const VERSION: {\n    commitHash: string;\n    version: string;\n};\n"},{name:"@taquito/local-forging/dist/types/michelson/codec-proto022.d.ts",dts:"import { Decoder } from '../decoder-proto022';\nimport { Uint8ArrayConsumer } from '../uint8array-consumer';\nimport { Encoder } from '../encoder-proto022';\nexport type PrimValue = {\n    prim: string;\n    args?: MichelsonValue[];\n    annots?: string[];\n};\nexport type BytesValue = {\n    bytes: string;\n};\nexport type StringValue = {\n    string: string;\n};\nexport type IntValue = {\n    int: string;\n};\nexport type MichelsonValue = PrimValue | BytesValue | StringValue | IntValue | (PrimValue | BytesValue | StringValue | IntValue)[];\nexport declare const isPrim: (value: MichelsonValue) => value is PrimValue;\nexport declare const isBytes: (value: MichelsonValue) => value is BytesValue;\nexport declare const isString: (value: MichelsonValue) => value is StringValue;\nexport declare const isInt: (value: MichelsonValue) => value is IntValue;\nexport declare const scriptEncoder: Encoder<{\n    code: MichelsonValue;\n    storage: MichelsonValue;\n}>;\nexport declare const scriptDecoder: Decoder;\nexport declare const valueEncoder: Encoder<MichelsonValue>;\nexport declare const valueDecoder: Decoder;\nexport declare const extractRequiredLen: (value: Uint8ArrayConsumer, bytesLength?: number) => Uint8Array;\n/**\n * @description parse bytes into multiple items of an array\n * @param value Uint8ArrayConsumer class of forged segment to parse\n * @param bytesLength default 4 bytes for length of variable bytes\n * @returns array of Uint8Array values for each array item\n */\nexport declare const stripLengthPrefixFromBytes: (value: Uint8ArrayConsumer, bytesLength?: number) => Uint8Array[];\nexport declare const bytesEncoder: Encoder<BytesValue>;\nexport declare const bytesDecoder: Decoder;\nexport declare const stringEncoder: Encoder<StringValue>;\nexport declare const stringDecoder: Decoder;\nexport declare const intEncoder: Encoder<IntValue>;\nexport declare const intDecoder: (value: Uint8ArrayConsumer) => IntValue;\nexport declare const primEncoder: Encoder<PrimValue>;\nexport declare const primDecoder: (value: Uint8ArrayConsumer, preamble: Uint8Array) => Partial<PrimValue>;\nexport declare const primViewDecoder: (value: Uint8ArrayConsumer, result: Partial<PrimValue>) => Partial<PrimValue>;\nexport declare const decodeCombPair: Decoder;\nexport declare const encodeAnnots: Encoder<string[]>;\nexport declare const decodeAnnots: Decoder;\n"},{name:"@taquito/local-forging/dist/types/michelson/codec.d.ts",dts:"import { Decoder } from '../decoder';\nimport { Uint8ArrayConsumer } from '../uint8array-consumer';\nimport { Encoder } from '../encoder';\nexport type PrimValue = {\n    prim: string;\n    args?: MichelsonValue[];\n    annots?: string[];\n};\nexport type BytesValue = {\n    bytes: string;\n};\nexport type StringValue = {\n    string: string;\n};\nexport type IntValue = {\n    int: string;\n};\nexport type MichelsonValue = PrimValue | BytesValue | StringValue | IntValue | (PrimValue | BytesValue | StringValue | IntValue)[];\nexport declare const isPrim: (value: MichelsonValue) => value is PrimValue;\nexport declare const isBytes: (value: MichelsonValue) => value is BytesValue;\nexport declare const isString: (value: MichelsonValue) => value is StringValue;\nexport declare const isInt: (value: MichelsonValue) => value is IntValue;\nexport declare const scriptEncoder: Encoder<{\n    code: MichelsonValue;\n    storage: MichelsonValue;\n}>;\nexport declare const scriptDecoder: Decoder;\nexport declare const valueEncoder: Encoder<MichelsonValue>;\nexport declare const valueDecoder: Decoder;\nexport declare const extractRequiredLen: (value: Uint8ArrayConsumer, bytesLength?: number) => Uint8Array;\n/**\n * @description parse bytes into multiple items of an array\n * @param value Uint8ArrayConsumer class of forged segment to parse\n * @param bytesLength default 4 bytes for length of variable bytes\n * @returns array of Uint8Array values for each array item\n */\nexport declare const stripLengthPrefixFromBytes: (value: Uint8ArrayConsumer, bytesLength?: number) => Uint8Array[];\nexport declare const bytesEncoder: Encoder<BytesValue>;\nexport declare const bytesDecoder: Decoder;\nexport declare const stringEncoder: Encoder<StringValue>;\nexport declare const stringDecoder: Decoder;\nexport declare const intEncoder: Encoder<IntValue>;\nexport declare const intDecoder: (value: Uint8ArrayConsumer) => IntValue;\nexport declare const primEncoder: Encoder<PrimValue>;\nexport declare const primDecoder: (value: Uint8ArrayConsumer, preamble: Uint8Array) => Partial<PrimValue>;\nexport declare const primViewDecoder: (value: Uint8ArrayConsumer, result: Partial<PrimValue>) => Partial<PrimValue>;\nexport declare const decodeCombPair: Decoder;\nexport declare const encodeAnnots: Encoder<string[]>;\nexport declare const decodeAnnots: Decoder;\n"},{name:"@taquito/local-forging/dist/types/schema/operation-proto022.d.ts",dts:"import { Decoder } from '../decoder-proto022';\nimport { Uint8ArrayConsumer } from '../uint8array-consumer';\nimport { CODEC } from '../constants-proto022';\nexport declare const ManagerOperationSchema: {\n    branch: CODEC;\n    contents: CODEC[];\n};\nexport declare const ActivationSchema: {\n    pkh: CODEC;\n    secret: CODEC;\n};\nexport declare const RevealSchema: {\n    source: CODEC;\n    fee: CODEC;\n    counter: CODEC;\n    gas_limit: CODEC;\n    storage_limit: CODEC;\n    public_key: CODEC;\n};\nexport declare const DelegationSchema: {\n    source: CODEC;\n    fee: CODEC;\n    counter: CODEC;\n    gas_limit: CODEC;\n    storage_limit: CODEC;\n    delegate: CODEC;\n};\nexport declare const TransactionSchema: {\n    source: CODEC;\n    fee: CODEC;\n    counter: CODEC;\n    gas_limit: CODEC;\n    storage_limit: CODEC;\n    amount: CODEC;\n    destination: CODEC;\n    parameters: CODEC;\n};\nexport declare const OriginationSchema: {\n    source: CODEC;\n    fee: CODEC;\n    counter: CODEC;\n    gas_limit: CODEC;\n    storage_limit: CODEC;\n    balance: CODEC;\n    delegate: CODEC;\n    script: CODEC;\n};\nexport declare const BallotSchema: {\n    source: CODEC;\n    period: CODEC;\n    proposal: CODEC;\n    ballot: CODEC;\n};\nexport declare const AttestationSchema: {\n    slot: CODEC;\n    level: CODEC;\n    round: CODEC;\n    block_payload_hash: CODEC;\n};\nexport declare const AttestationWithDalSchema: {\n    slot: CODEC;\n    level: CODEC;\n    round: CODEC;\n    block_payload_hash: CODEC;\n    dal_attestation: CODEC;\n};\nexport declare const SeedNonceRevelationSchema: {\n    level: CODEC;\n    nonce: CODEC;\n};\nexport declare const ProposalsSchema: {\n    source: CODEC;\n    period: CODEC;\n    proposals: CODEC;\n};\nexport declare const RegisterGlobalConstantSchema: {\n    source: CODEC;\n    fee: CODEC;\n    counter: CODEC;\n    gas_limit: CODEC;\n    storage_limit: CODEC;\n    value: CODEC;\n};\nexport declare const TransferTicketSchema: {\n    source: CODEC;\n    fee: CODEC;\n    counter: CODEC;\n    gas_limit: CODEC;\n    storage_limit: CODEC;\n    ticket_contents: CODEC;\n    ticket_ty: CODEC;\n    ticket_ticketer: CODEC;\n    ticket_amount: CODEC;\n    destination: CODEC;\n    entrypoint: CODEC;\n};\nexport declare const IncreasePaidStorageSchema: {\n    source: CODEC;\n    fee: CODEC;\n    counter: CODEC;\n    gas_limit: CODEC;\n    storage_limit: CODEC;\n    amount: CODEC;\n    destination: CODEC;\n};\nexport declare const UpdateConsensusKeySchema: {\n    source: CODEC;\n    fee: CODEC;\n    counter: CODEC;\n    gas_limit: CODEC;\n    storage_limit: CODEC;\n    pk: CODEC;\n    proof: CODEC;\n};\nexport declare const DrainDelegateSchema: {\n    consensus_key: CODEC;\n    delegate: CODEC;\n    destination: CODEC;\n};\nexport declare const SetDepositsLimitSchema: {\n    source: CODEC;\n    fee: CODEC;\n    counter: CODEC;\n    gas_limit: CODEC;\n    storage_limit: CODEC;\n    limit: CODEC;\n};\nexport declare const SmartRollupOriginateSchema: {\n    source: CODEC;\n    fee: CODEC;\n    counter: CODEC;\n    gas_limit: CODEC;\n    storage_limit: CODEC;\n    pvm_kind: CODEC;\n    kernel: CODEC;\n    parameters_ty: CODEC;\n    whitelist: CODEC;\n};\nexport declare const SmartRollupAddMessagesSchema: {\n    source: CODEC;\n    fee: CODEC;\n    counter: CODEC;\n    gas_limit: CODEC;\n    storage_limit: CODEC;\n    message: CODEC;\n};\nexport declare const SmartRollupExecuteOutboxMessageSchema: {\n    source: CODEC;\n    fee: CODEC;\n    counter: CODEC;\n    gas_limit: CODEC;\n    storage_limit: CODEC;\n    rollup: CODEC;\n    cemented_commitment: CODEC;\n    output_proof: CODEC;\n};\nexport declare const DalPublishCommitmentSchema: {\n    source: CODEC;\n    fee: CODEC;\n    counter: CODEC;\n    gas_limit: CODEC;\n    storage_limit: CODEC;\n    slot_header: CODEC;\n};\nexport declare const FailingNoopSchema: {\n    arbitrary: CODEC;\n};\nexport declare const operationEncoder: (encoders: {\n    [key: string]: (val: object) => string;\n}) => (operation: {\n    kind: string;\n}) => string;\nexport declare const operationDecoder: (decoders: {\n    [key: string]: Decoder;\n}) => (value: Uint8ArrayConsumer) => {\n    kind: string;\n};\ntype Schema = Record<string, CODEC | CODEC[]>;\nexport type Value = Record<keyof Schema, unknown[]>;\nexport declare const schemaEncoder: (encoders: {\n    [key: string]: (val: object) => string;\n}) => (schema: Schema) => (value: Value) => string;\nexport declare const schemaDecoder: (decoders: {\n    [key: string]: Decoder;\n}) => (schema: {\n    [key: string]: string | string[];\n}) => (value: Uint8ArrayConsumer) => {};\nexport {};\n"},{name:"@taquito/local-forging/dist/types/schema/operation.d.ts",dts:"import { Decoder } from '../decoder';\nimport { Uint8ArrayConsumer } from '../uint8array-consumer';\nimport { CODEC } from '../constants';\nexport declare const ManagerOperationSchema: {\n    branch: CODEC;\n    contents: CODEC[];\n};\nexport declare const ActivationSchema: {\n    pkh: CODEC;\n    secret: CODEC;\n};\nexport declare const RevealSchema: {\n    source: CODEC;\n    fee: CODEC;\n    counter: CODEC;\n    gas_limit: CODEC;\n    storage_limit: CODEC;\n    public_key: CODEC;\n    proof: CODEC;\n};\nexport declare const DelegationSchema: {\n    source: CODEC;\n    fee: CODEC;\n    counter: CODEC;\n    gas_limit: CODEC;\n    storage_limit: CODEC;\n    delegate: CODEC;\n};\nexport declare const TransactionSchema: {\n    source: CODEC;\n    fee: CODEC;\n    counter: CODEC;\n    gas_limit: CODEC;\n    storage_limit: CODEC;\n    amount: CODEC;\n    destination: CODEC;\n    parameters: CODEC;\n};\nexport declare const OriginationSchema: {\n    source: CODEC;\n    fee: CODEC;\n    counter: CODEC;\n    gas_limit: CODEC;\n    storage_limit: CODEC;\n    balance: CODEC;\n    delegate: CODEC;\n    script: CODEC;\n};\nexport declare const BallotSchema: {\n    source: CODEC;\n    period: CODEC;\n    proposal: CODEC;\n    ballot: CODEC;\n};\nexport declare const AttestationSchema: {\n    slot: CODEC;\n    level: CODEC;\n    round: CODEC;\n    block_payload_hash: CODEC;\n};\nexport declare const AttestationWithDalSchema: {\n    slot: CODEC;\n    level: CODEC;\n    round: CODEC;\n    block_payload_hash: CODEC;\n    dal_attestation: CODEC;\n};\nexport declare const SeedNonceRevelationSchema: {\n    level: CODEC;\n    nonce: CODEC;\n};\nexport declare const ProposalsSchema: {\n    source: CODEC;\n    period: CODEC;\n    proposals: CODEC;\n};\nexport declare const RegisterGlobalConstantSchema: {\n    source: CODEC;\n    fee: CODEC;\n    counter: CODEC;\n    gas_limit: CODEC;\n    storage_limit: CODEC;\n    value: CODEC;\n};\nexport declare const TransferTicketSchema: {\n    source: CODEC;\n    fee: CODEC;\n    counter: CODEC;\n    gas_limit: CODEC;\n    storage_limit: CODEC;\n    ticket_contents: CODEC;\n    ticket_ty: CODEC;\n    ticket_ticketer: CODEC;\n    ticket_amount: CODEC;\n    destination: CODEC;\n    entrypoint: CODEC;\n};\nexport declare const IncreasePaidStorageSchema: {\n    source: CODEC;\n    fee: CODEC;\n    counter: CODEC;\n    gas_limit: CODEC;\n    storage_limit: CODEC;\n    amount: CODEC;\n    destination: CODEC;\n};\nexport declare const UpdateConsensusKeySchema: {\n    source: CODEC;\n    fee: CODEC;\n    counter: CODEC;\n    gas_limit: CODEC;\n    storage_limit: CODEC;\n    pk: CODEC;\n    proof: CODEC;\n};\nexport declare const UpdateCompanionKeySchema: {\n    source: CODEC;\n    fee: CODEC;\n    counter: CODEC;\n    gas_limit: CODEC;\n    storage_limit: CODEC;\n    pk: CODEC;\n    proof: CODEC;\n};\nexport declare const DrainDelegateSchema: {\n    consensus_key: CODEC;\n    delegate: CODEC;\n    destination: CODEC;\n};\nexport declare const SetDepositsLimitSchema: {\n    source: CODEC;\n    fee: CODEC;\n    counter: CODEC;\n    gas_limit: CODEC;\n    storage_limit: CODEC;\n    limit: CODEC;\n};\nexport declare const SmartRollupOriginateSchema: {\n    source: CODEC;\n    fee: CODEC;\n    counter: CODEC;\n    gas_limit: CODEC;\n    storage_limit: CODEC;\n    pvm_kind: CODEC;\n    kernel: CODEC;\n    parameters_ty: CODEC;\n    whitelist: CODEC;\n};\nexport declare const SmartRollupAddMessagesSchema: {\n    source: CODEC;\n    fee: CODEC;\n    counter: CODEC;\n    gas_limit: CODEC;\n    storage_limit: CODEC;\n    message: CODEC;\n};\nexport declare const SmartRollupExecuteOutboxMessageSchema: {\n    source: CODEC;\n    fee: CODEC;\n    counter: CODEC;\n    gas_limit: CODEC;\n    storage_limit: CODEC;\n    rollup: CODEC;\n    cemented_commitment: CODEC;\n    output_proof: CODEC;\n};\nexport declare const DalPublishCommitmentSchema: {\n    source: CODEC;\n    fee: CODEC;\n    counter: CODEC;\n    gas_limit: CODEC;\n    storage_limit: CODEC;\n    slot_header: CODEC;\n};\nexport declare const FailingNoopSchema: {\n    arbitrary: CODEC;\n};\nexport declare const operationEncoder: (encoders: {\n    [key: string]: (val: object) => string;\n}) => (operation: {\n    kind: string;\n}) => string;\nexport declare const operationDecoder: (decoders: {\n    [key: string]: Decoder;\n}) => (value: Uint8ArrayConsumer) => {\n    kind: string;\n};\ntype Schema = Record<string, CODEC | CODEC[]>;\nexport type Value = Record<keyof Schema, unknown[]>;\nexport declare const schemaEncoder: (encoders: {\n    [key: string]: (val: object) => string;\n}) => (schema: Schema) => (value: Value) => string;\nexport declare const schemaDecoder: (decoders: {\n    [key: string]: Decoder;\n}) => (schema: {\n    [key: string]: string | string[];\n}) => (value: Uint8ArrayConsumer) => {};\nexport {};\n"},{name:"@taquito/local-forging/dist/types/codec-proto022.d.ts",dts:"import { Prefix } from '@taquito/utils';\nimport { MichelsonValue } from './michelson/codec-proto022';\nimport { Uint8ArrayConsumer } from './uint8array-consumer';\nexport declare const prefixEncoder: (prefix: Prefix) => (str: string) => string;\nexport declare const prefixDecoder: (pre: Prefix) => (str: Uint8ArrayConsumer) => string;\nexport declare const tz1Decoder: (str: Uint8ArrayConsumer) => string;\nexport declare const branchDecoder: (str: Uint8ArrayConsumer) => string;\nexport declare const publicKeyHashDecoder: (val: Uint8ArrayConsumer) => string | undefined;\nexport declare const publicKeyHashesDecoder: (val: Uint8ArrayConsumer) => (string | undefined)[] | undefined;\nexport declare const branchEncoder: (str: string) => string;\nexport declare const tz1Encoder: (str: string) => string;\nexport declare const boolEncoder: (bool: unknown) => string;\nexport declare const proposalEncoder: (proposal: string) => string;\nexport declare const proposalDecoder: (proposal: Uint8ArrayConsumer) => string;\nexport declare const proposalsDecoder: (proposal: Uint8ArrayConsumer) => string[];\nexport declare const proposalsEncoder: (proposals: string[]) => string;\nexport declare const ballotEncoder: (ballot: string) => string;\nexport declare const ballotDecoder: (ballot: Uint8ArrayConsumer) => string;\nexport declare const pvmKindEncoder: (pvm: string) => string;\nexport declare const pvmKindDecoder: (pvm: Uint8ArrayConsumer) => string;\nexport declare const delegateEncoder: (val: string) => string;\nexport declare const int32Encoder: (val: number | string) => string;\nexport declare const int32Decoder: (val: Uint8ArrayConsumer) => number;\nexport declare const int16Encoder: (val: number | string) => string;\nexport declare const int16Decoder: (val: Uint8ArrayConsumer) => number;\nexport declare const boolDecoder: (val: Uint8ArrayConsumer) => boolean;\nexport declare const delegateDecoder: (val: Uint8ArrayConsumer) => string | undefined;\nexport declare const publicKeyHashEncoder: (val: string) => string;\nexport declare const publicKeyHashesEncoder: (val?: string[]) => string;\nexport declare const publicKeyEncoder: (val: string) => string;\nexport declare const addressEncoder: (val: string) => string;\nexport declare const smartRollupAddressEncoder: (val: string) => string;\nexport declare const smartContractAddressEncoder: (val: string) => string;\nexport declare const publicKeyDecoder: (val: Uint8ArrayConsumer) => string;\nexport declare const smartRollupCommitmentHashEncoder: (val: string) => string;\nexport declare const addressDecoder: (val: Uint8ArrayConsumer) => string | undefined;\nexport declare const smartRollupAddressDecoder: (val: Uint8ArrayConsumer) => string;\nexport declare const smartContractAddressDecoder: (val: Uint8ArrayConsumer) => string;\nexport declare const smartRollupCommitmentHashDecoder: (val: Uint8ArrayConsumer) => string;\nexport declare const zarithEncoder: (n: string) => string;\nexport declare const zarithDecoder: (n: Uint8ArrayConsumer) => string;\nexport declare const entrypointDecoder: (value: Uint8ArrayConsumer) => string;\nexport declare const parametersDecoder: (val: Uint8ArrayConsumer) => {\n    entrypoint: string;\n    value: string | number | object | undefined;\n} | undefined;\nexport declare const entrypointEncoder: (entrypoint: string) => string;\nexport declare const parametersEncoder: (val: {\n    entrypoint: string;\n    value: MichelsonValue;\n}) => string;\nexport declare const valueParameterEncoder: (value: MichelsonValue) => string;\nexport declare const valueParameterDecoder: (val: Uint8ArrayConsumer) => string | number | object | undefined;\nexport declare const blockPayloadHashEncoder: (str: string) => string;\nexport declare const blockPayloadHashDecoder: (str: Uint8ArrayConsumer) => string;\nexport declare const entrypointNameEncoder: (entrypoint: string) => string;\nexport declare const entrypointNameDecoder: (val: Uint8ArrayConsumer) => string;\nexport declare const burnLimitEncoder: (val: string) => string;\nexport declare const burnLimitDecoder: (value: Uint8ArrayConsumer) => string | undefined;\nexport declare const depositsLimitEncoder: (val: string) => string;\nexport declare const depositsLimitDecoder: (value: Uint8ArrayConsumer) => string | undefined;\nexport declare const signatureProofEncoder: (val: string) => string;\nexport declare const signatureProofDecoder: (value: Uint8ArrayConsumer) => string | undefined;\nexport declare const paddedBytesEncoder: (val: string, paddingLength?: number) => string;\nexport declare const paddedBytesDecoder: (val: Uint8ArrayConsumer) => string;\nexport declare const smartRollupMessageEncoder: (val: string[]) => string;\nexport declare const smartRollupMessageDecoder: (val: Uint8ArrayConsumer) => string[];\nexport declare const dalCommitmentEncoder: (val: string) => string;\nexport declare const dalCommitmentDecoder: (val: Uint8ArrayConsumer) => string;\nexport declare const slotHeaderEncoder: (val: {\n    slot_index: number;\n    commitment: string;\n    commitment_proof: string;\n}) => string;\nexport declare const slotHeaderDecoder: (val: Uint8ArrayConsumer) => {\n    slot_index: number;\n    commitment: string;\n    commitment_proof: string;\n};\n"},{name:"@taquito/local-forging/dist/types/codec.d.ts",dts:"import { PrefixV2 } from '@taquito/utils';\nimport { MichelsonValue } from './michelson/codec';\nimport { Uint8ArrayConsumer } from './uint8array-consumer';\nexport declare const prefixEncoder: (prefix: PrefixV2) => (str: string) => string;\nexport declare const prefixDecoder: (pre: PrefixV2) => (str: Uint8ArrayConsumer) => string;\nexport declare const tz1Decoder: (str: Uint8ArrayConsumer) => string;\nexport declare const branchDecoder: (str: Uint8ArrayConsumer) => string;\nexport declare const publicKeyHashDecoder: (val: Uint8ArrayConsumer) => string | undefined;\nexport declare const publicKeyHashesDecoder: (val: Uint8ArrayConsumer) => (string | undefined)[] | undefined;\nexport declare const branchEncoder: (str: string) => string;\nexport declare const tz1Encoder: (str: string) => string;\nexport declare const boolEncoder: (bool: unknown) => string;\nexport declare const proposalEncoder: (proposal: string) => string;\nexport declare const proposalDecoder: (proposal: Uint8ArrayConsumer) => string;\nexport declare const proposalsDecoder: (proposal: Uint8ArrayConsumer) => string[];\nexport declare const proposalsEncoder: (proposals: string[]) => string;\nexport declare const ballotEncoder: (ballot: string) => string;\nexport declare const ballotDecoder: (ballot: Uint8ArrayConsumer) => string;\nexport declare const pvmKindEncoder: (pvm: string) => string;\nexport declare const pvmKindDecoder: (pvm: Uint8ArrayConsumer) => string;\nexport declare const delegateEncoder: (val: string) => string;\nexport declare const int32Encoder: (val: number | string) => string;\nexport declare const int32Decoder: (val: Uint8ArrayConsumer) => number;\nexport declare const int16Encoder: (val: number | string) => string;\nexport declare const int16Decoder: (val: Uint8ArrayConsumer) => number;\nexport declare const boolDecoder: (val: Uint8ArrayConsumer) => boolean;\nexport declare const delegateDecoder: (val: Uint8ArrayConsumer) => string | undefined;\nexport declare const publicKeyHashEncoder: (val: string) => string;\nexport declare const publicKeyHashesEncoder: (val?: string[]) => string;\nexport declare const publicKeyEncoder: (val: string) => string;\nexport declare const addressEncoder: (val: string) => string;\nexport declare const smartRollupAddressEncoder: (val: string) => string;\nexport declare const smartContractAddressEncoder: (val: string) => string;\nexport declare const publicKeyDecoder: (val: Uint8ArrayConsumer) => string;\nexport declare const smartRollupCommitmentHashEncoder: (val: string) => string;\nexport declare const addressDecoder: (val: Uint8ArrayConsumer) => string | undefined;\nexport declare const smartRollupAddressDecoder: (val: Uint8ArrayConsumer) => string;\nexport declare const smartContractAddressDecoder: (val: Uint8ArrayConsumer) => string;\nexport declare const smartRollupCommitmentHashDecoder: (val: Uint8ArrayConsumer) => string;\nexport declare const zarithEncoder: (n: string) => string;\nexport declare const zarithDecoder: (n: Uint8ArrayConsumer) => string;\nexport declare const entrypointDecoder: (value: Uint8ArrayConsumer) => string;\nexport declare const parametersDecoder: (val: Uint8ArrayConsumer) => {\n    entrypoint: string;\n    value: string | number | object | undefined;\n} | undefined;\nexport declare const entrypointEncoder: (entrypoint: string) => string;\nexport declare const parametersEncoder: (val: {\n    entrypoint: string;\n    value: MichelsonValue;\n}) => string;\nexport declare const valueParameterEncoder: (value: MichelsonValue) => string;\nexport declare const valueParameterDecoder: (val: Uint8ArrayConsumer) => string | number | object | undefined;\nexport declare const blockPayloadHashEncoder: (str: string) => string;\nexport declare const blockPayloadHashDecoder: (str: Uint8ArrayConsumer) => string;\nexport declare const entrypointNameEncoder: (entrypoint: string) => string;\nexport declare const entrypointNameDecoder: (val: Uint8ArrayConsumer) => string;\nexport declare const burnLimitEncoder: (val: string) => string;\nexport declare const burnLimitDecoder: (value: Uint8ArrayConsumer) => string | undefined;\nexport declare const depositsLimitEncoder: (val: string) => string;\nexport declare const depositsLimitDecoder: (value: Uint8ArrayConsumer) => string | undefined;\nexport declare const signatureProofEncoder: (val: string) => string;\nexport declare const signatureProofDecoder: (value: Uint8ArrayConsumer) => string | undefined;\nexport declare const paddedBytesEncoder: (val: string, paddingLength?: number) => string;\nexport declare const paddedBytesDecoder: (val: Uint8ArrayConsumer) => string;\nexport declare const smartRollupMessageEncoder: (val: string[]) => string;\nexport declare const smartRollupMessageDecoder: (val: Uint8ArrayConsumer) => string[];\nexport declare const dalCommitmentEncoder: (val: string) => string;\nexport declare const dalCommitmentDecoder: (val: Uint8ArrayConsumer) => string;\nexport declare const slotHeaderEncoder: (val: {\n    slot_index: number;\n    commitment: string;\n    commitment_proof: string;\n}) => string;\nexport declare const slotHeaderDecoder: (val: Uint8ArrayConsumer) => {\n    slot_index: number;\n    commitment: string;\n    commitment_proof: string;\n};\n"},{name:"@taquito/local-forging/dist/types/constants-proto022.d.ts",dts:'export declare const ENTRYPOINT_MAX_LENGTH = 31;\nexport declare enum CODEC {\n    SECRET = "secret",\n    RAW = "raw",\n    TZ1 = "tz1",\n    BRANCH = "branch",\n    ZARITH = "zarith",\n    PUBLIC_KEY = "public_key",\n    PKH = "pkh",\n    PKH_ARR = "pkhArr",\n    DELEGATE = "delegate",\n    SCRIPT = "script",\n    BALLOT_STATEMENT = "ballotStmt",\n    PROPOSAL = "proposal",\n    PROPOSAL_ARR = "proposalArr",\n    INT32 = "int32",\n    INT16 = "int16",\n    PARAMETERS = "parameters",\n    ADDRESS = "address",\n    SMART_CONTRACT_ADDRESS = "smart_contract_address",\n    SMART_ROLLUP_ADDRESS = "smart_rollup_address",\n    SMART_ROLLUP_COMMITMENT_HASH = "smart_rollup_commitment_hash",\n    VALUE = "value",\n    PADDED_BYTES = "padded_bytes",\n    SMART_ROLLUP_MESSAGE = "smart_rollup_message",\n    MANAGER = "manager",\n    BLOCK_PAYLOAD_HASH = "blockPayloadHash",\n    ENTRYPOINT = "entrypoint",\n    OPERATION = "operation",\n    OP_ACTIVATE_ACCOUNT = "activate_account",\n    OP_DELEGATION = "delegation",\n    OP_TRANSACTION = "transaction",\n    OP_ORIGINATION = "origination",\n    OP_BALLOT = "ballot",\n    OP_FAILING_NOOP = "failing_noop",\n    OP_ATTESTATION = "attestation",\n    OP_ATTESTATION_WITH_DAL = "attestation_with_dal",\n    OP_SEED_NONCE_REVELATION = "seed_nonce_revelation",\n    OP_REVEAL = "reveal",\n    OP_PROPOSALS = "proposals",\n    OP_REGISTER_GLOBAL_CONSTANT = "register_global_constant",\n    OP_TRANSFER_TICKET = "transfer_ticket",\n    BURN_LIMIT = "burn_limit",\n    OP_INCREASE_PAID_STORAGE = "increase_paid_storage",\n    OP_UPDATE_CONSENSUS_KEY = "update_consensus_key",\n    SIGNATURE_PROOF = "signature_proof",\n    OP_DRAIN_DELEGATE = "drain_delegate",\n    DEPOSITS_LIMIT = "deposits_limit",\n    OP_SET_DEPOSITS_LIMIT = "set_deposits_limit",\n    OP_SMART_ROLLUP_ORIGINATE = "smart_rollup_originate",\n    PVM_KIND = "pvm_kind",\n    OP_SMART_ROLLUP_ADD_MESSAGES = "smart_rollup_add_messages",\n    OP_SMART_ROLLUP_EXECUTE_OUTBOX_MESSAGE = "smart_rollup_execute_outbox_message",\n    OP_DAL_PUBLISH_COMMITMENT = "dal_publish_commitment",\n    SLOT_HEADER = "slot_header"\n}\nexport declare const opMapping: {\n    [key: string]: string;\n};\nexport declare const opMappingReverse: {\n    [key: string]: string;\n};\nexport declare const kindMapping: {\n    [key: number]: string;\n};\nexport declare const kindMappingReverse: {\n    [key: string]: string;\n};\nexport declare const entrypointMapping: {\n    [key: string]: string;\n};\nexport declare const entrypointMappingReverse: {\n    [key: string]: string;\n};\n'},{name:"@taquito/local-forging/dist/types/constants.d.ts",dts:'export declare const ENTRYPOINT_MAX_LENGTH = 31;\nexport declare enum CODEC {\n    SECRET = "secret",\n    RAW = "raw",\n    TZ1 = "tz1",\n    BRANCH = "branch",\n    ZARITH = "zarith",\n    PUBLIC_KEY = "public_key",\n    PKH = "pkh",\n    PKH_ARR = "pkhArr",\n    DELEGATE = "delegate",\n    SCRIPT = "script",\n    BALLOT_STATEMENT = "ballotStmt",\n    PROPOSAL = "proposal",\n    PROPOSAL_ARR = "proposalArr",\n    INT32 = "int32",\n    INT16 = "int16",\n    PARAMETERS = "parameters",\n    ADDRESS = "address",\n    SMART_CONTRACT_ADDRESS = "smart_contract_address",\n    SMART_ROLLUP_ADDRESS = "smart_rollup_address",\n    SMART_ROLLUP_COMMITMENT_HASH = "smart_rollup_commitment_hash",\n    VALUE = "value",\n    PADDED_BYTES = "padded_bytes",\n    SMART_ROLLUP_MESSAGE = "smart_rollup_message",\n    MANAGER = "manager",\n    BLOCK_PAYLOAD_HASH = "blockPayloadHash",\n    ENTRYPOINT = "entrypoint",\n    OPERATION = "operation",\n    OP_ACTIVATE_ACCOUNT = "activate_account",\n    OP_DELEGATION = "delegation",\n    OP_TRANSACTION = "transaction",\n    OP_ORIGINATION = "origination",\n    OP_BALLOT = "ballot",\n    OP_FAILING_NOOP = "failing_noop",\n    OP_ATTESTATION = "attestation",\n    OP_ATTESTATION_WITH_DAL = "attestation_with_dal",\n    OP_SEED_NONCE_REVELATION = "seed_nonce_revelation",\n    OP_REVEAL = "reveal",\n    OP_PROPOSALS = "proposals",\n    OP_REGISTER_GLOBAL_CONSTANT = "register_global_constant",\n    OP_TRANSFER_TICKET = "transfer_ticket",\n    BURN_LIMIT = "burn_limit",\n    OP_INCREASE_PAID_STORAGE = "increase_paid_storage",\n    OP_UPDATE_CONSENSUS_KEY = "update_consensus_key",\n    OP_UPDATE_COMPANION_KEY = "update_companion_key",\n    SIGNATURE_PROOF = "signature_proof",\n    OP_DRAIN_DELEGATE = "drain_delegate",\n    DEPOSITS_LIMIT = "deposits_limit",\n    OP_SET_DEPOSITS_LIMIT = "set_deposits_limit",\n    OP_SMART_ROLLUP_ORIGINATE = "smart_rollup_originate",\n    PVM_KIND = "pvm_kind",\n    OP_SMART_ROLLUP_ADD_MESSAGES = "smart_rollup_add_messages",\n    OP_SMART_ROLLUP_EXECUTE_OUTBOX_MESSAGE = "smart_rollup_execute_outbox_message",\n    OP_DAL_PUBLISH_COMMITMENT = "dal_publish_commitment",\n    SLOT_HEADER = "slot_header"\n}\nexport declare const opMapping: {\n    [key: string]: string;\n};\nexport declare const opMappingReverse: {\n    [key: string]: string;\n};\nexport declare const kindMapping: {\n    [key: number]: string;\n};\nexport declare const kindMappingReverse: {\n    [key: string]: string;\n};\nexport declare const entrypointMapping: {\n    [key: string]: string;\n};\nexport declare const entrypointMappingReverse: {\n    [key: string]: string;\n};\n'},{name:"@taquito/local-forging/dist/types/decoder-proto022.d.ts",dts:"import { Uint8ArrayConsumer } from './uint8array-consumer';\nexport type Decoder = (val: Uint8ArrayConsumer) => string | number | object | undefined;\nexport declare const decoders: {\n    [key: string]: Decoder;\n};\n"},{name:"@taquito/local-forging/dist/types/decoder.d.ts",dts:"import { Uint8ArrayConsumer } from './uint8array-consumer';\nexport type Decoder = (val: Uint8ArrayConsumer) => string | number | object | undefined;\nexport declare const decoders: {\n    [key: string]: Decoder;\n};\n"},{name:"@taquito/local-forging/dist/types/encoder-proto022.d.ts",dts:"export type Encoder<T> = (val: T) => string;\nexport declare const encoders: {\n    [key: string]: Encoder<any>;\n};\n"},{name:"@taquito/local-forging/dist/types/encoder.d.ts",dts:"export type Encoder<T> = (val: T) => string;\nexport declare const encoders: {\n    [key: string]: Encoder<any>;\n};\n"},{name:"@taquito/local-forging/dist/types/errors.d.ts",dts:"import { ParameterValidationError } from '@taquito/core';\nimport { OperationContents } from '@taquito/rpc';\n/**\n *  @category Error\n *  @description Error that indicates an invalid operation content being passed or used\n */ export declare class InvalidOperationSchemaError extends ParameterValidationError {\n    readonly operation: OperationContents;\n    readonly errorDetail?: string | undefined;\n    constructor(operation: OperationContents, errorDetail?: string | undefined);\n}\n/**\n *  @category Error\n *  @description Error that indicates an entrypoint name exceeding maximum length\n */\nexport declare class OversizedEntryPointError extends ParameterValidationError {\n    readonly entrypoint: string;\n    constructor(entrypoint: string);\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid ballot value being used\n */\nexport declare class InvalidBallotValueError extends ParameterValidationError {\n    readonly ballotValue: string;\n    constructor(ballotValue: string);\n}\n/**\n *  @category Error\n *  @description Error that indicates a failure when trying to decode ballot value\n */\nexport declare class DecodeBallotValueError extends ParameterValidationError {\n    readonly ballotValue: string;\n    constructor(ballotValue: string);\n}\n/**\n *  @category Error\n *  @description Error that indicates unexpected Michelson Value being passed or used\n */\nexport declare class UnexpectedMichelsonValueError extends ParameterValidationError {\n    readonly value: string;\n    constructor(value: string);\n}\n/**\n *  @category Error\n *  @description Error that indicates a failure when trying to decode an operation\n */\nexport declare class OperationDecodingError extends ParameterValidationError {\n    readonly message: string;\n    constructor(message: string);\n}\n/**\n *  @category Error\n *  @description Error that indicates a failure when trying to encode an operation\n */\nexport declare class OperationEncodingError extends ParameterValidationError {\n    readonly message: string;\n    constructor(message: string);\n}\n/**\n *  @category Error\n *  @description Error that indicates an unsupported operation being passed or used\n */\nexport declare class UnsupportedOperationError extends ParameterValidationError {\n    readonly op: string;\n    constructor(op: string);\n}\n/**\n * @cateogry Error\n * @description Error that indicates an unsupported pvm being passed or used\n */\nexport declare class UnsupportedPvmKindError extends ParameterValidationError {\n    readonly pvm: string;\n    constructor(pvm: string);\n}\n/**\n * @category Error\n * @description Error that indicates an unsupported pvm to decode\n */\nexport declare class DecodePvmKindError extends ParameterValidationError {\n    readonly pvm: string;\n    constructor(pvm: string);\n}\n/**\n * @category Error\n * @description Error that indicates an invalid Smart Rollup Address (sr1)\n */\nexport declare class InvalidSmartRollupAddressError extends ParameterValidationError {\n    readonly address: string;\n    readonly errorDetail?: string | undefined;\n    constructor(address: string, errorDetail?: string | undefined);\n}\n/**\n * @category Error\n * @description Error that indicates an invalid Smart Rollup commitment hash (src1)\n */\nexport declare class InvalidSmartRollupCommitmentHashError extends ParameterValidationError {\n    readonly hash: string;\n    readonly errorDetail?: string | undefined;\n    constructor(hash: string, errorDetail?: string | undefined);\n}\n/**\n * @category Error\n * @description Error that indicates an invalid dal commitment (sh)\n */\nexport declare class InvalidDalCommitmentError extends ParameterValidationError {\n    readonly commitment: string;\n    readonly errorDetail?: string | undefined;\n    constructor(commitment: string, errorDetail?: string | undefined);\n}\n"},{name:"@taquito/local-forging/dist/types/interface.d.ts",dts:"import { OperationContents } from '@taquito/rpc';\nexport interface ForgeParams {\n    branch: string;\n    contents: OperationContents[];\n}\nexport type ForgeResponse = string;\nexport interface Forger {\n    forge(params: ForgeParams): Promise<ForgeResponse>;\n}\n"},{name:"@taquito/local-forging/dist/types/protocols.d.ts",dts:'export declare enum ProtocolsHash {\n    Pt24m4xi = "Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd",\n    PsBABY5H = "PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU",\n    PsBabyM1 = "PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS",\n    PsCARTHA = "PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb",\n    PsDELPH1 = "PsDELPH1Kxsxt8f9eWbxQeRxkjfbxoqM52jvs5Y5fBxWWh4ifpo",\n    PtEdo2Zk = "PtEdo2ZkT9oKpimTah6x2embF25oss54njMuPzkJTEi5RqfdZFA",\n    PsFLorena = "PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i",\n    PtGRANADs = "PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV",\n    PtHangz2 = "PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx",\n    Psithaca2 = "Psithaca2MLRFYargivpo7YvUr7wUDqyxrdhC5CQq78mRvimz6A",\n    PtJakart2 = "PtJakart2xVj7pYXJBXrqHgd82rdkLey5ZeeGwDgPp9rhQUbSqY",\n    PtKathman = "PtKathmankSpLLDALzWw7CGD2j2MtyveTwboEYokqUCP4a1LxMg",\n    PtLimaPtL = "PtLimaPtLMwfNinJi9rCfDPWea8dFgTZ1MeJ9f1m2SRic6ayiwW",\n    PtMumbaii = "PtMumbaiiFFEGbew1rRjzSPyzRbA51Tm3RVZL5suHPxSZYDhCEc",\n    PtMumbai2 = "PtMumbai2TmsJHNGRkD8v8YDbtao7BLUC3wjASn1inAKLFCjaH1",\n    PtNairobi = "PtNairobiyssHuh87hEhfVBGCVrK3WnS8Z2FT4ymB5tAa4r1nQf",\n    ProxfordY = "ProxfordYmVfjWnRcgjWH36fW6PArwqykTFzotUxRs6gmTcZDuH",\n    PtParisBx = "PtParisBxoLz5gzMmn3d9WBQNoPSZakgnkMC2VNuQ3KXfUtUQeZ",\n    PsParisCZ = "PsParisCZo7KAh1Z1smVd9ZMZ1HHn5gkzbM94V3PLCpknFWhUAi",\n    PsQuebecn = "PsQuebecnLByd3JwTiGadoG4nGWi3HYiLXUjkibeFV8dCFeVMUg",\n    PsRiotuma = "PsRiotumaAMotcRoDWW1bysEhQy2n1M5fy8JgRp8jjRfHGmfeA7",\n    PtSeouLou = "PtSeouLouXkxhg39oWzjxDWaCydNfR3RxCUrNe4Q9Ro8BTehcbh",\n    ProtoALpha = "ProtoALphaALphaALphaALphaALphaALphaALphaALphaDdp3zK"\n}\nexport declare function ProtoInferiorTo(a: ProtocolsHash, b: ProtocolsHash): boolean;\n'},{name:"@taquito/local-forging/dist/types/taquito-local-forging.d.ts",dts:"/**\n * @packageDocumentation\n * @module @taquito/local-forging\n */\nimport 'fast-text-encoding';\nimport { ForgeParams, Forger } from './interface';\nimport { CODEC } from './constants';\nimport { CODEC as CODECPROTO022 } from './constants-proto022';\nimport { ProtocolsHash } from './protocols';\nexport { CODEC, opMapping, opMappingReverse } from './constants';\nexport * from './decoder';\nexport * from './encoder';\nexport * from './uint8array-consumer';\nexport * from './interface';\nexport { VERSION } from './version';\nexport { ProtocolsHash } from './protocols';\nexport declare function getCodec(codec: CODEC | CODECPROTO022, _proto: ProtocolsHash): {\n    encoder: import(\"./encoder-proto022\").Encoder<any>;\n    decoder: (hex: string) => any;\n};\nexport declare class LocalForger implements Forger {\n    readonly protocolHash: ProtocolsHash;\n    constructor(protocolHash?: ProtocolsHash);\n    private codec;\n    forge(params: ForgeParams): Promise<string>;\n    parse(hex: string): Promise<ForgeParams>;\n}\nexport declare const localForger: LocalForger;\n"},{name:"@taquito/local-forging/dist/types/uint8array-consumer.d.ts",dts:"export declare class Uint8ArrayConsumer {\n    private readonly arr;\n    private offset;\n    static fromHexString(hex: string): Uint8ArrayConsumer;\n    constructor(arr: Uint8Array, offset?: number);\n    consume(count: number): Uint8Array;\n    get(idx: number): number;\n    length(): number;\n    slice(start: number, end?: number): Uint8ArrayConsumer;\n}\n"},{name:"@taquito/local-forging/dist/types/utils.d.ts",dts:"export declare const concat: (...arr: Uint8Array[]) => Uint8Array;\nexport declare const toHexString: (bytes: Uint8Array) => string;\nexport declare const pad: (num: number, paddingLen?: number) => string;\n"},{name:"@taquito/local-forging/dist/types/validator-proto022.d.ts",dts:"import { OpKind } from '@taquito/rpc';\nimport { OperationContents } from '@taquito/rpc';\n/**\n * @returns A boolean value to indicate whether the operation kind is valid or not\n */\nexport declare const validateOperationKind: (opKind: OpKind) => boolean;\n/**\n *  returns 0 when the two array of properties are identical or the passed property\n *  does not have any missing parameters from the corresponding schema\n *\n *  @returns array element differences if there are missing required property keys\n */\nexport declare const validateMissingProperty: (operationContent: OperationContents) => string[];\n"},{name:"@taquito/local-forging/dist/types/validator.d.ts",dts:"import { OpKind } from '@taquito/rpc';\nimport { OperationContents } from '@taquito/rpc';\n/**\n * @returns A boolean value to indicate whether the operation kind is valid or not\n */\nexport declare const validateOperationKind: (opKind: OpKind) => boolean;\n/**\n *  returns 0 when the two array of properties are identical or the passed property\n *  does not have any missing parameters from the corresponding schema\n *\n *  @returns array element differences if there are missing required property keys\n */\nexport declare const validateMissingProperty: (operationContent: OperationContents) => string[];\n"},{name:"@taquito/local-forging/dist/types/version.d.ts",dts:"export declare const VERSION: {\n    commitHash: string;\n    version: string;\n};\n"},{name:"@taquito/michel-codec/dist/types/base58.d.ts",dts:"import { TaquitoError } from '@taquito/core';\n/**\n *  @category Error\n *  @description Error that indicates a failure when decoding a base58 encoding\n */\nexport declare class Base58DecodingError extends TaquitoError {\n    readonly message: string;\n    constructor(message: string);\n}\nexport declare function decodeBase58(src: string): number[];\nexport declare function encodeBase58(src: number[] | Uint8Array): string;\nexport declare function decodeBase58Check(src: string): number[];\nexport declare function encodeBase58Check(src: number[] | Uint8Array): string;\n"},{name:"@taquito/michel-codec/dist/types/binary.d.ts",dts:'import { BytesLiteral } from \'./micheline\';\nimport { MichelsonData, MichelsonType } from \'./michelson-types\';\ntype AddressType = \'ED25519PublicKeyHash\' | \'SECP256K1PublicKeyHash\' | \'P256PublicKeyHash\' | \'ContractHash\';\nexport interface Address {\n    type: AddressType;\n    hash: number[] | Uint8Array;\n    entryPoint?: string;\n}\nexport type PublicKeyType = \'ED25519PublicKey\' | \'SECP256K1PublicKey\' | \'P256PublicKey\';\nexport interface PublicKey {\n    type: PublicKeyType;\n    publicKey: number[] | Uint8Array;\n}\n/**\n * Serializes any value of packable type to its optimized binary representation\n * identical to the one used by PACK and UNPACK Michelson instructions.\n * Without a type definition (not recommended) the data will be encoded as a binary form of a generic Michelson expression.\n * Type definition allows some types like `timestamp` and `address` and other base58 representable types to be encoded to\n * corresponding optimized binary forms borrowed from the Tezos protocol\n *\n * ```typescript\n * const data: MichelsonData = {\n *     string: "KT1RvkwF4F7pz1gCoxkyZrG1RkrxQy3gmFTv%foo"\n * };\n *\n * const typ: MichelsonType = {\n *     prim: "address"\n * };\n *\n * const packed = packData(data, typ);\n *\n * // 050a0000001901be41ee922ddd2cf33201e49d32da0afec571dce300666f6f\n * ```\n *\n * Without a type definition the base58 encoded address will be treated as a string\n * ```typescript\n * const data: MichelsonData = {\n *     string: "KT1RvkwF4F7pz1gCoxkyZrG1RkrxQy3gmFTv%foo"\n * };\n *\n * const packed = packData(data);\n *\n * // 0501000000284b543152766b7746344637707a3167436f786b795a724731526b7278517933676d46547625666f6f\n * ```\n * @param d Data object\n * @param t Optional type definition\n * @returns Binary representation as numeric array\n */\nexport declare function packData(d: MichelsonData, t?: MichelsonType): number[];\n/**\n * Serializes any value of packable type to its optimized binary representation\n * identical to the one used by PACK and UNPACK Michelson instructions.\n * Same as {@link packData} but returns a `bytes` Michelson data literal instead of an array\n *\n * ```typescript\n * const data: MichelsonData = {\n *     string: "2019-09-26T10:59:51Z"\n * };\n *\n * const typ: MichelsonType = {\n *     prim: "timestamp"\n * };\n *\n * const packed = packDataBytes(data, typ);\n *\n * // { bytes: "0500a7e8e4d80b" }\n * ```\n * @param d Data object\n * @param t Optional type definition\n * @returns Binary representation as a bytes literal\n */\nexport declare function packDataBytes(d: MichelsonData, t?: MichelsonType): BytesLiteral;\n/**\n * Deserialize a byte array into the corresponding Michelson value.\n * Without a type definition (not recommended) the binary data will be treated as a binary form of a generic Michelson expression and returned as is.\n * Type definition allows some types like `timestamp` and `address` and other types usually encoded in optimized binary forms to be transformed\n * back to their string representations like base58 and ISO timestamps.\n *\n * ```typescript\n * const src = [0x05, 0x00, 0xa7, 0xe8, 0xe4, 0xd8, 0x0b];\n *\n * const typ: MichelsonType = {\n *     prim: "timestamp"\n * };\n *\n * const data = unpackData(src, typ);\n *\n * // { string: "2019-09-26T10:59:51Z" }\n * ```\n *\n * Same binary data without a type definition\n * ```typescript\n * const src = [0x05, 0x00, 0xa7, 0xe8, 0xe4, 0xd8, 0x0b];\n *\n * const data = unpackData(src);\n *\n * // { int: "1569495591" }\n * ```\n * @param src Byte array\n * @param t Optional type definition\n * @returns Deserialized data\n */\nexport declare function unpackData(src: number[] | Uint8Array, t?: MichelsonType): MichelsonData;\n/**\n * Deserialize a byte array into the corresponding Michelson value.\n * Same as {@link unpackData} but takes a `bytes` Michelson data literal instead of an array\n *\n * ```typescript\n * const src = { bytes: "0500a7e8e4d80b" };\n *\n * const typ: MichelsonType = {\n *     prim: "timestamp"\n * };\n *\n * const data = unpackDataBytes(src, typ);\n *\n * // { string: "2019-09-26T10:59:51Z" }\n * ```\n * @param src Bytes object\n * @param t Optional type definition\n * @returns Deserialized data\n */\nexport declare function unpackDataBytes(src: BytesLiteral, t?: MichelsonType): MichelsonData;\nexport declare function decodeAddressBytes(b: BytesLiteral): Address;\nexport declare function decodePublicKeyHashBytes(b: BytesLiteral): Address;\nexport declare function decodePublicKeyBytes(b: BytesLiteral): PublicKey;\nexport {};\n'},{name:"@taquito/michel-codec/dist/types/errors.d.ts",dts:"import { ParameterValidationError, TaquitoError } from '@taquito/core';\n/**\n *  @category Error\n *  @description Error that indicates an invalid Michelson being passed or used\n */\nexport declare class InvalidMichelsonError extends ParameterValidationError {\n    readonly message: string;\n    constructor(message: string);\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid type expression being passed or used\n */\nexport declare class InvalidTypeExpressionError extends ParameterValidationError {\n    readonly message: string;\n    constructor(message: string);\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid data expression being passed or used\n */\nexport declare class InvalidDataExpressionError extends ParameterValidationError {\n    readonly message: string;\n    constructor(message: string);\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid contract entrypoint being referenced or passed\n */\nexport declare class InvalidEntrypointError extends ParameterValidationError {\n    readonly entrypoint?: string | undefined;\n    constructor(entrypoint?: string | undefined);\n}\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when trying to encode Tezos ID\n */\nexport declare class TezosIdEncodeError extends ParameterValidationError {\n    readonly message: string;\n    constructor(message: string);\n}\n/**\n *  @category Error\n *  @description Error that indicates a general error happening when trying to create a LongInteger\n */\nexport declare class LongIntegerError extends TaquitoError {\n    readonly message: string;\n    constructor(message: string);\n}\n/**\n *  @category Error\n *  @description Error that indicates a failure occurring when trying to parse a hex byte\n */\nexport declare class HexParseError extends TaquitoError {\n    readonly hexByte: string;\n    constructor(hexByte: string);\n}\n"},{name:"@taquito/michel-codec/dist/types/formatters.d.ts",dts:"import { InstructionTrace } from './michelson-typecheck';\nimport { MichelsonError } from './utils';\nimport { MichelsonReturnType } from './michelson-types';\nexport declare function formatStack(s: MichelsonReturnType): string;\nexport declare function traceDumpFunc(blocks: boolean, cb: (s: string) => void): (v: InstructionTrace) => void;\nexport declare function formatError(err: MichelsonError): string;\n"},{name:"@taquito/michel-codec/dist/types/global-constants.d.ts",dts:"import { Prim, Expr } from './micheline';\nimport { GlobalConstantHashAndValue } from './micheline-parser';\nexport declare function expandGlobalConstants(ex: Prim, hashAndValue: GlobalConstantHashAndValue): Expr;\n"},{name:"@taquito/michel-codec/dist/types/macros.d.ts",dts:"import { TaquitoError } from '@taquito/core';\nimport { Prim, Expr } from './micheline';\nimport { ProtocolOptions } from './michelson-types';\n/**\n *  @category Error\n *  @description Error that indicates macros failed to be expanded\n */\nexport declare class MacroError extends TaquitoError {\n    readonly prim: Prim;\n    readonly message: string;\n    constructor(prim: Prim, message: string);\n}\nexport declare function expandMacros(ex: Prim, opt?: ProtocolOptions): Expr;\n"},{name:"@taquito/michel-codec/dist/types/micheline-emitter.d.ts",dts:"import { Expr } from './micheline';\nexport interface FormatOptions {\n    /**\n     * A string used for code indentation if desired. Usually a tab character or a number of spaces.\n     */\n    indent?: string;\n    /**\n     * A string used for line separation. Usually a newline character (\"\\n\");\n     */\n    newline?: string;\n}\n/**\n * Formats Micheline expression\n * @param expr An AST node\n * @param opt Options\n */\nexport declare function emitMicheline(expr: Expr, opt?: FormatOptions, foldMacros?: boolean): string;\n"},{name:"@taquito/michel-codec/dist/types/micheline-parser.d.ts",dts:'import { Token } from \'./scan\';\nimport { Expr } from \'./micheline\';\nimport { ProtocolOptions } from \'./michelson-types\';\nimport { TaquitoError } from \'@taquito/core\';\n/**\n *  @category Error\n *  @description Error that indicates a failure when parsing Micheline expressions\n */\nexport declare class MichelineParseError extends TaquitoError {\n    readonly token: Token | null;\n    readonly message: string;\n    /**\n     * @param token A token caused the error\n     * @param message An error message\n     */\n    constructor(token: Token | null, message: string);\n}\n/**\n *  @category Error\n *  @description Error indicates a failure when parsing Micheline JSON\n */\nexport declare class JSONParseError extends TaquitoError {\n    readonly node: unknown;\n    readonly message: string;\n    /**\n     * @param node A node caused the error\n     * @param message An error message\n     */\n    constructor(node: unknown, message: string);\n}\nexport interface GlobalConstantHashAndValue {\n    [globalConstantHash: string]: Expr;\n}\nexport interface ParserOptions extends ProtocolOptions {\n    /**\n     * Expand [Michelson macros](https://tezos.gitlab.io/whitedoc/michelson.html#macros) during parsing.\n     */\n    expandMacros?: boolean;\n    /**\n     * Expand global constants during parsing.\n     * `expandGlobalConstant` expects an object where the keys are global constant hashes and the values are the corresponding JSON Micheline expressions.\n     * @example\n     * ```\n     * const parserOptions: ParserOptions = {\n     *  expandGlobalConstant: {\n     *      \'expr...\': { prim: \'DROP\', args: [{ int: \'2\' }] }\n     *  }\n     * }\n     *\n     * const p = new Parser(parserOptions);\n     * ```\n     */\n    expandGlobalConstant?: GlobalConstantHashAndValue;\n}\n/**\n * Converts and validates Michelson expressions between JSON-based Michelson and Micheline\n *\n * Pretty Print a Michelson Smart Contract:\n * ```\n * const contract = await Tezos.contract.at("KT1Vsw3kh9638gqWoHTjvHCoHLPKvCbMVbCg");\n * const p = new Parser();\n *\n * const michelsonCode = p.parseJSON(contract.script.code);\n * const storage = p.parseJSON(contract.script.storage);\n *\n * console.log("Pretty print Michelson smart contract:");\n * console.log(emitMicheline(michelsonCode, {indent:"    ", newline: "\\n",}));\n *\n * console.log("Pretty print Storage:");\n * console.log(emitMicheline(storage, {indent:"    ", newline: "\\n",}));\n * ```\n *\n * Encode a Michelson expression for initial storage of a smart contract\n * ```\n * const src = `(Pair (Pair { Elt 1\n *                (Pair (Pair "tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" "tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx")\n *                      0x0501000000026869) }\n *          10000000)\n *    (Pair 2 333))`;\n *\n * const p = new Parser();\n *\n * const exp = p.parseMichelineExpression(src);\n * console.log(JSON.stringify(exp));\n * ```\n */\nexport declare class Parser {\n    private opt?;\n    constructor(opt?: ParserOptions | undefined);\n    private expand;\n    private parseListExpr;\n    private parseArgs;\n    private parseSequenceExpr;\n    private parseExpr;\n    /**\n     * Parses a Micheline sequence expression, such as smart contract source. Enclosing curly brackets may be omitted.\n     * @param src A Micheline sequence `{parameter ...; storage int; code { DUP ; ...};}` or `parameter ...; storage int; code { DUP ; ...};`\n     */\n    parseSequence(src: string): Expr[] | null;\n    /**\n     * Parse a Micheline sequence expression. Enclosing curly brackets may be omitted.\n     * @param src A Michelson list expression such as `(Pair {Elt "0" 0} 0)` or `Pair {Elt "0" 0} 0`\n     * @returns An AST node or null for empty document.\n     */\n    parseList(src: string): Expr | null;\n    /**\n     * Parse any Michelson expression\n     * @param src A Michelson expression such as `(Pair {Elt "0" 0} 0)` or `{parameter ...; storage int; code { DUP ; ...};}`\n     * @returns An AST node or null for empty document.\n     */\n    parseMichelineExpression(src: string): Expr | null;\n    /**\n     * Parse a Micheline sequence expression, such as smart contract source. Enclosing curly brackets may be omitted.\n     * An alias for `parseSequence`\n     * @param src A Micheline sequence `{parameter ...; storage int; code { DUP ; ...};}` or `parameter ...; storage int; code { DUP ; ...};`\n     */\n    parseScript(src: string): Expr[] | null;\n    /**\n     * Parse a Micheline sequence expression. Enclosing curly brackets may be omitted.\n     * An alias for `parseList`\n     * @param src A Michelson list expression such as `(Pair {Elt "0" 0} 0)` or `Pair {Elt "0" 0} 0`\n     * @returns An AST node or null for empty document.\n     */\n    parseData(src: string): Expr | null;\n    /**\n     * Takes a JSON-encoded Michelson, validates it, strips away unneeded properties and optionally expands macros (See {@link ParserOptions}).\n     * @param src An object containing JSON-encoded Michelson, usually returned by `JSON.parse()`\n     */\n    parseJSON(src: object): Expr;\n}\n'},{name:"@taquito/michel-codec/dist/types/micheline.d.ts",dts:"export type SourceReference = {\n    first: number;\n    last: number;\n    macro?: Expr;\n    globalConstant?: Expr;\n};\nexport declare const sourceReference: unique symbol;\nexport interface Node {\n    [sourceReference]?: SourceReference;\n}\n/**\n * An AST node representing Michelson string literal.\n */\nexport interface StringLiteral extends Node {\n    string: string;\n}\n/**\n * An AST node representing Michelson int literal.\n */\nexport interface IntLiteral<T extends string = string> extends Node {\n    int: T;\n}\n/**\n * An AST node representing Michelson bytes literal.\n */\nexport interface BytesLiteral extends Node {\n    bytes: string;\n}\n/**\n * An AST node representing Michelson primitive.\n */\nexport interface Prim<PT extends string = string, AT extends Expr[] = Expr[]> extends Node {\n    prim: PT;\n    args?: AT;\n    annots?: string[];\n}\nexport type List<T extends Expr> = T[] & Node;\ninterface ExprList extends List<Expr> {\n}\n/**\n * An AST node representing valid Michelson expression. Directly corresponds to JSON-encoded Michelson node\n */\nexport type Expr = Prim | StringLiteral | IntLiteral | BytesLiteral | ExprList;\nexport {};\n"},{name:"@taquito/michel-codec/dist/types/michelson-contract.d.ts",dts:"import { MichelsonContract, MichelsonContractSection, MichelsonType, MichelsonData, MichelsonCode, MichelsonReturnType } from './michelson-types';\nimport { InstructionTrace } from './michelson-typecheck';\nimport { ParserOptions } from './micheline-parser';\nexport interface ContractOptions extends ParserOptions {\n    traceCallback?: (t: InstructionTrace) => void;\n}\nexport declare class Contract {\n    readonly contract: MichelsonContract;\n    private ctx;\n    readonly output: MichelsonReturnType;\n    constructor(contract: MichelsonContract, opt?: ContractOptions);\n    static parse(src: string | object, opt?: ContractOptions): Contract;\n    static parseTypeExpression(src: string | object, opt?: ParserOptions): MichelsonType;\n    static parseDataExpression(src: string | object, opt?: ParserOptions): MichelsonData;\n    section<T extends 'parameter' | 'storage' | 'code'>(section: T): MichelsonContractSection<T>;\n    entryPoints(): [string, MichelsonType][];\n    entryPoint(ep?: string): MichelsonType | null;\n    assertDataValid(d: MichelsonData, t: MichelsonType): void;\n    isDataValid(d: MichelsonData, t: MichelsonType): boolean;\n    assertParameterValid(ep: string | null, d: MichelsonData): void;\n    isParameterValid(ep: string | null, d: MichelsonData): boolean;\n    functionType(inst: MichelsonCode, stack: MichelsonType[]): MichelsonReturnType;\n}\nexport declare const dummyContract: Contract;\n"},{name:"@taquito/michel-codec/dist/types/michelson-typecheck.d.ts",dts:"import { MichelsonType, MichelsonData, MichelsonCode, MichelsonContract, MichelsonContractSection, MichelsonReturnType, MichelsonContractView } from './michelson-types';\nimport { MichelsonError } from './utils';\nimport { ParserOptions } from './micheline-parser';\nexport interface Context extends ParserOptions {\n    contract?: MichelsonContract;\n    traceCallback?: (t: InstructionTrace) => void;\n}\nexport declare class MichelsonInstructionError extends MichelsonError<MichelsonCode> {\n    readonly val: MichelsonCode;\n    readonly stackState: MichelsonReturnType;\n    readonly message: string;\n    /**\n     * @param val Value of a type node caused the error\n     * @param stackState Current stack state\n     * @param message An error message\n     */\n    constructor(val: MichelsonCode, stackState: MichelsonReturnType, message: string);\n}\nexport declare function assertTypeAnnotationsValid(t: MichelsonType, field?: boolean): void;\nexport interface InstructionTrace {\n    op: MichelsonCode;\n    in: MichelsonType[];\n    out: MichelsonReturnType;\n}\nexport declare function contractSection<T extends 'parameter' | 'storage' | 'code'>(contract: MichelsonContract, section: T): MichelsonContractSection<T>;\nexport declare function contractViews(contract: MichelsonContract): {\n    [name: string]: MichelsonContractView;\n};\nexport declare function contractEntryPoint(src: MichelsonContract | MichelsonType, ep?: string): MichelsonType | null;\nexport declare function contractEntryPoints(src: MichelsonContract | MichelsonType): [string, MichelsonType][];\nexport declare function assertContractValid(contract: MichelsonContract, ctx?: Context): MichelsonReturnType;\nexport declare function assertDataValid(d: MichelsonData, t: MichelsonType, ctx?: Context): void;\nexport declare function functionType(inst: MichelsonCode, stack: MichelsonType[], ctx?: Context): MichelsonReturnType;\nexport declare function assertTypesEqual<T1 extends MichelsonType | MichelsonType[], T2 extends T1>(a: T1, b: T2, field?: boolean): void;\nexport declare function isTypeAnnotationsValid(t: MichelsonType, field?: boolean): boolean;\nexport declare function isContractValid(contract: MichelsonContract, ctx?: Context): MichelsonReturnType | null;\nexport declare function isDataValid(d: MichelsonData, t: MichelsonType, ctx?: Context): boolean;\nexport declare function isTypeEqual<T1 extends MichelsonType | MichelsonType[], T2 extends T1>(a: T1, b: T2, field?: boolean): boolean;\n"},{name:"@taquito/michel-codec/dist/types/michelson-types.d.ts",dts:"import { Prim, Expr, IntLiteral, StringLiteral, BytesLiteral, List, Node } from './micheline';\ninterface Prim0<PT extends string = string> extends Prim<PT> {\n    args?: never;\n}\ninterface PrimX<PT extends string = string, AT extends Expr[] = Expr[]> extends Prim<PT, AT> {\n    args: AT;\n}\ntype MichelsonNoArgInstructionID = 'ABS' | 'ADD' | 'ADDRESS' | 'AMOUNT' | 'AND' | 'APPLY' | 'BALANCE' | 'BLAKE2B' | 'CAR' | 'CDR' | 'CHAIN_ID' | 'CHECK_SIGNATURE' | 'COMPARE' | 'CONCAT' | 'CONS' | 'EDIV' | 'EQ' | 'EXEC' | 'FAILWITH' | 'GE' | 'GET_AND_UPDATE' | 'GT' | 'HASH_KEY' | 'IMPLICIT_ACCOUNT' | 'INT' | 'ISNAT' | 'JOIN_TICKETS' | 'KECCAK' | 'LE' | 'LEVEL' | 'LSL' | 'LSR' | 'LT' | 'MEM' | 'MUL' | 'NEG' | 'NEQ' | 'NEVER' | 'NOT' | 'NOW' | 'OR' | 'PACK' | 'PAIRING_CHECK' | 'READ_TICKET' | 'SAPLING_VERIFY_UPDATE' | 'SELF' | 'SELF_ADDRESS' | 'SENDER' | 'SET_DELEGATE' | 'SHA256' | 'SHA3' | 'SHA512' | 'SIZE' | 'SLICE' | 'SOME' | 'SOURCE' | 'SPLIT_TICKET' | 'SUB' | 'SUB_MUTEZ' | 'SWAP' | 'TICKET' | 'TICKET_DEPRECATED' | 'TOTAL_VOTING_POWER' | 'TRANSFER_TOKENS' | 'UNIT' | 'VOTING_POWER' | 'XOR' | 'RENAME' | 'OPEN_CHEST' | 'MIN_BLOCK_TIME' | 'BYTES' | 'NAT' | 'IS_IMPLICIT_ACCOUNT';\ntype MichelsonRegularInstructionID = 'CONTRACT' | 'CREATE_CONTRACT' | 'DIG' | 'DIP' | 'DROP' | 'DUG' | 'DUP' | 'EMPTY_BIG_MAP' | 'EMPTY_MAP' | 'EMPTY_SET' | 'GET' | 'IF' | 'IF_CONS' | 'IF_LEFT' | 'IF_NONE' | 'ITER' | 'LAMBDA' | 'LAMBDA_REC' | 'LEFT' | 'LOOP' | 'LOOP_LEFT' | 'MAP' | 'NIL' | 'NONE' | 'PAIR' | 'PUSH' | 'RIGHT' | 'SAPLING_EMPTY_STATE' | 'UNPACK' | 'UNPAIR' | 'UPDATE' | 'CAST' | 'VIEW' | 'EMIT' | 'CREATE_ACCOUNT' | 'STEPS_TO_QUOTA';\nexport type MichelsonInstructionID = MichelsonNoArgInstructionID | MichelsonRegularInstructionID;\ntype InstrPrim<PT extends MichelsonInstructionID, AT extends Expr[]> = Prim<PT, AT>;\ntype Instr0<PT extends MichelsonNoArgInstructionID> = Prim0<PT>;\ntype InstrX<PT extends MichelsonRegularInstructionID, AT extends Expr[]> = PrimX<PT, AT>;\nexport type MichelsonCode = InstructionList | MichelsonInstruction;\nexport interface InstructionList extends List<MichelsonCode> {\n}\nexport type MichelsonNoArgInstruction = Instr0<MichelsonNoArgInstructionID>;\nexport type MichelsonInstruction = MichelsonNoArgInstruction | InstrX<'DIG' | 'DUG' | 'SAPLING_EMPTY_STATE', [IntLiteral]> | InstrX<'NONE' | 'LEFT' | 'RIGHT' | 'NIL' | 'CAST', [MichelsonType]> | InstrX<'IF_NONE' | 'IF_LEFT' | 'IF_CONS' | 'IF', [InstructionList, InstructionList]> | InstrX<'MAP' | 'ITER' | 'LOOP' | 'LOOP_LEFT' | 'DIP', [InstructionList]> | InstrX<'UNPACK', [MichelsonType]> | InstrX<'CONTRACT', [MichelsonType]> | InstrX<'CREATE_CONTRACT', [MichelsonContract]> | InstrX<'PUSH', [MichelsonType, MichelsonData]> | InstrX<'EMPTY_SET', [MichelsonType]> | InstrX<'EMPTY_MAP', [MichelsonType, MichelsonType]> | InstrX<'EMPTY_BIG_MAP', [MichelsonType, MichelsonType]> | InstrX<'LAMBDA' | 'LAMBDA_REC', [MichelsonType, MichelsonType, InstructionList]> | InstrX<'DIP', [IntLiteral, InstructionList] | [InstructionList]> | InstrX<'VIEW', [StringLiteral, MichelsonType]> | InstrX<'EMIT', [MichelsonType]> | InstrPrim<'DROP' | 'PAIR' | 'UNPAIR' | 'DUP' | 'GET' | 'UPDATE', [IntLiteral]>;\nexport type MichelsonSimpleComparableTypeID = 'string' | 'nat' | 'int' | 'bytes' | 'bool' | 'mutez' | 'key_hash' | 'address' | 'timestamp' | 'never' | 'key' | 'unit' | 'signature' | 'chain_id' | 'tx_rollup_l2_address';\nexport type MichelsonTypeID = MichelsonSimpleComparableTypeID | 'option' | 'list' | 'set' | 'contract' | 'operation' | 'pair' | 'or' | 'lambda' | 'map' | 'big_map' | 'sapling_transaction' | 'sapling_transaction_deprecated' | 'sapling_state' | 'ticket' | 'bls12_381_g1' | 'bls12_381_g2' | 'bls12_381_fr' | 'chest_key' | 'chest';\ntype Type0<PT extends MichelsonTypeID> = Prim0<PT>;\ntype TypeX<PT extends MichelsonTypeID, AT extends Expr[]> = PrimX<PT, AT>;\nexport declare const refContract: unique symbol;\nexport interface MichelsonTypeAddress extends Type0<'address'> {\n    [refContract]?: MichelsonTypeContract<MichelsonType>;\n}\nexport type MichelsonTypeInt = Type0<'int'>;\nexport type MichelsonTypeNat = Type0<'nat'>;\nexport type MichelsonTypeString = Type0<'string'>;\nexport type MichelsonTypeBytes = Type0<'bytes'>;\nexport type MichelsonTypeMutez = Type0<'mutez'>;\nexport type MichelsonTypeBool = Type0<'bool'>;\nexport type MichelsonTypeKeyHash = Type0<'key_hash'>;\nexport type MichelsonTypeTimestamp = Type0<'timestamp'>;\nexport type MichelsonTypeKey = Type0<'key'>;\nexport type MichelsonTypeUnit = Type0<'unit'>;\nexport type MichelsonTypeSignature = Type0<'signature'>;\nexport type MichelsonTypeOperation = Type0<'operation'>;\nexport type MichelsonTypeChainID = Type0<'chain_id'>;\nexport type MichelsonTypeNever = Type0<'never'>;\nexport type MichelsonTypeBLS12_381_G1 = Type0<'bls12_381_g1'>;\nexport type MichelsonTypeBLS12_381_G2 = Type0<'bls12_381_g2'>;\nexport type MichelsonTypeBLS12_381_FR = Type0<'bls12_381_fr'>;\nexport type MichelsonTypeChestKey = Type0<'chest_key'>;\nexport type MichelsonTypeChest = Type0<'chest'>;\ntype TypeList<T extends MichelsonType[]> = T & Node;\nexport type MichelsonTypePair<T extends MichelsonType[]> = TypeX<'pair', T> | TypeList<T>;\nexport interface MichelsonTypeOption<T extends MichelsonType> extends TypeX<'option', [T]> {\n}\nexport interface MichelsonTypeList<T extends MichelsonType> extends TypeX<'list', [T]> {\n}\nexport interface MichelsonTypeContract<T extends MichelsonType> extends TypeX<'contract', [T]> {\n}\nexport interface MichelsonTypeOr<T extends [MichelsonType, MichelsonType]> extends TypeX<'or', T> {\n}\nexport interface MichelsonTypeLambda<Arg extends MichelsonType, Ret extends MichelsonType> extends TypeX<'lambda', [Arg, Ret]> {\n}\nexport interface MichelsonTypeSet<T extends MichelsonType> extends TypeX<'set', [T]> {\n}\nexport interface MichelsonTypeMap<K extends MichelsonType, V extends MichelsonType> extends TypeX<'map', [K, V]> {\n}\nexport interface MichelsonTypeBigMap<K extends MichelsonType, V extends MichelsonType> extends TypeX<'big_map', [K, V]> {\n}\nexport interface MichelsonTypeSaplingState<S extends string = string> extends TypeX<'sapling_state', [IntLiteral<S>]> {\n}\nexport interface MichelsonTypeSaplingTransaction<S extends string = string> extends TypeX<'sapling_transaction', [IntLiteral<S>]> {\n}\nexport interface MichelsonTypeTicket<T extends MichelsonType> extends TypeX<'ticket', [T]> {\n}\nexport type MichelsonType<T extends MichelsonTypeID = MichelsonTypeID> = T extends 'int' ? MichelsonTypeInt : T extends 'nat' ? MichelsonTypeNat : T extends 'string' ? MichelsonTypeString : T extends 'bytes' ? MichelsonTypeBytes : T extends 'mutez' ? MichelsonTypeMutez : T extends 'bool' ? MichelsonTypeBool : T extends 'key_hash' ? MichelsonTypeKeyHash : T extends 'timestamp' ? MichelsonTypeTimestamp : T extends 'address' ? MichelsonTypeAddress : T extends 'key' ? MichelsonTypeKey : T extends 'unit' ? MichelsonTypeUnit : T extends 'signature' ? MichelsonTypeSignature : T extends 'operation' ? MichelsonTypeOperation : T extends 'chain_id' ? MichelsonTypeChainID : T extends 'option' ? MichelsonTypeOption<MichelsonType> : T extends 'list' ? MichelsonTypeList<MichelsonType> : T extends 'contract' ? MichelsonTypeContract<MichelsonType> : T extends 'ticket' ? MichelsonTypeTicket<MichelsonType> : T extends 'pair' ? MichelsonTypePair<MichelsonType[]> : T extends 'or' ? MichelsonTypeOr<[MichelsonType, MichelsonType]> : T extends 'lambda' ? MichelsonTypeLambda<MichelsonType, MichelsonType> : T extends 'set' ? MichelsonTypeSet<MichelsonType> : T extends 'map' ? MichelsonTypeMap<MichelsonType, MichelsonType> : T extends 'big_map' ? MichelsonTypeBigMap<MichelsonType, MichelsonType> : T extends 'never' ? MichelsonTypeNever : T extends 'bls12_381_g1' ? MichelsonTypeBLS12_381_G1 : T extends 'bls12_381_g2' ? MichelsonTypeBLS12_381_G2 : T extends 'bls12_381_fr' ? MichelsonTypeBLS12_381_FR : T extends 'sapling_transaction' ? MichelsonTypeSaplingTransaction : T extends 'sapling_state' ? MichelsonTypeSaplingState : T extends 'chest_key' ? MichelsonTypeChestKey : MichelsonTypeChest;\nexport type MichelsonDataID = 'Unit' | 'True' | 'False' | 'None' | 'Pair' | 'Left' | 'Right' | 'Some' | 'Lambda_rec' | 'Ticket';\ntype Data0<PT extends MichelsonDataID> = Prim0<PT>;\ntype DataX<PT extends MichelsonDataID, AT extends MichelsonData[]> = PrimX<PT, AT>;\nexport type MichelsonDataOption = DataX<'Some', [MichelsonData]> | Data0<'None'>;\nexport type MichelsonDataOr = DataX<'Left' | 'Right', [MichelsonData]>;\ntype DataList<T extends MichelsonData[]> = T & Node;\nexport type MichelsonDataPair<T extends MichelsonData[]> = DataX<'Pair', T> | DataList<T>;\nexport type MichelsonMapElt = PrimX<'Elt', [MichelsonData, MichelsonData]>;\nexport type MichelsonMapEltList = List<MichelsonMapElt>;\nexport type MichelsonLambdaRec = DataX<'Lambda_rec', [InstructionList]>;\nexport type MichelsonTicket = PrimX<'Ticket', [\n    StringLiteral | BytesLiteral,\n    MichelsonType,\n    MichelsonData,\n    IntLiteral\n]>;\nexport type MichelsonData = IntLiteral | StringLiteral | BytesLiteral | Data0<'Unit' | 'True' | 'False'> | MichelsonDataOption | MichelsonDataOr | DataList<MichelsonData[]> | MichelsonDataPair<MichelsonData[]> | InstructionList | MichelsonMapEltList | MichelsonLambdaRec | MichelsonTicket;\nexport type MichelsonSectionID = 'parameter' | 'storage' | 'code' | 'view';\ntype SectionPrim<PT extends MichelsonSectionID, AT extends Expr[]> = PrimX<PT, AT>;\nexport type MichelsonContractParameter = SectionPrim<'parameter', [MichelsonType]>;\nexport type MichelsonContractStorage = SectionPrim<'storage', [MichelsonType]>;\nexport type MichelsonContractCode = SectionPrim<'code', [InstructionList]>;\nexport type MichelsonContractView = SectionPrim<'view', [\n    StringLiteral,\n    MichelsonType,\n    MichelsonType,\n    InstructionList\n]>;\nexport type MichelsonContract = MichelsonContractSection[];\nexport type MichelsonContractSection<T extends MichelsonSectionID = MichelsonSectionID> = T extends 'parameter' ? MichelsonContractParameter : T extends 'storage' ? MichelsonContractStorage : T extends 'view' ? MichelsonContractView : MichelsonContractCode;\nexport interface MichelsonTypeFailed {\n    failed: MichelsonType;\n    level: number;\n}\nexport type MichelsonReturnType = MichelsonType[] | MichelsonTypeFailed;\nexport declare enum Protocol {\n    Ps9mPmXa = \"Ps9mPmXaRzmzk35gbAYNCAw6UXdE2qoABTHbN2oEEc1qM7CwT9P\",\n    PtCJ7pwo = \"PtCJ7pwoxe8JasnHY8YonnLYjcVHmhiARPJvqcC6VfHT5s8k8sY\",\n    PsYLVpVv = \"PsYLVpVvgbLhAhoqAkMFUo6gudkJ9weNXhUYCiLDzcUpFpkk8Wt\",\n    PsddFKi3 = \"PsddFKi32cMJ2qPjf43Qv5GDWLDPZb3T3bF6fLKiF5HtvHNU7aP\",\n    Pt24m4xi = \"Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd\",\n    PsBABY5H = \"PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU\",\n    PsBabyM1 = \"PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS\",\n    PsCARTHA = \"PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb\",\n    PsDELPH1 = \"PsDELPH1Kxsxt8f9eWbxQeRxkjfbxoqM52jvs5Y5fBxWWh4ifpo\",\n    PtEdoTez = \"PtEdoTezd3RHSC31mpxxo1npxFjoWWcFgQtxapi51Z8TLu6v6Uq\",\n    PtEdo2Zk = \"PtEdo2ZkT9oKpimTah6x2embF25oss54njMuPzkJTEi5RqfdZFA\",\n    PsFLorena = \"PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i\",\n    PtGRANADs = \"PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV\",\n    PtHangzH = \"PtHangzHogokSuiMHemCuowEavgYTP8J5qQ9fQS793MHYFpCY3r\",\n    PtHangz2 = \"PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx\",\n    PsiThaCa = \"PsiThaCaT47Zboaw71QWScM8sXeMM7bbQFncK9FLqYc6EKdpjVP\",\n    Psithaca2 = \"Psithaca2MLRFYargivpo7YvUr7wUDqyxrdhC5CQq78mRvimz6A\",\n    PtJakarta = \"PtJakartaiDz69SfDDLXJSiuZqTSeSKRDbKVZC8MNzJnvRjvnGw\",\n    PtJakart2 = \"PtJakart2xVj7pYXJBXrqHgd82rdkLey5ZeeGwDgPp9rhQUbSqY\",\n    PtKathman = \"PtKathmankSpLLDALzWw7CGD2j2MtyveTwboEYokqUCP4a1LxMg\",\n    PtLimaPtL = \"PtLimaPtLMwfNinJi9rCfDPWea8dFgTZ1MeJ9f1m2SRic6ayiwW\",\n    PtMumbaii = \"PtMumbaiiFFEGbew1rRjzSPyzRbA51Tm3RVZL5suHPxSZYDhCEc\",\n    PtMumbai2 = \"PtMumbai2TmsJHNGRkD8v8YDbtao7BLUC3wjASn1inAKLFCjaH1\",\n    PtNairobi = \"PtNairobiyssHuh87hEhfVBGCVrK3WnS8Z2FT4ymB5tAa4r1nQf\",\n    ProxfordY = \"ProxfordYmVfjWnRcgjWH36fW6PArwqykTFzotUxRs6gmTcZDuH\",\n    PtParisBx = \"PtParisBxoLz5gzMmn3d9WBQNoPSZakgnkMC2VNuQ3KXfUtUQeZ\",\n    PsParisCZ = \"PsParisCZo7KAh1Z1smVd9ZMZ1HHn5gkzbM94V3PLCpknFWhUAi\",\n    PsQuebecn = \"PsQuebecnLByd3JwTiGadoG4nGWi3HYiLXUjkibeFV8dCFeVMUg\",\n    PsRiotuma = \"PsRiotumaAMotcRoDWW1bysEhQy2n1M5fy8JgRp8jjRfHGmfeA7\",\n    PtSeouLou = \"PtSeouLouXkxhg39oWzjxDWaCydNfR3RxCUrNe4Q9Ro8BTehcbh\",\n    ProtoALpha = \"ProtoALphaALphaALphaALphaALphaALphaALphaALphaDdp3zK\"\n}\nexport declare const DefaultProtocol = Protocol.PtSeouLou;\nexport type ProtocolID = `${Protocol}`;\nexport declare function ProtoGreaterOrEqual(a: ProtocolID, b: ProtocolID): boolean;\nexport declare function ProtoInferiorTo(a: ProtocolID, b: ProtocolID): boolean;\nexport interface ProtocolOptions {\n    protocol?: ProtocolID;\n}\nexport {};\n"},{name:"@taquito/michel-codec/dist/types/michelson-validator.d.ts",dts:"import { Prim, Expr, StringLiteral } from './micheline';\nimport { MichelsonError } from './utils';\nimport { MichelsonCode, MichelsonType, MichelsonData, MichelsonContract, MichelsonInstruction, InstructionList } from './michelson-types';\nexport declare const instructionIDs: Record<MichelsonInstruction['prim'], true>;\nexport declare class MichelsonValidationError extends MichelsonError {\n    readonly val: Expr;\n    readonly message: string;\n    /**\n     * @param val Value of a node caused the error\n     * @param message An error message\n     */\n    constructor(val: Expr, message: string);\n}\n/**\n * Checks if the node is a valid Michelson code (sequence of instructions).\n * This is a type guard function which either returns true of throws an exception.\n * @param ex An AST node\n */\nexport declare function assertMichelsonInstruction(ex: Expr): ex is MichelsonCode;\nexport declare function assertMichelsonComparableType(ex: Expr): ex is MichelsonType;\nexport declare function assertMichelsonPackableType(ex: Expr): ex is MichelsonType;\nexport declare function assertMichelsonPushableType(ex: Expr): ex is MichelsonType;\nexport declare function assertMichelsonStorableType(ex: Expr): ex is MichelsonType;\nexport declare function assertMichelsonPassableType(ex: Expr): ex is MichelsonType;\nexport declare function assertMichelsonBigMapStorableType(ex: Expr): ex is MichelsonType;\nexport declare function assertViewNameValid(name: StringLiteral): void;\n/**\n * Checks if the node is a valid Michelson type expression.\n * This is a type guard function which either returns true of throws an exception.\n * @param ex An AST node\n */\nexport declare function assertMichelsonType(ex: Expr): ex is MichelsonType;\n/**\n * Checks if the node is a valid Michelson data literal such as `(Pair {Elt \"0\" 0} 0)`.\n * This is a type guard function which either returns true of throws an exception.\n * @param ex An AST node\n */\nexport declare function assertMichelsonData(ex: Expr): ex is MichelsonData;\n/**\n * Checks if the node is a valid Michelson smart contract source containing all required and valid properties such as `parameter`, `storage` and `code`.\n * This is a type guard function which either returns true of throws an exception.\n * @param ex An AST node\n */\nexport declare function assertMichelsonContract(ex: Expr): ex is MichelsonContract;\n/**\n * Checks if the node is a valid Michelson smart contract source containing all required and valid properties such as `parameter`, `storage` and `code`.\n * @param ex An AST node\n */\nexport declare function isMichelsonScript(ex: Expr): ex is MichelsonContract;\n/**\n * Checks if the node is a valid Michelson data literal such as `(Pair {Elt \"0\" 0} 0)`.\n * @param ex An AST node\n */\nexport declare function isMichelsonData(ex: Expr): ex is MichelsonData;\n/**\n * Checks if the node is a valid Michelson code (sequence of instructions).\n * @param ex An AST node\n */\nexport declare function isMichelsonCode(ex: Expr): ex is InstructionList;\n/**\n * Checks if the node is a valid Michelson type expression.\n * @param ex An AST node\n */\nexport declare function isMichelsonType(ex: Expr): ex is MichelsonType;\nexport declare function isInstruction(p: Prim): p is MichelsonInstruction;\nexport declare function assertDataListIfAny(d: MichelsonData): d is MichelsonData[];\n"},{name:"@taquito/michel-codec/dist/types/scan.d.ts",dts:"import { TaquitoError } from '@taquito/core';\n/**\n *  @category Error\n *  @description Error that indicates a failure when performing the scan step when parsing Michelson\n */\nexport declare class ScanError extends TaquitoError {\n    readonly src: string;\n    readonly idx: number;\n    readonly message: string;\n    constructor(src: string, idx: number, message: string);\n}\nexport declare enum Literal {\n    Comment = 0,\n    Number = 1,\n    String = 2,\n    Bytes = 3,\n    Ident = 4\n}\nexport type TokenType = '(' | ')' | '{' | '}' | ';' | Literal;\nexport interface Token {\n    t: TokenType;\n    v: string;\n    first: number;\n    last: number;\n}\nexport declare function scan(src: string, scanComments?: boolean): Generator<Token, void>;\n"},{name:"@taquito/michel-codec/dist/types/taquito-michel-codec.d.ts",dts:"/**\n * @packageDocumentation\n * @module @taquito/michel-codec\n */\nexport * from './micheline';\nexport * from './micheline-parser';\nexport * from './micheline-emitter';\nexport * from './michelson-validator';\nexport * from './michelson-types';\nexport * from './michelson-typecheck';\nexport * from './michelson-contract';\nexport * from './formatters';\nexport * from './binary';\nexport { MichelsonError, isMichelsonError, MichelsonTypeError } from './utils';\nexport { MacroError } from './macros';\nexport { VERSION } from './version';\n"},{name:"@taquito/michel-codec/dist/types/utils.d.ts",dts:"import { Prim, Expr, StringLiteral, IntLiteral } from './micheline';\nimport { MichelsonData, MichelsonDataPair, MichelsonType, MichelsonTypePair } from './michelson-types';\nimport { TaquitoError } from '@taquito/core';\nexport type Tuple<N extends number, T> = N extends 1 ? [T] : N extends 2 ? [T, T] : N extends 3 ? [T, T, T] : N extends 4 ? [T, T, T, T] : N extends 5 ? [T, T, T, T, T] : N extends 6 ? [T, T, T, T, T, T] : N extends 7 ? [T, T, T, T, T, T, T] : N extends 8 ? [T, T, T, T, T, T, T, T] : T[];\ntype RequiredProp<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>;\ntype OmitProp<T, K extends keyof T> = Omit<T, K> & {\n    [P in K]?: undefined;\n};\nexport type ReqArgs<T extends Prim> = RequiredProp<T, 'args'>;\nexport type NoArgs<T extends Prim> = OmitProp<T, 'args'>;\nexport type NoAnnots<T extends Prim> = OmitProp<T, 'annots'>;\nexport type Nullable<T> = {\n    [P in keyof T]: T[P] | null;\n};\n/**\n *  @category Error\n *  @description Error that indicates a Michelson failure occurring\n */\nexport declare class MichelsonError<T extends Expr = Expr> extends TaquitoError {\n    readonly val: T;\n    readonly message: string;\n    /**\n     * @param val Value of a AST node caused the error\n     * @param path Path to a node caused the error\n     * @param message An error message\n     */\n    constructor(val: T, message: string);\n}\nexport declare function isMichelsonError<T extends Expr = Expr>(err: unknown): err is MichelsonError<T>;\nexport declare class MichelsonTypeError extends MichelsonError<MichelsonType | MichelsonType[]> {\n    readonly val: MichelsonType | MichelsonType[];\n    readonly message: string;\n    data?: Expr;\n    /**\n     * @param val Value of a type node caused the error\n     * @param data Value of a data node caused the error\n     * @param message An error message\n     */\n    constructor(val: MichelsonType | MichelsonType[], message: string, data?: Expr);\n}\nexport declare class LongInteger {\n    private neg;\n    private buf;\n    private append;\n    constructor(arg?: string | number);\n    cmp(arg: LongInteger): number;\n    get sign(): number;\n}\nexport declare function parseBytes(s: string): number[] | null;\nexport declare function compareBytes(a: number[] | Uint8Array, b: number[] | Uint8Array): number;\nexport declare function isDecimal(x: string): boolean;\nexport declare function isNatural(x: string): boolean;\nexport interface UnpackedAnnotations {\n    f?: string[];\n    t?: string[];\n    v?: string[];\n}\nexport interface UnpackAnnotationsOptions {\n    specialVar?: boolean;\n    emptyVar?: boolean;\n    specialFields?: boolean;\n    emptyFields?: boolean;\n}\nexport declare function unpackAnnotations(p: Prim | Expr[], opt?: UnpackAnnotationsOptions): UnpackedAnnotations;\nexport type TezosIDType = 'BlockHash' | 'OperationHash' | 'OperationListHash' | 'OperationListListHash' | 'ProtocolHash' | 'ContextHash' | 'ED25519PublicKeyHash' | 'SECP256K1PublicKeyHash' | 'P256PublicKeyHash' | 'ContractHash' | 'CryptoboxPublicKeyHash' | 'ED25519Seed' | 'ED25519PublicKey' | 'SECP256K1SecretKey' | 'P256SecretKey' | 'ED25519EncryptedSeed' | 'SECP256K1EncryptedSecretKey' | 'P256EncryptedSecretKey' | 'SECP256K1PublicKey' | 'P256PublicKey' | 'SECP256K1Scalar' | 'SECP256K1Element' | 'ED25519SecretKey' | 'ED25519Signature' | 'SECP256K1Signature' | 'P256Signature' | 'GenericSignature' | 'ChainID' | 'RollupAddress';\nexport type TezosIDPrefix = [number, number[]];\nexport declare const tezosPrefix: Record<TezosIDType, TezosIDPrefix>;\nexport declare function checkDecodeTezosID<T extends TezosIDType[]>(id: string, ...types: T): [T[number], number[]] | null;\nexport declare function encodeTezosID(id: TezosIDType, data: number[] | Uint8Array): string;\ntype PairTypeOrDataPrim<I extends 'pair' | 'Pair'> = I extends 'pair' ? Extract<MichelsonTypePair<MichelsonType[]>, Prim> : Extract<MichelsonDataPair<MichelsonData[]>, Prim>;\nexport declare function unpackComb<I extends 'pair' | 'Pair'>(id: I, v: I extends 'pair' ? MichelsonTypePair<MichelsonType[]> : MichelsonDataPair<MichelsonData[]>): PairTypeOrDataPrim<I>;\nexport declare function isPairType(t: MichelsonType): t is MichelsonTypePair<MichelsonType[]>;\nexport declare function isPairData(d: Expr): d is MichelsonDataPair<MichelsonData[]>;\nexport declare function parseDate(a: StringLiteral | IntLiteral): Date | null;\nexport declare function parseHex(s: string): number[];\nexport declare function hexBytes(bytes: number[]): string;\nexport {};\n"},{name:"@taquito/michel-codec/dist/types/version.d.ts",dts:"export declare const VERSION: {\n    commitHash: string;\n    version: string;\n};\n"},{name:"@taquito/michelson-encoder/dist/types/schema/errors.d.ts",dts:"import { InvalidViewParameterError, TaquitoError } from '@taquito/core';\n/**\n *  @category Error\n *  @description Error that indicates a failure when encoding (transforming JS parameter into JSON Michelson) the parameter of the view\n */\nexport declare class ParameterEncodingError extends InvalidViewParameterError {\n    readonly viewName: string;\n    readonly sigs: any;\n    readonly args: any;\n    readonly cause?: any;\n    constructor(viewName: string, sigs: any, args: any, cause?: any);\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid on-chain view found on the script\n */\nexport declare class InvalidScriptError extends TaquitoError {\n    readonly script: any;\n    readonly reason?: string | undefined;\n    name: string;\n    constructor(script: any, reason?: string | undefined);\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid RPC response being passed or used\n */\nexport declare class InvalidRpcResponseError extends TaquitoError {\n    readonly script: any;\n    readonly reason?: string | undefined;\n    name: string;\n    constructor(script: any, reason?: string | undefined);\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid big map schema being passed or used\n */\nexport declare class InvalidBigMapSchemaError extends TaquitoError {\n    message: string;\n    name: string;\n    constructor(message: string);\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid big map diff being passed or used\n */\nexport declare class InvalidBigMapDiffError extends TaquitoError {\n    message: string;\n    readonly value: any;\n    name: string;\n    constructor(message: string, value: any);\n}\n/**\n *  @category Error\n *  @description Error that indicates a failure when trying to encode big maps\n */\nexport declare class BigMapEncodingError extends TaquitoError {\n    readonly details: any;\n    readonly schema: any;\n    readonly value: any;\n    name: string;\n    constructor(obj: 'key' | 'value', details: any, schema: any, value: any);\n}\n/**\n *  @category Error\n *  @description Error that indicates a failure when trying to encode storage\n */\nexport declare class StorageEncodingError extends TaquitoError {\n    details: any;\n    readonly schema: any;\n    readonly value: any;\n    readonly semantics?: any;\n    name: string;\n    constructor(obj: string, details: any, schema: any, value: any, semantics?: any);\n}\n/**\n *  @category Error\n *  @description General error that indicates a function not being passed a necessary argument\n */\nexport declare class MissingArgumentError extends TaquitoError {\n    message: string;\n    name: string;\n    constructor(message: string);\n}\n"},{name:"@taquito/michelson-encoder/dist/types/schema/event-schema.d.ts",dts:"import { MichelsonV1Expression, MichelsonV1ExpressionExtended, ScriptResponse } from '@taquito/rpc';\nexport declare class EventSchema {\n    readonly tag?: string | undefined;\n    readonly type?: MichelsonV1ExpressionExtended | undefined;\n    constructor(tag?: string | undefined, type?: MichelsonV1ExpressionExtended | undefined);\n    static fromMichelineValue(val: MichelsonV1ExpressionExtended): EventSchema;\n    static fromRPCResponse(val: {\n        script: ScriptResponse;\n    }): EventSchema[];\n    static removeDuplicates(events: EventSchema[]): EventSchema[];\n    static extractEventsRecursively(code: MichelsonV1Expression): EventSchema[];\n}\n"},{name:"@taquito/michelson-encoder/dist/types/schema/model.d.ts",dts:"export interface RpcTransaction {\n    protocol: string;\n    chain_id: string;\n    hash: string;\n    branch: string;\n    contents: Content[];\n    signature: string;\n}\ninterface Content {\n    kind: string;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    amount: string;\n    destination: string;\n    parameters: Params;\n    metadata: Metadata;\n}\ninterface Metadata {\n    balance_updates: Balanceupdate[];\n    operation_result: Operationresult;\n}\ninterface Operationresult {\n    status: string;\n    storage: Storage;\n    big_map_diff: Bigmapdiff[];\n    consumed_gas?: string;\n    storage_size: string;\n    paid_storage_size_diff: string;\n    consumed_milligas?: string;\n}\ninterface Bigmapdiff {\n    key_hash: string;\n    key: Key;\n    value: Value;\n}\ninterface Value {\n    prim: string;\n    args: any[];\n}\ninterface Key {\n    bytes: string;\n}\ninterface Storage {\n    prim: string;\n    args: any[];\n}\ninterface Balanceupdate {\n    kind: string;\n    contract?: string;\n    change: string;\n    category?: string;\n    delegate?: string;\n    level?: number;\n}\ninterface Params {\n    prim: string;\n    args: any[];\n}\nexport {};\n"},{name:"@taquito/michelson-encoder/dist/types/schema/parameter.d.ts",dts:"import { Semantic, SemanticEncoding } from '../tokens/token';\nimport { ScriptResponse, MichelsonV1Expression } from '@taquito/rpc';\nimport { TokenSchema } from './types';\n/**\n * @warn Our current smart contract abstraction feature is currently in preview. It's API is not final, and it may not cover every use case (yet). We will greatly appreciate any feedback on this feature.\n */\nexport declare class ParameterSchema {\n    private root;\n    /**\n     *\n     * @description Create an instance of ParameterSchema from a contract script\n     *\n     * @param val contract script obtained from the RPC\n     * @returns ParameterSchema\n     * @throws {InvalidRpcResponseError} If the RPC response is invalid\n     */\n    static fromRPCResponse(val: {\n        script: ScriptResponse;\n    }): ParameterSchema;\n    /**\n     * @description Check if the Contract parameter is multiple entry point or not\n     */\n    get isMultipleEntryPoint(): boolean;\n    /**\n     * @description Check if the Contract parameter has an annotation or not\n     */\n    get hasAnnotation(): boolean;\n    /**\n     * @description Return the schema of the parameter of a specific entry point\n     * @throws {@link InvalidTokenError}\n     */\n    constructor(val: MichelsonV1Expression);\n    /**\n     * @description Returns the javascript object equivalent of the Micheline value provided\n     */\n    Execute(val: any, semantics?: Semantic): any;\n    /**\n     * @description Returns a micheline formatted object for the values provided\n     * @throws {@link TokenValidationError}\n     * @throws {@link ParameterEncodingError}\n     */\n    Encode(...args: any[]): any;\n    /**\n     * @description Returns a micheline formatted object for the javascript object provided\n     * @throws {@link TokenValidationError}\n     * @throws {@link ParameterEncodingError}\n     */\n    EncodeObject(value?: any, semantics?: SemanticEncoding): any;\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */\n    ExtractSchema(): any;\n    /**\n     * @description Produce a schema grouping together all the entry points of a contract.\n     */\n    generateSchema(): TokenSchema;\n    ExtractSignatures(): any[][];\n}\n"},{name:"@taquito/michelson-encoder/dist/types/schema/storage.d.ts",dts:"import { MichelsonV1Expression, ScriptResponse } from '@taquito/rpc';\nimport { BigMapKeyType, Semantic, SemanticEncoding, Token } from '../tokens/token';\nimport { RpcTransaction } from './model';\nimport { TokenSchema } from './types';\ndeclare const schemaTypeSymbol: unique symbol;\nexport declare function deepEqual(a: MichelsonV1Expression | undefined, b: MichelsonV1Expression | undefined): boolean;\n/**\n * @warn Our current smart contract abstraction feature is currently in preview. Its API is not final, and it may not cover every use case (yet). We will greatly appreciate any feedback on this feature.\n */\nexport declare class Schema {\n    readonly val: MichelsonV1Expression;\n    private root;\n    [schemaTypeSymbol]: boolean;\n    static isSchema(obj: Schema): boolean;\n    private bigMap?;\n    /**\n     * @throws {@link InvalidRpcResponseError}\n     */\n    static fromRPCResponse(val: {\n        script: ScriptResponse;\n    }): Schema;\n    private isExpressionExtended;\n    constructor(val: MichelsonV1Expression);\n    private removeTopLevelAnnotation;\n    Execute(val: any, semantics?: Semantic): any;\n    Typecheck(val: any): void;\n    /**\n     * @throws {@link InvalidBigMapSchemaError}\n     * @throws {@link InvalidBigMapDiffError}\n     */\n    ExecuteOnBigMapDiff(diff: any[], semantics?: Semantic): any;\n    /**\n     * @throws {@link InvalidBigMapSchemaError}\n     */\n    ExecuteOnBigMapValue(key: any, semantics?: Semantic): any;\n    /**\n     * @throws {@link InvalidBigMapSchemaError}\n     * @throws {@link BigMapEncodingError}\n     */\n    EncodeBigMapKey(key: BigMapKeyType): {\n        key: {\n            [key: string]: string | object[];\n        };\n        type: {\n            prim: string;\n            args?: object[];\n        };\n    };\n    /**\n     * @throws {@link TokenValidationError}\n     * @throws {@link StorageEncodingError}\n     */\n    Encode(value?: any, semantics?: SemanticEncoding): any;\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */\n    ExtractSchema(): any;\n    /**\n     * @description Produce a representation of the storage schema.\n     * Note: Provide guidance on how to write the storage object for the origination operation with Taquito.\n     */\n    generateSchema(): TokenSchema;\n    /**\n     * @deprecated\n     * @throws {@link InvalidBigMapSchemaError}\n     */\n    ComputeState(tx: RpcTransaction[], state: any): any;\n    /**\n     * @description Look up in top-level pairs of the storage to find a value matching the specified type\n     *\n     * @returns The first value found that match the type or `undefined` if no value is found\n     *\n     * @param storage storage to parse to find the value\n     * @param valueType type of value to look for\n     *\n     */\n    FindFirstInTopLevelPair<T extends MichelsonV1Expression>(storage: any, valueType: any): T | undefined;\n    /**\n     * @throws {@link MissingArgumentError}\n     */\n    private findValue;\n    /**\n     * @description Look up the schema to find any occurrence of a particular token.\n     *\n     * @returns an array of tokens of the specified kind or an empty array if no token was found\n     *\n     * @param tokenToFind string representing the prim property of the token to find\n     *\n     * @example\n     * ```\n     * Useful to find all global constants in a script, an array of GlobalConstantToken is returned:\n     *\n     * const schema = new Schema(script);\n     * const allGlobalConstantTokens = schema.findToken('constant');\n     * ```\n     *\n     */\n    findToken(tokenToFind: string): Array<Token>;\n}\nexport {};\n"},{name:"@taquito/michelson-encoder/dist/types/schema/types.d.ts",dts:"export type Falsy<T> = T | undefined | false;\nexport type BaseTokenSchema = {\n    __michelsonType: 'address' | 'bool' | 'bytes' | 'int' | 'key' | 'key_hash' | 'mutez' | 'nat' | 'string' | 'timestamp' | 'bls12_381_fr' | 'bls12_381_g1' | 'bls12_381_g2' | 'chain_id' | 'never' | 'operation' | 'chest' | 'chest_key' | 'signature' | 'unit';\n    schema: string;\n};\nexport type OrTokenSchema = {\n    __michelsonType: 'or';\n    schema: Record<string, TokenSchema>;\n};\nexport type PairTokenSchema = {\n    __michelsonType: 'pair';\n    schema: Record<string, TokenSchema>;\n};\nexport type ListTokenSchema = {\n    __michelsonType: 'list';\n    schema: TokenSchema;\n};\nexport type SetTokenSchema = {\n    __michelsonType: 'set';\n    schema: TokenSchema;\n};\nexport type OptionTokenSchema = {\n    __michelsonType: 'option';\n    schema: TokenSchema;\n};\nexport type MapTokenSchema = {\n    __michelsonType: 'map';\n    schema: {\n        key: TokenSchema;\n        value: TokenSchema;\n    };\n};\nexport type BigMapTokenSchema = {\n    __michelsonType: 'big_map';\n    schema: {\n        key: TokenSchema;\n        value: TokenSchema;\n    };\n};\nexport type ConstantTokenSchema = {\n    __michelsonType: 'constant';\n    schema: {\n        hash: string;\n    };\n};\nexport type ContractTokenSchema = {\n    __michelsonType: 'contract';\n    schema: {\n        parameter: TokenSchema;\n    };\n};\nexport type LambdaTokenSchema = {\n    __michelsonType: 'lambda';\n    schema: {\n        parameters: TokenSchema;\n        returns: TokenSchema;\n    };\n};\nexport type SaplingStateTokenSchema = {\n    __michelsonType: 'sapling_state';\n    schema: {\n        memoSize: string;\n    };\n};\nexport type SaplingTransactionTokenSchema = {\n    __michelsonType: 'sapling_transaction';\n    schema: {\n        memoSize: string;\n    };\n};\nexport type SaplingTransactionDeprecatedTokenSchema = {\n    __michelsonType: 'sapling_transaction_deprecated';\n    schema: {\n        memoSize: string;\n    };\n};\nexport type TicketTokenSchema = {\n    __michelsonType: 'ticket';\n    schema: {\n        value: TokenSchema;\n        ticketer: {\n            __michelsonType: 'contract';\n            schema: 'contract';\n        };\n        amount: {\n            __michelsonType: 'int';\n            schema: 'int';\n        };\n    };\n};\nexport type TicketDeprecatedTokenSchema = {\n    __michelsonType: 'ticket_deprecated';\n    schema: {\n        value: TokenSchema;\n        ticketer: {\n            __michelsonType: 'contract';\n            schema: 'contract';\n        };\n        amount: {\n            __michelsonType: 'int';\n            schema: 'int';\n        };\n    };\n};\nexport type TokenSchema = BaseTokenSchema | OrTokenSchema | PairTokenSchema | ListTokenSchema | SetTokenSchema | OptionTokenSchema | MapTokenSchema | BigMapTokenSchema | ConstantTokenSchema | ContractTokenSchema | LambdaTokenSchema | SaplingStateTokenSchema | SaplingTransactionTokenSchema | SaplingTransactionDeprecatedTokenSchema | TicketTokenSchema | TicketDeprecatedTokenSchema;\n"},{name:"@taquito/michelson-encoder/dist/types/schema/view-schema.d.ts",dts:"import { MichelsonV1Expression, MichelsonV1ExpressionExtended, ScriptResponse } from '@taquito/rpc';\nimport { Semantic } from '../tokens/token';\nexport declare class ViewSchema {\n    readonly viewName: string;\n    readonly viewArgsType: MichelsonV1ExpressionExtended;\n    readonly viewReturnType: MichelsonV1ExpressionExtended;\n    readonly instructions: MichelsonV1ExpressionExtended[];\n    private rootArgsType;\n    private rootReturnType;\n    /**\n     *\n     * @description Create an instance of ViewSchema for each view in a script\n     *\n     * @param val contract script obtained from the RPC\n     * @returns array of ViewSchema or empty array if there is no view in the contract\n     * @throws {@link InvalidScriptError}\n     */\n    static fromRPCResponse(val: {\n        script: ScriptResponse;\n    }): ViewSchema[];\n    /**\n     * @throws {@link InvalidScriptError}\n     */\n    constructor(viewArgs: MichelsonV1Expression[] | undefined);\n    /**\n     *\n     * @description Transform the view parameter into Michelson\n     *\n     * @param args parameter of the view in js format\n     * @returns parameter of the view in Michelson\n     * @throws {@link ParameterEncodingError}\n     */\n    encodeViewArgs(args: any): any;\n    /**\n     *\n     * @description Transform the view result from Michelson to readable data\n     *\n     * @param val result of the view in JSON Michelson\n     * @param semantics optional semantics to override the default decoding behavior\n     * @returns result of the view in a readable format\n     */\n    decodeViewResult(val: any, semantics?: Semantic): any;\n    /**\n     *\n     * @description Return the signature of the view parameter\n     */\n    extractArgsSchema(): any;\n    /**\n     *\n     * @description Return the format of the view result\n     */\n    extractResultSchema(): any;\n}\n"},{name:"@taquito/michelson-encoder/dist/types/tokens/comparable/address.d.ts",dts:"import { Token, TokenFactory, ComparableToken, TokenValidationError, SemanticEncoding } from '../token';\nimport { BaseTokenSchema } from '../../schema/types';\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing an Address\n */\nexport declare class AddressValidationError extends TokenValidationError {\n    value: any;\n    token: AddressToken;\n    name: string;\n    constructor(value: any, token: AddressToken, message: string);\n}\nexport declare class AddressToken extends ComparableToken {\n    protected val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    };\n    protected idx: number;\n    protected fac: TokenFactory;\n    static prim: 'address';\n    constructor(val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    }, idx: number, fac: TokenFactory);\n    ToBigMapKey(val: any): {\n        key: {\n            bytes: string;\n        };\n        type: {\n            prim: string;\n        };\n    };\n    /**\n     * @throws {@link AddressValidationError}\n     */\n    private validate;\n    /**\n     * @throws {@link AddressValidationError}\n     */\n    Encode(args: any[]): any;\n    /**\n     * @throws {@link AddressValidationError}\n     */\n    EncodeObject(val: any, semantic?: SemanticEncoding): any;\n    /**\n     * @throws {@link AddressValidationError}\n     */\n    Execute(val: {\n        bytes: string;\n        string: string;\n    }): string;\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */\n    ExtractSchema(): \"address\";\n    generateSchema(): BaseTokenSchema;\n    /**\n     * @throws {@link AddressValidationError}\n     */\n    ToKey({ bytes, string }: any): any;\n    compare(address1: string, address2: string): number;\n    findAndReturnTokens(tokenToFind: string, tokens: Token[]): Token[];\n}\n"},{name:"@taquito/michelson-encoder/dist/types/tokens/comparable/bool.d.ts",dts:"import { BaseTokenSchema } from '../../schema/types';\nimport { Token, TokenFactory, ComparableToken, SemanticEncoding } from '../token';\nexport declare class BoolToken extends ComparableToken {\n    protected val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    };\n    protected idx: number;\n    protected fac: TokenFactory;\n    static prim: 'bool';\n    constructor(val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    }, idx: number, fac: TokenFactory);\n    Execute(val: any): boolean;\n    Encode(args: any[]): any;\n    EncodeObject(val: any, semantic?: SemanticEncoding): import(\"@taquito/rpc\").MichelsonV1Expression;\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */\n    ExtractSchema(): \"bool\";\n    generateSchema(): BaseTokenSchema;\n    ToBigMapKey(val: string): {\n        key: {\n            [key: string]: string;\n        };\n        type: {\n            prim: string;\n        };\n    };\n    ToKey(val: string): import(\"@taquito/rpc\").MichelsonV1Expression;\n    compare(val1: any, val2: any): 0 | 1 | -1;\n    findAndReturnTokens(tokenToFind: string, tokens: Token[]): Token[];\n}\n"},{name:"@taquito/michelson-encoder/dist/types/tokens/comparable/bytes.d.ts",dts:"import { BaseTokenSchema } from '../../schema/types';\nimport { TokenFactory, ComparableToken, TokenValidationError, Token, SemanticEncoding } from '../token';\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing Bytes\n */\nexport declare class BytesValidationError extends TokenValidationError {\n    value: any;\n    token: BytesToken;\n    name: string;\n    constructor(value: any, token: BytesToken, message: string);\n}\nexport declare class BytesToken extends ComparableToken {\n    protected val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    };\n    protected idx: number;\n    protected fac: TokenFactory;\n    static prim: 'bytes';\n    constructor(val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    }, idx: number, fac: TokenFactory);\n    ToBigMapKey(val: string): {\n        key: {\n            bytes: string;\n        };\n        type: {\n            prim: \"bytes\";\n        };\n    };\n    /**\n     * @throws {@link BytesValidationError}\n     */\n    private validate;\n    private convertUint8ArrayToHexString;\n    /**\n     * @throws {@link BytesValidationError}\n     */\n    Encode(args: any[]): any;\n    /**\n     * @throws {@link BytesValidationError}\n     */\n    EncodeObject(val: string | Uint8Array, semantic?: SemanticEncoding): import(\"@taquito/rpc\").MichelsonV1Expression;\n    Execute(val: any): string;\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */\n    ExtractSchema(): \"bytes\";\n    generateSchema(): BaseTokenSchema;\n    ToKey({ bytes, string }: any): any;\n    findAndReturnTokens(tokenToFind: string, tokens: Token[]): Token[];\n}\n"},{name:"@taquito/michelson-encoder/dist/types/tokens/comparable/int.d.ts",dts:"import { Token, TokenFactory, ComparableToken, TokenValidationError, SemanticEncoding } from '../token';\nimport { BaseTokenSchema } from '../../schema/types';\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing Int\n */\nexport declare class IntValidationError extends TokenValidationError {\n    value: any;\n    token: IntToken;\n    name: string;\n    constructor(value: any, token: IntToken, message: string);\n}\nexport declare class IntToken extends ComparableToken {\n    protected val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    };\n    protected idx: number;\n    protected fac: TokenFactory;\n    static prim: 'int';\n    constructor(val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    }, idx: number, fac: TokenFactory);\n    Execute(val: {\n        [key: string]: string;\n    }): {\n        [key: string]: any;\n    };\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */\n    ExtractSchema(): \"int\";\n    generateSchema(): BaseTokenSchema;\n    /**\n     * @throws {@link IntValidationError}\n     */\n    private validate;\n    /**\n     * @throws {@link IntValidationError}\n     */\n    Encode(args: any[]): any;\n    /**\n     * @throws {@link IntValidationError}\n     */\n    EncodeObject(val: any, semantic?: SemanticEncoding): any;\n    ToBigMapKey(val: string | number): {\n        key: {\n            int: string;\n        };\n        type: {\n            prim: \"int\";\n        };\n    };\n    ToKey({ int }: any): any;\n    compare(int1: string | number, int2: string | number): 0 | 1 | -1;\n    findAndReturnTokens(tokenToFind: string, tokens: Token[]): Token[];\n}\n"},{name:"@taquito/michelson-encoder/dist/types/tokens/comparable/key_hash.d.ts",dts:"import { Token, TokenFactory, ComparableToken, TokenValidationError, SemanticEncoding } from '../token';\nimport { BaseTokenSchema } from '../../schema/types';\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing Key Hash\n */\nexport declare class KeyHashValidationError extends TokenValidationError {\n    value: any;\n    token: KeyHashToken;\n    name: string;\n    constructor(value: any, token: KeyHashToken, message: string);\n}\nexport declare class KeyHashToken extends ComparableToken {\n    protected val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    };\n    protected idx: number;\n    protected fac: TokenFactory;\n    static prim: 'key_hash';\n    constructor(val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    }, idx: number, fac: TokenFactory);\n    Execute(val: {\n        bytes: string;\n        string: string;\n    }): string;\n    /**\n     * @throws {@link KeyHashValidationError}\n     */\n    private validate;\n    /**\n     * @throws {@link KeyHashValidationError}\n     */\n    Encode(args: any[]): any;\n    /**\n     * @throws {@link KeyHashValidationError}\n     */\n    EncodeObject(val: any, semantic?: SemanticEncoding): any;\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */\n    ExtractSchema(): \"key_hash\";\n    generateSchema(): BaseTokenSchema;\n    ToKey({ string, bytes }: any): any;\n    ToBigMapKey(val: string): {\n        key: {\n            string: string;\n        };\n        type: {\n            prim: \"key_hash\";\n        };\n    };\n    compare(pkh1: string, pkh2: string): number;\n    findAndReturnTokens(tokenToFind: string, tokens: Token[]): Token[];\n}\n"},{name:"@taquito/michelson-encoder/dist/types/tokens/comparable/mutez.d.ts",dts:"import { Token, TokenFactory, ComparableToken, TokenValidationError, SemanticEncoding } from '../token';\nimport BigNumber from 'bignumber.js';\nimport { BaseTokenSchema } from '../../schema/types';\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing Mutez\n */\nexport declare class MutezValidationError extends TokenValidationError {\n    value: any;\n    token: MutezToken;\n    name: string;\n    constructor(value: any, token: MutezToken, message: string);\n}\nexport declare class MutezToken extends ComparableToken {\n    protected val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    };\n    protected idx: number;\n    protected fac: TokenFactory;\n    static prim: 'mutez';\n    constructor(val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    }, idx: number, fac: TokenFactory);\n    Execute(val: any): BigNumber;\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */\n    ExtractSchema(): \"mutez\";\n    generateSchema(): BaseTokenSchema;\n    /**\n     * @throws {@link MutezValidationError}\n     */\n    private validate;\n    /**\n     * @throws {@link MutezValidationError}\n     */\n    Encode(args: any[]): any;\n    /**\n     * @throws {@link MutezValidationError}\n     */\n    EncodeObject(val: any, semantic?: SemanticEncoding): any;\n    ToBigMapKey(val: string | number): {\n        key: {\n            int: string;\n        };\n        type: {\n            prim: \"mutez\";\n        };\n    };\n    ToKey({ int }: any): any;\n    compare(mutez1: string | number, mutez2: string | number): 0 | 1 | -1;\n    findAndReturnTokens(tokenToFind: string, tokens: Token[]): Token[];\n}\n"},{name:"@taquito/michelson-encoder/dist/types/tokens/comparable/nat.d.ts",dts:"import { Token, TokenFactory, ComparableToken, TokenValidationError, SemanticEncoding } from '../token';\nimport BigNumber from 'bignumber.js';\nimport { BaseTokenSchema } from '../../schema/types';\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing Nat\n */\nexport declare class NatValidationError extends TokenValidationError {\n    value: any;\n    token: NatToken;\n    name: string;\n    constructor(value: any, token: NatToken, message: string);\n}\nexport declare class NatToken extends ComparableToken {\n    protected val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    };\n    protected idx: number;\n    protected fac: TokenFactory;\n    static prim: 'nat';\n    constructor(val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    }, idx: number, fac: TokenFactory);\n    Execute(val: any): {\n        [key: string]: any;\n    };\n    /**\n     * @throws {@link NatValidationError}\n     */\n    Encode(args: any[]): any;\n    /**\n     * @throws {@link NatValidationError}\n     */\n    private validate;\n    /**\n     * @throws {@link NatValidationError}\n     */\n    EncodeObject(val: any, semantic?: SemanticEncoding): any;\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */\n    ExtractSchema(): \"nat\";\n    generateSchema(): BaseTokenSchema;\n    ToBigMapKey(val: string | number): {\n        key: {\n            int: string;\n        };\n        type: {\n            prim: \"nat\";\n        };\n    };\n    ToKey({ int }: any): BigNumber;\n    compare(nat1: string | number, nat2: string | number): 0 | 1 | -1;\n    findAndReturnTokens(tokenToFind: string, tokens: Token[]): Token[];\n}\n"},{name:"@taquito/michelson-encoder/dist/types/tokens/comparable/string.d.ts",dts:"import { BaseTokenSchema } from '../../schema/types';\nimport { Token, TokenFactory, ComparableToken, SemanticEncoding } from '../token';\nexport declare class StringToken extends ComparableToken {\n    protected val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    };\n    protected idx: number;\n    protected fac: TokenFactory;\n    static prim: 'string';\n    constructor(val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    }, idx: number, fac: TokenFactory);\n    Execute(val: any): string;\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */\n    ExtractSchema(): \"string\";\n    generateSchema(): BaseTokenSchema;\n    Encode(args: any[]): any;\n    EncodeObject(val: any, semantic?: SemanticEncoding): any;\n    ToKey({ string }: any): any;\n    ToBigMapKey(val: string): {\n        key: {\n            string: string;\n        };\n        type: {\n            prim: \"string\";\n        };\n    };\n    findAndReturnTokens(tokenToFind: string, tokens: Token[]): Token[];\n}\n"},{name:"@taquito/michelson-encoder/dist/types/tokens/comparable/timestamp.d.ts",dts:"import { BaseTokenSchema } from '../../schema/types';\nimport { Token, TokenFactory, ComparableToken, SemanticEncoding } from '../token';\nexport declare class TimestampToken extends ComparableToken {\n    protected val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    };\n    protected idx: number;\n    protected fac: TokenFactory;\n    static prim: 'timestamp';\n    constructor(val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    }, idx: number, fac: TokenFactory);\n    Execute(val: {\n        string?: string;\n        int?: string;\n    }): string | undefined;\n    Encode(args: any[]): any;\n    EncodeObject(val: any, semantic?: SemanticEncoding): any;\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */\n    ExtractSchema(): \"timestamp\";\n    generateSchema(): BaseTokenSchema;\n    ToKey({ string }: any): any;\n    ToBigMapKey(val: string): {\n        key: {\n            string: string;\n        };\n        type: {\n            prim: \"timestamp\";\n        };\n    };\n    findAndReturnTokens(tokenToFind: string, tokens: Token[]): Token[];\n}\n"},{name:"@taquito/michelson-encoder/dist/types/tokens/bigmap.d.ts",dts:"import { BigMapTokenSchema } from '../schema/types';\nimport { ComparableToken, Semantic, SemanticEncoding, Token, TokenFactory, TokenValidationError } from './token';\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing Big Map types\n */\nexport declare class BigMapValidationError extends TokenValidationError {\n    value: any;\n    token: BigMapToken;\n    name: string;\n    constructor(value: any, token: BigMapToken, message: string);\n}\nexport declare class BigMapToken extends Token {\n    protected val: {\n        prim: string;\n        args: any[];\n        annots?: any[];\n    };\n    protected idx: number;\n    protected fac: TokenFactory;\n    static prim: 'big_map';\n    constructor(val: {\n        prim: string;\n        args: any[];\n        annots?: any[];\n    }, idx: number, fac: TokenFactory);\n    get ValueSchema(): Token;\n    get KeySchema(): ComparableToken;\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */\n    ExtractSchema(): {\n        big_map: {\n            key: any;\n            value: any;\n        };\n    };\n    generateSchema(): BigMapTokenSchema;\n    /**\n     * @throws {@link BigMapValidationError}\n     */\n    private validate;\n    private objLitToMichelsonMap;\n    /**\n     * @throws {@link BigMapValidationError}\n     */\n    Encode(args: any[]): any;\n    /**\n     * @throws {@link BigMapValidationError}\n     */\n    EncodeObject(args: any, semantic?: SemanticEncoding): any;\n    /**\n     * @throws {@link InvalidMapTypeError} when the argument passed to val is an array but not a valid map type\n     * @throws {@link BigMapValidationError} when the value is invalid\n     */\n    Execute(val: any[] | {\n        int: string;\n    }, semantic?: Semantic): any;\n    findAndReturnTokens(tokenToFind: string, tokens: Token[]): Token[];\n}\n"},{name:"@taquito/michelson-encoder/dist/types/tokens/bls12-381-fr.d.ts",dts:'import { BaseTokenSchema } from \'../schema/types\';\nimport { SemanticEncoding, Token, TokenFactory, TokenValidationError } from \'./token\';\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing a BLS12-381 scalar field Fr\n */\nexport declare class Bls12381frValidationError extends TokenValidationError {\n    value: any;\n    token: Bls12381frToken;\n    name: string;\n    constructor(value: any, token: Bls12381frToken, message: string);\n}\nexport declare class Bls12381frToken extends Token {\n    protected val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    };\n    protected idx: number;\n    protected fac: TokenFactory;\n    static prim: \'bls12_381_fr\';\n    constructor(val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    }, idx: number, fac: TokenFactory);\n    /**\n     * @throws {@link Bls12381frValidationError}\n     */\n    private validate;\n    private convertUint8ArrayToHexString;\n    /**\n     * @throws {@link Bls12381frValidationError}\n     */\n    Encode(args: any[]): {\n        int: string;\n        bytes?: undefined;\n    } | {\n        bytes: any;\n        int?: undefined;\n    };\n    /**\n     * @throws {@link Bls12381frValidationError}\n     */\n    EncodeObject(val: string | Uint8Array | number, semantic?: SemanticEncoding): import("@taquito/rpc").MichelsonV1ExpressionExtended | import("@taquito/rpc").MichelsonV1ExpressionBase | import("@taquito/rpc").MichelsonV1Expression[] | {\n        bytes: string | number | Uint8Array;\n    };\n    Execute(val: any): string;\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */\n    ExtractSchema(): "bls12_381_fr";\n    generateSchema(): BaseTokenSchema;\n    findAndReturnTokens(tokenToFind: string, tokens: Token[]): Token[];\n}\n'},{name:"@taquito/michelson-encoder/dist/types/tokens/bls12-381-g1.d.ts",dts:'import { BaseTokenSchema } from \'../schema/types\';\nimport { SemanticEncoding, Token, TokenFactory, TokenValidationError } from \'./token\';\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing a BLS12-381 curve G1\n */\nexport declare class Bls12381g1ValidationError extends TokenValidationError {\n    value: any;\n    token: Bls12381g1Token;\n    name: string;\n    constructor(value: any, token: Bls12381g1Token, message: string);\n}\nexport declare class Bls12381g1Token extends Token {\n    protected val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    };\n    protected idx: number;\n    protected fac: TokenFactory;\n    static prim: \'bls12_381_g1\';\n    constructor(val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    }, idx: number, fac: TokenFactory);\n    /**\n     * @throws {@link Bls12381g1ValidationError}\n     */\n    private validate;\n    private convertUint8ArrayToHexString;\n    /**\n     * @throws {@link Bls12381g1ValidationError}\n     */\n    Encode(args: any[]): {\n        bytes: any;\n    };\n    /**\n     * @throws {@link Bls12381g1ValidationError}\n     */\n    EncodeObject(val: string | Uint8Array, semantic?: SemanticEncoding): import("@taquito/rpc").MichelsonV1ExpressionExtended | import("@taquito/rpc").MichelsonV1ExpressionBase | import("@taquito/rpc").MichelsonV1Expression[] | {\n        bytes: string | Uint8Array;\n    };\n    Execute(val: any): string;\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */\n    ExtractSchema(): "bls12_381_g1";\n    generateSchema(): BaseTokenSchema;\n    findAndReturnTokens(tokenToFind: string, tokens: Token[]): Token[];\n}\n'},{name:"@taquito/michelson-encoder/dist/types/tokens/bls12-381-g2.d.ts",dts:'import { BaseTokenSchema } from \'../schema/types\';\nimport { SemanticEncoding, Token, TokenFactory, TokenValidationError } from \'./token\';\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing a BLS12-381 curve G2\n */\nexport declare class Bls12381g2ValidationError extends TokenValidationError {\n    value: any;\n    token: Bls12381g2Token;\n    name: string;\n    constructor(value: any, token: Bls12381g2Token, message: string);\n}\nexport declare class Bls12381g2Token extends Token {\n    protected val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    };\n    protected idx: number;\n    protected fac: TokenFactory;\n    static prim: \'bls12_381_g2\';\n    constructor(val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    }, idx: number, fac: TokenFactory);\n    /**\n     * @throws {@link Bls12381g2ValidationError}\n     */\n    private validate;\n    private convertUint8ArrayToHexString;\n    /**\n     * @throws {@link Bls12381g2ValidationError}\n     */\n    Encode(args: any[]): {\n        bytes: any;\n    };\n    /**\n     * @throws {@link Bls12381g2ValidationError}\n     */\n    EncodeObject(val: string | Uint8Array, semantic?: SemanticEncoding): import("@taquito/rpc").MichelsonV1ExpressionExtended | import("@taquito/rpc").MichelsonV1ExpressionBase | import("@taquito/rpc").MichelsonV1Expression[] | {\n        bytes: string | Uint8Array;\n    };\n    Execute(val: any): string;\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */\n    ExtractSchema(): "bls12_381_g2";\n    generateSchema(): BaseTokenSchema;\n    findAndReturnTokens(tokenToFind: string, tokens: Token[]): Token[];\n}\n'},{name:"@taquito/michelson-encoder/dist/types/tokens/chain-id.d.ts",dts:"import { Token, TokenFactory, ComparableToken, TokenValidationError, SemanticEncoding } from './token';\nimport { BaseTokenSchema } from '../schema/types';\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing a ChainID\n */\nexport declare class ChainIDValidationError extends TokenValidationError {\n    value: any;\n    token: ChainIDToken;\n    name: string;\n    constructor(value: any, token: ChainIDToken, message: string);\n}\nexport declare class ChainIDToken extends ComparableToken {\n    protected val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    };\n    protected idx: number;\n    protected fac: TokenFactory;\n    static prim: 'chain_id';\n    constructor(val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    }, idx: number, fac: TokenFactory);\n    /**\n     * @throws {@link ChainIDValidationError}\n     */\n    private validate;\n    Execute(val: any): string;\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */\n    ExtractSchema(): \"chain_id\";\n    generateSchema(): BaseTokenSchema;\n    /**\n     * @throws {@link ChainIDValidationError}\n     */\n    Encode(args: any[]): any;\n    /**\n     * @throws {@link ChainIDValidationError}\n     */\n    EncodeObject(val: any, semantic?: SemanticEncoding): any;\n    ToKey({ string }: any): any;\n    ToBigMapKey(val: string): {\n        key: {\n            string: string;\n        };\n        type: {\n            prim: \"chain_id\";\n        };\n    };\n    findAndReturnTokens(tokenToFind: string, tokens: Token[]): Token[];\n}\n"},{name:"@taquito/michelson-encoder/dist/types/tokens/chest-key.d.ts",dts:'import { BaseTokenSchema } from \'../schema/types\';\nimport { SemanticEncoding, Token, TokenFactory, TokenValidationError } from \'./token\';\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing a Chest Key\n */\nexport declare class ChestKeyValidationError extends TokenValidationError {\n    value: any;\n    token: ChestKeyToken;\n    name: string;\n    constructor(value: any, token: ChestKeyToken, message: string);\n}\nexport declare class ChestKeyToken extends Token {\n    protected val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    };\n    protected idx: number;\n    protected fac: TokenFactory;\n    static prim: \'chest_key\';\n    constructor(val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    }, idx: number, fac: TokenFactory);\n    /**\n     * @throws {@link ChestKeyValidationError}\n     */\n    private validate;\n    private convertUint8ArrayToHexString;\n    /**\n     * @throws {@link ChestKeyValidationError}\n     */\n    Encode(args: any[]): {\n        bytes: any;\n    };\n    /**\n     * @throws {@link ChestKeyValidationError}\n     */\n    EncodeObject(val: string | Uint8Array, semantic?: SemanticEncoding): import("@taquito/rpc").MichelsonV1ExpressionExtended | import("@taquito/rpc").MichelsonV1ExpressionBase | import("@taquito/rpc").MichelsonV1Expression[] | {\n        bytes: string | Uint8Array;\n    };\n    Execute(val: any): string;\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */\n    ExtractSchema(): "chest_key";\n    generateSchema(): BaseTokenSchema;\n    findAndReturnTokens(tokenToFind: string, tokens: Token[]): Token[];\n}\n'},{name:"@taquito/michelson-encoder/dist/types/tokens/chest.d.ts",dts:'import { BaseTokenSchema } from \'../schema/types\';\nimport { SemanticEncoding, Token, TokenFactory, TokenValidationError } from \'./token\';\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing a Chest\n */\nexport declare class ChestValidationError extends TokenValidationError {\n    value: any;\n    token: ChestToken;\n    name: string;\n    constructor(value: any, token: ChestToken, message: string);\n}\nexport declare class ChestToken extends Token {\n    protected val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    };\n    protected idx: number;\n    protected fac: TokenFactory;\n    static prim: \'chest\';\n    constructor(val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    }, idx: number, fac: TokenFactory);\n    /**\n     * @throws {@link ChestKeyValidationError}\n     */\n    private validate;\n    private convertUint8ArrayToHexString;\n    /**\n     * @throws {@link ChestKeyValidationError}\n     */\n    Encode(args: any[]): {\n        bytes: any;\n    };\n    /**\n     * @throws {@link ChestKeyValidationError}\n     */\n    EncodeObject(val: string | Uint8Array, semantic?: SemanticEncoding): import("@taquito/rpc").MichelsonV1ExpressionExtended | import("@taquito/rpc").MichelsonV1ExpressionBase | import("@taquito/rpc").MichelsonV1Expression[] | {\n        bytes: string | Uint8Array;\n    };\n    Execute(val: any): string;\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */\n    ExtractSchema(): "chest";\n    generateSchema(): BaseTokenSchema;\n    findAndReturnTokens(tokenToFind: string, tokens: Token[]): Token[];\n}\n'},{name:"@taquito/michelson-encoder/dist/types/tokens/constant.d.ts",dts:"import { ConstantTokenSchema } from '../schema/types';\nimport { Semantic, SemanticEncoding, Token, TokenFactory, TokenValidationError } from './token';\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding a Global Constant\n */\nexport declare class GlobalConstantEncodingError extends TokenValidationError {\n    value: any;\n    token: GlobalConstantToken;\n    name: string;\n    constructor(value: any, token: GlobalConstantToken, message: string);\n}\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing executing a Global Constant\n */\nexport declare class GlobalConstantDecodingError extends TokenValidationError {\n    value: any;\n    token: GlobalConstantToken;\n    name: string;\n    constructor(value: any, token: GlobalConstantToken, message: string);\n}\nexport declare class GlobalConstantToken extends Token {\n    protected val: {\n        prim: string;\n        args: any[];\n        annots?: any[];\n    };\n    protected idx: number;\n    protected fac: TokenFactory;\n    static prim: 'constant';\n    constructor(val: {\n        prim: string;\n        args: any[];\n        annots?: any[];\n    }, idx: number, fac: TokenFactory);\n    /**\n     * @throws {@link GlobalConstantDecodingError}\n     */\n    Execute(val: any, semantic?: Semantic): any;\n    /**\n     * @throws {@link GlobalConstantEncodingError}\n     */\n    Encode(args: any[]): any;\n    /**\n     * @throws {@link GlobalConstantEncodingError}\n     */\n    EncodeObject(val: any, semantic?: SemanticEncoding): any;\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */\n    ExtractSchema(): \"constant\";\n    generateSchema(): ConstantTokenSchema;\n    findAndReturnTokens(tokenToFind: string, tokens: Token[]): Token[];\n}\n"},{name:"@taquito/michelson-encoder/dist/types/tokens/contract.d.ts",dts:"import { ContractTokenSchema } from '../schema/types';\nimport { SemanticEncoding, Token, TokenFactory, TokenValidationError } from './token';\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing a Contract\n */\nexport declare class ContractValidationError extends TokenValidationError {\n    value: any;\n    token: ContractToken;\n    name: string;\n    constructor(value: any, token: ContractToken, message: string);\n}\nexport declare class ContractToken extends Token {\n    protected val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    };\n    protected idx: number;\n    protected fac: TokenFactory;\n    static prim: 'contract';\n    constructor(val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    }, idx: number, fac: TokenFactory);\n    /**\n     * @throws {@link ContractValidationError}\n     */\n    private validate;\n    /**\n     * @throws {@link ContractValidationError}\n     */\n    Execute(val: {\n        bytes: string;\n        string: string;\n    }): string;\n    /**\n     * @throws {@link ContractValidationError}\n     */\n    Encode(args: any[]): any;\n    /**\n     * @throws {@link ContractValidationError}\n     */\n    EncodeObject(val: any, semantic?: SemanticEncoding): any;\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */\n    ExtractSchema(): \"contract\";\n    generateSchema(): ContractTokenSchema;\n    findAndReturnTokens(tokenToFind: string, tokens: Token[]): Token[];\n}\n"},{name:"@taquito/michelson-encoder/dist/types/tokens/createToken.d.ts",dts:"import { Token } from './token';\nimport { TaquitoError } from '@taquito/core';\n/**\n *  @category Error\n *  @description Error that indicates a script having an invalid type or it being unsupported by the Michelson Encoder. Note some protocol changes might affect this, we encourage users to open an issue so we can look into implementing support for said types.\n */\nexport declare class InvalidTokenError extends TaquitoError {\n    message: string;\n    data: any;\n    name: string;\n    constructor(message: string, data: any);\n}\n/**\n *\n * @description Create a token from a value\n * @throws {@link InvalidTokenError} If the value passed is not supported by the Michelson Encoder\n */\nexport declare function createToken(val: any, idx: number, parentTokenType?: 'Or' | 'Pair' | 'Other' | undefined): Token;\n"},{name:"@taquito/michelson-encoder/dist/types/tokens/key.d.ts",dts:"import { ComparableToken, SemanticEncoding, Token, TokenFactory, TokenValidationError } from './token';\nimport { BaseTokenSchema } from '../schema/types';\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing a Key\n */\nexport declare class KeyValidationError extends TokenValidationError {\n    value: any;\n    token: KeyToken;\n    name: string;\n    constructor(value: any, token: KeyToken, message: string);\n}\nexport declare class KeyToken extends ComparableToken {\n    protected val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    };\n    protected idx: number;\n    protected fac: TokenFactory;\n    static prim: 'key';\n    constructor(val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    }, idx: number, fac: TokenFactory);\n    Execute(val: {\n        bytes: string;\n        string: string;\n    }): string;\n    /**\n     * @throws {@link KeyValidationError}\n     */\n    private validate;\n    /**\n     * @throws {@link KeyValidationError}\n     */\n    Encode(args: any[]): any;\n    /**\n     * @throws {@link KeyValidationError}\n     */\n    EncodeObject(val: any, semantic?: SemanticEncoding): any;\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */\n    ExtractSchema(): \"key\";\n    generateSchema(): BaseTokenSchema;\n    ToKey(val: any): string;\n    ToBigMapKey(val: string): {\n        key: {\n            string: string;\n        };\n        type: {\n            prim: \"key\";\n        };\n    };\n    decompressP256PublicKey(compressedKey: Uint8Array): Buffer;\n    compare(key1: string, key2: string): number;\n    findAndReturnTokens(tokenToFind: string, tokens: Token[]): Token[];\n}\n"},{name:"@taquito/michelson-encoder/dist/types/tokens/lambda.d.ts",dts:"import { LambdaTokenSchema } from '../schema/types';\nimport { SemanticEncoding, Token, TokenFactory } from './token';\nexport declare class LambdaToken extends Token {\n    protected val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    };\n    protected idx: number;\n    protected fac: TokenFactory;\n    static prim: 'lambda';\n    constructor(val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    }, idx: number, fac: TokenFactory);\n    get paramSchema(): Token;\n    get returnSchema(): Token;\n    Execute(val: any): any;\n    Encode(args: any[]): any;\n    EncodeObject(val: any, semantic?: SemanticEncoding): any;\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */\n    ExtractSchema(): {\n        lambda: {\n            parameters: any;\n            returns: any;\n        };\n    };\n    generateSchema(): LambdaTokenSchema;\n    findAndReturnTokens(tokenToFind: string, tokens: Token[]): Token[];\n}\n"},{name:"@taquito/michelson-encoder/dist/types/tokens/list.d.ts",dts:"import { ListTokenSchema } from '../schema/types';\nimport { Token, TokenFactory, Semantic, TokenValidationError, SemanticEncoding } from './token';\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing a List\n */\nexport declare class ListValidationError extends TokenValidationError {\n    value: any;\n    token: ListToken;\n    name: string;\n    constructor(value: any, token: ListToken, message: string);\n}\nexport declare class ListToken extends Token {\n    protected val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    };\n    protected idx: number;\n    protected fac: TokenFactory;\n    static prim: 'list';\n    constructor(val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    }, idx: number, fac: TokenFactory);\n    get valueSchema(): Token;\n    /**\n     * @throws {@link ListValidationError}\n     */\n    private validate;\n    /**\n     * @throws {@link ListValidationError}\n     */\n    Encode(args: any[]): any;\n    /**\n     * @throws {@link ListValidationError}\n     */\n    Execute(val: any, semantics?: Semantic): any;\n    /**\n     * @throws {@link ListValidationError}\n     */\n    EncodeObject(args: any, semantic?: SemanticEncoding): any;\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */\n    ExtractSchema(): {\n        list: any;\n    };\n    generateSchema(): ListTokenSchema;\n    findAndReturnTokens(tokenToFind: string, tokens: Token[]): Token[];\n}\n"},{name:"@taquito/michelson-encoder/dist/types/tokens/map.d.ts",dts:"import { MapTokenSchema } from '../schema/types';\nimport { ComparableToken, Semantic, SemanticEncoding, Token, TokenFactory, TokenValidationError } from './token';\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing a Map\n */\nexport declare class MapValidationError extends TokenValidationError {\n    value: any;\n    token: MapToken;\n    name: string;\n    constructor(value: any, token: MapToken, message: string);\n}\nexport declare class MapToken extends Token {\n    protected val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    };\n    protected idx: number;\n    protected fac: TokenFactory;\n    static prim: 'map';\n    constructor(val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    }, idx: number, fac: TokenFactory);\n    get ValueSchema(): Token;\n    get KeySchema(): ComparableToken;\n    /**\n     * @throws {@link MapValidationError}\n     */\n    validate(value: any): void;\n    Execute(val: any[], semantics?: Semantic): {\n        [key: string]: any;\n    };\n    private objLitToMichelsonMap;\n    /**\n     * @throws {@link MapValidationError}\n     */\n    Encode(args: any[]): any;\n    /**\n     * @throws {@link MapValidationError}\n     */\n    EncodeObject(args: any, semantic?: SemanticEncoding): any;\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */\n    ExtractSchema(): {\n        map: {\n            key: any;\n            value: any;\n        };\n    };\n    generateSchema(): MapTokenSchema;\n    findAndReturnTokens(tokenToFind: string, tokens: Token[]): Token[];\n}\n"},{name:"@taquito/michelson-encoder/dist/types/tokens/never.d.ts",dts:"import { BaseTokenSchema } from '../schema/types';\nimport { SemanticEncoding, Token, TokenFactory, TokenValidationError } from './token';\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing a Never Token\n */\nexport declare class NeverTokenError extends TokenValidationError {\n    value: any;\n    token: NeverToken;\n    name: string;\n    constructor(value: any, token: NeverToken, message: string);\n}\nexport declare class NeverToken extends Token {\n    protected val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    };\n    protected idx: number;\n    protected fac: TokenFactory;\n    static prim: 'never';\n    constructor(val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    }, idx: number, fac: TokenFactory);\n    /**\n     * @throws {@link NeverTokenError}\n     */\n    Encode(args: any[]): any;\n    /**\n     * @throws {@link NeverTokenError}\n     */\n    EncodeObject(val: any, semantic?: SemanticEncoding): any;\n    /**\n     * @throws {@link NeverTokenError}\n     */\n    Execute(val: any): void;\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */\n    ExtractSchema(): \"never\";\n    generateSchema(): BaseTokenSchema;\n    findAndReturnTokens(tokenToFind: string, tokens: Token[]): Token[];\n}\n"},{name:"@taquito/michelson-encoder/dist/types/tokens/operation.d.ts",dts:"import { BaseTokenSchema } from '../schema/types';\nimport { SemanticEncoding, Token, TokenFactory } from './token';\nexport declare class OperationToken extends Token {\n    protected val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    };\n    protected idx: number;\n    protected fac: TokenFactory;\n    static prim: 'operation';\n    constructor(val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    }, idx: number, fac: TokenFactory);\n    Execute(val: any): {\n        [key: string]: any;\n    };\n    Encode(...args: any[]): any;\n    EncodeObject(val: any, semantic?: SemanticEncoding): any;\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */\n    ExtractSchema(): \"operation\";\n    generateSchema(): BaseTokenSchema;\n    findAndReturnTokens(tokenToFind: string, tokens: Token[]): Token[];\n}\n"},{name:"@taquito/michelson-encoder/dist/types/tokens/option.d.ts",dts:"import { OptionTokenSchema } from '../schema/types';\nimport { Token, TokenFactory, Semantic, ComparableToken, SemanticEncoding } from './token';\nexport declare class OptionToken extends ComparableToken {\n    protected val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    };\n    protected idx: number;\n    protected fac: TokenFactory;\n    static prim: 'option';\n    constructor(val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    }, idx: number, fac: TokenFactory);\n    subToken(): Token;\n    schema(): Token;\n    annot(): string;\n    Encode(args: any): any;\n    EncodeObject(args: any, semantic?: SemanticEncoding): any;\n    Execute(val: any, semantics?: Semantic): {\n        Some: any;\n    } | null;\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */\n    ExtractSchema(): {\n        Some: any;\n    };\n    generateSchema(): OptionTokenSchema;\n    ExtractSignature(): any[][];\n    get KeySchema(): ComparableToken;\n    compare(val1: any, val2: any): number;\n    ToKey(val: any): {\n        Some: any;\n    } | null;\n    ToBigMapKey(val: any): {\n        key: any;\n        type: Omit<import(\"@taquito/rpc\").MichelsonV1ExpressionExtended, \"annots\">;\n    };\n    findAndReturnTokens(tokenToFind: string, tokens: Token[]): Token[];\n}\n"},{name:"@taquito/michelson-encoder/dist/types/tokens/or.d.ts",dts:"import { OrTokenSchema } from '../schema/types';\nimport { Token, TokenFactory, Semantic, ComparableToken, SemanticEncoding, TokenValidationError } from './token';\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing an OrToken\n */\nexport declare class OrValidationError extends TokenValidationError {\n    value: any;\n    token: OrToken;\n    name: string;\n    constructor(value: any, token: OrToken, message: string);\n}\nexport declare class OrToken extends ComparableToken {\n    protected val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    };\n    protected idx: number;\n    protected fac: TokenFactory;\n    protected parentTokenType?: 'Or' | 'Pair' | 'Other' | undefined;\n    static prim: 'or';\n    constructor(val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    }, idx: number, fac: TokenFactory, parentTokenType?: 'Or' | 'Pair' | 'Other' | undefined);\n    Encode(args: any[]): any;\n    ExtractSignature(): any;\n    /**\n     * @throws {@link OrValidationError}\n     */\n    EncodeObject(args: any, semantic?: SemanticEncoding): any;\n    /**\n     * @throws {@link OrValidationError}\n     */\n    private validateJavascriptObject;\n    /**\n     * @throws {@link OrValidationError}\n     */\n    Execute(val: any, semantics?: Semantic): any;\n    private traversal;\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */\n    ExtractSchema(): any;\n    generateSchema(): OrTokenSchema;\n    private findToken;\n    compare(val1: any, val2: any): any;\n    ToKey(val: any): any;\n    ToBigMapKey(val: any): {\n        key: any;\n        type: Omit<import(\"@taquito/rpc\").MichelsonV1ExpressionExtended, \"annots\">;\n    };\n    findAndReturnTokens(tokenToFind: string, tokens: Token[]): Token[];\n    protected getIdxForChildren(): number;\n}\n"},{name:"@taquito/michelson-encoder/dist/types/tokens/pair.d.ts",dts:"import { Token, TokenFactory, Semantic, ComparableToken, SemanticEncoding } from './token';\nimport { PairTokenSchema } from '../schema/types';\nimport { MichelsonV1Expression, MichelsonV1ExpressionExtended } from '@taquito/rpc';\nimport { TaquitoError } from '@taquito/core';\n/**\n *  @category Error\n *  @description Error that indicates in invalid token argument being passed\n */\nexport declare class TokenArgumentValidationError extends TaquitoError {\n    message: string;\n    name: string;\n    constructor(message: string);\n}\n/**\n *  @category Error\n *  @description Error that indicates a failure occurring when doing a comparison of tokens\n */\nexport declare class TokenComparisonError extends TaquitoError {\n    val1: string;\n    val2: string;\n    name: string;\n    constructor(val1: string, val2: string);\n}\nexport declare class PairToken extends ComparableToken {\n    static prim: 'pair';\n    constructor(val: MichelsonV1Expression, idx: number, fac: TokenFactory, parentTokenType?: 'Or' | 'Pair' | 'Other' | undefined);\n    private args;\n    private tokens;\n    Encode(args: any[]): any;\n    ExtractSignature(): any;\n    ToBigMapKey(val: any): {\n        key: any;\n        type: Omit<MichelsonV1ExpressionExtended, \"annots\">;\n    };\n    ToKey(val: any): {\n        [key: string]: any;\n    };\n    EncodeObject(args: any, semantic?: SemanticEncoding): any;\n    private traversal;\n    Execute(val: any, semantics?: Semantic): {\n        [key: string]: any;\n    };\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */\n    ExtractSchema(): any;\n    generateSchema(): PairTokenSchema;\n    /**\n     * @throws {@link TokenComparisonError}\n     */\n    compare(val1: any, val2: any): number;\n    findAndReturnTokens(tokenToFind: string, tokens: Token[]): Token[];\n    protected getIdxForChildren(): number;\n}\n"},{name:"@taquito/michelson-encoder/dist/types/tokens/sapling-state.d.ts",dts:"import { SaplingStateTokenSchema } from '../schema/types';\nimport { Semantic, SemanticEncoding, Token, TokenFactory, TokenValidationError } from './token';\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing a Sapling State\n */\nexport declare class SaplingStateValidationError extends TokenValidationError {\n    value: any;\n    token: SaplingStateToken;\n    name: string;\n    constructor(value: any, token: SaplingStateToken, message: string);\n}\nexport declare class SaplingStateToken extends Token {\n    protected val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    };\n    protected idx: number;\n    protected fac: TokenFactory;\n    static prim: 'sapling_state';\n    constructor(val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    }, idx: number, fac: TokenFactory);\n    private isValid;\n    /**\n     * @throws {@link SaplingStateValidationError}\n     */\n    Execute(val: {\n        int: string;\n    }, semantic?: Semantic): any;\n    /**\n     * @throws {@link SaplingStateValidationError}\n     */\n    Encode(args: any[]): any;\n    /**\n     * @throws {@link SaplingStateValidationError}\n     */\n    EncodeObject(val: any, semantic?: SemanticEncoding): any;\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */\n    ExtractSchema(): {\n        sapling_state: {\n            'memo-size': number;\n        };\n    };\n    generateSchema(): SaplingStateTokenSchema;\n    findAndReturnTokens(tokenToFind: string, tokens: Token[]): Token[];\n}\n"},{name:"@taquito/michelson-encoder/dist/types/tokens/sapling-transaction-deprecated.d.ts",dts:"import { SaplingTransactionDeprecatedTokenSchema } from '../schema/types';\nimport { SemanticEncoding, Token, TokenFactory, TokenValidationError } from './token';\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing a Sapling Transaction Deprecated\n */\nexport declare class SaplingTransactionDeprecatedValidationError extends TokenValidationError {\n    value: any;\n    token: SaplingTransactionDeprecatedToken;\n    name: string;\n    constructor(value: any, token: SaplingTransactionDeprecatedToken, message: string);\n}\nexport declare class SaplingTransactionDeprecatedToken extends Token {\n    protected val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    };\n    protected idx: number;\n    protected fac: TokenFactory;\n    static prim: 'sapling_transaction_deprecated';\n    constructor(val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    }, idx: number, fac: TokenFactory);\n    /**\n     * @throws {@link SaplingTransactionDeprecatedValidationError}\n     */\n    Execute(_val: any): void;\n    /**\n     * @throws {@link SaplingTransactionDeprecatedValidationError}\n     */\n    private validateBytes;\n    private convertUint8ArrayToHexString;\n    Encode(args: any[]): any;\n    EncodeObject(val: string | Uint8Array, semantic?: SemanticEncoding): import(\"@taquito/rpc\").MichelsonV1Expression;\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */\n    ExtractSchema(): {\n        sapling_transaction_deprecated: {\n            'memo-size': number;\n        };\n    };\n    generateSchema(): SaplingTransactionDeprecatedTokenSchema;\n    findAndReturnTokens(tokenToFind: string, tokens: Token[]): Token[];\n}\n"},{name:"@taquito/michelson-encoder/dist/types/tokens/sapling-transaction.d.ts",dts:"import { SaplingTransactionTokenSchema } from '../schema/types';\nimport { SemanticEncoding, Token, TokenFactory, TokenValidationError } from './token';\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing a Sapling Transaction\n */\nexport declare class SaplingTransactionValidationError extends TokenValidationError {\n    value: any;\n    token: SaplingTransactionToken;\n    name: string;\n    constructor(value: any, token: SaplingTransactionToken, message: string);\n}\nexport declare class SaplingTransactionToken extends Token {\n    protected val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    };\n    protected idx: number;\n    protected fac: TokenFactory;\n    static prim: 'sapling_transaction';\n    constructor(val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    }, idx: number, fac: TokenFactory);\n    /**\n     * @throws {@link SaplingTransactionValidationError}\n     */\n    Execute(_val: any): void;\n    /**\n     * @throws {@link SaplingTransactionValidationError}\n     */\n    private validateBytes;\n    private convertUint8ArrayToHexString;\n    Encode(args: any[]): any;\n    EncodeObject(val: string | Uint8Array, semantic?: SemanticEncoding): import(\"@taquito/rpc\").MichelsonV1Expression;\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */\n    ExtractSchema(): {\n        sapling_transaction: {\n            'memo-size': number;\n        };\n    };\n    generateSchema(): SaplingTransactionTokenSchema;\n    findAndReturnTokens(tokenToFind: string, tokens: Token[]): Token[];\n}\n"},{name:"@taquito/michelson-encoder/dist/types/tokens/set.d.ts",dts:"import { SetTokenSchema } from '../schema/types';\nimport { Token, TokenFactory, Semantic, TokenValidationError, ComparableToken, SemanticEncoding } from './token';\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing a Set\n */\nexport declare class SetValidationError extends TokenValidationError {\n    value: any;\n    token: SetToken;\n    name: string;\n    constructor(value: any, token: SetToken, message: string);\n}\nexport declare class SetToken extends Token {\n    protected val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    };\n    protected idx: number;\n    protected fac: TokenFactory;\n    static prim: 'set';\n    constructor(val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    }, idx: number, fac: TokenFactory);\n    get KeySchema(): ComparableToken;\n    /**\n     * @throws {@link SetValidationError}\n     */\n    private validate;\n    /**\n     * @throws {@link SetValidationError}\n     */\n    Encode(args: any[]): any;\n    Execute(val: any, semantics?: Semantic): any;\n    /**\n     * @throws {@link SetValidationError}\n     */\n    EncodeObject(args: any, semantic?: SemanticEncoding): any;\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */\n    ExtractSchema(): \"set\";\n    generateSchema(): SetTokenSchema;\n    findAndReturnTokens(tokenToFind: string, tokens: Token[]): Token[];\n}\n"},{name:"@taquito/michelson-encoder/dist/types/tokens/signature.d.ts",dts:"import { ComparableToken, SemanticEncoding, Token, TokenFactory, TokenValidationError } from './token';\nimport { BaseTokenSchema } from '../schema/types';\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing a Signature\n */\nexport declare class SignatureValidationError extends TokenValidationError {\n    value: any;\n    token: SignatureToken;\n    name: string;\n    constructor(value: any, token: SignatureToken, message: string);\n}\nexport declare class SignatureToken extends ComparableToken {\n    protected val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    };\n    protected idx: number;\n    protected fac: TokenFactory;\n    static prim: 'signature';\n    constructor(val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    }, idx: number, fac: TokenFactory);\n    Execute(val: {\n        [key: string]: string;\n    }): string;\n    /**\n     * @throws {@link SignatureValidationError}\n     */\n    private validate;\n    /**\n     * @throws {@link SignatureValidationError}\n     */\n    Encode(args: any[]): any;\n    /**\n     * @throws {@link SignatureValidationError}\n     */\n    EncodeObject(val: any, semantic?: SemanticEncoding): any;\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */\n    ExtractSchema(): \"signature\";\n    generateSchema(): BaseTokenSchema;\n    ToKey(val: any): string;\n    ToBigMapKey(val: string): {\n        key: {\n            string: string;\n        };\n        type: {\n            prim: \"signature\";\n        };\n    };\n    findAndReturnTokens(tokenToFind: string, tokens: Token[]): Token[];\n}\n"},{name:"@taquito/michelson-encoder/dist/types/tokens/ticket-deprecated.d.ts",dts:"import { TaquitoError } from '@taquito/core';\nimport { TicketDeprecatedTokenSchema } from '../schema/types';\nimport { Token, TokenFactory, Semantic, SemanticEncoding } from './token';\n/**\n *  @category Error\n *  @description Error that indicates a failure when encoding and sending a ticket to the blockchain\n */\nexport declare class EncodeTicketDeprecatedError extends TaquitoError {\n    name: string;\n    constructor();\n}\nexport declare class TicketDeprecatedToken extends Token {\n    protected val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    };\n    protected idx: number;\n    protected fac: TokenFactory;\n    static prim: 'ticket_deprecated';\n    constructor(val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    }, idx: number, fac: TokenFactory);\n    get valueToken(): Token;\n    /**\n     * @throws {@link EncodeTicketDeprecatedError}\n     */\n    Encode(_args: any[]): any;\n    /**\n     * @throws {@link EncodeTicketDeprecatedError}\n     */\n    EncodeObject(args: any, semantic?: SemanticEncoding): any;\n    Execute(val: any, semantics?: Semantic): any;\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */\n    ExtractSchema(): {\n        ticketer: \"contract\";\n        value: any;\n        amount: \"int\";\n    };\n    generateSchema(): TicketDeprecatedTokenSchema;\n    findAndReturnTokens(tokenToFind: string, tokens: Token[]): Token[];\n}\n"},{name:"@taquito/michelson-encoder/dist/types/tokens/ticket.d.ts",dts:"import { TaquitoError } from '@taquito/core';\nimport { TicketTokenSchema } from '../schema/types';\nimport { Token, TokenFactory, Semantic, SemanticEncoding } from './token';\n/**\n *  @category Error\n *  @description Error that indicates a failure when encoding and sending a ticket to the blockchain\n */\nexport declare class EncodeTicketError extends TaquitoError {\n    name: string;\n    constructor();\n}\nexport declare class TicketToken extends Token {\n    protected val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    };\n    protected idx: number;\n    protected fac: TokenFactory;\n    static prim: 'ticket';\n    constructor(val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    }, idx: number, fac: TokenFactory);\n    get valueToken(): Token;\n    /**\n     * @throws {@link EncodeTicketError}\n     */\n    Encode(_args: any[]): any;\n    /**\n     * @throws {@link EncodeTicketError}\n     */\n    EncodeObject(args: any, semantic?: SemanticEncoding): any;\n    Execute(val: any, semantics?: Semantic): any;\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */\n    ExtractSchema(): {\n        ticketer: \"contract\";\n        value: any;\n        amount: \"int\";\n    };\n    generateSchema(): TicketTokenSchema;\n    findAndReturnTokens(tokenToFind: string, tokens: Token[]): Token[];\n}\n"},{name:"@taquito/michelson-encoder/dist/types/tokens/token.d.ts",dts:"import { MichelsonV1Expression, MichelsonV1ExpressionExtended } from '@taquito/rpc';\nimport { TokenSchema } from '../schema/types';\nimport { TaquitoError } from '@taquito/core';\n/**\n *  @category Error\n *  @description Error that indicates a failure when encoding invalid or incorrect data (e.g. if an address is expected but a number is received)\n */\nexport declare abstract class TokenValidationError extends TaquitoError {\n    readonly value: any;\n    readonly token: Token;\n    name: string;\n    constructor(value: any, token: Token, baseMessage: string);\n}\nexport type TokenFactory = (val: any, idx: number, parentTokenType?: 'Or' | 'Pair' | 'Other') => Token;\nexport interface Semantic {\n    [key: string]: (value: MichelsonV1Expression, schema: MichelsonV1Expression) => any;\n}\nexport interface SemanticEncoding {\n    [key: string]: (value: any, type?: MichelsonV1Expression) => MichelsonV1Expression;\n}\n/**\n * @description Possible strategies for mapping between javascript classes and Michelson values\n * Legacy: The old behaviour: { annot1: 'some value', annot2: 'other Value', annot3: { 2: 'yet another value', 3: 'also some value' }}\n * ResetFieldNumbersInNestedObjects: { annot1: 'some value', annot2: 'other Value', annot3: { 0: 'yet another value', 1: 'also some value' }}\n * Latest: This will include new changes as we might implement in the future. This is the suggested value if it does not break your code\n */\nexport type FieldNumberingStrategy = 'Legacy' | 'ResetFieldNumbersInNestedObjects' | 'Latest';\nexport declare abstract class Token {\n    protected val: MichelsonV1ExpressionExtended;\n    protected idx: number;\n    protected fac: TokenFactory;\n    protected parentTokenType?: (\"Or\" | \"Pair\" | \"Other\") | undefined;\n    private static _fieldNumberingStrategy;\n    /**\n     * @description Gets the strategy used for field numbering in Token execute/encode/decode to convert Michelson values to/from javascript objects, returns a value of type {@link FieldNumberingStrategy} that controls how field numbers are calculated\n     */\n    static get fieldNumberingStrategy(): FieldNumberingStrategy;\n    /**\n     * @description Sets the strategy used for field numbering in Token execute/encode/decode to convert Michelson values to/from javascript objects, accepts a value of type {@link FieldNumberingStrategy} that controls how field numbers are calculated\n     */\n    static set fieldNumberingStrategy(value: FieldNumberingStrategy);\n    constructor(val: MichelsonV1ExpressionExtended, idx: number, fac: TokenFactory, parentTokenType?: (\"Or\" | \"Pair\" | \"Other\") | undefined);\n    protected typeWithoutAnnotations(): Omit<MichelsonV1ExpressionExtended, \"annots\">;\n    annot(): string;\n    hasAnnotations(): number | false;\n    get tokenVal(): MichelsonV1ExpressionExtended;\n    createToken: TokenFactory;\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */\n    abstract ExtractSchema(): any;\n    abstract generateSchema(): TokenSchema;\n    abstract Execute(val: any, semantics?: Semantic): any;\n    abstract Encode(_args: any[]): any;\n    abstract EncodeObject(args: any, semantics?: SemanticEncoding): any;\n    ExtractSignature(): any[][];\n    abstract findAndReturnTokens(tokenToFind: string, tokens: Array<Token>): Array<Token>;\n}\nexport type BigMapKeyType = string | number | object;\nexport declare abstract class ComparableToken extends Token {\n    abstract ToBigMapKey(val: BigMapKeyType): {\n        key: {\n            [key: string]: string | object[];\n        };\n        type: {\n            prim: string;\n            args?: object[];\n        };\n    };\n    abstract ToKey(val: string | MichelsonV1Expression): any;\n    compare(o1: string, o2: string): number;\n}\n"},{name:"@taquito/michelson-encoder/dist/types/tokens/tokens.d.ts",dts:"import { PairToken } from './pair';\nimport { NatToken } from './comparable/nat';\nimport { StringToken } from './comparable/string';\nimport { BigMapToken } from './bigmap';\nimport { AddressToken } from './comparable/address';\nimport { MapToken } from './map';\nimport { BoolToken } from './comparable/bool';\nimport { OrToken } from './or';\nimport { ContractToken } from './contract';\nimport { ListToken } from './list';\nimport { MutezToken } from './comparable/mutez';\nimport { BytesToken } from './comparable/bytes';\nimport { OptionToken } from './option';\nimport { TimestampToken } from './comparable/timestamp';\nimport { IntToken } from './comparable/int';\nimport { UnitToken } from './unit';\nimport { KeyToken } from './key';\nimport { KeyHashToken } from './comparable/key_hash';\nimport { SignatureToken } from './signature';\nimport { LambdaToken } from './lambda';\nimport { OperationToken } from './operation';\nimport { SetToken } from './set';\nimport { ChainIDToken } from './chain-id';\nimport { TicketToken } from './ticket';\nimport { TicketDeprecatedToken } from './ticket-deprecated';\nimport { NeverToken } from './never';\nimport { SaplingStateToken } from './sapling-state';\nimport { SaplingTransactionToken } from './sapling-transaction';\nimport { SaplingTransactionDeprecatedToken } from './sapling-transaction-deprecated';\nimport { Bls12381frToken } from './bls12-381-fr';\nimport { Bls12381g1Token } from './bls12-381-g1';\nimport { Bls12381g2Token } from './bls12-381-g2';\nimport { ChestToken } from './chest';\nimport { ChestKeyToken } from './chest-key';\nimport { GlobalConstantToken } from './constant';\nexport declare const tokens: (typeof PairToken | typeof NatToken | typeof StringToken | typeof BigMapToken | typeof AddressToken | typeof MapToken | typeof BoolToken | typeof OrToken | typeof ContractToken | typeof ListToken | typeof MutezToken | typeof BytesToken | typeof OptionToken | typeof TimestampToken | typeof IntToken | typeof UnitToken | typeof KeyToken | typeof KeyHashToken | typeof SignatureToken | typeof LambdaToken | typeof OperationToken | typeof SetToken | typeof ChainIDToken | typeof TicketToken | typeof TicketDeprecatedToken | typeof NeverToken | typeof SaplingStateToken | typeof SaplingTransactionToken | typeof SaplingTransactionDeprecatedToken | typeof Bls12381frToken | typeof Bls12381g1Token | typeof Bls12381g2Token | typeof ChestToken | typeof ChestKeyToken | typeof GlobalConstantToken)[];\n"},{name:"@taquito/michelson-encoder/dist/types/tokens/unit.d.ts",dts:"import { ComparableToken, SemanticEncoding, Token, TokenFactory } from './token';\nimport { BaseTokenSchema } from '../schema/types';\nexport declare class UnitToken extends ComparableToken {\n    protected val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    };\n    protected idx: number;\n    protected fac: TokenFactory;\n    static prim: 'unit';\n    constructor(val: {\n        prim: string;\n        args: any[];\n        annots: any[];\n    }, idx: number, fac: TokenFactory);\n    Encode(args: any[]): any;\n    EncodeObject(val: any, semantic?: SemanticEncoding): any;\n    Execute(_val: {\n        prim: string;\n    }): symbol;\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */\n    ExtractSchema(): \"unit\";\n    generateSchema(): BaseTokenSchema;\n    compare(_val1: any, _val2: any): number;\n    ToKey(_val: any): symbol;\n    ToBigMapKey(_val: any): {\n        key: {\n            prim: string;\n        };\n        type: {\n            prim: \"unit\";\n        };\n    };\n    findAndReturnTokens(tokenToFind: string, tokens: Token[]): Token[];\n}\n"},{name:"@taquito/michelson-encoder/dist/types/errors.d.ts",dts:"export { ListValidationError } from './tokens/list';\nexport { MapValidationError } from './tokens/map';\nexport { SetValidationError } from './tokens/set';\nexport { BigMapValidationError } from './tokens/bigmap';\nexport { TokenArgumentValidationError, TokenComparisonError } from './tokens/pair';\nexport { OrValidationError } from './tokens/or';\nexport { ChainIDValidationError } from './tokens/chain-id';\nexport { KeyValidationError } from './tokens/key';\nexport { ContractValidationError } from './tokens/contract';\nexport { SignatureValidationError } from './tokens/signature';\nexport { AddressValidationError } from './tokens/comparable/address';\nexport { BytesValidationError } from './tokens/comparable/bytes';\nexport { IntValidationError } from './tokens/comparable/int';\nexport { KeyHashValidationError } from './tokens/comparable/key_hash';\nexport { MutezValidationError } from './tokens/comparable/mutez';\nexport { NatValidationError } from './tokens/comparable/nat';\nexport { EncodeTicketError } from './tokens/ticket';\n"},{name:"@taquito/michelson-encoder/dist/types/michelson-map.d.ts",dts:'import { MichelsonV1Expression } from \'@taquito/rpc\';\nimport { TaquitoError } from \'@taquito/core\';\n/**\n *  @category Error\n *  @description Error that indicates an invalid map type being passed or used\n */\nexport declare class InvalidMapTypeError extends TaquitoError {\n    readonly mapType: any;\n    readonly reason: string;\n    constructor(mapType: any, reason: string);\n}\ndeclare const michelsonMapTypeSymbol: unique symbol;\nexport type MichelsonMapKey = Array<any> | object | string | boolean | number | null;\n/**\n *  @category Error\n *  @description Error that indicates a map type mismatch, where an attempt to set a key or value in a Map doesn\'t match the defined type of the Map\n */\nexport declare class MapTypecheckError extends TaquitoError {\n    readonly value: any;\n    readonly type: any;\n    readonly reason: any;\n    name: string;\n    constructor(value: any, type: any, objectType: \'key\' | \'value\', reason: any);\n}\n/**\n * @description Michelson Map is an abstraction over the michelson native map. It supports complex Pair as key\n */\nexport declare class MichelsonMap<K extends MichelsonMapKey, T> {\n    private valueMap;\n    private keyMap;\n    [michelsonMapTypeSymbol]: boolean;\n    static isMichelsonMap(obj: any): obj is MichelsonMap<any, any>;\n    private keySchema?;\n    private valueSchema?;\n    /**\n     * @param mapType If specified key and value will be type-checked before being added to the map\n     *\n     * @example new MichelsonMap({ prim: "map", args: [{prim: "string"}, {prim: "int"}]})\n     */\n    constructor(mapType?: MichelsonV1Expression);\n    setType(mapType: MichelsonV1Expression): void;\n    removeType(): void;\n    static fromLiteral(obj: {\n        [key: string]: any;\n    }, mapType?: MichelsonV1Expression): MichelsonMap<MichelsonMapKey, unknown>;\n    private typecheckKey;\n    private typecheckValue;\n    /**\n     * @throws {@link MapTypecheckError} when the argument passed does not match the expected schema for value\n     */\n    private assertTypecheckValue;\n    /**\n     * @throws {@link MapTypecheckError} when the argument passed does not match the expected schema for key\n     */\n    private assertTypecheckKey;\n    private serializeDeterministically;\n    keys(): Generator<K>;\n    values(): Generator<T>;\n    entries(): Generator<[K, T]>;\n    get(key: K): T | undefined;\n    /**\n     *\n     * @description Set a key and a value in the MichelsonMap. If the key already exists, override the current value.\n     *\n     * @example map.set("myKey", "myValue") // Using a string as key\n     *\n     * @example map.set({0: "test", 1: "test1"}, "myValue") // Using a pair as key\n     *\n     * @warn The same key can be represented in multiple ways, depending on the type of the key. This duplicate key situation will cause a runtime error (duplicate key) when sending the map data to the Tezos RPC node.\n     *\n     * For example, consider a contract with a map whose key is of type boolean.  If you set the following values in MichelsonMap: map.set(false, "myValue") and map.set(null, "myValue").\n     *\n     * You will get two unique entries in the MichelsonMap. These values will both be evaluated as falsy by the MichelsonEncoder and ultimately rejected by the Tezos RPC.\n     */\n    set(key: K, value: T): void;\n    delete(key: K): void;\n    has(key: K): boolean;\n    clear(): void;\n    get size(): number;\n    forEach(cb: (value: T, key: K, map: MichelsonMap<K, T>) => void): void;\n}\nexport {};\n'},{name:"@taquito/michelson-encoder/dist/types/taquito-michelson-encoder.d.ts",dts:"/**\n * @packageDocumentation\n * @module @taquito/michelson-encoder\n */\nexport * from './schema/storage';\nexport * from './schema/parameter';\nexport * from './schema/view-schema';\nexport * from './schema/event-schema';\nexport * from './schema/errors';\nexport * from './schema/types';\nexport { Semantic, SemanticEncoding, BigMapKeyType } from './tokens/token';\nexport * from './errors';\nexport declare const UnitValue: unique symbol;\nexport declare const SaplingStateValue: {};\nexport * from './michelson-map';\nexport { VERSION } from './version';\nexport { FieldNumberingStrategy, Token } from './tokens/token';\n"},{name:"@taquito/michelson-encoder/dist/types/version.d.ts",dts:"export declare const VERSION: {\n    commitHash: string;\n    version: string;\n};\n"},{name:"@taquito/rpc/dist/types/rpc-client-modules/rpc-cache.d.ts",dts:"import BigNumber from 'bignumber.js';\nimport { RpcClientInterface, RPCOptions } from '../rpc-client-interface';\nimport { BakingRightsQueryArguments, BakingRightsResponse, BalanceResponse, UnstakeRequestsResponse, BallotListResponse, BallotsResponse, BigMapGetResponse, BigMapKey, BigMapResponse, BlockHeaderResponse, BlockMetadata, BlockResponse, ConstantsResponse, ContractResponse, CurrentProposalResponse, CurrentQuorumResponse, DelegateResponse, DelegatesResponse, VotingInfoResponse, AttestationRightsQueryArguments, AttestationRightsResponse, EntrypointsResponse, ForgeOperationsParams, ManagerKeyResponse, OperationHash, PackDataParams, PreapplyParams, PreapplyResponse, ProposalsResponse, ProtocolsResponse, RPCRunCodeParam, RPCRunOperationParam, RPCRunScriptViewParam, RPCRunViewParam, RunCodeResult, RunScriptViewResult, RunViewResult, SaplingDiffResponse, ScriptResponse, StorageResponse, UnparsingMode, VotesListingsResponse, VotingPeriodBlockResult, TicketTokenParams, AllTicketBalances, PendingOperationsQueryArguments, PendingOperationsV2, RPCSimulateOperationParam, AILaunchCycleResponse, AllDelegatesQueryArguments, ProtocolActivationsResponse } from '../types';\ninterface CachedDataInterface {\n    [key: string]: {\n        handle: () => void;\n        response: Promise<any>;\n    };\n}\n/***\n * @description RpcClientCache acts as a decorator over the RpcClient instance by caching responses for the period defined by the ttl.\n */\nexport declare class RpcClientCache implements RpcClientInterface {\n    private rpcClient;\n    private ttl;\n    private _cache;\n    /**\n     *\n     * @param rpcClient rpcClient responsible of the interaction with Tezos network through an rpc node\n     * @param ttl number representing the time to live (default 1000 milliseconds)\n     *\n     * @example new RpcClientCache(new RpcClient('https://mainnet.tezos.ecadinfra.com/'))\n     */\n    constructor(rpcClient: RpcClientInterface, ttl?: number);\n    getAllCachedData(): CachedDataInterface;\n    /**\n     * @description Remove all the data in the cache.\n     *\n     */\n    deleteAllCachedData(): void;\n    private formatCacheKey;\n    private has;\n    private get;\n    private put;\n    private remove;\n    private validateAddress;\n    private validateContract;\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Get the block's hash, its unique identifier.\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-hash\n     */\n    getBlockHash({ block }?: RPCOptions): Promise<string>;\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description List the ancestors of the given block which, if referred to as the branch in an operation header, are recent enough for that operation to be included in the current block.\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-live-blocks\n     */\n    getLiveBlocks({ block }?: RPCOptions): Promise<string[]>;\n    /**\n     * @param address address from which we want to retrieve the spendable balance\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description The spendable balance of a contract (in mutez), also known as liquid balance. Corresponds to tez owned by the contract that are neither staked, nor in unstaked requests, nor in frozen bonds. Identical to the 'spendable' RPC.\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-contracts-contract-id-balance\n     */\n    getBalance(address: string, { block }?: RPCOptions): Promise<BalanceResponse>;\n    /**\n     * @param address address from which we want to retrieve the balance\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description The spendable balance of a contract (in mutez), also known as liquid balance. Corresponds to tez owned by the contract that are neither staked, nor in unstaked requests, nor in frozen bonds. Identical to the 'balance' RPC.\n     */\n    getSpendable(address: string, { block }?: RPCOptions): Promise<BalanceResponse>;\n    /**\n     * @param address address from which we want to retrieve balance and frozen bonds\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description The sum (in mutez) of the spendable balance and frozen bonds of a contract. Corresponds to the contract's full balance from which staked funds and unstake requests have been excluded. Identical to the 'spendable_and_frozen_bonds' RPC.\n     */\n    getBalanceAndFrozenBonds(address: string, { block }?: RPCOptions): Promise<BalanceResponse>;\n    /**\n     * @param address address from which we want to retrieve spendable and frozen bonds\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description The sum (in mutez) of the spendable balance and frozen bonds of a contract. Corresponds to the contract's full balance from which staked funds and unstake requests have been excluded. Identical to the 'balance_and_frozen_bonds' RPC.\n     */\n    getSpendableAndFrozenBonds(address: string, { block }?: RPCOptions): Promise<BalanceResponse>;\n    /**\n     * @param address address from which we want to retrieve the full balance\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the full balance of a contract, including frozen bonds and stake.\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-contracts-contract-id-full-balance\n     */\n    getFullBalance(address: string, { block }?: RPCOptions): Promise<BalanceResponse>;\n    /**\n     * @param address address from which we want to retrieve the staked balance\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the staked balance of a contract. Returns None if the contract is originated, or neither delegated nor a delegate.\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-contracts-contract-id-staked-balance\n     */\n    getStakedBalance(address: string, { block }?: RPCOptions): Promise<BalanceResponse>;\n    /**\n     * @param address address from which we want to retrieve the unstaked finalizable balance\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the balance of a contract that was requested for an unstake operation, and is no longer frozen, which means it will appear in the spendable balance of the contract after any stake/unstake/finalize_unstake operation. Returns None if the contract is originated.\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-contracts-contract-id-unstaked-finalizable-balance\n     */\n    getUnstakedFinalizableBalance(address: string, { block }?: RPCOptions): Promise<BalanceResponse>;\n    /**\n     * @param address address from which we want to retrieve the unstaked frozen balance\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the balance of a contract that was requested for an unstake operation, but is still frozen for the duration of the slashing period. Returns None if the contract is originated.\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-contracts-contract-id-unstaked-frozen-balance\n     */\n    getUnstakedFrozenBalance(address: string, { block }?: RPCOptions): Promise<BalanceResponse>;\n    /**\n     * @param address address from which we want to retrieve the unstake requests\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the unstake requests of the contract. The requests that appear in the finalizable field can be finalized, which means that the contract can transfer these (no longer frozen) funds to their spendable balance with a [finalize_unstake] operation call. Returns null if there is no unstake request pending.\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-contracts-contract-id-unstake-requests\n     */\n    getUnstakeRequests(address: string, { block }?: RPCOptions): Promise<UnstakeRequestsResponse>;\n    /**\n     * @param address contract address from which we want to retrieve the storage\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the data of the contract.\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-contracts-contract-id-storage\n     */\n    getStorage(address: string, { block }?: {\n        block: string;\n    }): Promise<StorageResponse>;\n    /**\n     * @param address contract address from which we want to retrieve the script\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the code and data of the contract.\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-contracts-contract-id-script\n     */\n    getScript(address: string, { block }?: {\n        block: string;\n    }): Promise<ScriptResponse>;\n    /**\n     * @param address contract address from which we want to retrieve the script\n     * @param unparsingMode default is { unparsing_mode: \"Readable\" }\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the script of the contract and normalize it using the requested unparsing mode.\n     */\n    getNormalizedScript(address: string, unparsingMode?: UnparsingMode, { block }?: {\n        block: string;\n    }): Promise<ScriptResponse>;\n    /**\n     * @param address contract address from which we want to retrieve\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the complete status of a contract.\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-contracts-contract-id\n     */\n    getContract(address: string, { block }?: {\n        block: string;\n    }): Promise<ContractResponse>;\n    /**\n     * @param address contract address from which we want to retrieve the manager\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the manager of an implicit contract\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-contracts-contract-id-manager-key\n     */\n    getManagerKey(address: string, { block }?: {\n        block: string;\n    }): Promise<ManagerKeyResponse>;\n    /**\n     * @param address contract address from which we want to retrieve the delegate (baker)\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the delegate of a contract, if any\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-contracts-contract-id-delegate\n     */\n    getDelegate(address: string, { block }?: {\n        block: string;\n    }): Promise<DelegateResponse>;\n    /**\n     * @deprecated Deprecated in favor of getBigMapKeyByID\n     * @param address contract address from which we want to retrieve the big map key\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the value associated with a key in the big map storage of the contract.\n     * @see https://tezos.gitlab.io/active/rpc.html#post-block-id-context-contracts-contract-id-big-map-get\n     */\n    getBigMapKey(address: string, key: BigMapKey, { block }?: {\n        block: string;\n    }): Promise<BigMapGetResponse>;\n    /**\n     * @param id Big Map ID\n     * @param expr Expression hash to query (A b58check encoded Blake2b hash of the expression (The expression can be packed using the pack_data method))\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the value associated with a key in a big map.\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-big-maps-big-map-id-script-expr\n     */\n    getBigMapExpr(id: string, expr: string, { block }?: {\n        block: string;\n    }): Promise<BigMapResponse>;\n    /**\n     * @param args contains optional query arguments (active, inactive, with_minimal_stake, without_minimal_stake)\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Lists all registered delegates by default with query arguments to filter unneeded values.\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-delegates-pkh\n     */\n    getAllDelegates(args?: AllDelegatesQueryArguments, { block }?: {\n        block: string;\n    }): Promise<string[]>;\n    /**\n     * @param address delegate address which we want to retrieve\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Everything about a delegate\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-delegates-pkh\n     */\n    getDelegates(address: string, { block }?: {\n        block: string;\n    }): Promise<DelegatesResponse>;\n    /**\n     * @param address delegate address which we want to retrieve\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Returns the delegate info (e.g. voting power) found in the listings of the current voting period\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-delegates-pkh-voting-info\n     */\n    getVotingInfo(address: string, { block }?: {\n        block: string;\n    }): Promise<VotingInfoResponse>;\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description All constants\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-constants\n     */\n    getConstants({ block }?: RPCOptions): Promise<ConstantsResponse>;\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head) and version.\n     * @description All the information about a block\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id\n     * @example getBlock() will default to `/main/chains/block/head?version=1`\n     * @example getBlock({ block: 'head~2') will return an offset of 2 from head blocks\n     * @example getBlock({ block: 'BL8fTiWcSxWCjiMVnDkbh6EuhqVPZzgWheJ2dqwrxYRm9AephXh~2' }) will return an offset of 2 blocks from given block hash..\n     */\n    getBlock({ block }?: RPCOptions): Promise<BlockResponse>;\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description The whole block header\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-header\n     */\n    getBlockHeader({ block }?: RPCOptions): Promise<BlockHeaderResponse>;\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head) and version\n     * @description All the metadata associated to the block\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-metadata\n     */\n    getBlockMetadata({ block }?: RPCOptions): Promise<BlockMetadata>;\n    /**\n     * @param args contains optional query arguments (level, cycle, delegate, consensus_key, and max_round)\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Retrieves the list of delegates allowed to bake a block.\n     * @see https://gitlab.com/tezos/tezos/-/blob/master/docs/api/alpha-openapi.json\n     */\n    getBakingRights(args?: BakingRightsQueryArguments, { block }?: RPCOptions): Promise<BakingRightsResponse>;\n    /**\n     * @param args contains optional query arguments (level, cycle, delegate, and consensus_key)\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Retrieves the delegates allowed to attest a block\n     * @see https://gitlab.com/tezos/tezos/-/blob/master/docs/api/alpha-openapi.json\n     */\n    getAttestationRights(args?: AttestationRightsQueryArguments, { block }?: RPCOptions): Promise<AttestationRightsResponse>;\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Ballots casted so far during a voting period\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-votes-ballot-list\n     */\n    getBallotList({ block }?: RPCOptions): Promise<BallotListResponse>;\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Sum of ballots casted so far during a voting period\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-votes-ballots\n     */\n    getBallots({ block }?: RPCOptions): Promise<BallotsResponse>;\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Current proposal under evaluation.\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-votes-current-proposal\n     */\n    getCurrentProposal({ block, }?: RPCOptions): Promise<CurrentProposalResponse>;\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Current expected quorum.\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-votes-current-quorum\n     */\n    getCurrentQuorum({ block, }?: RPCOptions): Promise<CurrentQuorumResponse>;\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description List of delegates with their voting power\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-votes-listings\n     */\n    getVotesListings({ block, }?: RPCOptions): Promise<VotesListingsResponse>;\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description List of proposals with number of supporters\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-votes-proposals\n     */\n    getProposals({ block }?: RPCOptions): Promise<ProposalsResponse>;\n    /**\n     * @param data operation contents to forge\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Forge an operation returning the unsigned bytes\n     * @see https://gitlab.com/tezos/tezos/-/blob/master/docs/api/alpha-openapi.json\n     */\n    forgeOperations(data: ForgeOperationsParams, { block }?: RPCOptions): Promise<string>;\n    /**\n     * @param signedOpBytes signed bytes to inject\n     * @description Inject an operation in node and broadcast it and return the ID of the operation\n     * @see https://tezos.gitlab.io/shell/rpc.html#post-injection-operation\n     */\n    injectOperation(signedOpBytes: string): Promise<OperationHash>;\n    /**\n     * @param ops Operations to apply\n     * @param options contains generic configuration for rpc calls to specified block and version\n     * @description Simulate the application of the operations with the context of the given block and return the result of each operation application\n     * @see https://tezos.gitlab.io/active/rpc.html#post-block-id-helpers-preapply-operations\n     */\n    preapplyOperations(ops: PreapplyParams, { block }?: RPCOptions): Promise<PreapplyResponse[]>;\n    /**\n     * @param contract address of the contract we want to get the entrypoints of\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Return the list of entrypoints of the contract\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-contracts-contract-id-entrypoints\n     * @version 005_PsBABY5H\n     */\n    getEntrypoints(contract: string, { block }?: RPCOptions): Promise<EntrypointsResponse>;\n    /**\n     * @deprecated Deprecated in favor of simulateOperation\n     * @param op Operation to run\n     * @param options contains generic configuration for rpc calls to specified block and version\n     * @description Run an operation with the context of the given block and without signature checks and return the operation application result, including the consumed gas.\n     * @see https://gitlab.com/tezos/tezos/-/blob/master/docs/api/alpha-openapi.json\n     */\n    runOperation(op: RPCRunOperationParam, { block }?: RPCOptions): Promise<PreapplyResponse>;\n    /**\n     * @param op Operation to simulate\n     * @param options contains generic configuration for rpc calls to specified block and version\n     * @description Simulate running an operation at some future moment (based on the number of blocks given in the `latency` argument), and return the operation application result.\n     * @see https://gitlab.com/tezos/tezos/-/blob/master/docs/api/alpha-openapi.json\n     */\n    simulateOperation(op: RPCSimulateOperationParam, { block }?: RPCOptions): Promise<PreapplyResponse>;\n    /**\n     * @param code Code to run\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Run a Michelson script in the current context\n     * @see https://gitlab.com/tezos/tezos/-/blob/master/docs/api/alpha-openapi.json\n     */\n    runCode(code: RPCRunCodeParam, { block }?: RPCOptions): Promise<RunCodeResult>;\n    /**\n     * @param viewScriptParams Parameters of the script view to run\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Simulate a call to a michelson view\n     * @see https://gitlab.com/tezos/tezos/-/blob/master/docs/api/alpha-openapi.json\n     */\n    runScriptView({ unparsing_mode, ...rest }: RPCRunScriptViewParam, { block }?: RPCOptions): Promise<RunScriptViewResult>;\n    /**\n     * @param viewParams Parameters of the view to run\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Simulate a call to a view following the TZIP-4 standard.\n     * @see https://gitlab.com/tezos/tezos/-/blob/master/docs/api/alpha-openapi.json\n     */\n    runView({ unparsing_mode, ...rest }: RPCRunViewParam, { block }?: RPCOptions): Promise<RunViewResult>;\n    getChainId(): Promise<any>;\n    /**\n     * @param data Data to pack\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Computes the serialized version of a data expression using the same algorithm as script instruction PACK\n     * Note: You should always verify the packed bytes before signing or requesting that they be signed when using the RPC to pack.\n     * This precaution helps protect you and your applications users from RPC nodes that have been compromised.\n     * A node that is operated by a bad actor, or compromised by a bad actor could return a fully formed operation that does not correspond to the input provided to the RPC endpoint.\n     * A safer solution to pack and sign data would be to use the `packDataBytes` function available in the `@taquito/michel-codec` package.\n     * @example packData({ data: { string: \"test\" }, type: { prim: \"string\" } })\n     * @see https://gitlab.com/tezos/tezos/-/blob/master/docs/api/alpha-openapi.json\n     */\n    packData(data: PackDataParams, { block }?: RPCOptions): Promise<{\n        packed: string;\n        gas: BigNumber | 'unaccounted' | undefined;\n    }>;\n    /**\n     *\n     * @description Return rpc root url\n     */\n    getRpcUrl(): string;\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Returns the voting period (index, kind, starting position) and related information (position, remaining) of the interrogated block\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-votes-current-period\n     */\n    getCurrentPeriod({ block, }?: RPCOptions): Promise<VotingPeriodBlockResult>;\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Returns the voting period (index, kind, starting position) and related information (position, remaining) of the next block.Useful to craft operations that will be valid in the next block\n     * @example getSuccessorPeriod() will default to successor voting period for /main/chains/block/head.\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-votes-successor-period\n     */\n    getSuccessorPeriod({ block, }?: RPCOptions): Promise<VotingPeriodBlockResult>;\n    /**\n     * @param id Sapling state ID\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Returns the root and a diff of a state starting from an optional offset which is zero by default\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-sapling-sapling-state-id-get-diff\n     */\n    getSaplingDiffById(id: string, { block }?: {\n        block: string;\n    }): Promise<SaplingDiffResponse>;\n    /**\n     * @param contract address of the contract we want to get the sapling diff\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Returns the root and a diff of a state starting from an optional offset which is zero by default\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-contracts-contract-id-single-sapling-get-diff\n     */\n    getSaplingDiffByContract(contract: string, { block }?: {\n        block: string;\n    }): Promise<SaplingDiffResponse>;\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description get current and next protocol\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-protocols\n     */\n    getProtocols({ block }?: {\n        block: string;\n    }): Promise<ProtocolsResponse>;\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description get current and next protocol\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-protocols\n     */\n    getProtocolActivations(protocol?: string): Promise<ProtocolActivationsResponse>;\n    /**\n     * @param contract address of the contract we want to retrieve storage information of\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the used storage space of the contract\n     * @see https://gitlab.com/tezos/tezos/-/blob/master/docs/api/alpha-openapi.json\n     */\n    getStorageUsedSpace(contract: string, { block }?: {\n        block: string;\n    }): Promise<string>;\n    /**\n     * @param contract address of the contract we want to retrieve storage information of\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n  =   * @description Access the paid storage space of the contract\n     * @see https://gitlab.com/tezos/tezos/-/blob/master/docs/api/alpha-openapi.json\n     */\n    getStoragePaidSpace(contract: string, { block }?: {\n        block: string;\n    }): Promise<string>;\n    /**\n     * @param contract implicit or originated address we want to retrieve ticket balance of\n     * @param ticket object to specify a ticket by ticketer, content type and content\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the contract's balance of ticket with specified ticketer, content type, and content.\n     * @example ticket { ticketer: 'address', content_type: { prim: \"string\" }, content: { string: 'ticket1' } }\n     * @see https://gitlab.com/tezos/tezos/-/blob/master/docs/api/alpha-openapi.json\n     */\n    getTicketBalance(contract: string, ticket: TicketTokenParams, { block }?: RPCOptions): Promise<string>;\n    /**\n     * @param contract originated address we want to retrieve ticket balances of\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the complete list of tickets owned by the given contract by scanning the contract's storage.\n     * @see https://gitlab.com/tezos/tezos/-/blob/master/docs/api/alpha-openapi.json\n     */\n    getAllTicketBalances(contract: string, { block }?: RPCOptions): Promise<AllTicketBalances>;\n    /**\n     * @description Returns the cycle at which the launch of the Adaptive Issuance feature is set to happen. A result of null means that the feature is not yet set to launch.\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-adaptive-issuance-launch-cycle\n     */\n    getAdaptiveIssuanceLaunchCycle({ block, }?: RPCOptions): Promise<AILaunchCycleResponse>;\n    /**\n     * @description List the prevalidated operations in mempool (accessibility of mempool depends on each rpc endpoint)\n     * @param args has 5 optional properties\n     * @default args { version: '2', validated: true, refused: true, outdated, true, branchRefused: true, branchDelayed: true, validationPass: undefined }\n     */\n    getPendingOperations(args?: PendingOperationsQueryArguments): Promise<PendingOperationsV2>;\n}\nexport {};\n"},{name:"@taquito/rpc/dist/types/utils/utils.d.ts",dts:"/**\n * Casts object/array items to BigNumber\n * @param data input object or array\n * @param keys keys for processing or all items if not defined\n *\n */\nexport declare function castToBigNumber(data: any, keys?: any): object;\n/**\n * Casts object/array BigNumber items to strings for readability\n * @param data input object or array\n * @param keys keys for processing or all items if not defined\n *\n */\nexport declare function castToString(data: any, keys?: any): object;\n"},{name:"@taquito/rpc/dist/types/opkind.d.ts",dts:'export declare enum OpKind {\n    ORIGINATION = "origination",\n    DELEGATION = "delegation",\n    REVEAL = "reveal",\n    TRANSACTION = "transaction",\n    ACTIVATION = "activate_account",\n    ATTESTATION = "attestation",\n    ENDORSEMENT = "endorsement",\n    PREATTESTATION = "preattestation",\n    PREENDORSEMENT = "preendorsement",\n    SET_DEPOSITS_LIMIT = "set_deposits_limit",\n    DOUBLE_PREATTESTATION_EVIDENCE = "double_preattestation_evidence",\n    DOUBLE_PREENDORSEMENT_EVIDENCE = "double_preendorsement_evidence",\n    ATTESTATION_WITH_DAL = "attestation_with_dal",\n    ENDORSEMENT_WITH_DAL = "endorsement_with_dal",\n    SEED_NONCE_REVELATION = "seed_nonce_revelation",\n    DOUBLE_ATTESTATION_EVIDENCE = "double_attestation_evidence",\n    DOUBLE_ENDORSEMENT_EVIDENCE = "double_endorsement_evidence",\n    DOUBLE_BAKING_EVIDENCE = "double_baking_evidence",\n    PROPOSALS = "proposals",\n    BALLOT = "ballot",\n    FAILING_NOOP = "failing_noop",\n    REGISTER_GLOBAL_CONSTANT = "register_global_constant",\n    TRANSFER_TICKET = "transfer_ticket",\n    INCREASE_PAID_STORAGE = "increase_paid_storage",\n    UPDATE_CONSENSUS_KEY = "update_consensus_key",\n    DRAIN_DELEGATE = "drain_delegate",\n    VDF_REVELATION = "vdf_revelation",\n    EVENT = "event",\n    TICKET_UPDATES = "ticket_updates",\n    SMART_ROLLUP_ORIGINATE = "smart_rollup_originate",\n    SMART_ROLLUP_ADD_MESSAGES = "smart_rollup_add_messages",\n    SMART_ROLLUP_EXECUTE_OUTBOX_MESSAGE = "smart_rollup_execute_outbox_message",\n    SMART_ROLLUP_PUBLISH = "smart_rollup_publish",\n    SMART_ROLLUP_CEMENT = "smart_rollup_cement",\n    SMART_ROLLUP_RECOVER_BOND = "smart_rollup_recover_bond",\n    SMART_ROLLUP_REFUTE = "smart_rollup_refute",\n    SMART_ROLLUP_TIMEOUT = "smart_rollup_timeout",\n    DAL_PUBLISH_COMMITMENT = "dal_publish_commitment",\n    DAL_ENTRAPMENT_EVIDENCE = "dal_entrapment_evidence",\n    PREATTESTATIONS_AGGREGATE = "preattestations_aggregate",\n    ATTESTATIONS_AGGREGATE = "attestations_aggregate",\n    UPDATE_COMPANION_KEY = "update_companion_key",\n    DOUBLE_CONSENSUS_OPERATION_EVIDENCE = "double_consensus_operation_evidence"\n}\n'},{name:"@taquito/rpc/dist/types/rpc-client-interface.d.ts",dts:'import { BigNumber } from \'bignumber.js\';\nimport { BakingRightsQueryArguments, BakingRightsResponse, BalanceResponse, UnstakeRequestsResponse, BallotListResponse, BallotsResponse, BigMapGetResponse, BigMapKey, BigMapResponse, BlockHeaderResponse, BlockMetadata, BlockResponse, ConstantsResponse, ContractResponse, CurrentProposalResponse, CurrentQuorumResponse, DelegateResponse, DelegatesResponse, AttestationRightsQueryArguments, AttestationRightsResponse, EntrypointsResponse, ForgeOperationsParams, ManagerKeyResponse, OperationHash, PackDataParams, PreapplyParams, PreapplyResponse, ProposalsResponse, ProtocolsResponse, RPCRunCodeParam, RPCRunOperationParam, RPCRunScriptViewParam, RPCRunViewParam, RunCodeResult, RunScriptViewResult, RunViewResult, SaplingDiffResponse, ScriptResponse, StorageResponse, UnparsingMode, VotesListingsResponse, VotingInfoResponse, VotingPeriodBlockResult, TicketTokenParams, AllTicketBalances, PendingOperationsV2, PendingOperationsQueryArguments, RPCSimulateOperationParam, AILaunchCycleResponse, AllDelegatesQueryArguments, ProtocolActivationsResponse } from \'./types\';\nexport interface RPCOptions {\n    block: string;\n    version?: 1 | \'1\';\n}\nexport declare const defaultChain = "main";\nexport declare const defaultRPCOptions: RPCOptions;\nexport interface RpcClientInterface {\n    getBlockHash(options?: RPCOptions): Promise<string>;\n    getLiveBlocks(options?: RPCOptions): Promise<string[]>;\n    getBalance(address: string, options?: RPCOptions): Promise<BalanceResponse>;\n    getSpendable(address: string, options?: RPCOptions): Promise<BalanceResponse>;\n    getBalanceAndFrozenBonds(address: string, options?: RPCOptions): Promise<BalanceResponse>;\n    getSpendableAndFrozenBonds(address: string, options?: RPCOptions): Promise<BalanceResponse>;\n    getFullBalance(address: string, options?: RPCOptions): Promise<BalanceResponse>;\n    getStakedBalance(address: string, options?: RPCOptions): Promise<BalanceResponse>;\n    getUnstakedFinalizableBalance(address: string, options?: RPCOptions): Promise<BalanceResponse>;\n    getUnstakedFrozenBalance(address: string, options?: RPCOptions): Promise<BalanceResponse>;\n    getUnstakeRequests(address: string, options?: RPCOptions): Promise<UnstakeRequestsResponse>;\n    getStorage(address: string, options?: RPCOptions): Promise<StorageResponse>;\n    getScript(address: string, options?: RPCOptions): Promise<ScriptResponse>;\n    getNormalizedScript(address: string, unparsingMode?: UnparsingMode, options?: RPCOptions): Promise<ScriptResponse>;\n    getContract(address: string, options?: RPCOptions): Promise<ContractResponse>;\n    getManagerKey(address: string, options?: RPCOptions): Promise<ManagerKeyResponse>;\n    getDelegate(address: string, options?: RPCOptions): Promise<DelegateResponse>;\n    getBigMapKey(address: string, key: BigMapKey, options?: RPCOptions): Promise<BigMapGetResponse>;\n    getBigMapExpr(id: string, expr: string, options?: RPCOptions): Promise<BigMapResponse>;\n    getAllDelegates(args: AllDelegatesQueryArguments, options?: RPCOptions): Promise<string[]>;\n    getDelegates(address: string, options?: RPCOptions): Promise<DelegatesResponse>;\n    getVotingInfo(address: string, options?: RPCOptions): Promise<VotingInfoResponse>;\n    getConstants(options?: RPCOptions): Promise<ConstantsResponse>;\n    getBlock(options?: RPCOptions): Promise<BlockResponse>;\n    getBlockHeader(options?: RPCOptions): Promise<BlockHeaderResponse>;\n    getBlockMetadata(options?: RPCOptions): Promise<BlockMetadata>;\n    getBakingRights(args: BakingRightsQueryArguments, options?: RPCOptions): Promise<BakingRightsResponse>;\n    getAttestationRights(args: AttestationRightsQueryArguments, options?: RPCOptions): Promise<AttestationRightsResponse>;\n    getBallotList(options?: RPCOptions): Promise<BallotListResponse>;\n    getBallots(options?: RPCOptions): Promise<BallotsResponse>;\n    getCurrentProposal(options?: RPCOptions): Promise<CurrentProposalResponse>;\n    getCurrentQuorum(options?: RPCOptions): Promise<CurrentQuorumResponse>;\n    getVotesListings(options?: RPCOptions): Promise<VotesListingsResponse>;\n    getProposals(options?: RPCOptions): Promise<ProposalsResponse>;\n    forgeOperations(data: ForgeOperationsParams, options?: RPCOptions): Promise<string>;\n    injectOperation(signedOpBytes: string): Promise<OperationHash>;\n    preapplyOperations(ops: PreapplyParams, options?: RPCOptions): Promise<PreapplyResponse[]>;\n    getEntrypoints(contract: string, options?: RPCOptions): Promise<EntrypointsResponse>;\n    runOperation(op: RPCRunOperationParam, options?: RPCOptions): Promise<PreapplyResponse>;\n    simulateOperation(op: RPCSimulateOperationParam, options?: RPCOptions): Promise<PreapplyResponse>;\n    runCode(code: RPCRunCodeParam, options?: RPCOptions): Promise<RunCodeResult>;\n    runScriptView(viewScriptParams: RPCRunScriptViewParam, options?: RPCOptions): Promise<RunScriptViewResult>;\n    runView(viewParams: RPCRunViewParam, options?: RPCOptions): Promise<RunViewResult>;\n    getChainId(): Promise<string>;\n    packData(data: PackDataParams, options?: RPCOptions): Promise<{\n        packed: string;\n        gas: BigNumber | \'unaccounted\' | undefined;\n    }>;\n    getRpcUrl(): string;\n    getCurrentPeriod(options?: RPCOptions): Promise<VotingPeriodBlockResult>;\n    getSuccessorPeriod(options?: RPCOptions): Promise<VotingPeriodBlockResult>;\n    getSaplingDiffById(id: string, options?: RPCOptions): Promise<SaplingDiffResponse>;\n    getSaplingDiffByContract(contract: string, options?: RPCOptions): Promise<SaplingDiffResponse>;\n    getProtocols(options?: RPCOptions): Promise<ProtocolsResponse>;\n    getProtocolActivations(protocol?: string): Promise<ProtocolActivationsResponse>;\n    getStorageUsedSpace(contract: string, options?: RPCOptions): Promise<string>;\n    getStoragePaidSpace(contract: string, options?: RPCOptions): Promise<string>;\n    getTicketBalance(contract: string, ticket: TicketTokenParams, options?: RPCOptions): Promise<string>;\n    getAllTicketBalances(contract: string, options?: RPCOptions): Promise<AllTicketBalances>;\n    getAdaptiveIssuanceLaunchCycle(options?: RPCOptions): Promise<AILaunchCycleResponse>;\n    getPendingOperations(args: PendingOperationsQueryArguments): Promise<PendingOperationsV2>;\n}\nexport declare enum RPCMethodName {\n    GET_BAKING_RIGHTS = "getBakingRights",\n    GET_BALLOTS = "getBallots",\n    GET_BALLOT_LIST = "getBallotList",\n    GET_BIG_MAP_KEY = "getBigMapKey",\n    GET_BIG_MAP_EXPR = "getBigMapExpr",\n    GET_BLOCK_HASH = "getBlockHash",\n    GET_BLOCK = "getBlock",\n    GET_BLOCK_HEADER = "getBlockHeader",\n    GET_BLOCK_METADATA = "getBlockMetadata",\n    GET_BALANCE = "getBalance",\n    GET_SPENDABLE = "getSpendable",\n    GET_BALANCE_AND_FROZEN_BONDS = "getBalanceAndFrozenBonds",\n    GET_SPENDABLE_AND_FROZEN_BONDS = "getSpendableAndFrozenBonds",\n    GET_FULL_BALANCE = "getFullBalance",\n    GET_STAKED_BALANCE = "getStakedBalance",\n    GET_UNSTAKED_FINALIZABLE_BALANCE = "getUnstakedFinalizableBalance",\n    GET_UNSTAKED_FROZEN_BALANCE = "getUnstakedFrozenBalance",\n    GET_UNSTAKE_REQUESTS = "getUnstakeRequests",\n    GET_CHAIN_ID = "getChainId",\n    GET_CONSTANTS = "getConstants",\n    GET_CONTRACT = "getContract",\n    GET_CURRENT_PERIOD = "getCurrentPeriod",\n    GET_CURRENT_PROPOSAL = "getCurrentProposal",\n    GET_CURRENT_QUORUM = "getCurrentQuorum",\n    GET_DELEGATE = "getDelegate",\n    GET_ALL_DELEGATES = "getAllDelegates",\n    GET_DELEGATES = "getDelegates",\n    GET_VOTING_INFO = "getVotingInfo",\n    GET_ATTESTATION_RIGHTS = "getAttestationRights",\n    GET_ENTRYPOINTS = "getEntrypoints",\n    GET_LIVE_BLOCKS = "getLiveBlocks",\n    GET_MANAGER_KEY = "getManagerKey",\n    GET_NORMALIZED_SCRIPT = "getNormalizedScript",\n    GET_PROPOSALS = "getProposals",\n    GET_PROTOCOLS = "getProtocols",\n    GET_SAPLING_DIFF_BY_CONTRACT = "getSaplingDiffByContract",\n    GET_PROTOCOL_ACTIVATIONS = "getProtocolActivations",\n    GET_SAPLING_DIFF_BY_ID = "getSaplingDiffById",\n    GET_SCRIPT = "getScript",\n    GET_STORAGE = "getStorage",\n    GET_SUCCESSOR_PERIOD = "getSuccessorPeriod",\n    GET_VOTES_LISTINGS = "getVotesListings",\n    PACK_DATA = "packData",\n    GET_STORAGE_USED_SPACE = "getStorageUsedSpace",\n    GET_STORAGE_PAID_SPACE = "getStoragePaidSpace",\n    GET_TICKET_BALANCE = "getTicketBalance",\n    GET_ALL_TICKET_BALANCES = "getAllTicketBalances",\n    GET_ADAPTIVE_ISSUANCE_LAUNCH_CYCLE = "getAdaptiveIssuanceLaunchCycle",\n    GET_PENDING_OPERATIONS = "getPendingOperations"\n}\n'},{name:"@taquito/rpc/dist/types/taquito-rpc.d.ts",dts:"/**\n * @packageDocumentation\n * @module @taquito/rpc\n */\nimport { HttpBackend } from '@taquito/http-utils';\nimport BigNumber from 'bignumber.js';\nimport { RpcClientInterface, RPCOptions } from './rpc-client-interface';\nimport { BakingRightsQueryArguments, BakingRightsResponse, BalanceResponse, UnstakeRequestsResponse, BallotListResponse, BallotsResponse, BigMapGetResponse, BigMapKey, BigMapResponse, BlockHeaderResponse, BlockMetadata, BlockResponse, ConstantsResponse, ContractResponse, CurrentProposalResponse, CurrentQuorumResponse, DelegateResponse, DelegatesResponse, VotingInfoResponse, AttestationRightsQueryArguments, AttestationRightsResponse, EntrypointsResponse, ForgeOperationsParams, ManagerKeyResponse, OperationHash, PackDataParams, PreapplyParams, PreapplyResponse, ProposalsResponse, ProtocolsResponse, RPCRunCodeParam, RPCRunOperationParam, RPCRunViewParam, RPCRunScriptViewParam, RunCodeResult, RunViewResult, RunScriptViewResult, SaplingDiffResponse, ScriptResponse, StorageResponse, UnparsingMode, VotesListingsResponse, VotingPeriodBlockResult, TicketTokenParams, AllTicketBalances, PendingOperationsQueryArguments, PendingOperationsV2, RPCSimulateOperationParam, AILaunchCycleResponse, AllDelegatesQueryArguments, ProtocolActivationsResponse } from './types';\nexport { castToBigNumber } from './utils/utils';\nexport { RPCOptions, defaultChain, defaultRPCOptions, RpcClientInterface, } from './rpc-client-interface';\nexport { RpcClientCache } from './rpc-client-modules/rpc-cache';\nexport * from './types';\nexport { OpKind } from './opkind';\nexport { VERSION } from './version';\n/***\n * @description RpcClient allows interaction with Tezos network through an rpc node\n */\nexport declare class RpcClient implements RpcClientInterface {\n    protected url: string;\n    protected chain: string;\n    protected httpBackend: HttpBackend;\n    /**\n     *\n     * @param url rpc root url\n     * @param chain chain (default main)\n     * @param httpBackend Http backend that issue http request.\n     * You can override it by providing your own if you which to hook in the request/response\n     *\n     * @example new RpcClient('https://mainnet.tezos.ecadinfra.com/', 'main') this will use https://mainnet.tezos.ecadinfra.com//chains/main\n     */\n    constructor(url: string, chain?: string, httpBackend?: HttpBackend);\n    protected createURL(path: string): string;\n    private validateAddress;\n    private validateContract;\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Get the block's hash, its unique identifier.\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-hash\n     */\n    getBlockHash({ block }?: RPCOptions): Promise<string>;\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description List the ancestors of the given block which, if referred to as the branch in an operation header, are recent enough for that operation to be included in the current block.\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-live-blocks\n     */\n    getLiveBlocks({ block }?: RPCOptions): Promise<string[]>;\n    /**\n     * @param address address from which we want to retrieve the spendable balance\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description The spendable balance of a contract (in mutez), also known as liquid balance. Corresponds to tez owned by the contract that are neither staked, nor in unstaked requests, nor in frozen bonds. Identical to the 'spendable' RPC.\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-contracts-contract-id-balance\n     */\n    getBalance(address: string, { block }?: RPCOptions): Promise<BalanceResponse>;\n    /**\n     * @param address address from which we want to retrieve the spendable balance\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description The spendable balance of a contract (in mutez), also known as liquid balance. Corresponds to tez owned by the contract that are neither staked, nor in unstaked requests, nor in frozen bonds. Identical to the 'balance' RPC.\n     */\n    getSpendable(address: string, { block }?: RPCOptions): Promise<BalanceResponse>;\n    /**\n     * @param address address from which we want to retrieve balance and frozen bonds\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description The sum (in mutez) of the spendable balance and frozen bonds of a contract. Corresponds to the contract's full balance from which staked funds and unstake requests have been excluded. Identical to the 'spendable_and_frozen_bonds' RPC.\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-contracts-contract-id-full-balance\n     */\n    getBalanceAndFrozenBonds(address: string, { block }?: RPCOptions): Promise<BalanceResponse>;\n    /**\n     * @param address address from which we want to retrieve spendable and frozen bonds\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description The sum (in mutez) of the spendable balance and frozen bonds of a contract. Corresponds to the contract's full balance from which staked funds and unstake requests have been excluded. Identical to the 'balance_and_frozen_bonds' RPC.\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-contracts-contract-id-full-balance\n     */\n    getSpendableAndFrozenBonds(address: string, { block }?: RPCOptions): Promise<BalanceResponse>;\n    /**\n     * @param address address from which we want to retrieve the full balance\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the full balance of a contract, including frozen bonds and stake.\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-contracts-contract-id-full-balance\n     */\n    getFullBalance(address: string, { block }?: RPCOptions): Promise<BalanceResponse>;\n    /**\n     * @param address address from which we want to retrieve the staked balance\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the staked balance of a contract. Returns None if the contract is originated, or neither delegated nor a delegate.\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-contracts-contract-id-staked-balance\n     */\n    getStakedBalance(address: string, { block }?: RPCOptions): Promise<BalanceResponse>;\n    /**\n     * @param address address from which we want to retrieve the unstaked finalizable balance\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the balance of a contract that was requested for an unstake operation, and is no longer frozen, which means it will appear in the spendable balance of the contract after any stake/unstake/finalize_unstake operation. Returns None if the contract is originated.\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-contracts-contract-id-unstaked-finalizable-balance\n     */\n    getUnstakedFinalizableBalance(address: string, { block }?: RPCOptions): Promise<BalanceResponse>;\n    /**\n     * @param address address from which we want to retrieve the unstaked frozen balance\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the balance of a contract that was requested for an unstake operation, but is still frozen for the duration of the slashing period. Returns None if the contract is originated.\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-contracts-contract-id-unstaked-frozen-balance\n     */\n    getUnstakedFrozenBalance(address: string, { block }?: RPCOptions): Promise<BalanceResponse>;\n    /**\n     * @param address address from which we want to retrieve the unstaked requests\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the unstake requests of the contract. The requests that appear in the finalizable field can be finalized, which means that the contract can transfer these (no longer frozen) funds to their spendable balance with a [finalize_unstake] operation call. Returns null if there is no unstake request pending.\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-contracts-contract-id-unstake-requests\n     */\n    getUnstakeRequests(address: string, { block }?: RPCOptions): Promise<UnstakeRequestsResponse>;\n    /**\n     * @param address contract address from which we want to retrieve the storage\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the data of the contract.\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-contracts-contract-id-storage\n     */\n    getStorage(address: string, { block }?: {\n        block: string;\n    }): Promise<StorageResponse>;\n    /**\n     * @param address contract address from which we want to retrieve the script\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the code and data of the contract.\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-contracts-contract-id-script\n     */\n    getScript(address: string, { block }?: {\n        block: string;\n    }): Promise<ScriptResponse>;\n    /**\n     * @param address contract address from which we want to retrieve the script\n     * @param unparsingMode default is { unparsing_mode: \"Readable\" }\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the script of the contract and normalize it using the requested unparsing mode.\n     */\n    getNormalizedScript(address: string, unparsingMode?: UnparsingMode, { block }?: {\n        block: string;\n    }): Promise<ScriptResponse>;\n    /**\n     * @param address contract address from which we want to retrieve\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the complete status of a contract.\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-contracts-contract-id\n     */\n    getContract(address: string, { block }?: {\n        block: string;\n    }): Promise<ContractResponse>;\n    /**\n     * @param address contract address from which we want to retrieve the manager\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the manager of an implicit contract\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-contracts-contract-id-manager-key\n     */\n    getManagerKey(address: string, { block }?: {\n        block: string;\n    }): Promise<ManagerKeyResponse>;\n    /**\n     * @param address contract address from which we want to retrieve the delegate (baker)\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the delegate of a contract, if any\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-contracts-contract-id-delegate\n     */\n    getDelegate(address: string, { block }?: {\n        block: string;\n    }): Promise<DelegateResponse>;\n    /**\n     * @deprecated Deprecated in favor of getBigMapKeyByID\n     * @param address contract address from which we want to retrieve the big map key\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the value associated with a key in the big map storage of the contract.\n     * @see https://tezos.gitlab.io/active/rpc.html#post-block-id-context-contracts-contract-id-big-map-get\n     */\n    getBigMapKey(address: string, key: BigMapKey, { block }?: {\n        block: string;\n    }): Promise<BigMapGetResponse>;\n    /**\n     * @param id Big Map ID\n     * @param expr Expression hash to query (A b58check encoded Blake2b hash of the expression (The expression can be packed using the pack_data method))\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the value associated with a key in a big map.\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-big-maps-big-map-id-script-expr\n     */\n    getBigMapExpr(id: string, expr: string, { block }?: {\n        block: string;\n    }): Promise<BigMapResponse>;\n    /**\n     * @param args contains optional query arguments (active, inactive, with_minimal_stake, without_minimal_stake)\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Lists all registered delegates by default with query arguments to filter unneeded values.\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-delegates-pkh\n     */\n    getAllDelegates(args?: AllDelegatesQueryArguments, { block }?: {\n        block: string;\n    }): Promise<string[]>;\n    /**\n     * @param address delegate address which we want to retrieve\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Everything about a delegate\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-delegates-pkh\n     */\n    getDelegates(address: string, { block }?: {\n        block: string;\n    }): Promise<DelegatesResponse>;\n    /**\n     * @param address delegate address which we want to retrieve\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Returns the delegate info (e.g. voting power) found in the listings of the current voting period\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-delegates-pkh-voting-info\n     */\n    getVotingInfo(address: string, { block }?: {\n        block: string;\n    }): Promise<VotingInfoResponse>;\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description All constants\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-constants\n     */\n    getConstants({ block }?: RPCOptions): Promise<ConstantsResponse>;\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head) and version.\n     * @description All the information about a block\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id\n     * @example getBlock() will default to `/main/chains/block/head?version=1`\n     * @example getBlock({ block: 'head~2' }) will return an offset of 2 from head blocks\n     * @example getBlock({ block: 'BL8fTiWcSxWCjiMVnDkbh6EuhqVPZzgWheJ2dqwrxYRm9AephXh~2' }) will return an offset of 2 blocks from given block hash..\n     */\n    getBlock({ block, version }?: RPCOptions): Promise<BlockResponse>;\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description The whole block header\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-header\n     */\n    getBlockHeader({ block }?: RPCOptions): Promise<BlockHeaderResponse>;\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head) and version\n     * @description All the metadata associated to the block\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-metadata\n     */\n    getBlockMetadata({ block, version, }?: RPCOptions): Promise<BlockMetadata>;\n    /**\n     * @param args contains optional query arguments (level, cycle, delegate, consensus_key, and max_round)\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Retrieves the list of delegates allowed to bake a block.\n     * @see https://gitlab.com/tezos/tezos/-/blob/master/docs/api/alpha-openapi.json\n     */\n    getBakingRights(args?: BakingRightsQueryArguments, { block }?: RPCOptions): Promise<BakingRightsResponse>;\n    /**\n     * @param args contains optional query arguments (level, cycle, delegate, and consensus_key)\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Retrieves the delegates allowed to attest a block\n     * @see https://gitlab.com/tezos/tezos/-/blob/master/docs/api/alpha-openapi.json\n     */\n    getAttestationRights(args?: AttestationRightsQueryArguments, { block }?: RPCOptions): Promise<AttestationRightsResponse>;\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Ballots casted so far during a voting period\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-votes-ballot-list\n     */\n    getBallotList({ block }?: RPCOptions): Promise<BallotListResponse>;\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Sum of ballots casted so far during a voting period\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-votes-ballots\n     */\n    getBallots({ block }?: RPCOptions): Promise<BallotsResponse>;\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Current proposal under evaluation.\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-votes-current-proposal\n     */\n    getCurrentProposal({ block, }?: RPCOptions): Promise<CurrentProposalResponse>;\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Current expected quorum.\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-votes-current-quorum\n     */\n    getCurrentQuorum({ block, }?: RPCOptions): Promise<CurrentQuorumResponse>;\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description List of delegates with their voting power\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-votes-listings\n     */\n    getVotesListings({ block, }?: RPCOptions): Promise<VotesListingsResponse>;\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description List of proposals with number of supporters\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-votes-proposals\n     */\n    getProposals({ block }?: RPCOptions): Promise<ProposalsResponse>;\n    /**\n     * @param data operation contents to forge\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Forge an operation returning the unsigned bytes\n     * @see https://gitlab.com/tezos/tezos/-/blob/master/docs/api/alpha-openapi.json\n     */\n    forgeOperations(data: ForgeOperationsParams, { block }?: RPCOptions): Promise<string>;\n    /**\n     * @param signedOpBytes signed bytes to inject\n     * @description Inject an operation in node and broadcast it and return the ID of the operation\n     * @see https://tezos.gitlab.io/shell/rpc.html#post-injection-operation\n     */\n    injectOperation(signedOpBytes: string): Promise<OperationHash>;\n    /**\n     * @param ops Operations to apply\n     * @param options contains generic configuration for rpc calls to specified block and version\n     * @description Simulate the application of the operations with the context of the given block and return the result of each operation application\n     * @see https://tezos.gitlab.io/active/rpc.html#post-block-id-helpers-preapply-operations\n     */\n    preapplyOperations(ops: PreapplyParams, { block, version }?: RPCOptions): Promise<PreapplyResponse[]>;\n    /**\n     * @param contract address of the contract we want to get the entrypoints of\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Return the list of entrypoints of the contract\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-contracts-contract-id-entrypoints\n     * @version 005_PsBABY5H\n     */\n    getEntrypoints(contract: string, { block }?: RPCOptions): Promise<EntrypointsResponse>;\n    /**\n     * @deprecated Deprecated in favor of simulateOperation\n     * @param op Operation to run\n     * @param options contains generic configuration for rpc calls to specified block and version\n     * @description Run an operation with the context of the given block and without signature checks and return the operation application result, including the consumed gas.\n     * @see https://gitlab.com/tezos/tezos/-/blob/master/docs/api/alpha-openapi.json\n     */\n    runOperation(op: RPCRunOperationParam, { block, version }?: RPCOptions): Promise<PreapplyResponse>;\n    /**\n     * @param op Operation to simulate\n     * @param options contains generic configuration for rpc calls to specified block and version\n     * @description Simulate running an operation at some future moment (based on the number of blocks given in the `latency` argument), and return the operation application result.\n     * @see https://gitlab.com/tezos/tezos/-/blob/master/docs/api/alpha-openapi.json\n     */\n    simulateOperation(op: RPCSimulateOperationParam, { block, version }?: RPCOptions): Promise<PreapplyResponse>;\n    /**\n     * @param code Code to run\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Run a Michelson script in the current context\n     * @see https://gitlab.com/tezos/tezos/-/blob/master/docs/api/alpha-openapi.json\n     */\n    runCode(code: RPCRunCodeParam, { block }?: RPCOptions): Promise<RunCodeResult>;\n    /**\n     * @param viewScriptParams Parameters of the script view to run\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Simulate a call to a michelson view\n     * @see https://gitlab.com/tezos/tezos/-/blob/master/docs/api/alpha-openapi.json\n     */\n    runScriptView({ unparsing_mode, ...rest }: RPCRunScriptViewParam, { block }?: RPCOptions): Promise<RunScriptViewResult>;\n    /**\n     * @param viewParams Parameters of the view to run\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Simulate a call to a view following the TZIP-4 standard.\n     * @see https://gitlab.com/tezos/tezos/-/blob/master/docs/api/alpha-openapi.json\n     */\n    runView({ unparsing_mode, ...rest }: RPCRunViewParam, { block }?: RPCOptions): Promise<RunViewResult>;\n    getChainId(): Promise<string>;\n    /**\n     * @param data Data to pack\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Computes the serialized version of a data expression using the same algorithm as script instruction PACK\n     * Note: You should always verify the packed bytes before signing or requesting that they be signed when using the RPC to pack.\n     * This precaution helps protect you and your applications users from RPC nodes that have been compromised.\n     * A node that is operated by a bad actor, or compromised by a bad actor could return a fully formed operation that does not correspond to the input provided to the RPC endpoint.\n     * A safer solution to pack and sign data would be to use the `packDataBytes` function available in the `@taquito/michel-codec` package.\n     * @example packData({ data: { string: \"test\" }, type: { prim: \"string\" } })\n     * @see https://gitlab.com/tezos/tezos/-/blob/master/docs/api/alpha-openapi.json\n     */\n    packData(data: PackDataParams, { block }?: RPCOptions): Promise<{\n        packed: import(\"./types\").HexString;\n        gas: BigNumber | \"unaccounted\" | undefined;\n    }>;\n    /**\n     *\n     * @description Return rpc root url\n     */\n    getRpcUrl(): string;\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Returns the voting period (index, kind, starting position) and related information (position, remaining) of the interrogated block\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-votes-current-period\n     */\n    getCurrentPeriod({ block, }?: RPCOptions): Promise<VotingPeriodBlockResult>;\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Returns the voting period (index, kind, starting position) and related information (position, remaining) of the next block.Useful to craft operations that will be valid in the next block\n     * @example getSuccessorPeriod() will default to successor voting period for /main/chains/block/head.\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-votes-successor-period\n     */\n    getSuccessorPeriod({ block, }?: RPCOptions): Promise<VotingPeriodBlockResult>;\n    /**\n     * @param id Sapling state ID\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Returns the root and a diff of a state starting from an optional offset which is zero by default\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-sapling-sapling-state-id-get-diff\n     */\n    getSaplingDiffById(id: string, { block }?: {\n        block: string;\n    }): Promise<SaplingDiffResponse>;\n    /**\n     * @param contract address of the contract we want to get the sapling diff\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Returns the root and a diff of a state starting from an optional offset which is zero by default\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-contracts-contract-id-single-sapling-get-diff\n     */\n    getSaplingDiffByContract(contract: string, { block }?: {\n        block: string;\n    }): Promise<SaplingDiffResponse>;\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description get current and next protocol\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-protocols\n     */\n    getProtocols({ block }?: {\n        block: string;\n    }): Promise<ProtocolsResponse>;\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description get current and next protocol\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-protocols\n     */\n    getProtocolActivations(protocol?: string): Promise<ProtocolActivationsResponse>;\n    /**\n     * @param contract address of the contract we want to retrieve storage information of\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the used storage space of the contract\n     * @see https://gitlab.com/tezos/tezos/-/blob/master/docs/api/alpha-openapi.json\n     */\n    getStorageUsedSpace(contract: string, { block }?: {\n        block: string;\n    }): Promise<string>;\n    /**\n     * @param contract address of the contract we want to retrieve storage information of\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the paid storage space of the contract\n     * @see https://gitlab.com/tezos/tezos/-/blob/master/docs/api/alpha-openapi.json\n     */\n    getStoragePaidSpace(contract: string, { block }?: {\n        block: string;\n    }): Promise<string>;\n    /**\n     * @param contract implicit or originated address we want to retrieve ticket balance of\n     * @param ticket object to specify a ticket by ticketer, content type and content\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the contract's balance of ticket with specified ticketer, content type, and content.\n     * @example ticket { ticketer: 'address', content_type: { prim: \"string\" }, content: { string: 'ticket1' } }\n     * @see https://tezos.gitlab.io/protocols/016_mumbai.html#rpc-changes\n     */\n    getTicketBalance(contract: string, ticket: TicketTokenParams, { block }?: {\n        block: string;\n    }): Promise<string>;\n    /**\n     * @param contract originated address we want to retrieve ticket balances of\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the complete list of tickets owned by the given contract by scanning the contract's storage.\n     * @see https://tezos.gitlab.io/protocols/016_mumbai.html#rpc-changes\n     */\n    getAllTicketBalances(contract: string, { block }?: {\n        block: string;\n    }): Promise<AllTicketBalances>;\n    /**\n     * @description Returns the cycle at which the launch of the Adaptive Issuance feature is set to happen. A result of null means that the feature is not yet set to launch.\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-adaptive-issuance-launch-cycle\n     */\n    getAdaptiveIssuanceLaunchCycle({ block, }?: {\n        block: string;\n    }): Promise<AILaunchCycleResponse>;\n    /**\n     * @description List the prevalidated operations in mempool (accessibility of mempool depends on each rpc endpoint)\n     * @param args has 5 optional properties\n     * @default args { version: '2', validated: true, refused: true, outdated, true, branchRefused: true, branchDelayed: true, validationPass: undefined, source: undefined, operationHash: undefined }\n     * @see https://gitlab.com/tezos/tezos/-/blob/master/docs/api/seoul-mempool-openapi.json\n     */\n    getPendingOperations(args?: PendingOperationsQueryArguments): Promise<PendingOperationsV2>;\n}\n"},{name:"@taquito/rpc/dist/types/types.d.ts",dts:"import BigNumber from 'bignumber.js';\nimport { OpKind } from './opkind';\nexport type BalanceResponse = BigNumber;\nexport type StorageResponse = ScriptedContracts['storage'];\nexport type ScriptResponse = ScriptedContracts;\nexport type BigMapGetResponse = MichelsonV1Expression;\nexport type ManagerResponse = {\n    manager: string;\n};\nexport type ManagerKeyResponse = string | {\n    key: string;\n};\nexport type DelegateResponse = string | null;\nexport type OperationHash = string;\nexport type UnstakeRequestsResponse = {\n    finalizable: {\n        delegate: string;\n        cycle: number;\n        amount: BigNumber;\n    }[];\n    unfinalizable: {\n        delegate: string;\n        requests: {\n            cycle: number;\n            amount: BigNumber;\n        }[];\n    };\n} | null;\ninterface INodeExtender {\n    length: string;\n    segment: string;\n    proof: string;\n}\ntype OtherEltsInner = {\n    value: any;\n} | {\n    inode_extender: INodeExtender;\n};\nexport type OtherElts = {\n    node: [string, {\n        value: string;\n    } | {\n        node: string;\n    }][];\n} | {\n    other_elts: OtherEltsInner;\n};\nexport interface Inode {\n    length: string;\n    proofs: [string | null, string | null];\n}\nexport interface DelegatesResponse {\n    deactivated: boolean;\n    is_forbidden?: boolean;\n    participation?: {\n        expected_cycle_activity: number;\n        minimal_cycle_activity: number;\n        missed_slots: number;\n        missed_levels: number;\n        remaining_allowed_missed_slots: number;\n        expected_attesting_rewards: string;\n    };\n    dal_participation?: {\n        expected_assigned_shards_per_slot: number;\n        delegate_attested_dal_slots: number;\n        delegate_attestable_dal_slots: number;\n        expected_dal_rewards: string;\n        sufficient_dal_participationa: true;\n        denounced: true;\n    };\n    grace_period: number;\n    active_staking_parameters?: StakingParameters;\n    pending_staking_parameters?: {\n        cycle: number;\n        parameters: StakingParameters;\n    }[];\n    baking_power?: string;\n    total_staked?: string;\n    total_delegated?: string;\n    min_delegated_in_current_cycle?: MinDelegatedInCurrentCycle;\n    own_full_balance?: string;\n    own_staked?: string;\n    own_delegated?: string;\n    external_staked?: string;\n    external_delegated?: string;\n    total_unstaked_per_cycle?: {\n        cycle: number;\n        deposit: string;\n    }[];\n    denunciations?: {\n        operation_hash: string;\n        rewarded: string;\n        misbehaviour: {\n            level: number;\n            round: number;\n            kind: 'attestation' | 'block' | 'preattestation';\n        };\n    }[];\n    estimated_shared_pending_slashed_amount?: string;\n    staking_denominator?: BigNumber;\n    current_voting_power?: BigNumber;\n    voting_power?: BigNumber;\n    voting_info?: VotingInfoResponse;\n    consensus_key?: {\n        active: {\n            pkh: string;\n            pk: string;\n        };\n        pendings?: {\n            cycle: number;\n            pkh: string;\n            pk: string;\n        }[];\n    };\n    companion_key?: {\n        active: {\n            pkh: string;\n            pk: string;\n        } | null;\n        pendings?: {\n            cycle: number;\n            pkh: string;\n            pk: string;\n        }[];\n    };\n    stakers?: {\n        staker: string;\n        frozen_deposits: string;\n    }[];\n    delegators?: string[];\n    full_balance?: BigNumber;\n    current_frozen_deposits?: BigNumber;\n    frozen_deposits?: BigNumber;\n    staking_balance?: BigNumber;\n    delegated_contracts?: string[];\n    delegated_balance?: BigNumber;\n    total_delegated_stake?: BigNumber;\n    active_consensus_key?: string;\n    pending_denunciations?: boolean;\n    frozen_deposits_limit?: BigNumber;\n    current_ballot?: BallotVote;\n    current_proposals?: string[];\n    remaining_proposals?: number;\n    pending_consensus_keys?: PendingConsensusKey[];\n    balance?: BigNumber;\n    frozen_balance?: BigNumber;\n    frozen_balance_by_cycle?: Frozenbalancebycycle[];\n}\nexport type StakingParameters = {\n    limit_of_staking_over_baking_millionth: number;\n    edge_of_baking_over_staking_billionth: number;\n};\nexport type MinDelegatedInCurrentCycle = {\n    amount: string;\n    level?: LevelInfo;\n};\nexport type PendingConsensusKey = {\n    cycle: number;\n    pkh: string;\n};\nexport type VotingInfoResponse = {\n    voting_power?: string;\n    current_ballot?: BallotListResponseEnum;\n    current_proposals?: string[];\n    remaining_proposals?: number;\n};\ninterface Frozenbalancebycycle {\n    cycle: number;\n    deposit?: BigNumber;\n    deposits?: BigNumber;\n    fees: BigNumber;\n    rewards: BigNumber;\n}\nexport type BigMapKey = {\n    key: {\n        [key: string]: string | object[];\n    };\n    type: {\n        prim: string;\n        args?: object[];\n    };\n};\nexport type LiquidityBakingToggleVotes = 'on' | 'off' | 'pass';\nexport type AdaptiveIssuanceVote = 'on' | 'off' | 'pass';\nexport interface BlockFullHeader {\n    level: number;\n    proto: number;\n    predecessor: string;\n    timestamp: TimeStampMixed;\n    validation_pass: number;\n    operations_hash: string;\n    fitness: string[];\n    context: string;\n    payload_hash?: string;\n    payload_round?: number;\n    priority?: number;\n    proof_of_work_nonce: string;\n    seed_nonce_hash?: string;\n    liquidity_baking_toggle_vote?: LiquidityBakingToggleVotes;\n    adaptive_issuance_vote?: AdaptiveIssuanceVote;\n    liquidity_baking_escape_vote?: boolean | LiquidityBakingToggleVotes;\n    signature: string;\n}\nexport type InlinedAttestationKindEnum = OpKind.ATTESTATION;\nexport type InlinedEndorsementKindEnum = OpKind.ENDORSEMENT;\nexport type InlinedAttestationContents = OperationContentsPreattestation | OperationContentsAttestation | OperationContentsAttestationWithDal | OperationContentsPreattestationsAggregate | OperationContentsAttestationsAggregate;\nexport interface InlinedEndorsementContents {\n    kind: InlinedEndorsementKindEnum;\n    slot?: number;\n    round?: number;\n    block_payload_hash?: string;\n    level: number;\n}\nexport interface InlinedPreattestationContents {\n    kind: OpKind.PREATTESTATION;\n    slot: number;\n    level: number;\n    round: number;\n    block_payload_hash: string;\n}\nexport interface InlinedPreEndorsementContents {\n    kind: OpKind.PREENDORSEMENT;\n    slot: number;\n    level: number;\n    round: number;\n    block_payload_hash: string;\n}\nexport interface InlinedAttestation {\n    branch: string;\n    operations: InlinedAttestationContents;\n    signature?: string;\n}\nexport interface InlinedEndorsement {\n    branch: string;\n    operations: InlinedEndorsementContents;\n    signature?: string;\n}\nexport interface InlinedPreattestation {\n    branch: string;\n    operations: InlinedPreattestationContents;\n    signature?: string;\n}\nexport interface InlinedPreEndorsement {\n    branch: string;\n    operations: InlinedPreEndorsementContents;\n    signature?: string;\n}\nexport type BallotVote = 'nay' | 'yay' | 'pass';\nexport interface OperationContentsAttestation {\n    kind: OpKind.ATTESTATION;\n    level: number;\n    slot?: number;\n    round?: number;\n    block_payload_hash?: string;\n}\nexport interface OperationContentsEndorsement {\n    kind: OpKind.ENDORSEMENT;\n    level: number;\n    slot?: number;\n    round?: number;\n    block_payload_hash?: string;\n}\nexport interface OperationContentsPreattestation {\n    kind: OpKind.PREATTESTATION;\n    slot: number;\n    level: number;\n    round: number;\n    block_payload_hash: string;\n}\nexport interface OperationContentsPreEndorsement {\n    kind: OpKind.PREENDORSEMENT;\n    slot: number;\n    level: number;\n    round: number;\n    block_payload_hash: string;\n}\nexport interface OperationContentsDoublePreattestation {\n    kind: OpKind.DOUBLE_PREATTESTATION_EVIDENCE;\n    op1: InlinedPreattestation;\n    op2: InlinedPreattestation;\n}\nexport interface OperationContentsDoublePreEndorsement {\n    kind: OpKind.DOUBLE_PREENDORSEMENT_EVIDENCE;\n    op1: InlinedPreEndorsement;\n    op2: InlinedPreEndorsement;\n}\nexport interface OperationContentsSetDepositsLimit {\n    kind: OpKind.SET_DEPOSITS_LIMIT;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    limit?: string;\n}\nexport interface OperationContentsAttestationWithDal {\n    kind: OpKind.ATTESTATION_WITH_DAL;\n    slot: number;\n    level: number;\n    round: number;\n    block_payload_hash: string;\n    dal_attestation: string;\n}\nexport interface OperationContentsEndorsementWithDal {\n    kind: OpKind.ENDORSEMENT_WITH_DAL;\n    slot: number;\n    level: number;\n    round: number;\n    block_payload_hash: string;\n    dal_attestation: string;\n}\nexport interface OperationContentsRevelation {\n    kind: OpKind.SEED_NONCE_REVELATION;\n    level: number;\n    nonce: string;\n}\nexport interface OperationContentsVdfRevelation {\n    kind: OpKind.VDF_REVELATION;\n    solution: string[];\n}\nexport interface OperationContentsDoubleAttestation {\n    kind: OpKind.DOUBLE_ATTESTATION_EVIDENCE;\n    op1: InlinedAttestation;\n    op2: InlinedAttestation;\n    slot?: number;\n}\nexport interface OperationContentsDoubleEndorsement {\n    kind: OpKind.DOUBLE_ENDORSEMENT_EVIDENCE;\n    op1: InlinedEndorsement;\n    op2: InlinedEndorsement;\n    slot?: number;\n}\nexport interface OperationContentsDoubleBaking {\n    kind: OpKind.DOUBLE_BAKING_EVIDENCE;\n    bh1: BlockFullHeader;\n    bh2: BlockFullHeader;\n}\nexport interface OperationContentsActivateAccount {\n    kind: OpKind.ACTIVATION;\n    pkh: string;\n    secret: string;\n}\nexport interface OperationContentsFailingNoop {\n    kind: OpKind.FAILING_NOOP;\n    arbitrary: string;\n}\nexport interface OperationContentsProposals {\n    kind: OpKind.PROPOSALS;\n    source: string;\n    period: number;\n    proposals: string[];\n}\nexport interface OperationContentsBallot {\n    kind: OpKind.BALLOT;\n    source: string;\n    period: number;\n    proposal: string;\n    ballot: BallotVote;\n}\nexport interface OperationContentsReveal {\n    kind: OpKind.REVEAL;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    public_key: string;\n    proof?: string;\n}\nexport interface OperationContentsTransaction {\n    kind: OpKind.TRANSACTION;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    amount: string;\n    destination: string;\n    parameters?: TransactionOperationParameter;\n}\nexport interface OperationContentsOrigination {\n    kind: OpKind.ORIGINATION;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    balance: string;\n    delegate?: string;\n    script?: ScriptedContracts;\n}\nexport interface OperationContentsDelegation {\n    kind: OpKind.DELEGATION;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    delegate?: string;\n}\nexport interface OperationContentsRegisterGlobalConstant {\n    kind: OpKind.REGISTER_GLOBAL_CONSTANT;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    value: MichelsonV1Expression;\n}\nexport interface OperationContentsTransferTicket {\n    kind: OpKind.TRANSFER_TICKET;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    ticket_contents: MichelsonV1Expression;\n    ticket_ty: MichelsonV1Expression;\n    ticket_ticketer: string;\n    ticket_amount: string;\n    destination: string;\n    entrypoint: string;\n}\nexport interface OperationContentsUpdateConsensusKey {\n    kind: OpKind.UPDATE_CONSENSUS_KEY;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    pk: string;\n    proof?: string;\n}\nexport interface OperationContentsUpdateCompanionKey {\n    kind: OpKind.UPDATE_COMPANION_KEY;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    pk: string;\n    proof?: string;\n}\nexport interface OperationContentsDrainDelegate {\n    kind: OpKind.DRAIN_DELEGATE;\n    consensus_key: string;\n    delegate: string;\n    destination: string;\n}\nexport interface OperationContentsIncreasePaidStorage {\n    kind: OpKind.INCREASE_PAID_STORAGE;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    amount: string;\n    destination: string;\n}\nexport interface OperationContentsSmartRollupOriginate {\n    kind: OpKind.SMART_ROLLUP_ORIGINATE;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    pvm_kind: PvmKind;\n    kernel: string;\n    parameters_ty: MichelsonV1Expression;\n    whitelist?: string[];\n}\nexport interface OperationContentsSmartRollupAddMessages {\n    kind: OpKind.SMART_ROLLUP_ADD_MESSAGES;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    message: string[];\n}\nexport interface OperationContentsSmartRollupExecuteOutboxMessage {\n    kind: OpKind.SMART_ROLLUP_EXECUTE_OUTBOX_MESSAGE;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    rollup: string;\n    cemented_commitment: string;\n    output_proof: string;\n}\nexport interface OperationContentsSmartRollupPublish {\n    kind: OpKind.SMART_ROLLUP_PUBLISH;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    rollup: string;\n    commitment: SmartRollupPublishCommitment;\n}\nexport interface OperationContentsSmartRollupCement {\n    kind: OpKind.SMART_ROLLUP_CEMENT;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    rollup: string;\n    commitment: string;\n}\nexport interface OperationContentsSmartRollupRefute {\n    kind: OpKind.SMART_ROLLUP_REFUTE;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    rollup: string;\n    opponent: string;\n    refutation: SmartRollupRefutation;\n}\nexport interface OperationContentsSmartRollupRecoverBond {\n    kind: OpKind.SMART_ROLLUP_RECOVER_BOND;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    rollup: string;\n    staker: string;\n}\nexport interface OperationContentsSmartRollupTimeout {\n    kind: OpKind.SMART_ROLLUP_TIMEOUT;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    rollup: string;\n    stakers: SmartRollupTimeoutStakers;\n}\nexport interface OperationContentsDalPublishCommitment {\n    kind: OpKind.DAL_PUBLISH_COMMITMENT;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    slot_header: {\n        slot_index: number;\n        commitment: string;\n        commitment_proof: string;\n    };\n}\nexport interface OperationContentsDalEntrapmentEvidence {\n    kind: OpKind.DAL_ENTRAPMENT_EVIDENCE;\n    attestation: InlinedAttestation;\n    consensus_slot: number;\n    slot_index: number;\n    shard_with_proof: {\n        shard: (number | string[])[];\n        proof: string;\n    };\n}\nexport interface OperationContentsPreattestationsAggregate {\n    kind: OpKind.PREATTESTATIONS_AGGREGATE;\n    consensus_content: {\n        level: number;\n        round: number;\n        block_payload_hash: string;\n    };\n    committee: number[];\n}\nexport interface OperationContentsAttestationsAggregate {\n    kind: OpKind.ATTESTATIONS_AGGREGATE;\n    consensus_content: {\n        level: number;\n        round: number;\n        block_payload_hash: string;\n    };\n    committee: {\n        slot: number;\n        dal_attestation?: string;\n    }[];\n}\nexport interface OperationContentsDoubleConsensusOperationEvidence {\n    kind: OpKind.DOUBLE_CONSENSUS_OPERATION_EVIDENCE;\n    slot: number;\n    op1: InlinedAttestation;\n    op2: InlinedAttestation;\n}\nexport type OperationContents = OperationContentsAttestation | OperationContentsPreattestation | OperationContentsDoublePreattestation | OperationContentsEndorsement | OperationContentsPreEndorsement | OperationContentsDoublePreEndorsement | OperationContentsRevelation | OperationContentsVdfRevelation | OperationContentsDoubleAttestation | OperationContentsDoubleEndorsement | OperationContentsDoubleBaking | OperationContentsActivateAccount | OperationContentsProposals | OperationContentsBallot | OperationContentsReveal | OperationContentsTransaction | OperationContentsOrigination | OperationContentsDelegation | OperationContentsAttestationWithDal | OperationContentsEndorsementWithDal | OperationContentsFailingNoop | OperationContentsRegisterGlobalConstant | OperationContentsSetDepositsLimit | OperationContentsTransferTicket | OperationContentsUpdateConsensusKey | OperationContentsDrainDelegate | OperationContentsIncreasePaidStorage | OperationContentsSmartRollupOriginate | OperationContentsSmartRollupAddMessages | OperationContentsSmartRollupExecuteOutboxMessage | OperationContentsSmartRollupPublish | OperationContentsSmartRollupCement | OperationContentsSmartRollupRefute | OperationContentsSmartRollupRecoverBond | OperationContentsSmartRollupTimeout | OperationContentsDalEntrapmentEvidence | OperationContentsDalPublishCommitment | OperationContentsDoubleConsensusOperationEvidence | OperationContentsUpdateCompanionKey | OperationContentsPreattestationsAggregate | OperationContentsAttestationsAggregate;\nexport interface OperationContentsAndResultMetadataExtended1 {\n    balance_updates?: OperationMetadataBalanceUpdates[];\n    delegate: string;\n    consensus_power: number;\n    consensus_key: string;\n}\nexport interface OperationContentsAndResultMetadataExtended0 {\n    balance_updates?: OperationMetadataBalanceUpdates[];\n    delegate: string;\n    endorsement_power: number;\n    consensus_key?: string;\n}\nexport interface OperationContentsAndResultMetadataAttestationsAggregate {\n    balance_updates?: OperationMetadataBalanceUpdates[];\n    committee: {\n        delegate: string;\n        consensus_pkh: string;\n    }[];\n    consensus_power: number;\n}\nexport interface OperationContentsAndResultMetadataPreattestation {\n    balance_updates?: OperationMetadataBalanceUpdates[];\n    delegate: string;\n    consensus_power: number;\n    consensus_key?: string;\n}\nexport interface OperationContentsAndResultMetadataPreattestationsAggregate {\n    balance_updates?: OperationMetadataBalanceUpdates[];\n    committee: {\n        delegate: string;\n        consensus_pkh: string;\n    }[];\n    consensus_power: number;\n}\nexport interface OperationContentsAndResultMetadataPreEndorsement {\n    balance_updates?: OperationMetadataBalanceUpdates[];\n    delegate: string;\n    preendorsement_power: number;\n    consensus_key?: string;\n}\nexport interface OperationContentsAndResultMetadataReveal {\n    balance_updates?: OperationMetadataBalanceUpdates[];\n    operation_result: OperationResultReveal;\n    internal_operation_results?: InternalOperationResult[];\n}\nexport interface OperationContentsAndResultMetadataTransaction {\n    balance_updates?: OperationMetadataBalanceUpdates[];\n    operation_result: OperationResultTransaction;\n    internal_operation_results?: InternalOperationResult[];\n}\nexport interface OperationContentsAndResultMetadataDelegation {\n    balance_updates?: OperationMetadataBalanceUpdates[];\n    operation_result: OperationResultDelegation;\n    internal_operation_results?: InternalOperationResult[];\n}\nexport interface OperationContentsAndResultMetadataRegisterGlobalConstant {\n    balance_updates?: OperationMetadataBalanceUpdates[];\n    operation_result: OperationResultRegisterGlobalConstant;\n    internal_operation_results?: InternalOperationResult[];\n}\nexport interface OperationContentsAndResultMetadataSetDepositsLimit {\n    balance_updates?: OperationMetadataBalanceUpdates[];\n    operation_result: OperationResultSetDepositsLimit;\n    internal_operation_results?: InternalOperationResult[];\n}\nexport interface OperationContentsAndResultMetadata {\n    balance_updates?: OperationMetadataBalanceUpdates[];\n}\nexport interface OperationContentsAndResultMetadataTransferTicket {\n    balance_updates?: OperationMetadataBalanceUpdates[];\n    operation_result: OperationResultTransferTicket;\n    internal_operation_results?: InternalOperationResult[];\n}\nexport interface OperationContentsAndResultMetadataIncreasePaidStorage {\n    balance_updates?: OperationMetadataBalanceUpdates[];\n    operation_result: OperationResultIncreasePaidStorage;\n    internal_operation_results?: InternalOperationResult[];\n}\nexport interface OperationContentsAndResultMetadataUpdateConsensusKey {\n    balance_updates?: OperationMetadataBalanceUpdates[];\n    operation_result: OperationResultUpdateConsensusKey;\n    internal_operation_results?: InternalOperationResult[];\n}\nexport interface OperationContentsAndResultMetadataUpdateCompanionKey {\n    balance_updates?: OperationMetadataBalanceUpdates[];\n    operation_result: OperationResultUpdateConsensusKey;\n    internal_operation_results?: InternalOperationResult[];\n}\nexport interface OperationContentsAndResultMetadataDrainDelegate {\n    balance_updates?: OperationMetadataBalanceUpdates[];\n    allocated_destination_contract?: boolean;\n}\nexport interface OperationContentsAndResultMetadataSmartRollupOriginate {\n    balance_updates?: OperationMetadataBalanceUpdates[];\n    operation_result: OperationResultSmartRollupOriginate;\n    internal_operation_results?: InternalOperationResult[];\n}\nexport interface OperationContentsAndResultMetadataSmartRollupAddMessages {\n    balance_updates?: OperationMetadataBalanceUpdates[];\n    operation_result: OperationResultSmartRollupAddMessages;\n    internal_operation_results?: InternalOperationResult[];\n}\nexport interface OperationContentsAndResultMetadataSmartRollupExecuteOutboxMessage {\n    balance_updates?: OperationMetadataBalanceUpdates[];\n    operation_result: OperationResultSmartRollupExecuteOutboxMessage;\n    internal_operation_results?: InternalOperationResult[];\n}\nexport interface OperationContentsAndResultMetadataSmartRollupPublish {\n    balance_updates?: OperationMetadataBalanceUpdates[];\n    operation_result: OperationResultSmartRollupPublish;\n    internal_operation_results?: InternalOperationResult[];\n}\nexport interface OperationContentsAndResultMetadataSmartRollupCement {\n    balance_updates?: OperationMetadataBalanceUpdates[];\n    operation_result: OperationResultSmartRollupCement;\n    internal_operation_results?: InternalOperationResult[];\n}\nexport interface OperationContentsAndResultMetadataSmartRollupRefute {\n    balance_updates?: OperationMetadataBalanceUpdates[];\n    operation_result: OperationResultSmartRollupRefute;\n    internal_operation_results?: InternalOperationResult[];\n}\nexport interface OperationContentsAndResultMetadataSmartRollupRecoverBond {\n    balance_updates?: OperationMetadataBalanceUpdates[];\n    operation_result: OperationResultSmartRollupRecoverBond;\n    internal_operation_results?: InternalOperationResult[];\n}\nexport interface OperationContentsAndResultMetadataSmartRollupTimeout {\n    balance_updates?: OperationMetadataBalanceUpdates[];\n    operation_result: OperationResultSmartRollupTimeout;\n    internal_operation_results?: InternalOperationResult[];\n}\nexport interface OperationContentsAndResultMetadataDalPublishCommitment {\n    balance_updates?: OperationMetadataBalanceUpdates[];\n    operation_result: OperationResultDalPublishCommitment;\n    internal_operation_results?: InternalOperationResult[];\n}\nexport interface OperationContentsAndResultMetadataDalEntrapmentEvidence {\n    balance_updates?: OperationMetadataBalanceUpdates[];\n}\nexport interface OperationContentsAndResultMetadataDoubleConsensusOperationEvidence {\n    punished_delegate: string;\n    rewarded_delegate: string;\n    misbehaviour: {\n        level: number;\n        round: number;\n        kind: 'attestation' | 'block' | 'preattestation';\n    };\n}\nexport interface OperationContentsAndResultMetadataDoubleBaking {\n    punished_delegate: string;\n    rewarded_delegate: string;\n    misbehaviour: {\n        level: number;\n        round: number;\n        kind: 'attestation' | 'block' | 'preattestation';\n    };\n}\nexport interface OperationContentsAndResultAttestation {\n    kind: OpKind.ATTESTATION;\n    block_payload_hash?: string;\n    level: number;\n    round?: number;\n    slot?: number;\n    metadata: OperationContentsAndResultMetadataExtended1;\n}\nexport interface OperationContentsAndResultAttestationsAggregate {\n    kind: OpKind.ATTESTATIONS_AGGREGATE;\n    consensus_content: {\n        level: number;\n        round: number;\n        block_payload_hash: string;\n    };\n    committee: {\n        slot: number;\n        dal_attestation?: string;\n    }[];\n    metadata: OperationContentsAndResultMetadataAttestationsAggregate;\n}\nexport interface OperationContentsAndResultEndorsement {\n    kind: OpKind.ENDORSEMENT;\n    block_payload_hash?: string;\n    level: number;\n    round?: number;\n    slot?: number;\n    metadata: OperationContentsAndResultMetadataExtended0;\n}\nexport interface OperationContentsAndResultPreattestation {\n    kind: OpKind.PREATTESTATION;\n    slot: number;\n    level: number;\n    round: number;\n    block_payload_hash: string;\n    metadata: OperationContentsAndResultMetadataPreattestation;\n}\nexport interface OperationContentsAndResultPreattestationsAggregate {\n    kind: OpKind.PREATTESTATIONS_AGGREGATE;\n    consensus_content: {\n        level: number;\n        round: number;\n        block_payload_hash: string;\n    };\n    committee: number[];\n    metadata: OperationContentsAndResultMetadataPreattestationsAggregate;\n}\nexport interface OperationContentsAndResultPreEndorsement {\n    kind: OpKind.PREENDORSEMENT;\n    slot: number;\n    level: number;\n    round: number;\n    block_payload_hash: string;\n    metadata: OperationContentsAndResultMetadataPreEndorsement;\n}\nexport interface OperationContentsAndResultDoublePreattestation {\n    kind: OpKind.DOUBLE_PREATTESTATION_EVIDENCE;\n    op1: InlinedPreattestation;\n    op2: InlinedPreattestation;\n    metadata: OperationContentsAndResultMetadata;\n}\nexport interface OperationContentsAndResultAttestationWithDal {\n    kind: OpKind.ATTESTATION_WITH_DAL;\n    slot: number;\n    level: number;\n    round: number;\n    block_payload_hash: string;\n    dal_attestation: string;\n    metadata: OperationContentsAndResultMetadataExtended1;\n}\nexport interface OperationContentsAndResultDoublePreEndorsement {\n    kind: OpKind.DOUBLE_PREENDORSEMENT_EVIDENCE;\n    op1: InlinedPreEndorsement;\n    op2: InlinedPreEndorsement;\n    metadata: OperationContentsAndResultMetadata;\n}\nexport interface OperationContentsAndResultEndorsementWithDal {\n    kind: OpKind.ENDORSEMENT_WITH_DAL;\n    slot: number;\n    level: number;\n    round: number;\n    block_payload_hash: string;\n    dal_attestation: string;\n    metadata: OperationContentsAndResultMetadataExtended0;\n}\nexport interface OperationContentsAndResultRevelation {\n    kind: OpKind.SEED_NONCE_REVELATION;\n    level: number;\n    nonce: string;\n    metadata: OperationContentsAndResultMetadata;\n}\nexport interface OperationContentsAndResultDoubleAttestation {\n    kind: OpKind.DOUBLE_ATTESTATION_EVIDENCE;\n    op1: InlinedAttestation;\n    op2: InlinedAttestation;\n    slot?: number;\n    metadata: OperationContentsAndResultMetadata;\n}\nexport interface OperationContentsAndResultDoubleEndorsement {\n    kind: OpKind.DOUBLE_ENDORSEMENT_EVIDENCE;\n    op1: InlinedEndorsement;\n    op2: InlinedEndorsement;\n    slot?: number;\n    metadata: OperationContentsAndResultMetadata;\n}\nexport interface OperationContentsAndResultDoubleBaking {\n    kind: OpKind.DOUBLE_BAKING_EVIDENCE;\n    bh1: BlockFullHeader;\n    bh2: BlockFullHeader;\n    metadata: OperationContentsAndResultMetadataDoubleBaking;\n}\nexport interface OperationContentsAndResultActivateAccount {\n    kind: OpKind.ACTIVATION;\n    pkh: string;\n    secret: string;\n    metadata: OperationContentsAndResultMetadata;\n}\nexport interface OperationContentsAndResultProposals {\n    kind: OpKind.PROPOSALS;\n    source: string;\n    period: number;\n    proposals: string[];\n}\nexport interface OperationContentsAndResultBallot {\n    kind: OpKind.BALLOT;\n    source: string;\n    period: number;\n    proposal: string;\n    ballot: BallotVote;\n}\nexport interface OperationContentsAndResultReveal {\n    kind: OpKind.REVEAL;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    public_key: string;\n    proof?: string;\n    metadata: OperationContentsAndResultMetadataReveal;\n}\nexport interface OperationContentsAndResultTransaction {\n    kind: OpKind.TRANSACTION;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    amount: string;\n    destination: string;\n    parameters?: TransactionOperationParameter;\n    metadata: OperationContentsAndResultMetadataTransaction;\n}\nexport interface OperationContentsAndResultDelegation {\n    kind: OpKind.DELEGATION;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    delegate?: string;\n    metadata: OperationContentsAndResultMetadataDelegation;\n}\nexport interface OperationContentsAndResultRegisterGlobalConstant {\n    kind: OpKind.REGISTER_GLOBAL_CONSTANT;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    value: MichelsonV1Expression;\n    metadata: OperationContentsAndResultMetadataRegisterGlobalConstant;\n}\nexport interface OperationContentsAndResultSetDepositsLimit {\n    kind: OpKind.SET_DEPOSITS_LIMIT;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    limit?: string;\n    metadata: OperationContentsAndResultMetadataSetDepositsLimit;\n}\nexport interface OperationContentsAndResultTransferTicket {\n    kind: OpKind.TRANSFER_TICKET;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    ticket_contents: MichelsonV1Expression;\n    ticket_ty: MichelsonV1Expression;\n    ticket_ticketer: string;\n    ticket_amount: string;\n    destination: string;\n    entrypoint: string;\n    metadata: OperationContentsAndResultMetadataTransferTicket;\n}\nexport interface OperationContentsAndResultUpdateConsensusKey {\n    kind: OpKind.UPDATE_CONSENSUS_KEY;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    pk: string;\n    proof?: string;\n    metadata: OperationContentsAndResultMetadataUpdateConsensusKey;\n}\nexport interface OperationContentsAndResultUpdateCompanionKey {\n    kind: OpKind.UPDATE_COMPANION_KEY;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    pk: string;\n    proof?: string;\n    metadata: OperationContentsAndResultMetadataUpdateCompanionKey;\n}\nexport interface OperationContentsAndResultDrainDelegate {\n    kind: OpKind.DRAIN_DELEGATE;\n    consensus_key: string;\n    delegate: string;\n    destination: string;\n    metadata: OperationContentsAndResultMetadataDrainDelegate;\n}\nexport interface OperationContentsAndResultIncreasePaidStorage {\n    kind: OpKind.INCREASE_PAID_STORAGE;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    amount: string;\n    destination: string;\n    metadata: OperationContentsAndResultMetadataIncreasePaidStorage;\n}\nexport interface OperationContentsAndResultVdfRevelation {\n    kind: OpKind.VDF_REVELATION;\n    solution: string[];\n    metadata: OperationContentsAndResultMetadata;\n}\nexport interface OperationContentsAndResultSmartRollupOriginate {\n    kind: OpKind.SMART_ROLLUP_ORIGINATE;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    pvm_kind: PvmKind;\n    kernel: string;\n    parameters_ty: MichelsonV1Expression;\n    whitelist?: string[];\n    metadata: OperationContentsAndResultMetadataSmartRollupOriginate;\n}\nexport interface OperationContentsAndResultSmartRollupAddMessages {\n    kind: OpKind.SMART_ROLLUP_ADD_MESSAGES;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    message: string[];\n    metadata: OperationContentsAndResultMetadataSmartRollupAddMessages;\n}\nexport interface OperationContentsAndResultSmartRollupExecuteOutboxMessage {\n    kind: OpKind.SMART_ROLLUP_EXECUTE_OUTBOX_MESSAGE;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    rollup: string;\n    cemented_commitment: string;\n    output_proof: string;\n    metadata: OperationContentsAndResultMetadataSmartRollupExecuteOutboxMessage;\n}\nexport interface OperationContentsAndResultSmartRollupPublish {\n    kind: OpKind.SMART_ROLLUP_PUBLISH;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    rollup: string;\n    commitment: SmartRollupPublishCommitment;\n    metadata: OperationContentsAndResultMetadataSmartRollupPublish;\n}\nexport interface OperationContentsAndResultSmartRollupCement {\n    kind: OpKind.SMART_ROLLUP_CEMENT;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    rollup: string;\n    metadata: OperationContentsAndResultMetadataSmartRollupCement;\n}\nexport interface OperationContentsAndResultSmartRollupRefute {\n    kind: OpKind.SMART_ROLLUP_REFUTE;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    rollup: string;\n    opponent: string;\n    refutation: SmartRollupRefutation;\n    metadata: OperationContentsAndResultMetadataSmartRollupRefute;\n}\nexport interface OperationContentsAndResultSmartRollupRecoverBond {\n    kind: OpKind.SMART_ROLLUP_RECOVER_BOND;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    rollup: string;\n    staker: string;\n    metadata: OperationContentsAndResultMetadataSmartRollupRecoverBond;\n}\nexport interface OperationContentsAndResultSmartRollupTimeout {\n    kind: OpKind.SMART_ROLLUP_TIMEOUT;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    rollup: string;\n    stakers: SmartRollupTimeoutStakers;\n    metadata: OperationContentsAndResultMetadataSmartRollupTimeout;\n}\nexport interface OperationContentsAndResultDalPublishCommitment {\n    kind: OpKind.DAL_PUBLISH_COMMITMENT;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    slot_header: {\n        slot_index: number;\n        commitment: string;\n        commitment_proof: string;\n    };\n    metadata: OperationContentsAndResultMetadataDalPublishCommitment;\n}\nexport interface OperationContentsAndResultDalEntrapmentEvidence {\n    kind: OpKind.DAL_ENTRAPMENT_EVIDENCE;\n    attestation: InlinedAttestation;\n    consensus_slot: number;\n    slot_index: number;\n    shard_with_proof: {\n        shard: (number | string[])[];\n        proof: string;\n    };\n    metadata: OperationContentsAndResultMetadataDalEntrapmentEvidence;\n}\nexport interface OperationContentsAndResultDoubleConsensusOperationEvidence {\n    kind: OpKind.DOUBLE_CONSENSUS_OPERATION_EVIDENCE;\n    slot: number;\n    op1: InlinedAttestation;\n    op2: InlinedAttestation;\n    metadata: OperationContentsAndResultMetadataDoubleConsensusOperationEvidence;\n}\nexport type OperationContentsAndResult = OperationContentsAndResultAttestation | OperationContentsAndResultPreattestation | OperationContentsAndResultDoublePreattestation | OperationContentsAndResultEndorsement | OperationContentsAndResultPreEndorsement | OperationContentsAndResultDoublePreEndorsement | OperationContentsAndResultRevelation | OperationContentsAndResultDoubleEndorsement | OperationContentsAndResultDoubleAttestation | OperationContentsAndResultDoubleBaking | OperationContentsAndResultActivateAccount | OperationContentsAndResultProposals | OperationContentsAndResultBallot | OperationContentsAndResultReveal | OperationContentsAndResultTransaction | OperationContentsAndResultOrigination | OperationContentsAndResultDelegation | OperationContentsAndResultAttestationWithDal | OperationContentsAndResultEndorsementWithDal | OperationContentsAndResultRegisterGlobalConstant | OperationContentsAndResultSetDepositsLimit | OperationContentsAndResultTransferTicket | OperationContentsAndResultIncreasePaidStorage | OperationContentsAndResultUpdateConsensusKey | OperationContentsAndResultDrainDelegate | OperationContentsAndResultVdfRevelation | OperationContentsAndResultSmartRollupOriginate | OperationContentsAndResultSmartRollupAddMessages | OperationContentsAndResultSmartRollupExecuteOutboxMessage | OperationContentsAndResultSmartRollupPublish | OperationContentsAndResultSmartRollupCement | OperationContentsAndResultSmartRollupRefute | OperationContentsAndResultSmartRollupRecoverBond | OperationContentsAndResultSmartRollupTimeout | OperationContentsAndResultDalPublishCommitment | OperationContentsAndResultDalEntrapmentEvidence | OperationContentsAndResultDoubleConsensusOperationEvidence | OperationContentsAndResultUpdateCompanionKey | OperationContentsAndResultPreattestationsAggregate | OperationContentsAndResultAttestationsAggregate;\nexport type OperationContentsAndResultWithFee = OperationContentsAndResultTransaction | OperationContentsAndResultOrigination | OperationContentsAndResultDelegation | OperationContentsAndResultReveal | OperationContentsAndResultRegisterGlobalConstant | OperationContentsAndResultSetDepositsLimit | OperationContentsAndResultUpdateConsensusKey | OperationContentsAndResultIncreasePaidStorage | OperationContentsAndResultTransferTicket | OperationContentsAndResultSmartRollupAddMessages | OperationContentsAndResultSmartRollupOriginate | OperationContentsAndResultSmartRollupExecuteOutboxMessage | OperationContentsAndResultDalPublishCommitment | OperationContentsAndResultUpdateCompanionKey;\nexport declare enum OPERATION_METADATA {\n    TOO_LARGE = \"too large\"\n}\nexport interface OperationEntry {\n    protocol: string;\n    chain_id: string;\n    hash: string;\n    branch: string;\n    contents: (OperationContents | OperationContentsAndResult)[];\n    signature?: string;\n    metadata?: OPERATION_METADATA;\n}\nexport interface BlockResponse {\n    protocol: string;\n    chain_id: string;\n    hash: string;\n    header: BlockFullHeader;\n    metadata: BlockMetadata;\n    operations: OperationEntry[][];\n}\nexport type BakingRightsArgumentsDelegate = string | string[];\nexport type BakingRightsArgumentsCycle = number | number[];\nexport type BakingRightsArgumentsLevel = number | number[];\nexport type AllDelegatesQueryArguments = {\n    active?: boolean;\n    inactive?: boolean;\n    with_minimal_stake?: boolean;\n    without_minimal_stake?: boolean;\n};\nexport type BakingRightsQueryArguments = BakingRightsQueryArgumentsBase;\nexport interface BakingRightsQueryArgumentsBase {\n    level?: BakingRightsArgumentsLevel;\n    cycle?: BakingRightsArgumentsCycle;\n    delegate?: BakingRightsArgumentsDelegate;\n    consensus_key?: string;\n    max_priority?: number;\n    max_round?: string;\n    all?: null;\n}\nexport interface BakingRightsResponseItem {\n    level: number;\n    delegate: string;\n    priority?: number;\n    round?: number;\n    estimated_time?: Date;\n    consensus_key?: string;\n}\nexport type BakingRightsResponse = BakingRightsResponseItem[];\nexport type AttestationRightsArgumentsDelegate = string | string[];\nexport type AttestationRightsArgumentsCycle = number | number[];\nexport type AttestationRightsArgumentsLevel = number | number[];\nexport interface AttestationRightsQueryArguments {\n    level?: AttestationRightsArgumentsLevel;\n    cycle?: AttestationRightsArgumentsCycle;\n    delegate?: AttestationRightsArgumentsDelegate;\n    consensus_key?: string;\n}\nexport interface AttestationRightsResponseItemDelegates {\n    delegate: string;\n    first_slot: number;\n    attestation_power: number;\n    consensus_key: string;\n}\nexport interface AttestationRightsResponseItem {\n    level: number;\n    delegate?: string;\n    delegates?: AttestationRightsResponseItemDelegates[];\n    slots?: number[];\n    estimated_time?: Date;\n}\nexport type AttestationRightsResponse = AttestationRightsResponseItem[];\nexport type BallotListResponseEnum = 'nay' | 'yay' | 'pass';\nexport interface BallotListResponseItem {\n    pkh: string;\n    ballot: BallotListResponseEnum;\n}\nexport type BallotListResponse = BallotListResponseItem[];\nexport interface BallotsResponse {\n    yay: BigNumber;\n    nay: BigNumber;\n    pass: BigNumber;\n}\nexport type PeriodKindResponse = 'proposal' | 'exploration' | 'cooldown' | 'promotion' | 'adoption' | 'testing_vote' | 'testing' | 'promotion_vote';\nexport type CurrentProposalResponse = string | null;\nexport type CurrentQuorumResponse = number;\nexport interface VotesListingsResponseItem {\n    pkh: string;\n    rolls?: number;\n    voting_power?: BigNumber;\n}\nexport type VotesListingsResponse = VotesListingsResponseItem[];\nexport type ProposalsResponseItem = [string, BigNumber];\nexport type ProposalsResponse = ProposalsResponseItem[];\nexport type HeaderContentEnum = 'activate' | 'activate_testchain';\nexport interface HeaderContent {\n    command: HeaderContentEnum;\n    hash: string;\n    fitness: string[];\n    protocol_parameters: string;\n}\nexport interface BlockHeaderResponse {\n    protocol: string;\n    chain_id: string;\n    hash: string;\n    level: number;\n    proto: number;\n    predecessor: string;\n    timestamp: string;\n    validation_pass: number;\n    operations_hash: string;\n    fitness: string[];\n    context: string;\n    content: HeaderContent;\n    payload_hash?: string;\n    payload_round?: number;\n    priority?: number;\n    proof_of_work_nonce: string;\n    liquidity_baking_escape_vote?: boolean | LiquidityBakingToggleVotes;\n    signature: string;\n}\nexport interface PackDataParams {\n    data: MichelsonV1Expression;\n    type: MichelsonV1Expression;\n    gas?: BigNumber;\n}\nexport interface TicketTokenParams {\n    ticketer: string;\n    content_type: MichelsonV1Expression;\n    content: MichelsonV1Expression;\n}\nexport interface TicketBalance {\n    ticketer: string;\n    content_type: MichelsonV1Expression;\n    content: MichelsonV1Expression;\n    amount: string;\n}\nexport type AllTicketBalances = TicketBalance[];\nexport type HexString = string;\nexport interface PackDataResponse {\n    packed: HexString;\n    gas?: BigNumber | 'unaccounted';\n}\nexport type BigMapResponse = MichelsonV1Expression | MichelsonV1Expression[];\nexport type SaplingDiffResponse = {\n    root: SaplingTransactionCommitmentHash;\n    commitments_and_ciphertexts: CommitmentsAndCiphertexts[];\n    nullifiers: string[];\n};\nexport type SaplingTransactionCommitmentHash = string;\nexport type PreapplyParams = OperationObject[];\nexport type PreapplyResponse = {\n    contents: OperationContentsAndResult[];\n};\nexport type ForgeOperationsParams = Pick<OperationObject, 'branch' | 'contents'>;\nexport type TimeStampMixed = Date | string;\nexport type BalanceUpdateKindEnum = MetadataBalanceUpdatesKindEnum;\nexport type BalanceUpdateCategoryEnum = MetadataBalanceUpdatesCategoryEnum;\nexport interface MichelsonV1ExpressionBase {\n    int?: string;\n    string?: string;\n    bytes?: string;\n}\nexport interface MichelsonV1ExpressionExtended {\n    prim: string;\n    args?: MichelsonV1Expression[];\n    annots?: string[];\n}\nexport type MichelsonV1Expression = MichelsonV1ExpressionBase | MichelsonV1ExpressionExtended | MichelsonV1Expression[];\nexport interface ScriptedContracts {\n    code: MichelsonV1Expression[];\n    storage: MichelsonV1Expression;\n}\nexport type AILaunchCycleResponse = number | null;\nexport type BondId = {\n    smart_rollup: string;\n};\nexport type OperationBalanceUpdates = OperationMetadataBalanceUpdates[];\nexport interface OperationObject {\n    branch?: string;\n    contents?: OperationContents[];\n    protocol?: string;\n    signature?: string;\n}\nexport type InternalOperationResultKindEnum = OpKind.TRANSACTION | OpKind.ORIGINATION | OpKind.DELEGATION | OpKind.EVENT;\nexport type SuccessfulManagerOperationResultKindEnum = OpKind.REVEAL | OpKind.TRANSACTION | OpKind.ORIGINATION | OpKind.DELEGATION;\nexport type InternalOperationResultEnum = OperationResultReveal | OperationResultTransaction | OperationResultDelegation | OperationResultOrigination | OperationResultEvent;\nexport interface OperationResultTransferTicket {\n    status: OperationResultStatusEnum;\n    balance_updates?: OperationBalanceUpdates;\n    ticket_updates?: TicketUpdates[];\n    consumed_milligas?: string;\n    paid_storage_size_diff?: string;\n    errors?: TezosGenericOperationError[];\n}\nexport interface OperationResultIncreasePaidStorage {\n    status: OperationResultStatusEnum;\n    balance_updates?: OperationBalanceUpdates;\n    consumed_milligas?: string;\n    errors?: TezosGenericOperationError[];\n}\nexport interface OperationResultUpdateConsensusKey {\n    status: OperationResultStatusEnum;\n    consumed_milligas?: string;\n    errors?: TezosGenericOperationError[];\n    kind?: boolean;\n}\nexport interface OperationResultDelegation {\n    status: OperationResultStatusEnum;\n    consumed_gas?: string;\n    errors?: TezosGenericOperationError[];\n    consumed_milligas?: string;\n}\nexport interface OperationResultSetDepositsLimit {\n    status: OperationResultStatusEnum;\n    consumed_gas?: string;\n    errors?: TezosGenericOperationError[];\n    consumed_milligas?: string;\n}\nexport interface OperationResultRegisterGlobalConstant {\n    status: OperationResultStatusEnum;\n    balance_updates?: OperationBalanceUpdates;\n    consumed_gas?: string;\n    storage_size?: string;\n    global_address?: string;\n    errors?: TezosGenericOperationError[];\n    consumed_milligas?: string;\n}\nexport interface OperationResultSmartRollupOriginate {\n    status: OperationResultStatusEnum;\n    balance_updates?: OperationBalanceUpdates;\n    address?: string;\n    genesis_commitment_hash?: string;\n    consumed_milligas?: string;\n    size?: string;\n    errors?: TezosGenericOperationError[];\n}\nexport interface OperationResultSmartRollupAddMessages {\n    status: OperationResultStatusEnum;\n    consumed_milligas?: string;\n    errors?: TezosGenericOperationError[];\n}\nexport interface OperationResultSmartRollupExecuteOutboxMessage {\n    status: OperationResultStatusEnum;\n    balance_updates?: OperationBalanceUpdates;\n    ticket_updates?: TicketUpdates[];\n    consumed_milligas?: string;\n    paid_storage_size_diff?: string;\n    errors?: TezosGenericOperationError[];\n}\nexport interface OperationResultSmartRollupPublish {\n    status: OperationResultStatusEnum;\n    consumed_milligas?: string;\n    staked_hash?: string;\n    published_at_level?: number;\n    balance_updates?: OperationBalanceUpdates;\n    errors?: TezosGenericOperationError[];\n}\nexport interface OperationResultSmartRollupCement {\n    status: OperationResultStatusEnum;\n    consumed_milligas?: string;\n    inbox_level?: number;\n    commitment_hash?: string;\n    errors?: TezosGenericOperationError[];\n}\nexport interface OperationResultSmartRollupRefute {\n    status: OperationResultStatusEnum;\n    consumed_milligas?: string;\n    game_status?: SmartRollupGameStatus;\n    balance_updates?: OperationBalanceUpdates;\n    errors?: TezosGenericOperationError[];\n}\nexport interface OperationResultSmartRollupRecoverBond {\n    status: OperationResultStatusEnum;\n    balance_updates?: OperationBalanceUpdates;\n    consumed_milligas?: string;\n    errors?: TezosGenericOperationError[];\n}\nexport interface OperationResultSmartRollupTimeout {\n    status: OperationResultStatusEnum;\n    consumed_milligas?: string;\n    game_status?: SmartRollupGameStatus;\n    balance_updates?: OperationBalanceUpdates;\n    errors?: TezosGenericOperationError[];\n}\nexport interface OperationResultDalPublishCommitment {\n    status: OperationResultStatusEnum;\n    slot_header?: {\n        version: string;\n        level: number;\n        index: number;\n        commitment: string;\n    };\n    consumed_milligas?: string;\n    errors?: TezosGenericOperationError[];\n}\nexport interface ContractBigMapDiffItem {\n    key_hash?: string;\n    key?: MichelsonV1Expression;\n    value?: MichelsonV1Expression;\n    action?: DiffActionEnum;\n    big_map?: string;\n    source_big_map?: string;\n    destination_big_map?: string;\n    key_type?: MichelsonV1Expression;\n    value_type?: MichelsonV1Expression;\n}\nexport type ContractBigMapDiff = ContractBigMapDiffItem[];\nexport interface TezosGenericOperationError {\n    kind: string;\n    id: string;\n    delegate?: string;\n}\nexport interface TicketUpdates {\n    ticket_token: {\n        ticketer: string;\n        content_type: MichelsonV1Expression;\n        content: MichelsonV1Expression;\n    };\n    updates: {\n        account: string;\n        amount: string;\n    }[];\n}\nexport type TicketReceipt = TicketUpdates;\nexport type BatchOperationResult = OperationResultTransaction | OperationResultReveal | OperationResultDelegation | OperationResultOrigination | OperationResultIncreasePaidStorage | OperationResultRegisterGlobalConstant | OperationResultTransferTicket | OperationResultSmartRollupAddMessages | OperationResultSmartRollupOriginate | OperationResultUpdateConsensusKey;\nexport type OperationResult = OperationResultOrigination | OperationResultTransaction | OperationResultReveal | OperationResultDelegation | OperationResultIncreasePaidStorage | OperationResultRegisterGlobalConstant | OperationResultTransferTicket | OperationResultUpdateConsensusKey | OperationResultSmartRollupOriginate | OperationResultSmartRollupAddMessages | OperationResultSetDepositsLimit | OperationResultSmartRollupPublish | OperationResultSmartRollupCement | OperationResultSmartRollupRefute | OperationResultSmartRollupRecoverBond | OperationResultSmartRollupTimeout | OperationResultSmartRollupExecuteOutboxMessage | OperationResultDalPublishCommitment;\nexport interface OperationResultTransaction {\n    status: OperationResultStatusEnum;\n    storage?: MichelsonV1Expression;\n    big_map_diff?: ContractBigMapDiff;\n    balance_updates?: OperationBalanceUpdates;\n    ticket_updates?: TicketUpdates[];\n    ticket_receipt?: TicketReceipt[];\n    originated_contracts?: string[];\n    consumed_gas?: string;\n    storage_size?: string;\n    paid_storage_size_diff?: string;\n    allocated_destination_contract?: boolean;\n    errors?: TezosGenericOperationError[];\n    consumed_milligas?: string;\n    lazy_storage_diff?: LazyStorageDiff[];\n    ticket_hash?: string;\n}\nexport interface OperationResultReveal {\n    status: OperationResultStatusEnum;\n    consumed_gas?: string;\n    errors?: TezosGenericOperationError[];\n    consumed_milligas?: string;\n}\nexport interface TransactionOperationParameter {\n    entrypoint: string;\n    value: MichelsonV1Expression;\n}\nexport interface InternalOperationResult {\n    kind: InternalOperationResultKindEnum;\n    source: string;\n    nonce: number;\n    amount?: string;\n    destination?: string;\n    parameters?: TransactionOperationParameter;\n    result: InternalOperationResultEnum;\n    balance?: string;\n    delegate?: string;\n    script?: ScriptedContracts;\n    type?: MichelsonV1Expression;\n    tag?: string;\n    payload?: MichelsonV1Expression;\n    public_key?: string;\n    value?: MichelsonV1Expression;\n    limit?: string;\n}\nexport interface SuccessfulManagerOperationResult {\n    kind: SuccessfulManagerOperationResultKindEnum;\n    consumed_gas?: string;\n    consumed_milligas?: string;\n    storage?: MichelsonV1Expression;\n    big_map_diff?: ContractBigMapDiff;\n    balance_updates?: OperationBalanceUpdates;\n    originated_contracts?: string[];\n    storage_size?: string;\n    paid_storage_size_diff?: string;\n    lazy_storage_diff?: LazyStorageDiff[];\n}\nexport type MetadataBalanceUpdatesKindEnum = 'contract' | 'accumulator' | 'freezer' | 'minted' | 'burned' | 'commitment' | 'staking';\nexport declare enum METADATA_BALANCE_UPDATES_CATEGORY {\n    ACTIVATION = \"activation\",\n    ATTESTATION = \"attestation\",\n    ATTESTATIONS_AGGREGATE = \"attestations_aggregate\",\n    ATTESTATION_WITH_DAL = \"attestation_with_dal\",\n    ATTESTING_REWARDS = \"attesting rewards\",\n    BAKING_BONUSES = \"baking bonuses\",\n    BAKING_REWARDS = \"baking rewards\",\n    BALLOT = \"ballot\",\n    BLOCK_FEES = \"block fees\",\n    BONDS = \"bonds\",\n    BOOTSTRAP = \"bootstrap\",\n    BURNED = \"burned\",\n    COMMITMENT = \"commitment\",\n    DAL_ATTESTING_REWARDS = \"dal attesting rewards\",\n    DAL_ENTRAPMENT_EVIDENCE = \"dal_entrapment_evidence\",\n    DAL_PUBLISH_COMMITMENT = \"dal_publish_commitment\",\n    DELEGATE_DENOMINATOR = \"delegate_denominator\",\n    DELEGATION = \"delegation\",\n    DELEGATOR_NUMERATOR = \"delegator_numerator\",\n    DEPOSITS = \"deposits\",\n    DOUBLE_ATTESTATION_EVIDENCE = \"double_attestation_evidence\",\n    DOUBLE_BAKING_EVIDENCE = \"double_baking_evidence\",\n    DOUBLE_ENDORSEMENT_EVIDENCE = \"double_endorsement_evidence\",\n    DOUBLE_PREATTESTATION_EVIDENCE = \"double_preattestation_evidence\",\n    DOUBLE_PREENDORSEMENT_EVIDENCE = \"double_preendorsement_evidence\",\n    DRAIN_DELEGATE = \"drain_delegate\",\n    ENDORSEMENT = \"endorsement\",\n    ENDORSEMENT_WITH_DAL = \"endorsement_with_dal\",\n    EVENT = \"event\",\n    FAILING_NOOP = \"failing_noop\",\n    INCREASE_PAID_STORAGE = \"increase_paid_storage\",\n    INVOICE = \"invoice\",\n    LOST_ATTESTING_REWARDS = \"lost attesting rewards\",\n    LOST_DAL_ATTESTING_REWARDS = \"lost dal attesting rewards\",\n    MINTED = \"minted\",\n    NONCE_REVELATION_REWARDS = \"nonce revelation rewards\",\n    ORIGINATION = \"origination\",\n    PREATTESTATION = \"preattestation\",\n    PREATTESTATIONS_AGGREGATE = \"preattestations_aggregate\",\n    PREENDORSEMENT = \"preendorsement\",\n    PROPOSALS = \"proposals\",\n    PUNISHMENTS = \"punishments\",\n    REGISTER_GLOBAL_CONSTANT = \"register_global_constant\",\n    REVEAL = \"reveal\",\n    SEED_NONCE_REVELATION = \"seed_nonce_revelation\",\n    SET_DEPOSITS_LIMIT = \"set_deposits_limit\",\n    SMART_ROLLUP_ADD_MESSAGES = \"smart_rollup_add_messages\",\n    SMART_ROLLUP_CEMENT = \"smart_rollup_cement\",\n    SMART_ROLLUP_EXECUTE_OUTBOX_MESSAGE = \"smart_rollup_execute_outbox_message\",\n    SMART_ROLLUP_ORIGINATE = \"smart_rollup_originate\",\n    SMART_ROLLUP_PUBLISH = \"smart_rollup_publish\",\n    SMART_ROLLUP_RECOVER_BOND = \"smart_rollup_recover_bond\",\n    SMART_ROLLUP_REFUTATION_PUNISHMENTS = \"smart_rollup_refutation_punishments\",\n    SMART_ROLLUP_REFUTATION_REWARDS = \"smart_rollup_refutation_rewards\",\n    SMART_ROLLUP_REFUTE = \"smart_rollup_refute\",\n    SMART_ROLLUP_TIMEOUT = \"smart_rollup_timeout\",\n    STORAGE_FEES = \"storage fees\",\n    SUBSIDY = \"subsidy\",\n    TICKET_UPDATES = \"ticket_updates\",\n    TRANSACTION = \"transaction\",\n    TRANSFER_TICKET = \"transfer_ticket\",\n    UNSTAKED_DEPOSITS = \"unstaked_deposits\",\n    UPDATE_COMPANION_KEY = \"update_companion_key\",\n    UPDATE_CONSENSUS_KEY = \"update_consensus_key\",\n    VDF_REVELATION = \"vdf_revelation\"\n}\nexport type MetadataBalanceUpdatesCategoryEnum = METADATA_BALANCE_UPDATES_CATEGORY;\nexport type MetadataBalanceUpdatesOriginEnum = 'block' | 'migration' | 'subsidy' | 'simulation' | 'delayed_operation';\nexport type FrozenStaker = SingleStaker | SharedStaker | Baker | Baker_edge;\nexport type Staker = SingleStaker | SharedStaker;\nexport interface SingleStaker {\n    contract: string;\n    delegate: string;\n}\nexport interface SharedStaker {\n    delegate: string;\n}\nexport interface Baker {\n    baker_own_stake: string;\n}\nexport interface Baker_edge {\n    baker_edge: string;\n}\nexport interface OperationMetadataBalanceUpdates {\n    kind: MetadataBalanceUpdatesKindEnum;\n    contract?: string;\n    change: string;\n    origin?: MetadataBalanceUpdatesOriginEnum;\n    category?: MetadataBalanceUpdatesCategoryEnum;\n    staker?: FrozenStaker | Staker;\n    delegate?: string;\n    participation?: boolean;\n    revelation?: boolean;\n    committer?: string;\n    bond_id?: BondId;\n    cycle?: number;\n    delegator?: string;\n    delayed_operation_hash?: string;\n}\nexport type OperationResultStatusEnum = 'applied' | 'failed' | 'skipped' | 'backtracked';\nexport type DiffActionEnum = 'update' | 'remove' | 'copy' | 'alloc';\nexport type LazyStorageDiff = LazyStorageDiffBigMap | LazyStorageDiffSaplingState;\nexport interface LazyStorageDiffBigMap {\n    kind: 'big_map';\n    id: string;\n    diff: LazyStorageDiffBigMapItems;\n}\nexport interface LazyStorageDiffSaplingState {\n    kind: 'sapling_state';\n    id: string;\n    diff: LazyStorageDiffSaplingStateItems;\n}\nexport interface LazyStorageDiffBigMapItems {\n    action: DiffActionEnum;\n    updates?: LazyStorageDiffUpdatesBigMap[];\n    source?: string;\n    key_type?: MichelsonV1Expression;\n    value_type?: MichelsonV1Expression;\n}\nexport interface LazyStorageDiffSaplingStateItems {\n    action: DiffActionEnum;\n    updates?: LazyStorageDiffUpdatesSaplingState;\n    source?: string;\n    memo_size?: number;\n}\nexport interface LazyStorageDiffUpdatesBigMap {\n    key_hash: string;\n    key: MichelsonV1Expression;\n    value?: MichelsonV1Expression;\n}\nexport type CommitmentsAndCiphertexts = [\n    SaplingTransactionCommitment,\n    SaplingTransactionCiphertext\n];\nexport type SaplingTransactionCommitment = string;\nexport interface LazyStorageDiffUpdatesSaplingState {\n    commitments_and_ciphertexts: CommitmentsAndCiphertexts[];\n    nullifiers: string[];\n}\nexport interface SaplingTransactionCiphertext {\n    cv: string;\n    epk: string;\n    payload_enc: string;\n    nonce_enc: string;\n    payload_out: string;\n    nonce_out: string;\n}\nexport interface OperationResultOrigination {\n    status: OperationResultStatusEnum;\n    big_map_diff?: ContractBigMapDiff;\n    balance_updates?: OperationBalanceUpdates;\n    originated_contracts?: string[];\n    consumed_gas?: string;\n    storage_size?: string;\n    paid_storage_size_diff?: string;\n    errors?: TezosGenericOperationError[];\n    consumed_milligas?: string;\n    lazy_storage_diff?: LazyStorageDiff[];\n}\nexport interface OperationResultEvent {\n    status: OperationResultStatusEnum;\n    consumed_milligas?: string;\n    errors?: TezosGenericOperationError[];\n}\nexport interface OperationContentsAndResultMetadataOrigination {\n    balance_updates: OperationMetadataBalanceUpdates[];\n    operation_result: OperationResultOrigination;\n    internal_operation_results?: InternalOperationResult[];\n}\nexport type ConstantsResponse = ConstantsResponseCommon & ConstantsResponseProto023 & ConstantsResponseProto022 & ConstantsResponseProto021 & ConstantsResponseProto020 & ConstantsResponseProto019 & ConstantsResponseProto017 & ConstantsResponseProto016 & ConstantsResponseProto015 & ConstantsResponseProto014 & ConstantsResponseProto013 & ConstantsResponseProto012 & ConstantsResponseProto011 & ConstantsResponseProto010 & ConstantsResponseProto009 & ConstantsResponseProto008 & ConstantsResponseProto007 & ConstantsResponseProto006 & ConstantsResponseProto005 & ConstantsResponseProto004 & ConstantsResponseProto003 & ConstantsResponseProto001And002;\nexport interface ConstantsResponseCommon {\n    proof_of_work_nonce_size: number;\n    nonce_length: number;\n    max_operation_data_length: number;\n    preserved_cycles: number;\n    blocks_per_cycle: number;\n    blocks_per_commitment: number;\n    blocks_per_roll_snapshot: number;\n    blocks_per_voting_period: number;\n    time_between_blocks: BigNumber[];\n    endorsers_per_block: number;\n    hard_gas_limit_per_operation: BigNumber;\n    hard_gas_limit_per_block: BigNumber;\n    proof_of_work_threshold: BigNumber;\n    tokens_per_roll: BigNumber;\n    michelson_maximum_type_size: number;\n    seed_nonce_revelation_tip: BigNumber;\n    block_security_deposit: BigNumber;\n    endorsement_security_deposit: BigNumber;\n    endorsement_reward: BigNumber | BigNumber[];\n    cost_per_byte: BigNumber;\n    hard_storage_limit_per_operation: BigNumber;\n}\nexport type Ratio = {\n    numerator: number;\n    denominator: number;\n};\nexport type ConstantsResponseProto023 = ConstantsResponseProto022;\nexport interface ConstantsResponseProto022 extends Omit<ConstantsResponseProto021, 'adaptive_issuance_activation_vote_enable' | 'adaptive_issuance_force_activation' | 'adaptive_issuance_launch_ema_threshold' | 'autostaking_enable' | 'consensus_threshold' | 'issuance_weights' | 'dal_parametric' | 'max_slashing_period' | 'max_slashing_threshold' | 'ns_enable' | 'percentage_of_frozen_deposits_slashed_per_double_attestation'> {\n    aggregate_attestation: boolean;\n    all_bakers_attest_activation_level: null | number;\n    allow_tz4_delegate_enable: boolean;\n    consensus_key_activation_delay: number;\n    consensus_threshold_size: number;\n    dal_parametric: {\n        attestation_lag: number;\n        attestation_threshold: number;\n        feature_enable: boolean;\n        incentives_enable: boolean;\n        minimal_participation_ratio: Ratio;\n        number_of_shards: number;\n        number_of_slots: number;\n        page_size: number;\n        redundancy_factor: number;\n        rewards_ratio: Ratio;\n        slot_size: number;\n        traps_fraction: Ratio;\n    };\n    denunciation_period: number;\n    issuance_modification_delay: number;\n    issuance_weights: {\n        attesting_reward_weight: number;\n        baking_reward_bonus_weight: number;\n        baking_reward_fixed_portion_weight: number;\n        base_total_issued_per_minute: string;\n        dal_rewards_weight: number;\n        seed_nonce_revelation_tip_weight: number;\n        vdf_revelation_tip_weight: number;\n    };\n    max_slashing_threshold: Ratio;\n    slashing_delay: number;\n    tolerated_inactivity_period: number;\n    unstake_finalization_delay: number;\n}\nexport type ConstantsResponseProto021 = ConstantsResponseProto020;\nexport interface ConstantsResponseProto020 extends Omit<ConstantsResponseProto019, 'adaptive_rewards_params' | 'blocks_per_stake_snapshot' | 'dal_parametric' | 'issuance_weights' | 'liquidity_baking_subsidy_weight' | 'preserved_cycles' | 'smart_rollup_reveal_activation_level'> {\n    adaptive_issuance_force_activation: boolean;\n    adaptive_rewards_params: {\n        center_dz: {\n            denominator: string;\n            numerator: string;\n        };\n        growth_rate: {\n            denominator: string;\n            numerator: string;\n        };\n        issuance_ratio_final_max: {\n            denominator: string;\n            numerator: string;\n        };\n        issuance_ratio_final_min: {\n            denominator: string;\n            numerator: string;\n        };\n        issuance_ratio_initial_max: {\n            denominator: string;\n            numerator: string;\n        };\n        issuance_ratio_initial_min: {\n            denominator: string;\n            numerator: string;\n        };\n        max_bonus: string;\n        radius_dz: {\n            denominator: string;\n            numerator: string;\n        };\n        initial_period: number;\n        transition_period: number;\n    };\n    blocks_preservation_cycles: number;\n    consensus_rights_delay: number;\n    dal_parametric: {\n        attestation_lag: number;\n        attestation_threshold: number;\n        feature_enable: boolean;\n        incentives_enable: boolean;\n        number_of_shards: number;\n        number_of_slots: number;\n        page_size: number;\n        redundancy_factor: number;\n        slot_size: number;\n    };\n    delegate_parameters_activation_delay: number;\n    direct_ticket_spending_enable: boolean;\n    issuance_weights: {\n        attesting_reward_weight: number;\n        baking_reward_bonus_weight: number;\n        baking_reward_fixed_portion_weight: number;\n        base_total_issued_per_minute: string;\n        seed_nonce_revelation_tip_weight: number;\n        vdf_revelation_tip_weight: number;\n    };\n    liquidity_baking_subsidy: string;\n    max_slashing_per_block: number;\n    max_slashing_threshold: number;\n    ns_enable: boolean;\n    smart_rollup_reveal_activation_level: {\n        dal_attested_slots_validity_lag: number;\n        dal_page: number;\n        dal_parameters: number;\n        metadata: number;\n        raw_data: {\n            Blake2B: number;\n        };\n    };\n}\nexport interface ConstantsResponseProto019 extends Omit<ConstantsResponseProto017, 'baking_reward_bonus_per_slot' | 'baking_reward_fixed_portion' | 'double_baking_punishment' | 'endorsing_reward_per_slot' | 'frozen_deposits_percentage' | 'liquidity_baking_subsidy' | 'ratio_of_frozen_deposits_slashed_per_double_endorsement' | 'seed_nonce_revelation_tip' | 'smart_rollup_enable' | 'tx_rollup_commitment_bond' | 'tx_rollup_cost_per_byte_ema_factor' | 'tx_rollup_enable' | 'tx_rollup_finality_period' | 'tx_rollup_hard_size_limit_per_inbox' | 'tx_rollup_hard_size_limit_per_message' | 'tx_rollup_max_commitments_count' | 'tx_rollup_max_inboxes_count' | 'tx_rollup_max_messages_per_inbox' | 'tx_rollup_max_ticket_payload_size' | 'tx_rollup_max_withdrawals_per_batch' | 'tx_rollup_origination_size' | 'tx_rollup_rejection_max_proof_size' | 'tx_rollup_sunset_level' | 'tx_rollup_withdraw_period'> {\n    adaptive_issuance_activation_vote_enable: boolean;\n    adaptive_issuance_launch_ema_threshold: number;\n    adaptive_rewards_params: {\n        center_dz: {\n            denominator: string;\n            numerator: string;\n        };\n        growth_rate: {\n            denominator: string;\n            numerator: string;\n        };\n        issuance_ratio_max: {\n            denominator: string;\n            numerator: string;\n        };\n        issuance_ratio_min: {\n            denominator: string;\n            numerator: string;\n        };\n        max_bonus: string;\n        radius_dz: {\n            denominator: string;\n            numerator: string;\n        };\n    };\n    autostaking_enable: boolean;\n    edge_of_staking_over_delegation: number;\n    global_limit_of_staking_over_baking: number;\n    issuance_weights: {\n        attesting_reward_weight: number;\n        baking_reward_bonus_weight: number;\n        baking_reward_fixed_portion_weight: number;\n        base_total_issued_per_minute: string;\n        liquidity_baking_subsidy_weight: number;\n        seed_nonce_revelation_tip_weight: number;\n        vdf_revelation_tip_weight: number;\n    };\n    limit_of_delegation_over_baking: number;\n    minimal_frozen_stake: string;\n    percentage_of_frozen_deposits_slashed_per_double_attestation: number;\n    percentage_of_frozen_deposits_slashed_per_double_baking: number;\n    smart_rollup_private_enable: boolean;\n    smart_rollup_reveal_activation_level: {\n        dal_page: number;\n        dal_parameters: number;\n        metadata: number;\n        raw_data: {\n            Blake2B: number;\n        };\n    };\n    smart_rollup_riscv_pvm_enable: boolean;\n    zk_rollup_max_ticket_payload_size: number;\n}\nexport type ConstantsResponseProto017 = ConstantsResponseProto016;\nexport interface ConstantsResponseProto016 extends Omit<ConstantsResponseProto015, 'sc_max_wrapped_proof_binary_size' | 'sc_rollup_challenge_window_in_blocks' | 'sc_rollup_commitment_period_in_blocks' | 'sc_rollup_enable' | 'sc_rollup_max_active_outbox_levels' | 'sc_rollup_max_lookahead_in_blocks' | 'sc_rollup_max_number_of_cemented_commitments' | 'sc_rollup_max_number_of_messages_per_commitment_period' | 'sc_rollup_max_outbox_messages_per_level' | 'sc_rollup_message_size_limit' | 'sc_rollup_number_of_sections_in_dissection' | 'sc_rollup_origination_size' | 'sc_rollup_stake_amount' | 'sc_rollup_timeout_period_in_blocks'> {\n    smart_rollup_arith_pvm_enable: boolean;\n    smart_rollup_challenge_window_in_blocks: number;\n    smart_rollup_commitment_period_in_blocks: number;\n    smart_rollup_enable: boolean;\n    smart_rollup_max_active_outbox_levels: number;\n    smart_rollup_max_lookahead_in_blocks: number;\n    smart_rollup_max_number_of_cemented_commitments: number;\n    smart_rollup_max_number_of_messages_per_level: string;\n    smart_rollup_max_number_of_parallel_games: number;\n    smart_rollup_max_outbox_messages_per_level: number;\n    smart_rollup_max_wrapped_proof_binary_size: number;\n    smart_rollup_message_size_limit: number;\n    smart_rollup_number_of_sections_in_dissection: number;\n    smart_rollup_origination_size: number;\n    smart_rollup_stake_amount: string;\n    smart_rollup_timeout_period_in_blocks: number;\n}\nexport interface ConstantsResponseProto015 extends Omit<ConstantsResponseProto014, 'max_wrapped_proof_binary_size' | 'tokens_per_roll' | 'liquidity_baking_sunset_level' | 'sc_rollup_max_available_messages'> {\n    minimal_stake: BigNumber;\n    sc_max_wrapped_proof_binary_size: number;\n    sc_rollup_message_size_limit: number;\n    sc_rollup_max_number_of_messages_per_commitment_period: number;\n    sc_rollup_number_of_sections_in_dissection: number;\n    sc_rollup_timeout_period_in_blocks: number;\n    sc_rollup_max_number_of_cemented_commitments: number;\n    zk_rollup_enable: number;\n    zk_rollup_origination_size: number;\n    zk_rollup_min_pending_to_process: number;\n}\nexport interface DalParametric {\n    feature_enable: boolean;\n    number_of_slots: number;\n    attestation_lag: number;\n    attestation_threshold?: number;\n    blocks_per_epoch?: number;\n    redundancy_factor?: number;\n    page_size?: number;\n    slot_size?: number;\n    number_of_shards: number;\n    endorsement_lag?: number;\n    availability_threshold: number;\n}\nexport interface ConstantsResponseProto014 extends ConstantsResponseProto013 {\n    max_wrapped_proof_binary_size?: number;\n    nonce_revelation_threshold?: number;\n    vdf_difficulty?: BigNumber;\n    testnet_dictator?: string;\n    dal_parametric?: DalParametric;\n    sc_rollup_stake_amount?: BigNumber;\n    sc_rollup_commitment_period_in_blocks?: number;\n    sc_rollup_max_lookahead_in_blocks?: number;\n    sc_rollup_max_active_outbox_levels?: number;\n    sc_rollup_max_outbox_messages_per_level?: number;\n}\nexport interface ConstantsResponseProto013 extends Omit<ConstantsResponseProto012, 'blocks_per_voting_period' | 'cache_layout' | 'delegate_selection' | 'liquidity_baking_escape_ema_threshold'> {\n    cache_layout_size?: number;\n    cache_sampler_state_cycles?: number;\n    cache_script_size?: number;\n    cache_stake_distribution_cycles?: number;\n    cycles_per_voting_period?: number;\n    liquidity_baking_toggle_ema_threshold?: number;\n    initial_seed?: string;\n    tx_rollup_enable?: boolean;\n    tx_rollup_origination_size?: number;\n    tx_rollup_hard_size_limit_per_inbox?: number;\n    tx_rollup_hard_size_limit_per_message?: number;\n    tx_rollup_max_withdrawals_per_batch?: number;\n    tx_rollup_commitment_bond?: BigNumber;\n    tx_rollup_finality_period?: number;\n    tx_rollup_withdraw_period?: number;\n    tx_rollup_max_inboxes_count?: number;\n    tx_rollup_max_messages_per_inbox?: number;\n    tx_rollup_max_commitments_count?: number;\n    tx_rollup_cost_per_byte_ema_factor?: number;\n    tx_rollup_max_ticket_payload_size?: number;\n    tx_rollup_rejection_max_proof_size?: number;\n    tx_rollup_sunset_level?: number;\n    sc_rollup_enable?: boolean;\n    sc_rollup_origination_size?: number;\n    sc_rollup_challenge_window_in_blocks?: number;\n    sc_rollup_max_available_messages?: number;\n}\nexport interface ConstantsResponseProto012 extends Omit<ConstantsResponseProto011, 'baking_reward_per_endorsement' | 'initial_endorsers' | 'delay_per_missing_endorsement' | 'test_chain_duration' | 'blocks_per_roll_snapshot' | 'time_between_blocks' | 'endorsers_per_block' | 'block_security_deposit' | 'endorsement_security_deposit' | 'endorsement_reward'> {\n    blocks_per_stake_snapshot?: number;\n    baking_reward_fixed_portion?: BigNumber;\n    baking_reward_bonus_per_slot?: BigNumber;\n    endorsing_reward_per_slot?: BigNumber;\n    max_operations_time_to_live?: number;\n    consensus_committee_size?: number;\n    consensus_threshold?: number;\n    minimal_participation_ratio?: Ratio;\n    max_slashing_period?: number;\n    frozen_deposits_percentage?: number;\n    double_baking_punishment?: BigNumber;\n    ratio_of_frozen_deposits_slashed_per_double_endorsement?: Ratio;\n    delegate_selection?: 'random' | string[][];\n    delay_increment_per_round?: BigNumber;\n}\nexport interface ConstantsResponseProto011 extends ConstantsResponseProto010 {\n    max_micheline_node_count?: number;\n    max_allowed_global_constants_depth?: number;\n    max_micheline_bytes_limit?: number;\n    cache_layout?: BigNumber[];\n}\nexport interface ConstantsResponseProto010 extends ConstantsResponseProto009 {\n    minimal_block_delay?: BigNumber;\n    liquidity_baking_subsidy?: BigNumber;\n    liquidity_baking_sunset_level?: number;\n    liquidity_baking_escape_ema_threshold?: number;\n}\nexport interface ConstantsResponseProto009 extends ConstantsResponseProto008 {\n}\nexport interface ConstantsResponseProto008 extends ConstantsResponseProto007 {\n}\nexport interface ConstantsResponseProto007 extends Omit<ConstantsResponseProto006, 'max_revelations_per_block'> {\n    max_anon_ops_per_block?: number;\n}\nexport interface ConstantsResponseProto006 extends Omit<ConstantsResponseProto005, 'block_reward'> {\n    baking_reward_per_endorsement?: BigNumber[];\n}\nexport interface ConstantsResponseProto005 extends ConstantsResponseProto004 {\n    quorum_min?: number;\n    quorum_max?: number;\n    min_proposal_quorum?: number;\n    initial_endorsers?: number;\n    delay_per_missing_endorsement?: BigNumber;\n}\nexport interface ConstantsResponseProto004 extends ConstantsResponseProto003 {\n    test_chain_duration?: BigNumber;\n}\nexport interface ConstantsResponseProto003 extends Omit<ConstantsResponseProto001And002, 'origination_burn'> {\n    origination_size?: number;\n    max_proposals_per_delegate?: number;\n}\nexport interface ConstantsResponseProto001And002 extends ConstantsResponseCommon {\n    max_revelations_per_block?: number;\n    origination_burn?: string;\n    block_reward?: BigNumber;\n}\nexport interface ContractResponse {\n    balance: BigNumber;\n    script: ScriptedContracts;\n    counter?: string;\n    delegate?: string;\n    revealed?: boolean;\n}\nexport interface TestChainStatus {\n    status: 'not_running' | 'forking' | 'running';\n    protocol?: string;\n    expiration?: TimeStampMixed;\n    chain_id?: string;\n    genesis?: string;\n}\nexport interface MaxOperationListLength {\n    max_size: number;\n    max_op?: number;\n}\nexport interface Level {\n    level: number;\n    level_position: number;\n    cycle: number;\n    cycle_position: number;\n    voting_period: number;\n    voting_period_position: number;\n    expected_commitment: boolean;\n}\nexport interface LevelInfo {\n    level: number;\n    level_position: number;\n    cycle: number;\n    cycle_position: number;\n    expected_commitment: boolean;\n}\nexport interface BlockMetadata {\n    protocol: string;\n    next_protocol: string;\n    test_chain_status: TestChainStatus;\n    max_operations_ttl: number;\n    max_operation_data_length: number;\n    max_block_header_length: number;\n    max_operation_list_length: MaxOperationListLength[];\n    proposer?: string;\n    baker: string;\n    level_info?: LevelInfo;\n    voting_period_info?: VotingPeriodBlockResult;\n    nonce_hash?: string;\n    deactivated?: string[];\n    balance_updates?: OperationBalanceUpdates;\n    liquidity_baking_toggle_ema?: number;\n    adaptive_issuance_vote_ema?: number;\n    adaptive_issuance_activation_cycle?: number;\n    implicit_operations_results?: SuccessfulManagerOperationResult[];\n    proposer_consensus_key?: string;\n    baker_consensus_key?: string;\n    consumed_milligas?: string;\n    dal_attestation?: string;\n    level?: Level;\n    voting_period_kind?: string;\n    consumed_gas?: string;\n    liquidity_baking_escape_ema?: number;\n}\nexport type RPCRunOperationParam = {\n    operation: OperationObject;\n    chain_id: string;\n};\nexport interface RPCSimulateOperationParam extends RPCRunOperationParam {\n    blocks_before_activation?: number;\n    latency?: number;\n}\nexport type RPCRunCodeParam = {\n    script: MichelsonV1ExpressionExtended[];\n    storage: MichelsonV1Expression;\n    input: MichelsonV1Expression;\n    amount: string;\n    chain_id: string;\n    source?: string;\n    payer?: string;\n    gas?: string;\n    self?: string;\n    entrypoint?: string;\n    balance?: string;\n    unparsing_mode?: UnparsingMode;\n    now?: string;\n    level?: string;\n};\nexport type RunCodeResult = {\n    storage: MichelsonV1Expression;\n    operations: InternalOperationResult[];\n    big_map_diff?: ContractBigMapDiff;\n    lazy_storage_diff?: LazyStorageDiff;\n};\nexport type RPCRunScriptViewParam = {\n    contract: string;\n    view: string;\n    input: MichelsonV1Expression;\n    unlimited_gas?: boolean;\n    chain_id: string;\n    source?: string;\n    payer?: string;\n    gas?: string;\n    unparsing_mode?: UnparsingModeEnum;\n    now?: string;\n    level?: string;\n};\nexport type RunScriptViewResult = {\n    data: MichelsonV1Expression;\n};\nexport type RPCRunViewParam = {\n    contract: string;\n    entrypoint: string;\n    input: MichelsonV1Expression;\n    chain_id: string;\n    source?: string;\n    payer?: string;\n    gas?: BigNumber;\n    unparsing_mode?: UnparsingModeEnum;\n};\nexport type RunViewResult = {\n    data: MichelsonV1Expression;\n};\nexport type EntrypointsResponse = {\n    entrypoints: {\n        [key: string]: MichelsonV1ExpressionExtended;\n    };\n    unreachable?: {\n        path: ('Left' | 'Right')[];\n    };\n};\nexport interface OperationContentsAndResultOrigination {\n    kind: OpKind.ORIGINATION;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    balance: string;\n    delegate?: string;\n    script?: ScriptedContracts;\n    metadata: OperationContentsAndResultMetadataOrigination;\n}\nexport interface VotingPeriodResult {\n    index: number;\n    kind: PeriodKindResponse;\n    start_position: number;\n}\nexport interface VotingPeriodBlockResult {\n    voting_period: VotingPeriodResult;\n    position: number;\n    remaining: number;\n}\nexport type UnparsingModeEnum = 'Readable' | 'Optimized' | 'Optimized_legacy';\nexport type UnparsingMode = {\n    unparsing_mode: UnparsingModeEnum;\n};\nexport type ProtocolsResponse = {\n    protocol: string;\n    next_protocol: string;\n};\nexport type ProtocolActivationsResponse = ProtocolActivation[] | ProtocolActivation;\nexport type ProtocolActivation = {\n    protocol: string;\n    proto_level: number;\n    activation_block: {\n        block_hash: string;\n        level: number;\n    };\n};\nexport type Next = {\n    next: number;\n} | {\n    newest: number;\n    oldest: number;\n};\nexport type LastRemovedCommitmentHashes = {\n    last_message_hash: string;\n    commitment_hash: string;\n};\nexport interface PendingOperationsQueryArguments {\n    version?: 1 | 2 | '1' | '2';\n    validated?: boolean;\n    applied?: boolean;\n    refused?: boolean;\n    outdated?: boolean;\n    branchRefused?: boolean;\n    branchDelayed?: boolean;\n    validationPass?: '0' | '1' | '2' | '3' | 0 | 1 | 2 | 3;\n    source?: string;\n    operationHash?: string;\n}\ntype FailedProcessedOperation = Pick<OperationEntry, 'hash' | 'protocol' | 'branch' | 'contents' | 'signature'> & {\n    error: TezosGenericOperationError[];\n};\nexport interface PendingOperationsV2 {\n    validated: Pick<OperationEntry, 'hash' | 'branch' | 'contents' | 'signature'>[];\n    refused: FailedProcessedOperation[];\n    outdated: FailedProcessedOperation[];\n    branch_refused: FailedProcessedOperation[];\n    branch_delayed: FailedProcessedOperation[];\n    unprocessed: Pick<OperationEntry, 'hash' | 'protocol' | 'branch' | 'contents' | 'signature'>[];\n}\nexport declare enum PvmKind {\n    WASM2 = \"wasm_2_0_0\",\n    ARITH = \"arith\",\n    RISCV = \"riscv\"\n}\nexport interface SmartRollupPublishCommitment {\n    compressed_state: string;\n    inbox_level: number;\n    predecessor: string;\n    number_of_ticks: string;\n}\nexport declare enum SmartRollupRefutationOptions {\n    START = \"start\",\n    MOVE = \"move\"\n}\nexport type SmartRollupRefutation = SmartRollupRefutationStart | SmartRollupRefutationMove;\nexport interface SmartRollupRefutationStart {\n    refutation_kind: SmartRollupRefutationOptions.START;\n    player_commitment_hash: string;\n    opponent_commitment_hash: string;\n}\nexport interface SmartRollupRefutationMove {\n    refutation_kind: SmartRollupRefutationOptions.MOVE;\n    choice: string;\n    step: SmartRollupRefutationMoveStep;\n}\nexport type SmartRollupRefutationMoveStep = SmartRollupRefutationMoveStepDissection[] | SmartRollupRefutationMoveStepProof;\nexport interface SmartRollupRefutationMoveStepDissection {\n    state?: string;\n    tick: number;\n}\nexport interface SmartRollupRefutationMoveStepProof {\n    pvm_step: string;\n    input_proof?: SmartRollupRefutationMoveInputProof;\n}\nexport declare enum SmartRollupInputProofKind {\n    INBOX_PROOF = \"inbox_proof\",\n    REVEAL_PROOF = \"reveal_proof\",\n    FIRST_INPUT = \"first_input\"\n}\nexport interface SmartRollupRefutationMoveInputProofInbox {\n    input_proof_kind: SmartRollupInputProofKind.INBOX_PROOF;\n    level: number;\n    message_counter: string;\n    serialized_proof: string;\n}\nexport interface SmartRollupRefutationMoveInputProofReveal {\n    input_proof_kind: SmartRollupInputProofKind.REVEAL_PROOF;\n    reveal_proof: SmartRollupRefuteRevealProofOptions;\n}\nexport interface SmartRollupRefutationMoveInputProofFirstInput {\n    input_proof_kind: SmartRollupInputProofKind.FIRST_INPUT;\n}\nexport type SmartRollupRefutationMoveInputProof = SmartRollupRefutationMoveInputProofInbox | SmartRollupRefutationMoveInputProofReveal | SmartRollupRefutationMoveInputProofFirstInput;\nexport declare enum SmartRollupRefuteRevealProofKind {\n    RAW_DATA_PROOF = \"raw_data_proof\",\n    METADATA_PROOF = \"metadata_proof\",\n    DAL_PAGE_PROOF = \"dal_page_proof\",\n    DAL_PARAMETERS_PROOF = \"dal_parameters_proof\"\n}\nexport interface SmartRollupRefuteRevealProofRaw {\n    reveal_proof_kind: SmartRollupRefuteRevealProofKind.RAW_DATA_PROOF;\n    raw_data: string;\n}\nexport interface SmartRollupRefuteRevealProofMetadata {\n    reveal_proof_kind: SmartRollupRefuteRevealProofKind.METADATA_PROOF;\n}\nexport interface SmartRollupRefuteRevealProofDalPage {\n    reveal_proof_kind: SmartRollupRefuteRevealProofKind.DAL_PAGE_PROOF;\n    dal_page_id: {\n        published_level: number;\n        slot_index: number;\n        page_index: number;\n    };\n    dal_proof: string;\n}\nexport interface SmartRollupRefuteRevealProofDalParameters {\n    reveal_proof_kind: SmartRollupRefuteRevealProofKind.DAL_PARAMETERS_PROOF;\n}\nexport type SmartRollupRefuteRevealProofOptions = SmartRollupRefuteRevealProofRaw | SmartRollupRefuteRevealProofMetadata | SmartRollupRefuteRevealProofDalPage | SmartRollupRefuteRevealProofDalParameters;\nexport type SmartRollupGameStatus = SmartRollupRefuteGameStatusOptions.ONGOING | SmartRollupRefuteGameStatusEnded;\nexport declare enum SmartRollupRefuteGameStatusOptions {\n    ONGOING = \"ongoing\",\n    ENDED = \"ended\"\n}\nexport interface SmartRollupRefuteGameStatusEnded {\n    result: SmartRollupRefuteGameStatusResult;\n}\nexport type SmartRollupRefuteGameStatusResult = SmartRollupRefuteGameEndedResultLoser | SmartRollupRefuteGameEndedResultDraw;\nexport interface SmartRollupRefuteGameEndedResultLoser {\n    kind: SmartRollupRefuteGameEndedPlayerOutcomes.LOSER;\n    reason: SmartRollupRefuteGameEndedReason;\n    player: string;\n}\nexport interface SmartRollupRefuteGameEndedResultDraw {\n    kind: SmartRollupRefuteGameEndedPlayerOutcomes.DRAW;\n}\nexport declare enum SmartRollupRefuteGameEndedPlayerOutcomes {\n    LOSER = \"loser\",\n    DRAW = \"draw\"\n}\nexport declare enum SmartRollupRefuteGameEndedReason {\n    CONFLICT_RESOLVED = \"conflict_resolved\",\n    TIMEOUT = \"timeout\"\n}\nexport interface SmartRollupTimeoutStakers {\n    alice: string;\n    bob: string;\n}\nexport {};\n"},{name:"@taquito/rpc/dist/types/version.d.ts",dts:"export declare const VERSION: {\n    commitHash: string;\n    version: string;\n};\n"},{name:"@taquito/batch/rpc-batch-provider.d.ts",dts:"import { Context } from '../context';\nimport { ContractStorageType, DefaultContractType } from '../contract/contract';\nimport { ContractMethod } from '../contract/contract-methods/contract-method-flat-param';\nimport { SendParams } from '../contract/contract-methods/contract-method-interface';\nimport { ContractProvider } from '../contract/interface';\nimport { BatchOperation } from '../operations/batch-operation';\nimport { ActivationParams, DelegateParams, OriginateParams, TransferParams, ParamsWithKind, RegisterGlobalConstantParams, TransferTicketParams, IncreasePaidStorageParams, SmartRollupAddMessagesParams, SmartRollupOriginateParams, SmartRollupExecuteOutboxMessageParams, UpdateConsensusKeyParams, UpdateCompanionKeyParams } from '../operations/types';\nimport { OpKind } from '@taquito/rpc';\nimport { ContractMethodObject } from '../contract/contract-methods/contract-method-object-param';\nimport { EstimationProvider } from '../estimate/estimate-provider-interface';\nimport { Provider } from '../provider';\nexport declare const BATCH_KINDS: OpKind[];\nexport type BatchKinds = OpKind.ACTIVATION | OpKind.ORIGINATION | OpKind.TRANSACTION | OpKind.DELEGATION;\nexport declare class OperationBatch extends Provider {\n    private estimator;\n    private operations;\n    constructor(context: Context, estimator: EstimationProvider);\n    private prepare;\n    /**\n     *\n     * @description Add a transaction operation to the batch\n     *\n     * @param params Transfer operation parameter\n     */\n    withTransfer(params: TransferParams): this;\n    /**\n     *\n     * @description Transfer tickets from a Tezos address (tz1,tz2 or tz3) to a smart contract address( KT1)\n     *\n     * @param params Transfer operation parameter\n     */\n    withTransferTicket(params: TransferTicketParams): this;\n    /**\n     *\n     * @description Add a contract call to the batch\n     *\n     * @param params Call a contract method\n     * @param options Generic operation parameters\n     */\n    withContractCall(params: ContractMethod<ContractProvider> | ContractMethodObject<ContractProvider>, options?: Partial<SendParams>): this;\n    /**\n     *\n     * @description Add a delegation operation to the batch\n     *\n     * @param params Delegation operation parameter\n     */\n    withDelegation(params: DelegateParams): this;\n    /**\n     *\n     * @description Add an activation operation to the batch\n     *\n     * @param params Activation operation parameter\n     * @throws {@link InvalidKeyHashError}\n     */\n    withActivation({ pkh, secret }: ActivationParams): this;\n    /**\n     *\n     * @description Add an origination operation to the batch\n     *\n     * @param params Origination operation parameter\n     */\n    withOrigination<TContract extends DefaultContractType = DefaultContractType>(params: OriginateParams<ContractStorageType<TContract>>): this;\n    /**\n     *\n     * @description Add a register a global constant operation to the batch\n     *\n     * @param params RegisterGlobalConstant operation parameter\n     */\n    withRegisterGlobalConstant(params: RegisterGlobalConstantParams): this;\n    /**\n     *\n     * @description Add an increase paid storage operation to the batch\n     *\n     * @param params IncreasePaidStorage operation parameter\n     */\n    withIncreasePaidStorage(params: IncreasePaidStorageParams): this;\n    /**\n     *\n     * @description Add a update consensus key operation to the batch\n     *\n     * @param params UpdateConsensusKey operation parameter\n     */\n    withUpdateConsensusKey(params: UpdateConsensusKeyParams): this;\n    /**\n     *\n     * @description Add a update companion key operation to the batch\n     *\n     * @param params UpdateCompanionKey operation parameter\n     */\n    withUpdateCompanionKey(params: UpdateCompanionKeyParams): this;\n    /**\n     *\n     * @description Add a smart rollup add messages operation to the batch\n     *\n     * @param params Rollup origination operation parameter\n     */\n    withSmartRollupAddMessages(params: SmartRollupAddMessagesParams): this;\n    /**\n     *\n     * @description Add a smart rollup originate operation to the batch\n     *\n     * @param params Smart Rollup Originate operation parameter\n     */\n    withSmartRollupOriginate(params: SmartRollupOriginateParams): this;\n    /**\n     *\n     * @description Add a smart rollup execute outbox message to the batch\n     *\n     * @param params Smart Rollup Execute Outbox Message operation parameter\n     */\n    withSmartRollupExecuteOutboxMessage(params: SmartRollupExecuteOutboxMessageParams): this;\n    getRPCOp(param: ParamsWithKind): Promise<import(\"../operations/types\").RPCTransferOperation | import(\"../operations/types\").RPCOriginationOperation | import(\"../operations/types\").RPCDelegateOperation | import(\"../operations/types\").RPCRegisterGlobalConstantOperation | import(\"../operations/types\").RPCIncreasePaidStorageOperation | import(\"../operations/types\").RPCUpdateConsensusKeyOperation | import(\"../operations/types\").RPCUpdateCompanionKeyOperation | import(\"../operations/types\").RPCTransferTicketOperation | import(\"../operations/types\").RPCSmartRollupAddMessagesOperation | import(\"../operations/types\").RPCSmartRollupOriginateOperation | import(\"../operations/types\").RPCSmartRollupOutboxMessageOperation>;\n    /**\n     *\n     * @description Add a group operation to the batch. Operation will be applied in the order they are in the params array\n     *\n     * @param params Operations parameter\n     * @throws {@link InvalidOperationKindError}\n     */\n    with(params: ParamsWithKind[]): this;\n    /**\n     *\n     * @description Forge and Inject the operation batch\n     *\n     * @param params Optionally specify the source of the operation\n     */\n    send(params?: {\n        source?: string;\n    }): Promise<BatchOperation>;\n}\nexport declare class RPCBatchProvider {\n    private context;\n    private estimator;\n    constructor(context: Context, estimator: EstimationProvider);\n    /***\n     *\n     * @description Batch a group of operation together. Operations will be applied in the order in which they are added to the batch\n     *\n     * @param params List of operation to batch together\n     */\n    batch(params?: ParamsWithKind[]): OperationBatch;\n}\n"},{name:"@taquito/contract/contract-methods/contract-method-factory.d.ts",dts:"import { Wallet } from '../../wallet';\nimport { ContractProvider } from '../../contract';\nimport { ContractMethodObject } from './contract-method-object-param';\nimport { ContractMethod } from './contract-method-flat-param';\nimport { ParameterSchema, ViewSchema } from '@taquito/michelson-encoder';\nimport { RpcClientInterface, MichelsonV1Expression } from '@taquito/rpc';\nimport { OnChainView } from './contract-on-chain-view';\nimport { TzReadProvider } from '../../read-provider/interface';\nexport declare class ContractMethodFactory<T extends ContractProvider | Wallet> {\n    private provider;\n    private contractAddress;\n    constructor(provider: T, contractAddress: string);\n    createContractMethodFlatParams(smartContractMethodSchema: ParameterSchema, smartContractMethodName: string, args: any[], isMultipleEntrypoint?: boolean, isAnonymous?: boolean): ContractMethod<T>;\n    createContractMethodObjectParam(smartContractMethodSchema: ParameterSchema, smartContractMethodName: string, args: any[], isMultipleEntrypoint?: boolean, isAnonymous?: boolean): ContractMethodObject<T>;\n    createContractViewObjectParam(rpc: RpcClientInterface, readProvider: TzReadProvider, smartContractViewSchema: ViewSchema, contractStorageType: MichelsonV1Expression, viewArgs: any): OnChainView;\n}\n"},{name:"@taquito/contract/contract-methods/contract-method-flat-param.d.ts",dts:"import { TransactionOperation } from '../../operations/transaction-operation';\nimport { TransferParams } from '../../operations/types';\nimport { ContractProvider } from '../interface';\nimport { TransactionWalletOperation, Wallet } from '../../wallet';\nimport { ParameterSchema } from '@taquito/michelson-encoder';\nimport { ContractMethodInterface, SendParams } from './contract-method-interface';\n/**\n * @description Utility class to send smart contract operation\n * The format for the arguments is the flattened representation\n */\nexport declare class ContractMethod<T extends ContractProvider | Wallet> implements ContractMethodInterface {\n    private provider;\n    private address;\n    private parameterSchema;\n    private name;\n    private args;\n    private isMultipleEntrypoint;\n    private isAnonymous;\n    constructor(provider: T, address: string, parameterSchema: ParameterSchema, name: string, args: any[], isMultipleEntrypoint?: boolean, isAnonymous?: boolean);\n    private validateArgs;\n    /**\n     * @description Get the schema of the smart contract method\n     */\n    get schema(): any;\n    /**\n     * @description Get the signature of the smart contract method\n     */\n    getSignature(): any[] | undefined;\n    /**\n     *\n     * @description Send the smart contract operation\n     *\n     * @param Options generic operation parameter\n     */\n    send(params?: Partial<SendParams>): Promise<T extends Wallet ? TransactionWalletOperation : TransactionOperation>;\n    /**\n     *\n     * @description Create transfer params to be used with TezosToolkit.contract.transfer methods\n     *\n     * @param Options generic transfer operation parameters\n     */\n    toTransferParams({ fee, gasLimit, storageLimit, source, amount, mutez, }?: Partial<SendParams>): TransferParams;\n}\n"},{name:"@taquito/contract/contract-methods/contract-method-interface.d.ts",dts:"import { TransactionOperation } from '../../operations/transaction-operation';\nimport { TransferParams } from '../../operations/types';\nimport { TransactionWalletOperation } from '../../wallet';\nexport interface SendParams {\n    fee?: number;\n    storageLimit?: number;\n    gasLimit?: number;\n    amount: number;\n    source?: string;\n    mutez?: boolean;\n}\nexport type ExplicitTransferParams = Required<Omit<TransferParams, keyof SendParams>> & SendParams;\nexport interface ContractMethodInterface {\n    /**\n     *\n     * @description Send the smart contract operation\n     *\n     * @param Options generic operation parameter\n     */\n    send(params: Partial<SendParams>): Promise<TransactionWalletOperation | TransactionOperation>;\n    /**\n     *\n     * @description Create transfer params to be used with TezosToolkit.contract.transfer methods\n     *\n     * @param Options generic transfer operation parameters\n     */\n    toTransferParams(params: Partial<SendParams>): TransferParams;\n}\n"},{name:"@taquito/contract/contract-methods/contract-method-object-param.d.ts",dts:"import { TransactionOperation } from '../../operations/transaction-operation';\nimport { TransferParams } from '../../operations/types';\nimport { ContractProvider } from '../interface';\nimport { TransactionWalletOperation, Wallet } from '../../wallet';\nimport { ParameterSchema } from \"@taquito/michelson-encoder\";\nimport { ContractMethodInterface, SendParams } from './contract-method-interface';\n/**\n * @description Utility class to send smart contract operation\n * The format for the arguments is the object representation\n */\nexport declare class ContractMethodObject<T extends ContractProvider | Wallet> implements ContractMethodInterface {\n    private provider;\n    private address;\n    private parameterSchema;\n    private name;\n    private args;\n    private isMultipleEntrypoint;\n    private isAnonymous;\n    constructor(provider: T, address: string, parameterSchema: ParameterSchema, name: string, args?: any, isMultipleEntrypoint?: boolean, isAnonymous?: boolean);\n    /**\n     * @description Get the signature of the smart contract method\n     */\n    getSignature(): any;\n    /**\n     *\n     * @description Send the smart contract operation\n     *\n     * @param Options generic operation parameter\n     */\n    send(params?: Partial<SendParams>): Promise<T extends Wallet ? TransactionWalletOperation : TransactionOperation>;\n    /**\n     *\n     * @description Create transfer params to be used with TezosToolkit.contract.transfer methods\n     *\n     * @param Options generic transfer operation parameters\n     */\n    toTransferParams({ fee, gasLimit, storageLimit, source, amount, mutez, }?: Partial<SendParams>): TransferParams;\n}\n"},{name:"@taquito/contract/contract-methods/contract-on-chain-view.d.ts",dts:"import { ViewSchema } from '@taquito/michelson-encoder';\nimport { MichelsonV1Expression, RpcClientInterface } from '@taquito/rpc';\nimport { TzReadProvider } from '../../read-provider/interface';\nexport interface ExecutionContextParams {\n    source?: string;\n    viewCaller: string;\n}\nexport declare class OnChainView {\n    private _rpc;\n    private _readProvider;\n    private _contractAddress;\n    private _smartContractViewSchema;\n    private _contractStorageType;\n    private _args;\n    constructor(_rpc: RpcClientInterface, _readProvider: TzReadProvider, _contractAddress: string, _smartContractViewSchema: ViewSchema, _contractStorageType: MichelsonV1Expression, _args?: any);\n    /**\n     * @description Get the signature of the smart contract view\n     */\n    getSignature(): {\n        parameter: any;\n        result: any;\n    };\n    /**\n     * @description Get the result of the view simulation\n     * @param executionContext.source the public key hash of the account who initialized this view execution.\n     * @param executionContext.viewCaller the contract address which is the caller of view.\n     */\n    executeView(executionContext: ExecutionContextParams): Promise<any>;\n    private verifyContextExecution;\n    private transformArgsToMichelson;\n    /**\n     * @description Loops through the view's instructions and replace BALANCE, SENDER, SELF_ADDRESS and AMOUNT with Michelson expressions that match the current context, if applicable.\n     *\n     * Certain specific instructions have different semantics in view:\n     * BALANCE represents the current amount of mutez held by the contract where view is;\n     * SENDER represents the contract which is the caller of view;\n     * SELF_ADDRESS represents the contract where view is;\n     * AMOUNT is always 0 mutez.\n     *\n     */\n    private adaptViewCodeToContext;\n    private executeViewAndDecodeResult;\n}\n"},{name:"@taquito/contract/big-map.d.ts",dts:"import { Schema, BigMapKeyType } from '@taquito/michelson-encoder';\nimport BigNumber from 'bignumber.js';\nimport { ContractProvider } from './interface';\nexport declare class BigMapAbstraction {\n    private id;\n    private schema;\n    private provider;\n    constructor(id: BigNumber, schema: Schema, provider: ContractProvider);\n    /**\n     *\n     * @description Fetch one value in a big map\n     *\n     * @param keysToEncode Key to query (will be encoded properly according to the schema)\n     * @param block optional block level to fetch the values from (head will be use by default)\n     * @returns Return a well formatted json object of a big map value or undefined if the key is not found in the big map\n     *\n     */\n    get<T>(keyToEncode: BigMapKeyType, block?: number): Promise<T | undefined>;\n    /**\n     *\n     * @description Fetch multiple values in a big map\n     * All values will be fetched on the same block level. If a block is specified in the request, the values will be fetched at it.\n     * Otherwise, a first request will be done to the node to fetch the level of the head and all values will be fetched at this level.\n     * If one of the keys does not exist in the big map, its value will be set to undefined.\n     *\n     * @param keysToEncode Array of keys to query (will be encoded properly according to the schema)\n     * @param block optional block level to fetch the values from\n     * @param batchSize optional batch size representing the number of requests to execute in parallel\n     * @returns A MichelsonMap containing the keys queried in the big map and their value in a well-formatted JSON object format\n     *\n     */\n    getMultipleValues<T>(keysToEncode: Array<BigMapKeyType>, block?: number, batchSize?: number): Promise<import(\"@taquito/michelson-encoder\").MichelsonMap<import(\"@taquito/michelson-encoder\").MichelsonMapKey, T | undefined>>;\n    toJSON(): string;\n    toString(): string;\n}\n"},{name:"@taquito/contract/compose.d.ts",dts:"import { Wallet } from '../wallet/wallet';\nimport { Context } from '../context';\nimport { ContractAbstraction } from './contract';\nimport { ContractProvider } from './interface';\nexport declare function compose<ContractAbsComposer1 extends ContractAbstraction<ContractProvider | Wallet>, ContractAbsComposer2 extends ContractAbstraction<ContractProvider | Wallet>, ContractAbstractionComposed>(functioncomposer1: (abs: ContractAbsComposer1, context: Context) => ContractAbsComposer2, functioncomposer2: (abs: ContractAbsComposer2, context: Context) => ContractAbstractionComposed): (abs: ContractAbsComposer1, context: Context) => ContractAbstractionComposed;\n"},{name:"@taquito/contract/contract.d.ts",dts:"import { ParameterSchema, Schema, ViewSchema, EventSchema } from '@taquito/michelson-encoder';\nimport { EntrypointsResponse, RpcClientInterface, ScriptResponse } from '@taquito/rpc';\nimport { ChainIds } from '../constants';\nimport { TzReadProvider } from '../read-provider/interface';\nimport { Wallet } from '../wallet';\nimport { ContractMethod } from './contract-methods/contract-method-flat-param';\nimport { ContractMethodObject } from './contract-methods/contract-method-object-param';\nimport { OnChainView } from './contract-methods/contract-on-chain-view';\nimport { ContractProvider, StorageProvider } from './interface';\nexport declare const DEFAULT_SMART_CONTRACT_METHOD_NAME = \"default\";\n/**\n * @description Utility class to retrieve data from a smart contract's storage without incurring fees via a contract's view method\n */\nexport declare class ContractView {\n    private currentContract;\n    private name;\n    private callbackParametersSchema;\n    private parameterSchema;\n    private args;\n    private rpc;\n    private readProvider;\n    constructor(currentContract: ContractAbstraction<ContractProvider | Wallet>, name: string, callbackParametersSchema: ParameterSchema, parameterSchema: ParameterSchema, args: any[], rpc: RpcClientInterface, readProvider: TzReadProvider);\n    read(chainId?: ChainIds): Promise<any>;\n}\nexport type Contract = ContractAbstraction<ContractProvider>;\nexport type WalletContract = ContractAbstraction<Wallet>;\ntype DefaultMethods<T extends ContractProvider | Wallet> = Record<string, (...args: any[]) => ContractMethod<T>>;\ntype DefaultMethodsObject<T extends ContractProvider | Wallet> = Record<string, (args?: any) => ContractMethodObject<T>>;\ntype DefaultViews = Record<string, (...args: any[]) => ContractView>;\ntype DefaultContractViews = Record<string, (args?: any) => OnChainView>;\ntype DefaultStorage = unknown;\ntype PromiseReturnType<T extends (...args: any) => any> = T extends (...args: any) => Promise<infer R> ? R : any;\nexport type ContractStorageType<T extends ContractAbstraction<ContractProvider | Wallet>> = PromiseReturnType<T['storage']>;\nexport type DefaultContractType = ContractAbstraction<ContractProvider>;\nexport type DefaultWalletType = ContractAbstraction<Wallet>;\n/**\n * @description Smart contract abstraction\n */\nexport declare class ContractAbstraction<T extends ContractProvider | Wallet, TMethods extends DefaultMethods<T> = DefaultMethods<T>, TMethodsObject extends DefaultMethodsObject<T> = DefaultMethodsObject<T>, TViews extends DefaultViews = DefaultViews, TContractViews extends DefaultContractViews = DefaultContractViews, TStorage extends DefaultStorage = DefaultStorage> {\n    readonly address: string;\n    readonly script: ScriptResponse;\n    private storageProvider;\n    readonly entrypoints: EntrypointsResponse;\n    private rpc;\n    private readProvider;\n    private contractMethodFactory;\n    /**\n     * @deprecated use methodsObject instead, flat params of methods can't sufficiently represent all Michelson values\n     * @description Contains methods that are implemented by the target Tezos Smart Contract, and offers the user to call the Smart Contract methods as if they were native TS/JS methods.\n     * NB: if the contract contains annotation it will include named properties; if not it will be indexed by a number.\n     */\n    methods: TMethods;\n    /**\n     * @description Contains methods that are implemented by the target Tezos Smart Contract, and offers the user to call the Smart Contract methods as if they were native TS/JS methods.\n     * `methodsObject` serves the exact same purpose as the `methods` member. The difference is that it allows passing the parameter in an object format when calling the smart contract method (instead of the flattened representation)\n     * NB: if the contract contains annotation it will include named properties; if not it will be indexed by a number.\n     *\n     */\n    methodsObject: TMethodsObject;\n    /**\n     * @description Contains lamda views (tzip4) that are implemented by the target Tezos Smart Contract, and offers the user to call the lambda views as if they were native TS/JS methods.\n     * NB: These are the view defined in the tzip4 standard, not the views introduced by the Hangzhou protocol.\n     */\n    views: TViews;\n    /**\n     * @description Contains on-chain views that are defined by the target Tezos Smart Contract, and offers the user to simulate the views execution as if they were native TS/JS methods.\n     * NB: the expected format for the parameter when calling a smart contract view is the object format (same format as for the storage) and not the flattened representation.\n     *\n     */\n    contractViews: TContractViews;\n    readonly schema: Schema;\n    readonly parameterSchema: ParameterSchema;\n    readonly viewSchema: ViewSchema[];\n    readonly eventSchema: EventSchema[];\n    constructor(address: string, script: ScriptResponse, provider: T, storageProvider: StorageProvider, entrypoints: EntrypointsResponse, rpc: RpcClientInterface, readProvider: TzReadProvider);\n    private _initializeMethods;\n    private _initializeOnChainViews;\n    /**\n     * @description Return a friendly representation of the smart contract storage\n     */\n    storage<T extends TStorage = TStorage>(): Promise<T>;\n    /**\n     *\n     * @description Return a friendly representation of the smart contract big map value\n     *\n     * @param key BigMap key to fetch\n     *\n     * @deprecated getBigMapKey has been deprecated in favor of getBigMapKeyByID\n     *\n     * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-context-contracts-contract-id-big-map-get\n     */\n    bigMap(key: string): Promise<unknown>;\n}\nexport {};\n"},{name:"@taquito/contract/errors.d.ts",dts:"import { ParameterValidationError, RpcError } from '@taquito/core';\nimport { HttpResponseError } from '@taquito/http-utils';\nimport { MichelsonV1Expression } from '@taquito/rpc';\n/**\n *  @category Error\n *  @description Error that indicates invalid smart contract parameters being passed or used\n */\nexport declare class InvalidParameterError extends ParameterValidationError {\n    readonly smartContractMethodName: string;\n    readonly sigs: any[];\n    readonly invalidParams: any[];\n    constructor(smartContractMethodName: string, sigs: any[], invalidParams: any[]);\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid delegation source contract address being passed or used\n */\nexport declare class InvalidDelegationSource extends ParameterValidationError {\n    readonly source: string;\n    constructor(source: string);\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid smart contract code parameter being passed or used\n */\nexport declare class InvalidCodeParameter extends ParameterValidationError {\n    readonly message: string;\n    readonly data: any;\n    constructor(message: string, data: any);\n}\n/**\n *  @category Error\n *  @description Error that indicates invalid smart contract init parameter being passed or used\n */\nexport declare class InvalidInitParameter extends ParameterValidationError {\n    readonly message: string;\n    readonly data: any;\n    constructor(message: string, data: any);\n}\n/**\n *  @category Error\n *  @description Error that indicates a failure when conducting a view simulation\n */\nexport declare class ViewSimulationError extends RpcError {\n    readonly message: string;\n    readonly viewName: string;\n    readonly failWith?: MichelsonV1Expression | undefined;\n    readonly cause?: any;\n    constructor(message: string, viewName: string, failWith?: MichelsonV1Expression | undefined, cause?: any);\n}\nexport declare const validateAndExtractFailwith: (error: HttpResponseError) => MichelsonV1Expression | undefined;\n/**\n *  @category Error\n *  @description Error that indicates invalid or unconfigured context when executing a view\n */\nexport declare class InvalidViewSimulationContext extends ParameterValidationError {\n    readonly info: string;\n    constructor(info: string);\n}\n/**\n *  @category Error\n *  @description Error that indicates a mistake happening during the reveal operation\n */\nexport declare class RevealOperationError extends RpcError {\n    readonly message: string;\n    constructor(message: string);\n}\n/**\n *  @category Error\n *  @description Error that indicates a mistake in the parameters in the preparation of an Origination operation\n */\nexport declare class OriginationParameterError extends ParameterValidationError {\n    readonly message: string;\n    constructor(message: string);\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid balance being passed or used\n */\nexport declare class InvalidBalanceError extends ParameterValidationError {\n    readonly message: string;\n    constructor(message: string);\n}\n"},{name:"@taquito/contract/index.d.ts",dts:"export * from './contract';\nexport * from './errors';\nexport * from './interface';\nexport * from './manager-lambda';\nexport * from './prepare';\nexport * from './view_lambda';\nexport { compose } from './compose';\nexport * from './contract-methods/contract-method-interface';\nexport * from './contract-methods/contract-method-flat-param';\nexport * from './contract-methods/contract-method-object-param';\nexport * from './sapling-state-abstraction';\nexport { smartContractAbstractionSemantic } from './semantic';\n"},{name:"@taquito/contract/interface.d.ts",dts:"import { BigMapKeyType, MichelsonMap, MichelsonMapKey, Schema } from '@taquito/michelson-encoder';\nimport { SaplingDiffResponse } from '@taquito/rpc';\nimport { OperationBatch } from '../batch/rpc-batch-provider';\nimport { Context } from '../context';\nimport { DelegateOperation } from '../operations/delegate-operation';\nimport { OriginationOperation } from '../operations/origination-operation';\nimport { RegisterGlobalConstantOperation } from '../operations/register-global-constant-operation';\nimport { RevealOperation } from '../operations/reveal-operation';\nimport { TransactionOperation } from '../operations/transaction-operation';\nimport { DelegateParams, OriginateParams, TransferParams, RegisterDelegateParams, ParamsWithKind, RevealParams, RegisterGlobalConstantParams, IncreasePaidStorageParams, TransferTicketParams, DrainDelegateParams, BallotParams, ProposalsParams, UpdateConsensusKeyParams, UpdateCompanionKeyParams, SmartRollupAddMessagesParams, SmartRollupOriginateParams, SmartRollupExecuteOutboxMessageParams, FailingNoopParams, StakeParams, UnstakeParams, FinalizeUnstakeParams } from '../operations/types';\nimport { ContractAbstraction, ContractStorageType, DefaultContractType } from './contract';\nimport { IncreasePaidStorageOperation } from '../operations/increase-paid-storage-operation';\nimport { TransferTicketOperation } from '../operations/transfer-ticket-operation';\nimport { DrainDelegateOperation } from '../operations';\nimport { BallotOperation } from '../operations';\nimport { ProposalsOperation } from '../operations/proposals-operation';\nimport { UpdateConsensusKeyOperation } from '../operations/update-consensus-key-operation';\nimport { UpdateCompanionKeyOperation } from '../operations/update-companion-key-operation';\nimport { SmartRollupAddMessagesOperation } from '../operations/smart-rollup-add-messages-operation';\nimport { SmartRollupOriginateOperation } from '../operations/smart-rollup-originate-operation';\nimport { SmartRollupExecuteOutboxMessageOperation } from '../operations/smart-rollup-execute-outbox-message-operation';\nimport { FailingNoopOperation } from '../operations/failing-noop-operation';\nexport type ContractSchema = Schema | unknown;\nexport interface StorageProvider {\n    /**\n     *\n     * @description Return a well formatted json object of the contract storage\n     *\n     * @param contract contract address you want to get the storage from\n     * @param schema optional schema can either be the contract script rpc response or a michelson-encoder schema\n     *\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-script\n     */\n    getStorage<T>(contract: string, schema?: ContractSchema): Promise<T>;\n    /**\n     *\n     * @description Return a well formatted json object of the contract big map storage\n     *\n     * @param contract contract address you want to get the storage from\n     * @param key contract big map key to fetch value from\n     * @param schema optional schema can either be the contract script rpc response or a michelson-encoder schema\n     *\n     * @deprecated Deprecated in favor of getBigMapKeyByID\n     *\n     * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-context-contracts-contract-id-big-map-get\n     */\n    getBigMapKey<T>(contract: string, key: string, schema?: ContractSchema): Promise<T>;\n    /**\n     *\n     * @description Return a well formatted json object of a big map value\n     *\n     * @param id Big Map ID\n     * @param keyToEncode key to query (will be encoded properly according to the schema)\n     * @param schema Big Map schema (can be determined using your contract type)\n     * @param block optional block level to fetch the value from\n     *\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-big-maps-big-map-id-script-expr\n     */\n    getBigMapKeyByID<T>(id: string, keyToEncode: BigMapKeyType, schema: Schema, block?: number): Promise<T>;\n    /**\n     *\n     * @description Fetch multiple values in a big map\n     *\n     * @param id Big Map ID\n     * @param keysToEncode Array of keys to query (will be encoded properly according to the schema)\n     * @param schema Big Map schema (can be determined using your contract type)\n     * @param block optional block level to fetch the values from\n     * @param batchSize optional batch size representing the number of requests to execute in parallel\n     * @returns An object containing the keys queried in the big map and their value in a well-formatted JSON object format\n     *\n     */\n    getBigMapKeysByID<T>(id: string, keysToEncode: Array<BigMapKeyType>, schema: Schema, block?: number, batchSize?: number): Promise<MichelsonMap<MichelsonMapKey, T | undefined>>;\n    /**\n     *\n     * @description Return a well formatted json object of a sapling state\n     *\n     * @param id Sapling state ID\n     * @param block optional block level to fetch the value from\n     *\n     */\n    getSaplingDiffByID(id: string, block?: number): Promise<SaplingDiffResponse>;\n}\nexport interface ContractProvider extends StorageProvider {\n    /**\n     *\n     * @description Originate a new contract according to the script in parameters. Will sign and inject an operation using the current context\n     *\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @param OriginationOperation Originate operation parameter\n     */\n    originate<TContract extends DefaultContractType = DefaultContractType>(contract: OriginateParams<ContractStorageType<TContract>>): Promise<OriginationOperation<TContract>>;\n    /**\n     *\n     * @description Set the delegate for a contract. Will sign and inject an operation using the current context\n     *\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @param SetDelegate operation parameter\n     */\n    setDelegate(params: DelegateParams): Promise<DelegateOperation>;\n    /**\n     *\n     * @description Register the current address as delegate. Will sign and inject an operation using the current context\n     *\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @param RegisterDelegate operation parameter\n     */\n    registerDelegate(params: RegisterDelegateParams): Promise<DelegateOperation>;\n    /**\n     *\n     * @description Transfer tz from current address to a specific address. Will sign and inject an operation using the current context\n     *\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @param Transfer operation parameter\n     */\n    transfer(params: TransferParams): Promise<TransactionOperation>;\n    /**\n     *\n     * @description Stake tz from current address to a specific address. Built on top of the existing transaction operation\n     *\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @param Stake pseudo-operation parameter\n     */\n    stake(params: StakeParams): Promise<TransactionOperation>;\n    /**\n     *\n     * @description Unstake tz from current address to a specific address. Built on top of the existing transaction operation\n     *\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @param Unstake pseudo-operation parameter\n     */\n    unstake(params: UnstakeParams): Promise<TransactionOperation>;\n    /**\n     *\n     * @description Finalize unstake tz from current address to a specific address. Built on top of the existing transaction operation\n     *\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @param finalize_unstake pseudo-operation parameter\n     */\n    finalizeUnstake(params: FinalizeUnstakeParams): Promise<TransactionOperation>;\n    /**\n     *\n     * @description Transfer tickets from an implicit account to a contract or another implicit account.\n     *\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @param TransferTicket operation parameter\n     */\n    transferTicket(params: TransferTicketParams): Promise<TransferTicketOperation>;\n    /**\n     *\n     * @description Reveal the current address. Will throw an error if the address is already revealed.\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @param Reveal operation parameter\n     */\n    reveal(params: RevealParams): Promise<RevealOperation>;\n    at<T extends ContractAbstraction<ContractProvider>>(address: string, contractAbstractionComposer?: (abs: ContractAbstraction<ContractProvider>, context: Context) => T): Promise<T>;\n    /**\n     *\n     * @description Batch a group of operation together. Operations will be applied in the order in which they are added to the batch\n     *\n     * @param params List of operation to batch together\n     */\n    batch(params?: ParamsWithKind[]): OperationBatch;\n    /**\n     *\n     * @description Register a Micheline expression in a global table of constants. Will sign and inject an operation using the current context\n     *\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @param params registerGlobalConstant operation parameter\n     */\n    registerGlobalConstant(params: RegisterGlobalConstantParams): Promise<RegisterGlobalConstantOperation>;\n    /**\n     *\n     * @description Increase the amount of bytes in a smart contract storage by paying a fee\n     *\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @param params IncreasePaidStorage operation parameter\n     */\n    increasePaidStorage(params: IncreasePaidStorageParams): Promise<IncreasePaidStorageOperation>;\n    /**\n     *\n     * @description Submit a drain delegate operation\n     *\n     * @returns An operation handle with the result from the RPC node\n     *\n     * @param DrainDelegateParams DrainDelegate operation parameter\n     */\n    drainDelegate(params: DrainDelegateParams): Promise<DrainDelegateOperation>;\n    /**\n     *\n     * @description Submit ballot for an ongoing proposal\n     *\n     * @returns An operation handle with the result from the RPC node\n     *\n     * @param BallotParams Ballot operation parameter\n     */\n    ballot(params: BallotParams): Promise<BallotOperation>;\n    /**\n     *\n     * @description Submit proposal\n     *\n     * @returns An operation handle with the result from the RPC node\n     *\n     * @param ProposalsParams Proposals operation parameter\n     */\n    proposals(params: ProposalsParams): Promise<ProposalsOperation>;\n    /**\n     *\n     * @description Update consensus key\n     * @returns An operation handle with the result from the RPC node\n     *\n     * @param UpdateConsensusKeyParams UpdateConsensusKey operation parameter\n     */\n    updateConsensusKey(params: UpdateConsensusKeyParams): Promise<UpdateConsensusKeyOperation>;\n    /**\n     *\n     * @description Update companion key\n     * @returns An operation handle with the result from the RPC node\n     *\n     * @param UpdateCompanionKeyParams UpdateCompanionKey operation parameter\n     */\n    updateCompanionKey(params: UpdateCompanionKeyParams): Promise<UpdateCompanionKeyOperation>;\n    /**\n     *\n     * @description Smart Rollup Add Messages\n     *\n     * @returns An operation handle with the result from the RPC node\n     *\n     * @param SmartRollupAddMessagesParams smartRollupAddMessages operation parameter\n     */\n    smartRollupAddMessages(params: SmartRollupAddMessagesParams): Promise<SmartRollupAddMessagesOperation>;\n    /**\n     * @description Smart rollup originate\n     *\n     * @returns An operation handle with the result from the RPC node\n     *\n     * @param SmartRollupOriginateParams smartRollupOriginate operation parameter\n     */\n    smartRollupOriginate(params: SmartRollupOriginateParams): Promise<SmartRollupOriginateOperation>;\n    /**\n     * @description Execute a message from a smart rollup's outbox of a cemented commitment\n     *\n     * @returns An operation handle with the result from the RPC node\n     *\n     * @param SmartRollupExecuteOutboxMessageParams smartRollupExecuteOutboxMessage operation parameter\n     */\n    smartRollupExecuteOutboxMessage(params: SmartRollupExecuteOutboxMessageParams): Promise<SmartRollupExecuteOutboxMessageOperation>;\n    /**\n     *\n     * @description Send arbitrary data inside a failing_noop operation that's guaranteed to fail.\n     *\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @param params FailingNoop operation parameter\n     */\n    failingNoop(params: FailingNoopParams): Promise<FailingNoopOperation>;\n}\n"},{name:"@taquito/contract/lambda-view.d.ts",dts:"import { MichelsonV1Expression } from '@taquito/rpc';\nimport { Contract, ContractAbstraction, WalletContract } from './contract';\nimport { ContractProvider } from './interface';\nimport { Wallet } from '../wallet';\n/**\n *\n * @deprecated LambdaView has been deprecated in favor of rpc.runView to simulate calls to views following the TZIP-4 standard\n */\nexport default class LambdaView {\n    private lambdaContract;\n    private viewContract;\n    readonly viewMethod: string;\n    private contractParameter;\n    readonly voidLambda: object;\n    constructor(lambdaContract: Contract | WalletContract, viewContract: ContractAbstraction<ContractProvider | Wallet>, viewMethod?: string, contractParameter?: MichelsonV1Expression);\n    execute(): Promise<any>;\n    private createVoidLambda;\n    private getView;\n}\n"},{name:"@taquito/contract/manager-lambda.d.ts",dts:"export declare const MANAGER_LAMBDA: {\n    setDelegate: (key: string) => ({\n        prim: string;\n        args?: undefined;\n    } | {\n        prim: string;\n        args: ({\n            prim: string;\n            string?: undefined;\n        } | {\n            string: string;\n            prim?: undefined;\n        })[];\n    })[];\n    removeDelegate: () => ({\n        prim: string;\n        args?: undefined;\n    } | {\n        prim: string;\n        args: {\n            prim: string;\n        }[];\n    })[];\n    transferImplicit: (key: string, mutez: number) => ({\n        prim: string;\n        args?: undefined;\n    } | {\n        prim: string;\n        args: ({\n            prim: string;\n            string?: undefined;\n        } | {\n            string: string;\n            prim?: undefined;\n        })[];\n    } | {\n        prim: string;\n        args: ({\n            prim: string;\n            int?: undefined;\n        } | {\n            int: string;\n            prim?: undefined;\n        })[];\n    })[];\n    transferToContract: (key: string, amount: number) => ({\n        prim: string;\n        args?: undefined;\n    } | {\n        prim: string;\n        args: ({\n            prim: string;\n            string?: undefined;\n        } | {\n            string: string;\n            prim?: undefined;\n        })[];\n    } | {\n        prim: string;\n        args: {\n            prim: string;\n        }[][];\n    } | {\n        prim: string;\n        args: ({\n            prim: string;\n            int?: undefined;\n        } | {\n            int: string;\n            prim?: undefined;\n        })[];\n    })[];\n};\n"},{name:"@taquito/contract/prepare.d.ts",dts:"import { OriginateParams, RPCOriginationOperation, TransferParams, RPCTransferOperation, DelegateParams, RPCDelegateOperation, RegisterDelegateParams, RPCRevealOperation, RevealParams, RegisterGlobalConstantParams, RPCRegisterGlobalConstantOperation, TransferTicketParams, RPCTransferTicketOperation, IncreasePaidStorageParams, RPCIncreasePaidStorageOperation, DrainDelegateParams, RPCDrainDelegateOperation, BallotParams, RPCBallotOperation, ProposalsParams, RPCProposalsOperation, UpdateConsensusKeyParams, RPCUpdateConsensusKeyOperation, UpdateCompanionKeyParams, RPCUpdateCompanionKeyOperation, SmartRollupAddMessagesParams, RPCSmartRollupAddMessagesOperation, SmartRollupOriginateParams, RPCSmartRollupOriginateOperation, SmartRollupExecuteOutboxMessageParams, RPCSmartRollupOutboxMessageOperation, ActivationParams, RPCActivateOperation } from '../operations/types';\nexport declare const createActivationOperation: ({ pkh, secret }: ActivationParams) => Promise<RPCActivateOperation>;\nexport declare const createOriginationOperation: ({ code, init, balance, delegate, storage, fee, gasLimit, storageLimit, mutez, }: OriginateParams) => Promise<RPCOriginationOperation>;\nexport declare const createTransferOperation: ({ to, amount, parameter, fee, gasLimit, storageLimit, mutez, }: TransferParams) => Promise<RPCTransferOperation>;\nexport declare const createSetDelegateOperation: ({ delegate, source, fee, gasLimit, storageLimit, }: DelegateParams) => Promise<RPCDelegateOperation>;\nexport declare const createRegisterDelegateOperation: ({ fee, gasLimit, storageLimit }: RegisterDelegateParams, source: string) => Promise<RPCDelegateOperation>;\nexport declare const createRevealOperation: ({ fee, gasLimit, storageLimit, proof }: RevealParams, source: string, publicKey: string) => Promise<RPCRevealOperation>;\nexport declare const createRegisterGlobalConstantOperation: ({ value, source, fee, gasLimit, storageLimit, }: RegisterGlobalConstantParams) => Promise<RPCRegisterGlobalConstantOperation>;\nexport declare const createTransferTicketOperation: ({ ticketContents, ticketTy, ticketTicketer, ticketAmount, destination, entrypoint, source, fee, gasLimit, storageLimit, }: TransferTicketParams) => Promise<RPCTransferTicketOperation>;\nexport declare const createIncreasePaidStorageOperation: ({ source, fee, gasLimit, storageLimit, amount, destination, }: IncreasePaidStorageParams) => Promise<RPCIncreasePaidStorageOperation>;\nexport declare const createDrainDelegateOperation: ({ consensus_key, delegate, destination, }: DrainDelegateParams) => Promise<RPCDrainDelegateOperation>;\nexport declare const createBallotOperation: ({ source, proposal, ballot }: BallotParams) => Promise<RPCBallotOperation>;\nexport declare const createProposalsOperation: ({ source, proposals }: ProposalsParams) => Promise<RPCProposalsOperation>;\nexport declare const createUpdateConsensusKeyOperation: ({ source, fee, gasLimit, storageLimit, pk, proof, }: UpdateConsensusKeyParams) => Promise<RPCUpdateConsensusKeyOperation>;\nexport declare const createUpdateCompanionKeyOperation: ({ source, fee, gasLimit, storageLimit, pk, proof, }: UpdateCompanionKeyParams) => Promise<RPCUpdateCompanionKeyOperation>;\nexport declare const createSmartRollupAddMessagesOperation: ({ source, fee, gasLimit, storageLimit, message, }: SmartRollupAddMessagesParams) => Promise<RPCSmartRollupAddMessagesOperation>;\nexport declare const createSmartRollupOriginateOperation: ({ source, fee, gasLimit, storageLimit, pvmKind, kernel, parametersType, }: SmartRollupOriginateParams) => Promise<RPCSmartRollupOriginateOperation>;\nexport declare const createSmartRollupExecuteOutboxMessageOperation: ({ source, fee, gasLimit, storageLimit, rollup, cementedCommitment, outputProof, }: SmartRollupExecuteOutboxMessageParams) => Promise<RPCSmartRollupOutboxMessageOperation>;\n"},{name:"@taquito/contract/rpc-contract-provider.d.ts",dts:"import { BigMapKeyType, MichelsonMap, MichelsonMapKey, Schema } from '@taquito/michelson-encoder';\nimport { OperationBatch } from '../batch/rpc-batch-provider';\nimport { Context } from '../context';\nimport { DelegateOperation } from '../operations/delegate-operation';\nimport { OriginationOperation } from '../operations/origination-operation';\nimport { RegisterGlobalConstantOperation } from '../operations/register-global-constant-operation';\nimport { RevealOperation } from '../operations/reveal-operation';\nimport { TransactionOperation } from '../operations/transaction-operation';\nimport { DelegateParams, OriginateParams, ParamsWithKind, RegisterDelegateParams, RegisterGlobalConstantParams, RevealParams, TransferParams, TransferTicketParams, IncreasePaidStorageParams, DrainDelegateParams, BallotParams, ProposalsParams, UpdateConsensusKeyParams, UpdateCompanionKeyParams, SmartRollupAddMessagesParams, SmartRollupOriginateParams, SmartRollupExecuteOutboxMessageParams, FailingNoopParams, StakeParams, UnstakeParams, FinalizeUnstakeParams } from '../operations/types';\nimport { DefaultContractType, ContractStorageType, ContractAbstraction } from './contract';\nimport { ContractProvider, ContractSchema, StorageProvider } from './interface';\nimport { EstimationProvider } from '../estimate/estimate-provider-interface';\nimport { TransferTicketOperation } from '../operations/transfer-ticket-operation';\nimport { IncreasePaidStorageOperation } from '../operations/increase-paid-storage-operation';\nimport { BallotOperation } from '../operations/ballot-operation';\nimport { DrainDelegateOperation } from '../operations/drain-delegate-operation';\nimport { ProposalsOperation } from '../operations/proposals-operation';\nimport { UpdateConsensusKeyOperation } from '../operations/update-consensus-key-operation';\nimport { UpdateCompanionKeyOperation } from '../operations/update-companion-key-operation';\nimport { SmartRollupAddMessagesOperation } from '../operations/smart-rollup-add-messages-operation';\nimport { SmartRollupOriginateOperation } from '../operations/smart-rollup-originate-operation';\nimport { SmartRollupExecuteOutboxMessageOperation } from '../operations/smart-rollup-execute-outbox-message-operation';\nimport { Provider } from '../provider';\nimport { FailingNoopOperation } from '../operations/failing-noop-operation';\nexport declare class RpcContractProvider extends Provider implements ContractProvider, StorageProvider {\n    private estimator;\n    constructor(context: Context, estimator: EstimationProvider);\n    contractProviderTypeSymbol: symbol;\n    private prepare;\n    /**\n     *\n     * @description Return a well formatted json object of the contract storage\n     *\n     * @param contract contract address you want to get the storage from\n     * @param schema optional schema can either be the contract script rpc response or a michelson-encoder schema\n     * @throws {@link InvalidContractAddressError}\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-script\n     */\n    getStorage<T>(contract: string, schema?: ContractSchema): Promise<T>;\n    /**\n     *\n     * @description Return a well formatted json object of the contract big map storage\n     *\n     * @param contract contract address you want to get the storage from\n     * @param key contract big map key to fetch value from\n     * @param schema optional schema can either be the contract script rpc response or a michelson-encoder schema\n     * @throws {@link InvalidContractAddressError}\n     * @deprecated Deprecated in favor of getBigMapKeyByID\n     *\n     * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-context-contracts-contract-id-big-map-get\n     */\n    getBigMapKey<T>(contract: string, key: string, schema?: ContractSchema): Promise<T>;\n    /**\n     *\n     * @description Return a well formatted json object of a big map value\n     *\n     * @param id Big Map ID\n     * @param keyToEncode key to query (will be encoded properly according to the schema)\n     * @param schema Big Map schema (can be determined using your contract type)\n     * @param block optional block level to fetch the values from\n     *\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-big-maps-big-map-id-script-expr\n     */\n    getBigMapKeyByID<T>(id: string, keyToEncode: BigMapKeyType, schema: Schema, block?: number): Promise<T>;\n    /**\n     *\n     * @description Fetch multiple values in a big map\n     * All values will be fetched on the same block level. If a block is specified in the request, the values will be fetched at it.\n     * Otherwise, a first request will be done to the node to fetch the level of the head and all values will be fetched at this level.\n     * If one of the keys does not exist in the big map, its value will be set to undefined.\n     *\n     * @param id Big Map ID\n     * @param keys Array of keys to query (will be encoded properly according to the schema)\n     * @param schema Big Map schema (can be determined using your contract type)\n     * @param block optional block level to fetch the values from\n     * @param batchSize optional batch size representing the number of requests to execute in parallel\n     * @returns A MichelsonMap containing the keys queried in the big map and their value in a well-formatted JSON object format\n     *\n     */\n    getBigMapKeysByID<T>(id: string, keys: Array<BigMapKeyType>, schema: Schema, block?: number, batchSize?: number): Promise<MichelsonMap<MichelsonMapKey, T | undefined>>;\n    private getBlockForRequest;\n    private getBigMapValueOrUndefined;\n    /**\n     *\n     * @description Return a well formatted json object of a sapling state\n     *\n     * @param id Sapling state ID\n     * @param block optional block level to fetch the value from\n     *\n     */\n    getSaplingDiffByID(id: string, block?: number): Promise<import(\"@taquito/rpc\").SaplingDiffResponse>;\n    /**\n     *\n     * @description Originate a new contract according to the script in parameters. Will sign and inject an operation using the current context\n     *\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @warn You cannot specify storage and init at the same time (use init to pass the raw michelson representation of storage)\n     *\n     * @param OriginationOperation Originate operation parameter\n     */\n    originate<TContract extends DefaultContractType = DefaultContractType>(params: OriginateParams<ContractStorageType<TContract>>): Promise<OriginationOperation<TContract>>;\n    /**\n     *\n     * @description Set the delegate for a contract. Will sign and inject an operation using the current context\n     *\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @param SetDelegate operation parameter\n     */\n    setDelegate(params: DelegateParams): Promise<DelegateOperation>;\n    /**\n     *\n     * @description Register the current address as delegate. Will sign and inject an operation using the current context\n     *\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @param RegisterDelegate operation parameter\n     */\n    registerDelegate(params: RegisterDelegateParams): Promise<DelegateOperation>;\n    /**\n     *\n     * @description Transfer tz from current address to a specific address. Will sign and inject an operation using the current context\n     *\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @param Transfer operation parameter\n     */\n    transfer(params: TransferParams): Promise<TransactionOperation>;\n    /**\n     *\n     * @description Stake a given amount for the source address\n     *\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @param Stake pseudo-operation parameter\n     */\n    stake(params: StakeParams): Promise<TransactionOperation>;\n    /**\n     *\n     * @description Unstake the given amount. If \"everything\" is given as amount, unstakes everything from the staking balance.\n     * Unstaked tez remains frozen for a set amount of cycles (the slashing period) after the operation. Once this period is over,\n     * the operation \"finalize unstake\" must be called for the funds to appear in the liquid balance.\n     *\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @param Unstake pseudo-operation parameter\n     */\n    unstake(params: UnstakeParams): Promise<TransactionOperation>;\n    /**\n     *\n     * @description Transfer all the finalizable unstaked funds of the source to their liquid balance\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @param Finalize_unstake pseudo-operation parameter\n     */\n    finalizeUnstake(params: FinalizeUnstakeParams): Promise<TransactionOperation>;\n    /**\n     *\n     * @description Transfer Tickets to a smart contract address\n     *\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @param TransferTicketParams operation parameter\n     */\n    transferTicket(params: TransferTicketParams): Promise<TransferTicketOperation>;\n    /**\n     *\n     * @description Reveal the public key of the current address. Will throw an error if the address is already revealed.\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @param RevealParams operation parameter\n     */\n    reveal(params: RevealParams): Promise<RevealOperation>;\n    /**\n     *\n     * @description Register a Micheline expression in a global table of constants. Will sign and inject an operation using the current context\n     *\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @param params registerGlobalConstant operation parameter\n     */\n    registerGlobalConstant(params: RegisterGlobalConstantParams): Promise<RegisterGlobalConstantOperation>;\n    /**\n     *\n     * @description Increase the paid storage of a smart contract\n     *\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @param params increasePaidStorage operation parameter\n     */\n    increasePaidStorage(params: IncreasePaidStorageParams): Promise<IncreasePaidStorageOperation>;\n    /**\n     *\n     * @description Transfers the spendable balance of the delegate to destination when consensus_key is the active consensus key of delegate\n     *\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @param params drainDelegate operation parameter\n     */\n    drainDelegate(params: DrainDelegateParams): Promise<DrainDelegateOperation>;\n    /**\n     *\n     * @description Submit a ballot vote to a specified proposal\n     *\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @param BallotParams Ballot operation parameter\n     */\n    ballot(params: BallotParams): Promise<BallotOperation>;\n    /**\n     *\n     * @description Submit or upvote a proposal during the Proposal period\n     *\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @param ProposalsParams Proposals operation parameter\n     */\n    proposals(params: ProposalsParams): Promise<ProposalsOperation>;\n    /**\n     *\n     * @description Update the consensus key of a delegate starting from the current cycle plus CONSENSUS_RIGHTS_DELAY + 1\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @param UpdateConsensusKeyParams\n     */\n    updateConsensusKey(params: UpdateConsensusKeyParams): Promise<UpdateConsensusKeyOperation>;\n    /**\n     *\n     * @description Updates the companion key of the delegate starting from the current cycle plus CONSENSUS_KEY_ACTIVATION_DELAY + 1\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @param UpdateCompanionKeyParams\n     */\n    updateCompanionKey(params: UpdateCompanionKeyParams): Promise<UpdateCompanionKeyOperation>;\n    /**\n     * @description Adds messages to the rollup inbox that can be executed/claimed after it gets cemented\n     * @param SmartRollupAddMessagesParams\n     * @returns An operation handle with results from the RPC node\n     */\n    smartRollupAddMessages(params: SmartRollupAddMessagesParams): Promise<SmartRollupAddMessagesOperation>;\n    /**\n     * @description Creates a smart rollup originate operation\n     * @param SmartRollupOriginateParams\n     * @returns An operation handle with results from the RPC node\n     */\n    smartRollupOriginate(params: SmartRollupOriginateParams): Promise<SmartRollupOriginateOperation>;\n    /**\n     * @description Execute a message from a smart rollup's outbox of a cemented commitment\n     * @param SmartRollupExecuteOutboxMessageParams\n     * @returns An operation handle with results from the RPC node\n     */\n    smartRollupExecuteOutboxMessage(params: SmartRollupExecuteOutboxMessageParams): Promise<SmartRollupExecuteOutboxMessageOperation>;\n    /**\n     *\n     * @description A failing_noop operation that is guaranteed to fail.\n     *\n     * @returns A FailingNoopOperation object representing the signed failing_noop operation\n     *\n     * @param params failingNoop operation parameter\n     */\n    failingNoop(params: FailingNoopParams): Promise<FailingNoopOperation>;\n    /**\n     *\n     * @description Create an smart contract abstraction for the address specified.\n     *\n     * @param address Smart contract address\n     * @throws {@link InvalidContractAddressError}\n     */\n    at<T extends DefaultContractType = DefaultContractType>(address: string, contractAbstractionComposer?: ContractAbstractionComposer<T>): Promise<T>;\n    /**\n     *\n     * @description Batch a group of operation together. Operations will be applied in the order in which they are added to the batch\n     *\n     * @returns A batch object from which we can add more operation or send a command to execute the batch\n     *\n     * @param params List of operation to batch together\n     */\n    batch(params?: ParamsWithKind[]): OperationBatch;\n}\ntype ContractAbstractionComposer<T> = (abs: ContractAbstraction<ContractProvider>, context: Context) => T;\nexport {};\n"},{name:"@taquito/contract/sapling-state-abstraction.d.ts",dts:"import BigNumber from 'bignumber.js';\nimport { ContractProvider } from './interface';\nexport declare class SaplingStateAbstraction {\n    private id;\n    private provider;\n    constructor(id: BigNumber, provider: ContractProvider);\n    /**\n     *\n     * @description Fetch the sapling state\n     *\n     * @param block optional block level to fetch the values from (head will be use by default)\n     * @returns Return a json object of the sapling_state\n     *\n     */\n    getSaplingDiff(block?: number): Promise<import(\"@taquito/rpc\").SaplingDiffResponse>;\n    getId(): string;\n}\n"},{name:"@taquito/contract/semantic.d.ts",dts:"import { Semantic } from '@taquito/michelson-encoder';\nimport { ContractProvider } from './interface';\n/**\n * @description Override the default michelson encoder semantic to provide richer abstraction over storage properties\n * @param provider ContractProvider (contract API)\n */\nexport declare const smartContractAbstractionSemantic: (p: ContractProvider) => Semantic;\n"},{name:"@taquito/contract/view_lambda.d.ts",dts:"export declare const VIEW_LAMBDA: {\n    code: ({\n        prim: string;\n        args: {\n            prim: string;\n            args: ({\n                prim: string;\n                args?: undefined;\n            } | {\n                prim: string;\n                args: ({\n                    prim: string;\n                    args: {\n                        prim: string;\n                    }[];\n                } | {\n                    prim: string;\n                    args?: undefined;\n                })[];\n            })[];\n        }[];\n    } | {\n        prim: string;\n        args: {\n            prim: string;\n        }[];\n    } | {\n        prim: string;\n        args: {\n            prim: string;\n        }[][];\n    })[];\n    storage: string;\n};\n"},{name:"@taquito/estimate/errors.d.ts",dts:"import { TaquitoError } from '@taquito/core';\n/**\n *  @category Error\n *  @description Error that indicates unable to get public key to estimate reveal operation in Wallet API\n */\nexport declare class RevealEstimateError extends TaquitoError {\n    constructor();\n}\n"},{name:"@taquito/estimate/estimate-provider-interface.d.ts",dts:"import { OriginateParams, TransferParams, DelegateParams, RegisterDelegateParams, ParamsWithKind } from '../operations';\nimport { RevealParams, RegisterGlobalConstantParams, TransferTicketParams, IncreasePaidStorageParams, UpdateConsensusKeyParams, UpdateCompanionKeyParams, SmartRollupAddMessagesParams, SmartRollupOriginateParams, SmartRollupExecuteOutboxMessageParams, StakeParams, UnstakeParams, FinalizeUnstakeParams } from '../operations/types';\nimport { Estimate } from './estimate';\nimport { ContractMethod, ContractMethodObject, ContractProvider } from '../contract';\nexport interface EstimationProvider {\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for an origination operation\n     *\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\n     *\n     * @param Estimate\n     */\n    originate(params: OriginateParams): Promise<Estimate>;\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for an transfer operation\n     *\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\n     *\n     * @param Estimate\n     */\n    transfer({ fee, storageLimit, gasLimit, ...rest }: TransferParams): Promise<Estimate>;\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for an stake pseudo-operation\n     *\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\n     *\n     * @param Estimate\n     */\n    stake({ fee, storageLimit, gasLimit, ...rest }: StakeParams): Promise<Estimate>;\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for an unstake pseudo-operation\n     *\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\n     *\n     * @param Estimate\n     */\n    unstake({ fee, storageLimit, gasLimit, ...rest }: UnstakeParams): Promise<Estimate>;\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for an finalize_unstake pseudo-operation\n     *\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\n     *\n     * @param Estimate\n     */\n    finalizeUnstake({ fee, storageLimit, gasLimit, ...rest }: FinalizeUnstakeParams): Promise<Estimate>;\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for an transferTicket operation\n     *\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\n     *\n     * @param Estimate\n     */\n    transferTicket({ fee, storageLimit, gasLimit, ...rest }: TransferTicketParams): Promise<Estimate>;\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for a delegate operation\n     *\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\n     *\n     * @param Estimate\n     */\n    setDelegate(params: DelegateParams): Promise<Estimate>;\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for a delegate operation\n     *\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\n     *\n     * @param Estimate\n     */\n    registerDelegate(params?: RegisterDelegateParams): Promise<Estimate>;\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for a reveal operation\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation or undefined if the account is already revealed\n     *\n     * @param Estimate\n     */\n    reveal(params?: RevealParams): Promise<Estimate | undefined>;\n    batch(params: ParamsWithKind[]): Promise<Estimate[]>;\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for registering an expression (registerGlobalConstant operation)\n     *\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\n     *\n     * @param params registerGlobalConstant operation parameter\n     */\n    registerGlobalConstant(params: RegisterGlobalConstantParams): Promise<Estimate>;\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for an increase paid storage operation\n     *\n     * @returns An estimation of gasLimit, storageLimit, and fees for the operation\n     *\n     * @param Estimate\n     */\n    increasePaidStorage(params: IncreasePaidStorageParams): Promise<Estimate>;\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for an Update Consensus Key operation\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\n     *\n     * @param Estimate\n     */\n    updateConsensusKey(params: UpdateConsensusKeyParams): Promise<Estimate>;\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for an Update Companion Key operation\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\n     *\n     * @param Estimate\n     */\n    updateCompanionKey(params: UpdateCompanionKeyParams): Promise<Estimate>;\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for an Smart Rollup Add Messages operation\n     *\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\n     *\n     * @param Estimate\n     */\n    smartRollupAddMessages(params: SmartRollupAddMessagesParams): Promise<Estimate>;\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for an Smart Rollup Execute Outbox Message operation\n     *\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\n     *\n     * @param Estimate\n     */\n    smartRollupExecuteOutboxMessage(params: SmartRollupExecuteOutboxMessageParams): Promise<Estimate>;\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for contract call\n     *\n     * @returns An estimation of gasLimit, storageLimit and fees for the contract call\n     *\n     * @param Estimate\n     */\n    contractCall(contractMethod: ContractMethod<ContractProvider> | ContractMethodObject<ContractProvider>): Promise<Estimate>;\n    /**\n     * @description Estimate gasLimit, storageLimit and fees for an Smart Rollup Originate operation\n     *\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\n     *\n     * @param SmartRollupOrigianteParams\n     */\n    smartRollupOriginate(params: SmartRollupOriginateParams): Promise<Estimate>;\n}\n"},{name:"@taquito/estimate/estimate.d.ts",dts:"export interface EstimateProperties {\n    milligasLimit: number;\n    storageLimit: number;\n    opSize: number;\n    minimalFeePerStorageByteMutez: number;\n    baseFeeMutez?: number;\n}\n/**\n * Examples of use :\n *\n *  Estimate a transfer operation :\n * ```\n * // Assuming that provider and signer are already configured...\n *\n * const amount = 2;\n * const address = 'tz1h3rQ8wBxFd8L9B3d7Jhaawu6Z568XU3xY';\n *\n * // Estimate gasLimit, storageLimit and fees for a transfer operation\n * const est = await Tezos.estimate.transfer({ to: address, amount: amount })\n * console.log(est.burnFeeMutez, est.gasLimit, est.minimalFeeMutez, est.storageLimit,\n *  est.suggestedFeeMutez, est.totalCost, est.usingBaseFeeMutez)\n *\n * ```\n *\n * Estimate a contract origination :\n * ```\n * // generic.json is referring to a Michelson Smart Contract\n *\n * const genericMultisigJSON = require('./generic.json')\n * const est = await Tezos.estimate.originate({\n *   code: genericMultisigJSON,\n *   storage: {\n *     stored_counter: 0,\n *     threshold: 1,\n *     keys: ['edpkuLxx9PQD8fZ45eUzrK3BhfDZJHhBuK4Zi49DcEGANwd2rpX82t']\n *   }\n * })\n * console.log(est.burnFeeMutez, est.gasLimit, est.minimalFeeMutez, est.storageLimit,\n *   est.suggestedFeeMutez, est.totalCost, est.usingBaseFeeMutez)\n *\n * ```\n */\nexport declare class Estimate {\n    private readonly _milligasLimit;\n    private readonly _storageLimit;\n    readonly opSize: number | string;\n    private readonly minimalFeePerStorageByteMutez;\n    /**\n     * @description Base fee in mutez (1 mutez = 1e10\u22126 tez)\n     */\n    private readonly baseFeeMutez;\n    constructor(_milligasLimit: number | string, _storageLimit: number | string, opSize: number | string, minimalFeePerStorageByteMutez: number | string, \n    /**\n     * @description Base fee in mutez (1 mutez = 1e10\u22126 tez)\n     */\n    baseFeeMutez?: number | string);\n    /**\n     * @description The number of Mutez that will be burned for the storage of the [operation](https://tezos.gitlab.io/user/glossary.html#operations). (Storage + Allocation fees)\n     */\n    get burnFeeMutez(): number;\n    /**\n     * @description  The limit on the amount of storage an [operation](https://tezos.gitlab.io/user/glossary.html#operations) can use with 20 buffer.\n     */\n    get storageLimit(): number;\n    /**\n     * @description The limit on the amount of [gas](https://tezos.gitlab.io/user/glossary.html#gas) a given operation can consume with 100 buffer depends on the operation.\n     */\n    get gasLimit(): number;\n    private get operationFeeMutez();\n    private roundUp;\n    /**\n     * @description Minimum fees for the [operation](https://tezos.gitlab.io/user/glossary.html#operations) according to [baker](https://tezos.gitlab.io/user/glossary.html#baker) defaults.\n     */\n    get minimalFeeMutez(): number;\n    /**\n     * @description The suggested fee for the operation which includes minimal fees and a small buffer.\n     */\n    get suggestedFeeMutez(): number;\n    /**\n     * @description Fees according to your specified base fee will ensure that at least minimum fees are used.\n     */\n    get usingBaseFeeMutez(): number;\n    /**\n     * @description The sum of `minimalFeeMutez` + `burnFeeMutez`.\n     */\n    get totalCost(): number;\n    /**\n     * @description Since Delphinet, consumed gas is provided in milligas for more precision.\n     * This function returns an estimation of the gas that operation will consume in milligas.\n     */\n    get consumedMilligas(): number;\n    static createEstimateInstanceFromProperties(estimateProperties: EstimateProperties[]): Estimate;\n    static createArrayEstimateInstancesFromProperties(estimateProperties: EstimateProperties[]): Estimate[];\n}\n"},{name:"@taquito/estimate/index.d.ts",dts:"export * from './estimate';\nexport * from './estimate-provider-interface';\nexport * from './rpc-estimate-provider';\nexport * from './errors';\n"},{name:"@taquito/estimate/rpc-estimate-provider.d.ts",dts:"import { DelegateParams, OriginateParams, ParamsWithKind, RegisterDelegateParams, TransferParams, RevealParams, RegisterGlobalConstantParams, TransferTicketParams, IncreasePaidStorageParams, UpdateConsensusKeyParams, UpdateCompanionKeyParams, SmartRollupAddMessagesParams, SmartRollupOriginateParams, SmartRollupExecuteOutboxMessageParams, StakeParams, UnstakeParams, FinalizeUnstakeParams } from '../operations/types';\nimport { Estimate } from './estimate';\nimport { EstimationProvider } from '../estimate/estimate-provider-interface';\nimport { ContractMethod, ContractMethodObject, ContractProvider } from '../contract';\nimport { Provider } from '../provider';\nexport declare class RPCEstimateProvider extends Provider implements EstimationProvider {\n    private readonly REVEAL_LENGTH;\n    private readonly REVEAL_LENGTH_TZ4;\n    private readonly MILLIGAS_BUFFER;\n    private readonly STORAGE_BUFFER;\n    private prepare;\n    private getKeys;\n    private getEstimationPropertiesFromOperationContent;\n    private calculateEstimates;\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for an origination operation\n     *\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\n     *\n     * @param OriginationOperation Originate operation parameter\n     */\n    originate(params: OriginateParams): Promise<Estimate>;\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for an transfer operation\n     *\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\n     *\n     * @param TransferOperation Originate operation parameter\n     */\n    transfer({ fee, storageLimit, gasLimit, ...rest }: TransferParams): Promise<Estimate>;\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for an stake pseudo-operation\n     *\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\n     *\n     * @param Stake pseudo-operation parameter\n     */\n    stake({ fee, storageLimit, gasLimit, ...rest }: StakeParams): Promise<Estimate>;\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for an Unstake pseudo-operation\n     *\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\n     *\n     * @param Unstake pseudo-operation parameter\n     */\n    unstake({ fee, storageLimit, gasLimit, ...rest }: UnstakeParams): Promise<Estimate>;\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for an finalize_unstake pseudo-operation\n     *\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\n     *\n     * @param finalize_unstake pseudo-operation parameter\n     */\n    finalizeUnstake({ fee, storageLimit, gasLimit, ...rest }: FinalizeUnstakeParams): Promise<Estimate>;\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for a transferTicket operation\n     *\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\n     *\n     * @param TransferTicketParams operation parameter\n     */\n    transferTicket({ fee, storageLimit, gasLimit, ...rest }: TransferTicketParams): Promise<Estimate>;\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for a delegate operation\n     *\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\n     *\n     * @param Estimate\n     */\n    setDelegate({ fee, gasLimit, storageLimit, ...rest }: DelegateParams): Promise<Estimate>;\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for a each operation in the batch\n     *\n     * @returns An array of Estimate objects. If a reveal operation is needed, the first element of the array is the Estimate for the reveal operation.\n     */\n    batch(params: ParamsWithKind[]): Promise<Estimate[]>;\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for a delegate operation\n     *\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\n     *\n     * @param Estimate\n     */\n    registerDelegate({ fee, storageLimit, gasLimit, ...rest }: RegisterDelegateParams, source?: string): Promise<Estimate>;\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees to reveal the current account\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation or undefined if the account is already revealed\n     *\n     * @param Estimate\n     */\n    reveal(params?: RevealParams): Promise<Estimate | undefined>;\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for an registerGlobalConstant operation\n     *\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\n     *\n     * @param params registerGlobalConstant operation parameter\n     */\n    registerGlobalConstant({ fee, storageLimit, gasLimit, ...rest }: RegisterGlobalConstantParams): Promise<Estimate>;\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit, and fees for an increasePaidStorage operation\n     *\n     * @returns An estimation of gasLimit, storageLimit, and fees for the operation\n     *\n     * @param params increasePaidStorage operation parameters\n     */\n    increasePaidStorage({ fee, storageLimit, gasLimit, ...rest }: IncreasePaidStorageParams): Promise<Estimate>;\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for an Update Consensus Key operation\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\n     * @param Estimate\n     */\n    updateConsensusKey(params: UpdateConsensusKeyParams): Promise<Estimate>;\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for an Update Companion Key operation\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\n     * @param Estimate\n     */\n    updateCompanionKey(params: UpdateCompanionKeyParams): Promise<Estimate>;\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for a smart_rollup_add_messages operation\n     *\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\n     *\n     * @param Estimate\n     */\n    smartRollupAddMessages(params: SmartRollupAddMessagesParams): Promise<Estimate>;\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for an Smart Rollup Originate operation\n     *\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\n     *\n     * @param SmartRollupOriginateParams\n     */\n    smartRollupOriginate(params: SmartRollupOriginateParams): Promise<Estimate>;\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for a smart_rollup_execute_outbox_message operation\n     *\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\n     *\n     * @param Estimate\n     */\n    smartRollupExecuteOutboxMessage(params: SmartRollupExecuteOutboxMessageParams): Promise<Estimate>;\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for contract call\n     *\n     * @returns An estimation of gasLimit, storageLimit and fees for the contract call\n     *\n     * @param Estimate\n     */\n    contractCall(contractMethod: ContractMethod<ContractProvider> | ContractMethodObject<ContractProvider>): Promise<Estimate>;\n}\n"},{name:"@taquito/extension/extension.d.ts",dts:'import { Context } from "../context";\nexport interface Extension {\n    configureContext(context: Context): void;\n}\n'},{name:"@taquito/forger/composite-forger.d.ts",dts:"import { Forger, ForgeParams, ForgeResponse } from '@taquito/local-forging';\nexport declare class CompositeForger implements Forger {\n    private forgers;\n    constructor(forgers: Forger[]);\n    forge({ branch, contents }: ForgeParams): Promise<ForgeResponse>;\n}\n"},{name:"@taquito/forger/errors.d.ts",dts:"import { TaquitoError, TezosToolkitConfigError } from '@taquito/core';\n/**\n *  @category Error\n *  @description Error that indicates CompositeForger.forge() results doesn't match each other\n */\nexport declare class ForgingMismatchError extends TaquitoError {\n    readonly results: string[];\n    constructor(results: string[]);\n}\n/**\n *  @category Error\n *  @description Error that indicates no forger has been configured for CompositeForger\n */\nexport declare class UnspecifiedForgerError extends TezosToolkitConfigError {\n    constructor();\n}\n"},{name:"@taquito/forger/rpc-forger.d.ts",dts:"import { Forger, ForgeParams, ForgeResponse } from '@taquito/local-forging';\nimport { Context } from '../context';\nexport declare class RpcForger implements Forger {\n    private context;\n    constructor(context: Context);\n    forge({ branch, contents }: ForgeParams): Promise<ForgeResponse>;\n}\n"},{name:"@taquito/forger/taquito-local-forger.d.ts",dts:"import { Forger, ForgeParams, ForgeResponse } from '@taquito/local-forging';\nimport { Context } from '../context';\nexport declare class TaquitoLocalForger implements Forger {\n    private context;\n    constructor(context: Context);\n    private getNextProto;\n    forge({ branch, contents }: ForgeParams): Promise<ForgeResponse>;\n}\n"},{name:"@taquito/global-constants/default-global-constants-provider.d.ts",dts:"import { GlobalConstantHashAndValue } from '@taquito/michel-codec';\nimport { GlobalConstantHash, GlobalConstantsProvider } from './interface-global-constants-provider';\nexport declare class DefaultGlobalConstantsProvider implements GlobalConstantsProvider {\n    private _globalConstantsLibrary;\n    /**\n     *\n     * @description Allows to load global constant hashes and their corresponding Michelson JSON values\n     */\n    loadGlobalConstant(globalConstant: GlobalConstantHashAndValue): void;\n    /**\n     *\n     * @description Retrieve the Michelson value of a global constant based on its hash\n     *\n     * @param hash a string representing the global constant hash\n     * @returns Expr, the JSON Michelson value\n     */\n    getGlobalConstantByHash(hash: GlobalConstantHash): Promise<import(\"@taquito/michel-codec\").Expr>;\n}\n"},{name:"@taquito/global-constants/errors.d.ts",dts:"import { TaquitoError, TezosToolkitConfigError } from '@taquito/core';\n/**\n *  @category Error\n *  @description Error that indicates that a global constant does not exist\n */\nexport declare class GlobalConstantNotFound extends TaquitoError {\n    readonly hash: string;\n    constructor(hash: string);\n}\n/**\n *  @category Error\n *  @description Error that indicates the global constant provider not being configured under TezosToolkit\n */\nexport declare class UnconfiguredGlobalConstantsProviderError extends TezosToolkitConfigError {\n    constructor();\n}\n"},{name:"@taquito/global-constants/interface-global-constants-provider.d.ts",dts:'import { Expr } from "@taquito/michel-codec";\nexport type GlobalConstantHash = string;\nexport interface GlobalConstantsProvider {\n    /**\n     *\n     * @description Retrieve the Michelson value of a global constant based on its hash\n     *\n     * @param hash a string representing the global constant hash\n     */\n    getGlobalConstantByHash(hash: GlobalConstantHash): Promise<Expr>;\n}\n'},{name:"@taquito/global-constants/noop-global-constants-provider.d.ts",dts:"import { Expr } from '@taquito/michel-codec';\nimport { GlobalConstantHash, GlobalConstantsProvider } from './interface-global-constants-provider';\nexport declare class NoopGlobalConstantsProvider implements GlobalConstantsProvider {\n    getGlobalConstantByHash(_hash: GlobalConstantHash): Promise<Expr>;\n}\n"},{name:"@taquito/injector/helper.d.ts",dts:"import { HttpResponseError } from '@taquito/http-utils';\nexport declare function formatErrorMessage(error: HttpResponseError, stringToReplace: string): HttpResponseError;\n"},{name:"@taquito/injector/interface.d.ts",dts:"export type InjectorParams = string;\nexport type TxHash = string;\nexport interface Injector {\n    inject(signedOperationBytes: InjectorParams): Promise<TxHash>;\n}\n"},{name:"@taquito/injector/rpc-injector.d.ts",dts:"import { Injector } from './interface';\nimport { Context } from '../context';\nexport declare class RpcInjector implements Injector {\n    private context;\n    constructor(context: Context);\n    inject(signedOperationBytes: string): Promise<string>;\n}\n"},{name:"@taquito/operations/ballot-operation.d.ts",dts:"import { OperationContentsAndResult, OperationContentsAndResultBallot, OperationContentsBallot } from '@taquito/rpc';\nimport { Context } from '../context';\nimport { Operation } from './operations';\nimport { ForgedBytes } from './types';\n/**\n *\n * @description BallotOperation provides utility functions to fetch a new operation of kind ballot\n *\n */\nexport declare class BallotOperation extends Operation {\n    private readonly params;\n    readonly source: string;\n    constructor(hash: string, params: OperationContentsBallot, source: string, raw: ForgedBytes, results: OperationContentsAndResult[], context: Context);\n    get operationResults(): OperationContentsAndResultBallot | undefined;\n    get period(): number | undefined;\n    get proposal(): string;\n    get ballot(): import(\"@taquito/rpc\").BallotVote;\n}\n"},{name:"@taquito/operations/batch-operation.d.ts",dts:"import { OperationContents, OperationContentsAndResult } from '@taquito/rpc';\nimport { Context } from '../context';\nimport { Operation } from './operations';\nimport { FeeConsumingOperation, ForgedBytes, GasConsumingOperation, StorageConsumingOperation } from './types';\nexport declare class BatchOperation extends Operation implements GasConsumingOperation, StorageConsumingOperation, FeeConsumingOperation {\n    private readonly params;\n    readonly source: string;\n    constructor(hash: string, params: OperationContents[], source: string, raw: ForgedBytes, results: OperationContentsAndResult[], context: Context);\n    private sumProp;\n    getOriginatedContractAddresses(): string[];\n    get status(): import(\"@taquito/rpc\").OperationResultStatusEnum | \"unknown\";\n    get fee(): any;\n    get gasLimit(): any;\n    get storageLimit(): any;\n    get consumedGas(): string;\n    get consumedMilliGas(): string;\n    get storageDiff(): string;\n    get errors(): import(\"@taquito/rpc\").TezosGenericOperationError[];\n}\n"},{name:"@taquito/operations/delegate-operation.d.ts",dts:"import { OperationContentsAndResult, OperationContentsDelegation } from '@taquito/rpc';\nimport { Context } from '../context';\nimport { Operation } from './operations';\nimport { FeeConsumingOperation, ForgedBytes, GasConsumingOperation, StorageConsumingOperation } from './types';\n/**\n * @description Delegation operation provide utility function to fetch newly issued delegation\n *\n * @warn Currently support only one delegation per operation\n */\nexport declare class DelegateOperation extends Operation implements GasConsumingOperation, StorageConsumingOperation, FeeConsumingOperation {\n    private readonly params;\n    readonly source: string;\n    constructor(hash: string, params: OperationContentsDelegation, source: string, raw: ForgedBytes, results: OperationContentsAndResult[], context: Context);\n    get operationResults(): import(\"@taquito/rpc\").OperationResultDelegation | undefined;\n    get status(): import(\"@taquito/rpc\").OperationResultStatusEnum | \"unknown\";\n    get delegate(): string | undefined;\n    get isRegisterOperation(): boolean;\n    get fee(): number;\n    get gasLimit(): number;\n    get storageLimit(): number;\n    get consumedGas(): string | undefined;\n    get consumedMilliGas(): string | undefined;\n    get errors(): import(\"@taquito/rpc\").TezosGenericOperationError[] | undefined;\n}\n"},{name:"@taquito/operations/drain-delegate-operation.d.ts",dts:"import { OperationContentsAndResult, OperationContentsDrainDelegate } from '@taquito/rpc';\nimport { Context } from '../context';\nimport { Operation } from './operations';\nimport { ForgedBytes } from './types';\n/**\n *\n * @description DrainDelegateOperation provides utility functions to fetch a new operation of kind drain_delegate\n *\n */\nexport declare class DrainDelegateOperation extends Operation {\n    private readonly params;\n    constructor(hash: string, params: OperationContentsDrainDelegate, raw: ForgedBytes, results: OperationContentsAndResult[], context: Context);\n    get operationResults(): import(\"@taquito/rpc\").OperationMetadataBalanceUpdates[] | undefined;\n    get consensusKey(): string;\n    get delegate(): string;\n    get destination(): string;\n}\n"},{name:"@taquito/operations/errors.d.ts",dts:"import { ParameterValidationError, RpcError, TaquitoError } from '@taquito/core';\nimport { MichelsonV1ExpressionBase, OperationContentsAndResult, OperationResultDelegation, OperationResultOrigination, OperationResultRegisterGlobalConstant, OperationResultReveal, OperationResultSmartRollupOriginate, OperationResultTransaction, OperationResultTransferTicket, PreapplyResponse, TezosGenericOperationError } from '@taquito/rpc';\nexport interface TezosOperationErrorWithMessage extends TezosGenericOperationError {\n    with: MichelsonV1ExpressionBase;\n}\n/**\n *  @category Error\n *  @description Generic tezos error that will be thrown when a mistake occurs when doing an operation; more details here https://tezos.gitlab.io/api/errors.html\n */\nexport declare class TezosOperationError extends RpcError {\n    readonly errors: TezosGenericOperationError[];\n    readonly errorDetails: string;\n    readonly operationsWithResults: OperationContentsAndResult[];\n    readonly lastError: TezosGenericOperationError;\n    constructor(errors: TezosGenericOperationError[], errorDetails: string, operationsWithResults: OperationContentsAndResult[]);\n    get id(): string;\n    get kind(): string;\n}\n/**\n *  @category Error\n *  @description Tezos error that will be thrown when a mistake happens during the preapply stage\n */\nexport declare class TezosPreapplyFailureError extends Error {\n    readonly result: any;\n    constructor(result: any);\n}\nexport type MergedOperationResult = OperationResultTransaction & OperationResultOrigination & OperationResultDelegation & OperationResultRegisterGlobalConstant & OperationResultTransferTicket & Partial<OperationResultSmartRollupOriginate> & OperationResultReveal & {\n    fee?: string;\n};\nexport declare const flattenOperationResult: (response: PreapplyResponse | PreapplyResponse[]) => MergedOperationResult[];\n/***\n * @description Flatten all error from preapply response (including internal error)\n */\nexport declare const flattenErrors: (response: PreapplyResponse | PreapplyResponse[], status?: string) => TezosGenericOperationError[];\n/**\n *  @category Error\n *  @description Error that indicates a general failure happening during an origination operation.\n */\nexport declare class OriginationOperationError extends TaquitoError {\n    readonly message: string;\n    constructor(message: string);\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid estimate value being passed\n */\nexport declare class InvalidEstimateValueError extends ParameterValidationError {\n    readonly message: string;\n    constructor(message: string);\n}\n"},{name:"@taquito/operations/failing-noop-operation.d.ts",dts:"import { OpKind } from '@taquito/rpc';\n/**\n * @description FailingNoopOperation interface that contains information about a signed failing_noop operation\n */\nexport interface FailingNoopOperation {\n    signedContent: {\n        branch: string;\n        contents: [\n            {\n                kind: OpKind.FAILING_NOOP;\n                arbitrary: string;\n            }\n        ];\n    };\n    bytes: string;\n    signature: string;\n}\n"},{name:"@taquito/operations/increase-paid-storage-operation.d.ts",dts:"import { OperationContentsAndResult, OperationContentsIncreasePaidStorage } from '@taquito/rpc';\nimport { Context } from '../context';\nimport { Operation } from './operations';\nimport { FeeConsumingOperation, ForgedBytes, GasConsumingOperation, StorageConsumingOperation } from './types';\n/**\n *\n * @description IncreasePaidStorageOperation provides utility functions to fetch a new operation of kind increase_paid_storage\n *\n */\nexport declare class IncreasePaidStorageOperation extends Operation implements GasConsumingOperation, StorageConsumingOperation, FeeConsumingOperation {\n    private readonly params;\n    readonly source: string;\n    constructor(hash: string, params: OperationContentsIncreasePaidStorage, source: string, raw: ForgedBytes, results: OperationContentsAndResult[], context: Context);\n    get operationResults(): import(\"@taquito/rpc\").OperationResultIncreasePaidStorage | undefined;\n    get status(): import(\"@taquito/rpc\").OperationResultStatusEnum | \"unknown\";\n    get fee(): number;\n    get gasLimit(): number;\n    get storageLimit(): number;\n    get errors(): import(\"@taquito/rpc\").TezosGenericOperationError[] | undefined;\n    get consumedMilliGas(): string | undefined;\n    get amount(): string;\n    get destination(): string;\n}\n"},{name:"@taquito/operations/index.d.ts",dts:"export * from './types';\nexport { TezosOperationError, TezosOperationErrorWithMessage, TezosPreapplyFailureError, InvalidEstimateValueError, } from './errors';\nexport { BatchOperation } from './batch-operation';\nexport { OriginationOperation } from './origination-operation';\nexport { DelegateOperation } from './delegate-operation';\nexport { TransactionOperation } from './transaction-operation';\nexport { RegisterGlobalConstantOperation } from './register-global-constant-operation';\nexport { IncreasePaidStorageOperation } from './increase-paid-storage-operation';\nexport { TransferTicketOperation } from './transfer-ticket-operation';\nexport { UpdateConsensusKeyOperation } from './update-consensus-key-operation';\nexport { UpdateCompanionKeyOperation } from './update-companion-key-operation';\nexport { SmartRollupAddMessagesOperation } from './smart-rollup-add-messages-operation';\nexport { SmartRollupOriginateOperation } from './smart-rollup-originate-operation';\nexport { BallotOperation } from './ballot-operation';\nexport { DrainDelegateOperation } from './drain-delegate-operation';\nexport { ProposalsOperation } from './proposals-operation';\nexport { RevealOperation } from './reveal-operation';\nexport { Operation } from './operations';\n"},{name:"@taquito/operations/operations.d.ts",dts:'import { OperationContentsAndResult, OperationContentsAndResultReveal } from \'@taquito/rpc\';\nimport { Context } from \'../context\';\nimport { ForgedBytes } from \'./types\';\n/**\n * @description Utility class to interact with Tezos operations\n */\nexport declare class Operation {\n    readonly hash: string;\n    readonly raw: ForgedBytes;\n    readonly results: OperationContentsAndResult[];\n    protected readonly context: Context;\n    private _pollingConfig$;\n    private lastHead;\n    private currentHead$;\n    private confirmed$;\n    protected _foundAt: number;\n    get includedInBlock(): number;\n    /**\n     *\n     * @param hash Operation hash\n     * @param raw Raw operation that was injected\n     * @param context Taquito context allowing access to rpc and signer\n     * @throws {@link InvalidOperationHashError}\n     */\n    constructor(hash: string, raw: ForgedBytes, results: OperationContentsAndResult[], context: Context);\n    get revealOperation(): false | OperationContentsAndResultReveal | undefined;\n    get revealStatus(): import("@taquito/rpc").OperationResultStatusEnum | "unknown";\n    get status(): import("@taquito/rpc").OperationResultStatusEnum | "unknown";\n    /**\n     *\n     * @param confirmations [0] Number of confirmation to wait for\n     * @param timeout [180] Timeout\n     */\n    confirmation(confirmations?: number, timeout?: number): Promise<number>;\n}\n'},{name:"@taquito/operations/origination-operation.d.ts",dts:"import { OperationContentsAndResult, OperationContentsOrigination } from '@taquito/rpc';\nimport { Context } from '../context';\nimport { DefaultContractType } from '../contract/contract';\nimport { RpcContractProvider } from '../contract/rpc-contract-provider';\nimport { Operation } from './operations';\nimport { FeeConsumingOperation, ForgedBytes, GasConsumingOperation, StorageConsumingOperation } from './types';\n/**\n * @description Origination operation provide utility function to fetch newly originated contract\n *\n * @warn Currently support only one origination per operation\n */\nexport declare class OriginationOperation<TContract extends DefaultContractType = DefaultContractType> extends Operation implements GasConsumingOperation, StorageConsumingOperation, FeeConsumingOperation {\n    private readonly params;\n    private contractProvider;\n    /**\n     * @description Contract address of the newly originated contract\n     */\n    readonly contractAddress?: string;\n    constructor(hash: string, params: OperationContentsOrigination, raw: ForgedBytes, results: OperationContentsAndResult[], context: Context, contractProvider: RpcContractProvider);\n    get status(): import(\"@taquito/rpc\").OperationResultStatusEnum | \"unknown\";\n    get operationResults(): import(\"@taquito/rpc\").OperationResultOrigination | undefined;\n    get fee(): number;\n    get gasLimit(): number;\n    get storageLimit(): number;\n    get consumedGas(): string | undefined;\n    get consumedMilliGas(): string | undefined;\n    get storageDiff(): string | undefined;\n    get storageSize(): string | undefined;\n    get errors(): import(\"@taquito/rpc\").TezosGenericOperationError[] | undefined;\n    /**\n     * @description Provide the contract abstract of the newly originated contract\n     * @throws {@link OriginationOperationError}\n     */\n    contract(confirmations?: number, timeout?: number): Promise<TContract>;\n}\n"},{name:"@taquito/operations/proposals-operation.d.ts",dts:"import { OperationContentsAndResult, OperationContentsAndResultProposals, OperationContentsProposals } from '@taquito/rpc';\nimport { Context } from '../context';\nimport { Operation } from './operations';\nimport { ForgedBytes } from './types';\n/**\n *\n * @description ProposalsOperation provides utility functions to fetch a new operation of kind proposals\n *\n */\nexport declare class ProposalsOperation extends Operation {\n    private readonly params;\n    readonly source: string;\n    constructor(hash: string, params: OperationContentsProposals, source: string, raw: ForgedBytes, results: OperationContentsAndResult[], context: Context);\n    get operationResults(): OperationContentsAndResultProposals | undefined;\n    get proposals(): string[];\n    get period(): number | undefined;\n}\n"},{name:"@taquito/operations/register-global-constant-operation.d.ts",dts:'import { OperationContentsAndResult, OperationContentsRegisterGlobalConstant } from \'@taquito/rpc\';\nimport { Context } from \'../context\';\nimport { Operation } from \'./operations\';\nimport { FeeConsumingOperation, ForgedBytes, GasConsumingOperation, StorageConsumingOperation } from \'./types\';\n/**\n * @description RegisterGlobalConstantOperation provides utility functions to fetch a newly issued operation of kind register_global_constant\n */\nexport declare class RegisterGlobalConstantOperation extends Operation implements GasConsumingOperation, StorageConsumingOperation, FeeConsumingOperation {\n    private readonly params;\n    readonly source: string;\n    /**\n     * @description Hash (index) of the newly registered constant\n     */\n    readonly globalConstantHash?: string;\n    constructor(hash: string, params: OperationContentsRegisterGlobalConstant, source: string, raw: ForgedBytes, results: OperationContentsAndResult[], context: Context);\n    get operationResults(): import("@taquito/rpc").OperationResultRegisterGlobalConstant | undefined;\n    get status(): import("@taquito/rpc").OperationResultStatusEnum | "unknown";\n    get registeredExpression(): import("@taquito/rpc").MichelsonV1Expression;\n    get fee(): number;\n    get gasLimit(): number;\n    get storageLimit(): number;\n    get errors(): import("@taquito/rpc").TezosGenericOperationError[] | undefined;\n    get consumedGas(): string | undefined;\n    get consumedMilliGas(): string | undefined;\n}\n'},{name:"@taquito/operations/reveal-operation.d.ts",dts:"import { OperationContentsAndResult, OperationContentsAndResultReveal, OperationContentsReveal } from '@taquito/rpc';\nimport { Context } from '../context';\nimport { Operation } from './operations';\nimport { FeeConsumingOperation, ForgedBytes, GasConsumingOperation, StorageConsumingOperation } from './types';\n/**\n * @description Reveal operation provides utility functions to fetch a newly issued revelation\n */\nexport declare class RevealOperation extends Operation implements GasConsumingOperation, StorageConsumingOperation, FeeConsumingOperation {\n    private readonly params;\n    readonly source: string;\n    constructor(hash: string, params: OperationContentsReveal, source: string, raw: ForgedBytes, results: OperationContentsAndResult[], context: Context);\n    get operationResults(): OperationContentsAndResultReveal[];\n    get status(): import(\"@taquito/rpc\").OperationResultStatusEnum | \"unknown\";\n    get fee(): number;\n    get gasLimit(): number;\n    get storageLimit(): number;\n    get publicKey(): string;\n    get proof(): string;\n    private sumProp;\n    get consumedGas(): string;\n    get consumedMilliGas(): string;\n    get storageDiff(): string;\n    get storageSize(): string;\n    get errors(): import(\"@taquito/rpc\").TezosGenericOperationError[];\n}\n"},{name:"@taquito/operations/smart-rollup-add-messages-operation.d.ts",dts:"import { OperationContentsAndResult, OperationContentsSmartRollupAddMessages } from '@taquito/rpc';\nimport { Context } from '../context';\nimport { Operation } from './operations';\nimport { FeeConsumingOperation, ForgedBytes, GasConsumingOperation, StorageConsumingOperation } from './types';\n/**\n * @description SmartRollupAddMessagesOperation provides utility to fetch properties of SmartRollupAddMessages\n */\nexport declare class SmartRollupAddMessagesOperation extends Operation implements GasConsumingOperation, StorageConsumingOperation, FeeConsumingOperation {\n    private readonly params;\n    readonly source: string;\n    constructor(hash: string, params: OperationContentsSmartRollupAddMessages, source: string, raw: ForgedBytes, results: OperationContentsAndResult[], context: Context);\n    get operationResults(): import(\"@taquito/rpc\").OperationResultSmartRollupAddMessages | undefined;\n    get status(): import(\"@taquito/rpc\").OperationResultStatusEnum | \"unknown\";\n    get message(): string[];\n    get fee(): number;\n    get gasLimit(): number;\n    get storageLimit(): number;\n    get consumedMilliGas(): string | undefined;\n    get errors(): import(\"@taquito/rpc\").TezosGenericOperationError[] | undefined;\n}\n"},{name:"@taquito/operations/smart-rollup-execute-outbox-message-operation.d.ts",dts:"import { OperationContentsAndResult, OperationContentsSmartRollupExecuteOutboxMessage } from '@taquito/rpc';\nimport { Context } from '../context';\nimport { Operation } from './operations';\nimport { FeeConsumingOperation, ForgedBytes, GasConsumingOperation, StorageConsumingOperation } from './types';\n/**\n *\n * @description SmartRollupExecuteOutboxMessage Operation provides utility to fetch properties for Operation of kind SmartRollupExecuteOutboxMessage\n *\n */\nexport declare class SmartRollupExecuteOutboxMessageOperation extends Operation implements GasConsumingOperation, StorageConsumingOperation, FeeConsumingOperation {\n    private readonly params;\n    readonly source: string;\n    constructor(hash: string, params: OperationContentsSmartRollupExecuteOutboxMessage, source: string, raw: ForgedBytes, results: OperationContentsAndResult[], context: Context);\n    get operationResults(): import(\"@taquito/rpc\").OperationResultSmartRollupExecuteOutboxMessage | undefined;\n    get status(): import(\"@taquito/rpc\").OperationResultStatusEnum | \"unknown\";\n    get rollup(): string;\n    get cementedCommitment(): string;\n    get outputProof(): string;\n    get fee(): number;\n    get gasLimit(): number;\n    get storageLimit(): number;\n    get consumedMilliGas(): string | undefined;\n    get errors(): import(\"@taquito/rpc\").TezosGenericOperationError[] | undefined;\n}\n"},{name:"@taquito/operations/smart-rollup-originate-operation.d.ts",dts:'import { OperationContentsAndResult, OperationContentsSmartRollupOriginate } from \'@taquito/rpc\';\nimport { Context } from \'../context\';\nimport { Operation } from \'./operations\';\nimport { FeeConsumingOperation, ForgedBytes, GasConsumingOperation, StorageConsumingOperation } from \'./types\';\n/**\n *\n * @description SmartRollupOriginate Operation provides utility to fetch properties for Operation of kind SmartRollupOriginate\n *\n */\nexport declare class SmartRollupOriginateOperation extends Operation implements GasConsumingOperation, StorageConsumingOperation, FeeConsumingOperation {\n    private readonly params;\n    readonly source: string;\n    constructor(hash: string, params: OperationContentsSmartRollupOriginate, source: string, raw: ForgedBytes, results: OperationContentsAndResult[], context: Context);\n    get operationResults(): import("@taquito/rpc").OperationResultSmartRollupOriginate | undefined;\n    get status(): import("@taquito/rpc").OperationResultStatusEnum | "unknown";\n    get fee(): number;\n    get gasLimit(): number;\n    get storageLimit(): number;\n    get consumedMilliGas(): string | undefined;\n    get pvmKind(): import("@taquito/rpc").PvmKind;\n    get kernel(): string;\n    get errors(): import("@taquito/rpc").TezosGenericOperationError[] | undefined;\n}\n'},{name:"@taquito/operations/transaction-operation.d.ts",dts:"import { OperationContentsAndResult, OperationContentsAndResultTransaction, OperationContentsTransaction } from '@taquito/rpc';\nimport BigNumber from 'bignumber.js';\nimport { Context } from '../context';\nimport { Operation } from './operations';\nimport { FeeConsumingOperation, ForgedBytes, GasConsumingOperation, StorageConsumingOperation } from './types';\n/**\n * @description Transaction operation provides utility functions to fetch a newly issued transaction\n *\n * @warn Currently supports one transaction per operation\n */\nexport declare class TransactionOperation extends Operation implements GasConsumingOperation, StorageConsumingOperation, FeeConsumingOperation {\n    private readonly params;\n    readonly source: string;\n    constructor(hash: string, params: OperationContentsTransaction, source: string, raw: ForgedBytes, results: OperationContentsAndResult[], context: Context);\n    get operationResults(): OperationContentsAndResultTransaction[];\n    get status(): import(\"@taquito/rpc\").OperationResultStatusEnum | \"unknown\";\n    get amount(): BigNumber;\n    get destination(): string;\n    get fee(): number;\n    get gasLimit(): number;\n    get storageLimit(): number;\n    private sumProp;\n    get consumedGas(): string;\n    get consumedMilliGas(): string;\n    get storageDiff(): string;\n    get storageSize(): string;\n    get errors(): import(\"@taquito/rpc\").TezosGenericOperationError[];\n}\n"},{name:"@taquito/operations/transfer-ticket-operation.d.ts",dts:"import { OperationContentsAndResult, OperationContentsTransferTicket } from '@taquito/rpc';\nimport { Context } from '../context';\nimport { Operation } from '../operations';\nimport { GasConsumingOperation, StorageConsumingOperation, FeeConsumingOperation, ForgedBytes } from './types';\n/**\n *\n * @description Transfer tickets from a Tezos address (tz1, tz2 or tz3) to a smart contract address (KT1) (everything on layer 1 at this step)\n *\n * @warn Currently only supports one L2 ticket holder transfer at once. ie. one collection of tickets owned by tz1, tz2 or tz3 to a smart contract.\n */\nexport declare class TransferTicketOperation extends Operation implements GasConsumingOperation, StorageConsumingOperation, FeeConsumingOperation {\n    private readonly params;\n    private readonly source;\n    constructor(hash: string, params: OperationContentsTransferTicket, source: string, raw: ForgedBytes, results: OperationContentsAndResult[], context: Context);\n    get operationResults(): import(\"@taquito/rpc\").OperationResultTransferTicket | undefined;\n    get status(): import(\"@taquito/rpc\").OperationResultStatusEnum | \"unknown\";\n    get fee(): number;\n    get gasLimit(): number;\n    get storageLimit(): number;\n    get consumedGas(): string | undefined;\n    get consumedMilliGas(): string | undefined;\n}\n"},{name:"@taquito/operations/types.d.ts",dts:"import { OperationObject, InternalOperationResultKindEnum, OpKind, TransactionOperationParameter, MichelsonV1Expression, BallotVote, PvmKind } from '@taquito/rpc';\nimport { BlockIdentifier } from '../read-provider/interface';\nexport { OpKind } from '@taquito/rpc';\nexport type withKind<T, K extends OpKind> = T & {\n    kind: K;\n};\nexport type ParamsWithKind = withKind<OriginateParams, OpKind.ORIGINATION> | withKind<DelegateParams, OpKind.DELEGATION> | withKind<TransferParams, OpKind.TRANSACTION> | withKind<ActivationParams, OpKind.ACTIVATION> | withKind<RegisterGlobalConstantParams, OpKind.REGISTER_GLOBAL_CONSTANT> | withKind<IncreasePaidStorageParams, OpKind.INCREASE_PAID_STORAGE> | withKind<TransferTicketParams, OpKind.TRANSFER_TICKET> | withKind<UpdateConsensusKeyParams, OpKind.UPDATE_CONSENSUS_KEY> | withKind<UpdateCompanionKeyParams, OpKind.UPDATE_COMPANION_KEY> | withKind<SmartRollupAddMessagesParams, OpKind.SMART_ROLLUP_ADD_MESSAGES> | withKind<FailingNoopParams, OpKind.FAILING_NOOP> | withKind<SmartRollupOriginateParams, OpKind.SMART_ROLLUP_ORIGINATE> | withKind<SmartRollupExecuteOutboxMessageParams, OpKind.SMART_ROLLUP_EXECUTE_OUTBOX_MESSAGE>;\nexport type ParamsWithKindExtended = ParamsWithKind | withKind<RevealParams, OpKind.REVEAL>;\nexport declare const attachKind: <T, K extends OpKind>(op: T, kind: K) => withKind<T, K>;\nexport declare const findWithKind: <T extends {\n    kind: OpKind;\n}, K extends OpKind>(arr: T[], kind: K) => (T & {\n    kind: K;\n}) | undefined;\nexport declare const isKind: <T extends {\n    kind: OpKind;\n}, K extends OpKind>(op: T, kind: K) => op is withKind<T, K>;\nexport type RPCOpWithFee = RPCTransferOperation | RPCOriginationOperation | RPCDelegateOperation | RPCRevealOperation | RPCRegisterGlobalConstantOperation | RPCIncreasePaidStorageOperation | RPCTransferTicketOperation | RPCUpdateConsensusKeyOperation | RPCUpdateCompanionKeyOperation | RPCSmartRollupAddMessagesOperation | RPCSmartRollupOriginateOperation | RPCSmartRollupOutboxMessageOperation;\nexport type RPCOpWithSource = RPCTransferOperation | RPCOriginationOperation | RPCDelegateOperation | RPCRevealOperation | RPCRegisterGlobalConstantOperation | RPCIncreasePaidStorageOperation | RPCTransferTicketOperation | RPCUpdateConsensusKeyOperation | RPCUpdateCompanionKeyOperation | RPCSmartRollupAddMessagesOperation | RPCSmartRollupOriginateOperation | RPCSmartRollupOutboxMessageOperation;\nexport declare const isOpWithGasBuffer: <T extends {\n    kind: OpKind;\n    destination?: string;\n}>(op: T) => boolean;\nexport declare const isOpWithFee: <T extends {\n    kind: OpKind;\n}>(op: T) => op is withKind<T, Exclude<Exclude<OpKind, OpKind.ACTIVATION>, OpKind.FAILING_NOOP>>;\nexport declare const isOpRequireReveal: <T extends {\n    kind: OpKind;\n}>(op: T) => op is withKind<T, Exclude<InternalOperationResultKindEnum, OpKind.REVEAL>>;\nexport type SourceKinds = InternalOperationResultKindEnum;\nexport declare const isSourceOp: <T extends {\n    kind: OpKind;\n}>(op: T) => op is withKind<T, SourceKinds>;\nexport declare const hasMetadata: <T extends {\n    kind: OpKind;\n}, K>(op: T) => op is T & {\n    metadata: K;\n};\nexport declare const hasMetadataWithResult: <T extends {\n    kind: OpKind;\n}, K>(op: T) => op is T & {\n    metadata: {\n        operation_result: K;\n    };\n};\nexport declare const hasMetadataWithInternalOperationResult: <T extends {\n    kind: OpKind;\n}, K>(op: T) => op is T & {\n    metadata: {\n        internal_operation_results?: K;\n    };\n};\nexport interface GasConsumingOperation {\n    consumedGas?: string;\n    gasLimit: number;\n}\nexport interface StorageConsumingOperation {\n    storageDiff?: string;\n    storageSize?: string;\n    storageLimit: number;\n}\nexport interface FeeConsumingOperation {\n    fee: number;\n}\nexport type OriginateParamsBase = {\n    balance?: string | number;\n    code: string | object[];\n    delegate?: string;\n    fee?: number;\n    gasLimit?: number;\n    storageLimit?: number;\n    mutez?: boolean;\n};\n/**\n * @description Parameters for originate method\n */\nexport type OriginateParams<TStorage = any> = OriginateParamsBase & ({\n    init?: never;\n    /** JS representation of a storage object */\n    storage: TStorage;\n} | {\n    /** Initial storage object value. Either Micheline or JSON encoded */\n    init: string | object;\n    storage?: never;\n});\nexport interface ActivationParams {\n    pkh: string;\n    secret: string;\n}\n/**\n * @description RPC origination operation\n */\nexport interface RPCOriginationOperation {\n    kind: OpKind.ORIGINATION;\n    fee: number;\n    gas_limit: number;\n    storage_limit: number;\n    balance: string;\n    delegate?: string;\n    source?: string;\n    script: {\n        code: any;\n        storage: any;\n    };\n}\n/**\n * @description RPC reveal operation\n */\nexport interface RPCRevealOperation {\n    kind: OpKind.REVEAL;\n    fee: number;\n    public_key: string;\n    source?: string;\n    gas_limit: number;\n    storage_limit: number;\n    proof?: string;\n}\nexport interface RevealParams {\n    fee?: number;\n    gasLimit?: number;\n    storageLimit?: number;\n    proof?: string;\n}\n/**\n * @description Result of a forge operation contains the operation plus its encoded version\n */\nexport interface ForgedBytes {\n    opbytes: string;\n    opOb: OperationObject;\n    counter: number;\n}\n/**\n * @description Parameters for setDelegate method\n */\nexport interface DelegateParams {\n    source: string;\n    delegate?: string;\n    fee?: number;\n    gasLimit?: number;\n    storageLimit?: number;\n}\n/**\n * @description Parameters for registerDelegate method\n */\nexport interface RegisterDelegateParams {\n    fee?: number;\n    gasLimit?: number;\n    storageLimit?: number;\n}\n/**\n * @description RPC delegation operation\n */\nexport interface RPCDelegateOperation {\n    kind: OpKind.DELEGATION;\n    source?: string;\n    fee: number;\n    gas_limit: number;\n    storage_limit: number;\n    delegate?: string;\n}\n/**\n * @description Parameters for transfer method\n */\nexport interface TransferParams {\n    to: string;\n    source?: string;\n    amount: number;\n    fee?: number;\n    parameter?: TransactionOperationParameter;\n    gasLimit?: number;\n    storageLimit?: number;\n    mutez?: boolean;\n}\n/**\n * @description RPC Stake pseudo operation params\n */\nexport interface StakeParams {\n    to?: string;\n    source?: string;\n    amount: number;\n    fee?: number;\n    parameter?: TransactionOperationParameter;\n    gasLimit?: number;\n    storageLimit?: number;\n    mutez?: boolean;\n}\n/**\n * @description RPC unstake pseudo operation params\n */\nexport interface UnstakeParams {\n    to?: string;\n    source?: string;\n    amount: number;\n    fee?: number;\n    parameter?: TransactionOperationParameter;\n    gasLimit?: number;\n    storageLimit?: number;\n    mutez?: boolean;\n}\n/**\n * @description RPC finalize_unstake pseudo operation params\n */\nexport interface FinalizeUnstakeParams {\n    to?: string;\n    source?: string;\n    amount?: number;\n    fee?: number;\n    parameter?: TransactionOperationParameter;\n    gasLimit?: number;\n    storageLimit?: number;\n    mutez?: boolean;\n}\n/**\n * @description RPC register global constant operation\n */\nexport interface RPCRegisterGlobalConstantOperation {\n    kind: OpKind.REGISTER_GLOBAL_CONSTANT;\n    fee: number;\n    gas_limit: number;\n    storage_limit: number;\n    source: string;\n    value: MichelsonV1Expression;\n}\n/**\n * @description Parameters for the `registerGlobalConstant` method\n */\nexport interface RegisterGlobalConstantParams {\n    value: MichelsonV1Expression;\n    source?: string;\n    fee?: number;\n    gasLimit?: number;\n    storageLimit?: number;\n}\n/**\n * @description RPC transfer operation\n */\nexport interface RPCTransferOperation {\n    kind: OpKind.TRANSACTION;\n    fee: number;\n    gas_limit: number;\n    storage_limit: number;\n    amount: string;\n    source?: string;\n    destination: string;\n    parameters?: TransactionOperationParameter;\n}\n/**\n * @description RPC activate account operation\n */\nexport interface RPCActivateOperation {\n    kind: OpKind.ACTIVATION;\n    pkh: string;\n    secret: string;\n}\n/**\n * @description Parameters for the transferTicket contract provider\n */\nexport interface TransferTicketParams {\n    source?: string;\n    fee?: number;\n    gasLimit?: number;\n    storageLimit?: number;\n    ticketContents: MichelsonV1Expression;\n    ticketTy: MichelsonV1Expression;\n    ticketTicketer: string;\n    ticketAmount: number;\n    destination: string;\n    entrypoint: string;\n}\n/**\n * @description Rpc transfer-ticket operation\n */\nexport interface RPCTransferTicketOperation {\n    kind: OpKind.TRANSFER_TICKET;\n    source?: string;\n    fee: number;\n    gas_limit: number;\n    storage_limit: number;\n    ticket_contents: MichelsonV1Expression;\n    ticket_ty: MichelsonV1Expression;\n    ticket_ticketer: string;\n    ticket_amount: number;\n    destination: string;\n    entrypoint: string;\n}\n/**\n * @description Parameters for the increasePaidStorage method\n */\nexport interface IncreasePaidStorageParams {\n    source?: string;\n    fee?: number;\n    gasLimit?: number;\n    storageLimit?: number;\n    amount: number;\n    destination: string;\n}\n/**\n * @description RPC IncreasePaidStorage operation\n */\nexport interface RPCIncreasePaidStorageOperation {\n    kind: OpKind.INCREASE_PAID_STORAGE;\n    source: string;\n    fee: number;\n    gas_limit: number;\n    storage_limit: number;\n    amount: number;\n    destination: string;\n}\n/**\n * @description Parameters for the DrainDelegate method\n */\nexport interface DrainDelegateParams {\n    consensus_key: string;\n    delegate: string;\n    destination: string;\n}\n/**\n * @description RPC DrainDelegate operation\n */\nexport interface RPCDrainDelegateOperation {\n    kind: OpKind.DRAIN_DELEGATE;\n    consensus_key: string;\n    delegate: string;\n    destination: string;\n}\n/**\n * @description Ballot operation params\n */\nexport interface BallotParams {\n    source?: string;\n    proposal: string;\n    ballot: BallotVote;\n}\nexport interface RPCBallotOperation {\n    kind: OpKind.BALLOT;\n    source: string;\n    period: number;\n    proposal: string;\n    ballot: BallotVote;\n}\nexport interface ProposalsParams {\n    source?: string;\n    proposals: string[];\n}\nexport interface RPCProposalsOperation {\n    kind: OpKind.PROPOSALS;\n    source: string;\n    period: number;\n    proposals: string[];\n}\nexport interface UpdateConsensusKeyParams {\n    source?: string;\n    fee?: number;\n    gasLimit?: number;\n    storageLimit?: number;\n    pk: string;\n    proof?: string;\n}\nexport interface RPCUpdateConsensusKeyOperation {\n    kind: OpKind.UPDATE_CONSENSUS_KEY;\n    source: string;\n    fee: number;\n    gas_limit: number;\n    storage_limit: number;\n    pk: string;\n    proof?: string;\n}\nexport interface UpdateCompanionKeyParams {\n    source?: string;\n    fee?: number;\n    gasLimit?: number;\n    storageLimit?: number;\n    pk: string;\n    proof?: string;\n}\nexport interface RPCUpdateCompanionKeyOperation {\n    kind: OpKind.UPDATE_COMPANION_KEY;\n    source: string;\n    fee: number;\n    gas_limit: number;\n    storage_limit: number;\n    pk: string;\n    proof?: string;\n}\nexport interface SmartRollupAddMessagesParams {\n    source?: string;\n    fee?: number;\n    gasLimit?: number;\n    storageLimit?: number;\n    message: string[];\n}\nexport interface RPCSmartRollupAddMessagesOperation {\n    kind: OpKind.SMART_ROLLUP_ADD_MESSAGES;\n    source: string;\n    fee: number;\n    gas_limit: number;\n    storage_limit: number;\n    message: string[];\n}\nexport interface SmartRollupOriginateParams {\n    source?: string;\n    fee?: number;\n    gasLimit?: number;\n    storageLimit?: number;\n    pvmKind: PvmKind;\n    kernel: string;\n    parametersType: MichelsonV1Expression;\n}\nexport interface RPCSmartRollupOriginateOperation {\n    kind: OpKind.SMART_ROLLUP_ORIGINATE;\n    source: string;\n    fee: number;\n    gas_limit: number;\n    storage_limit: number;\n    pvm_kind: PvmKind;\n    kernel: string;\n    parameters_ty: MichelsonV1Expression;\n}\nexport interface SmartRollupExecuteOutboxMessageParams {\n    source?: string;\n    fee?: number;\n    gasLimit?: number;\n    storageLimit?: number;\n    rollup: string;\n    cementedCommitment: string;\n    outputProof: string;\n}\nexport interface RPCSmartRollupOutboxMessageOperation {\n    kind: OpKind.SMART_ROLLUP_EXECUTE_OUTBOX_MESSAGE;\n    source: string;\n    fee: number;\n    gas_limit: number;\n    storage_limit: number;\n    rollup: string;\n    cemented_commitment: string;\n    output_proof: string;\n}\n/**\n * @description RPC failing noop operation\n */\nexport interface RPCFailingNoopOperation {\n    kind: OpKind.FAILING_NOOP;\n    arbitrary: string;\n}\n/**\n * @description Parameters for the `failingNoop` method\n */\nexport interface FailingNoopParams {\n    arbitrary: string;\n    basedOnBlock: BlockIdentifier;\n}\nexport type RPCOperation = RPCOriginationOperation | RPCTransferOperation | RPCDelegateOperation | RPCRevealOperation | RPCActivateOperation | RPCRegisterGlobalConstantOperation | RPCTransferTicketOperation | RPCIncreasePaidStorageOperation | RPCDrainDelegateOperation | RPCBallotOperation | RPCProposalsOperation | RPCUpdateConsensusKeyOperation | RPCUpdateCompanionKeyOperation | RPCSmartRollupAddMessagesOperation | RPCSmartRollupOriginateOperation | RPCSmartRollupOutboxMessageOperation | RPCFailingNoopOperation;\nexport type PrepareOperationParams = {\n    operation: RPCOperation | RPCOperation[];\n    source?: string;\n};\n"},{name:"@taquito/operations/update-companion-key-operation.d.ts",dts:"import { OperationContentsAndResult, OperationContentsUpdateCompanionKey } from '@taquito/rpc';\nimport { Context } from '../context';\nimport { Operation } from './operations';\nimport { FeeConsumingOperation, ForgedBytes, GasConsumingOperation, StorageConsumingOperation } from './types';\n/**\n *\n * @description UpdateCompanionKeyOperation provides utility to fetch properties for Operation of kind UpdateCompanionKey\n *\n */\nexport declare class UpdateCompanionKeyOperation extends Operation implements GasConsumingOperation, StorageConsumingOperation, FeeConsumingOperation {\n    private readonly params;\n    readonly source: string;\n    constructor(hash: string, params: OperationContentsUpdateCompanionKey, source: string, raw: ForgedBytes, results: OperationContentsAndResult[], context: Context);\n    get operationResults(): import(\"@taquito/rpc\").OperationResultUpdateConsensusKey | undefined;\n    get status(): import(\"@taquito/rpc\").OperationResultStatusEnum | \"unknown\";\n    get fee(): number;\n    get gasLimit(): number;\n    get storageLimit(): number;\n    get pk(): string;\n    get proof(): string;\n    get consumedMilliGas(): string | undefined;\n    get errors(): import(\"@taquito/rpc\").TezosGenericOperationError[] | undefined;\n}\n"},{name:"@taquito/operations/update-consensus-key-operation.d.ts",dts:"import { OperationContentsAndResult, OperationContentsUpdateConsensusKey } from '@taquito/rpc';\nimport { Context } from '../context';\nimport { Operation } from './operations';\nimport { FeeConsumingOperation, ForgedBytes, GasConsumingOperation, StorageConsumingOperation } from './types';\n/**\n *\n * @description UpdateConsensusKeyOperation provides utility to fetch properties for Operation of kind UpdateConsensusKey\n *\n */\nexport declare class UpdateConsensusKeyOperation extends Operation implements GasConsumingOperation, StorageConsumingOperation, FeeConsumingOperation {\n    private readonly params;\n    readonly source: string;\n    constructor(hash: string, params: OperationContentsUpdateConsensusKey, source: string, raw: ForgedBytes, results: OperationContentsAndResult[], context: Context);\n    get operationResults(): import(\"@taquito/rpc\").OperationResultUpdateConsensusKey | undefined;\n    get status(): import(\"@taquito/rpc\").OperationResultStatusEnum | \"unknown\";\n    get fee(): number;\n    get gasLimit(): number;\n    get storageLimit(): number;\n    get pk(): string;\n    get proof(): string;\n    get consumedMilliGas(): string | undefined;\n    get errors(): import(\"@taquito/rpc\").TezosGenericOperationError[] | undefined;\n}\n"},{name:"@taquito/packer/interface.d.ts",dts:"import { PackDataParams, PackDataResponse } from '@taquito/rpc';\nexport interface Packer {\n    packData(data: PackDataParams): Promise<PackDataResponse>;\n}\n"},{name:"@taquito/packer/michel-codec-packer.d.ts",dts:"import { Packer } from './interface';\nimport { PackDataResponse, PackDataParams } from '@taquito/rpc';\nexport declare class MichelCodecPacker implements Packer {\n    packData(data: PackDataParams): Promise<PackDataResponse>;\n}\n"},{name:"@taquito/packer/rpc-packer.d.ts",dts:"import { Packer } from './interface';\nimport { Context } from '../context';\nimport { PackDataParams, PackDataResponse } from '@taquito/rpc';\nexport declare class RpcPacker implements Packer {\n    private context;\n    constructor(context: Context);\n    packData(data: PackDataParams): Promise<PackDataResponse>;\n}\n"},{name:"@taquito/parser/interface.d.ts",dts:"import { OriginateParams } from '../operations/types';\nexport interface ParserProvider {\n    prepareCodeOrigination(params: OriginateParams): Promise<OriginateParams>;\n}\n"},{name:"@taquito/parser/michel-codec-parser.d.ts",dts:"import { Context } from '../context';\nimport { ParserProvider } from './interface';\nimport { Expr } from '@taquito/michel-codec';\nimport { OriginateParams } from '../operations/types';\nexport declare class MichelCodecParser implements ParserProvider {\n    private context;\n    constructor(context: Context);\n    private getNextProto;\n    parseScript(src: string): Promise<Expr[] | null>;\n    parseMichelineExpression(src: string): Promise<Expr | null>;\n    parseJSON(src: object): Promise<Expr>;\n    prepareCodeOrigination(params: OriginateParams): Promise<OriginateParams>;\n    private formatCodeParam;\n    private formatInitParam;\n    private findGlobalConstantsHashAndValue;\n}\n"},{name:"@taquito/parser/noop-parser.d.ts",dts:'import { OriginateParams } from "../operations/types";\nimport { ParserProvider } from "./interface";\nexport declare class NoopParser implements ParserProvider {\n    prepareCodeOrigination(params: OriginateParams): Promise<OriginateParams>;\n}\n'},{name:"@taquito/prepare/index.d.ts",dts:"export * from './interface';\nexport * from './prepare-provider';\n"},{name:"@taquito/prepare/interface.d.ts",dts:"import { OperationContents, PreapplyParams } from '@taquito/rpc';\nimport { BallotParams, DelegateParams, DrainDelegateParams, IncreasePaidStorageParams, OriginateParams, ProposalsParams, RegisterGlobalConstantParams, RevealParams, TransferParams, TransferTicketParams, UpdateConsensusKeyParams, UpdateCompanionKeyParams, ActivationParams, SmartRollupAddMessagesParams, SmartRollupOriginateParams } from '../operations/types';\nimport { ContractMethod } from '../contract/contract-methods/contract-method-flat-param';\nimport { ContractMethodObject } from '../contract/contract-methods/contract-method-object-param';\nimport { ContractProvider } from '../contract/interface';\nimport { ParamsWithKind } from '../operations/types';\nimport { ForgeParams } from '@taquito/local-forging';\n/**\n * @description PrepareProvider is a utility class to output the prepared format of an operation\n */\nexport interface PreparationProvider {\n    /**\n     * @description Method to prepare an activation operation\n     * @param operation RPCOperation object or RPCOperation array\n     * @param source string or undefined source pkh\n     * @returns a PreparedOperation object\n     */\n    activate(params: ActivationParams): Promise<PreparedOperation>;\n    /**\n     *\n     * @description Method to prepare a reveal operation\n     * @param params reveal operation parameters\n     * @param source string or undefined source pkh\n     * @returns a PreparedOperation object\n     */\n    reveal(params: RevealParams): Promise<PreparedOperation>;\n    /**\n     * @description Method to prepare an origination operation\n     * @param params originate operation parameters\n     * @param source string or undefined source pkh\n     * @returns a PreparedOperation object\n     */\n    originate(params: OriginateParams): Promise<PreparedOperation>;\n    /**\n     *\n     * @description Method to prepare a transaction operation\n     *\n     * @param params transaction operation parameters\n     * @param source string or undefined source pkh\n     *\n     * @returns a PreparedOperation object\n     */\n    transaction(params: TransferParams): Promise<PreparedOperation>;\n    /**\n     *\n     * @description Method to prepare a delegation operation\n     * @param params delegation operation parameters\n     * @param source string or undefined source pkh\n     * @returns a PreparedOperation object\n     */\n    delegation(params: DelegateParams): Promise<PreparedOperation>;\n    /**\n     * @description Method to prepare a register_global_constant operation\n     * @param params registerGlobalConstant operation parameters\n     * @param source string or undefined source pkh\n     * @returns a PreparedOperation object\n     */\n    registerGlobalConstant(params: RegisterGlobalConstantParams): Promise<PreparedOperation>;\n    /**\n     * @description Method to prepare an update_consensus_key operation\n     * @param params updateConsensusKey operation parameters\n     * @param source string or undefined source pkh\n     * @returns a PreparedOperation object\n     */\n    updateConsensusKey(params: UpdateConsensusKeyParams): Promise<PreparedOperation>;\n    /**\n     * @description Method to prepare an update_companion_key operation\n     * @param params updateCompanionKey operation parameters\n     * @param source string or undefined source pkh\n     * @returns a PreparedOperation object\n     */\n    updateCompanionKey(params: UpdateCompanionKeyParams): Promise<PreparedOperation>;\n    /**\n     *\n     * @description Method to prepare a transfer_ticket operation\n     * @param params TransferTicketx operation parameters\n     * @param source string or undefined source pkh\n     * @returns a PreparedOperation object\n     */\n    transferTicket(params: TransferTicketParams): Promise<PreparedOperation>;\n    /**\n     * @description Method to prepare an increase_paid_storage operation\n     * @param params increasePaidStorage operation parameters\n     * @param source string or undefined source pkh\n     * @returns a PreparedOperation object\n     */\n    increasePaidStorage(params: IncreasePaidStorageParams): Promise<PreparedOperation>;\n    /**\n     * @description Method to prepare a ballot operation\n     * @param params ballot operation parameters\n     * @returns a PreparedOperation object\n     */\n    ballot(params: BallotParams): Promise<PreparedOperation>;\n    /**\n     *\n     * @description Method to prepare a proposals operation\n     * @param params proposals operation parameters\n     * @returns a PreparedOperation object\n     */\n    proposals(params: ProposalsParams): Promise<PreparedOperation>;\n    /**\n     * @description Method to prepare a drain_delegate operation\n     * @param params drainDelegate operation parameters\n     * @returns a PreparedOperation object\n     */\n    drainDelegate(params: DrainDelegateParams): Promise<PreparedOperation>;\n    /**\n     * @description Method to prepare a smart_rollup_add_messages operation\n     * @param params smartRollupAddMessages operation parameters\n     * @returns a PreparedOperation object\n     */\n    smartRollupAddMessages(params: SmartRollupAddMessagesParams): Promise<PreparedOperation>;\n    /**\n     * @description Method to prepare a smart_rollup_originate operation\n     * @param params smartRollupOriginate operation parameters\n     * @returns a PreparedOperation object\n     */\n    smartRollupOriginate(params: SmartRollupOriginateParams): Promise<PreparedOperation>;\n    /**\n     *\n     * @description Method to prepare a batch operation\n     * @param params x operation parameters\n     * @returns a PreparedOperation object\n     */\n    batch(batchParams: ParamsWithKind[]): Promise<PreparedOperation>;\n    /**\n     * @description Method to prepare a contract call (transfer) operation\n     * @param contractMethod ContractMethod or ContractMethodObject retrieved from smart contract\n     * @returns a PreparedOperation object\n     */\n    contractCall(contractMethod: ContractMethod<ContractProvider> | ContractMethodObject<ContractProvider>): Promise<PreparedOperation>;\n    /**\n     *\n     * @description Method to convert a PreparedOperation to the params needed for the preapplyOperation method\n     * @param prepared a Prepared Operation\n     * @returns a PreapplyParams object\n     */\n    toPreapply(prepared: PreparedOperation): Promise<PreapplyParams>;\n    /**\n     *\n     * @description Method to convert a PreparedOperation to the params needed for forging\n     * @param param a Prepared Operation\n     * @returns a ForgeParams object\n     */\n    toForge(param: PreparedOperation): ForgeParams;\n}\nexport interface PreparedOperation {\n    opOb: {\n        branch: string;\n        contents: OperationContents[];\n        protocol: string;\n    };\n    counter: number;\n}\n"},{name:"@taquito/prepare/prepare-provider.d.ts",dts:"import { PreapplyParams } from '@taquito/rpc';\nimport { DelegateParams, RevealParams, RegisterGlobalConstantParams, TransferParams, OriginateParams, UpdateConsensusKeyParams, UpdateCompanionKeyParams, TransferTicketParams, IncreasePaidStorageParams, BallotParams, ProposalsParams, DrainDelegateParams, ParamsWithKind, SmartRollupAddMessagesParams, SmartRollupOriginateParams, SmartRollupExecuteOutboxMessageParams, RegisterDelegateParams, ActivationParams, StakeParams, UnstakeParams, FinalizeUnstakeParams } from '../operations/types';\nimport { PreparationProvider, PreparedOperation } from './interface';\nimport { Context } from '../context';\nimport { ContractMethod } from '../contract/contract-methods/contract-method-flat-param';\nimport { ContractMethodObject } from '../contract/contract-methods/contract-method-object-param';\nimport { ContractProvider } from '../contract/interface';\nimport { DefaultContractType, ContractStorageType } from '../contract';\nimport { Estimate } from '../estimate';\nimport { ForgeParams } from '@taquito/local-forging';\nimport { Provider } from '../provider';\n/**\n * @description PrepareProvider is a utility class to output the prepared format of an operation\n */\nexport declare class PrepareProvider extends Provider implements PreparationProvider {\n    #private;\n    protected context: Context;\n    constructor(context: Context);\n    private getBlockHash;\n    private getProtocolHash;\n    private getHeadCounter;\n    private adjustGasForBatchOperation;\n    private getOperationLimits;\n    private getFee;\n    private getSource;\n    private addRevealOperationIfNeeded;\n    private getKeys;\n    private convertIntoArray;\n    private constructOpContents;\n    /**\n     *\n     * @description Method to prepare an activation operation\n     * @param operation RPCOperation object or RPCOperation array\n     * @param source string or undefined source pkh\n     * @returns a PreparedOperation object\n     */\n    activate({ pkh, secret }: ActivationParams): Promise<PreparedOperation>;\n    /**\n     *\n     * @description Method to prepare a reveal operation\n     * @param operation RPCOperation object or RPCOperation array\n     * @param source string or undefined source pkh\n     * @returns a PreparedOperation object\n     */\n    reveal({ fee, gasLimit, storageLimit, proof }: RevealParams): Promise<PreparedOperation>;\n    /**\n     *\n     * @description Method to prepare an origination operation\n     * @param operation RPCOperation object or RPCOperation array\n     * @param source string or undefined source pkh\n     * @returns a PreparedOperation object\n     */\n    originate<TContract extends DefaultContractType = DefaultContractType>({ fee, storageLimit, gasLimit, ...rest }: OriginateParams<ContractStorageType<TContract>>, source?: string): Promise<PreparedOperation>;\n    /**\n     *\n     * @description Method to prepare a transaction operation\n     * @param operation RPCOperation object or RPCOperation array\n     * @param source string or undefined source pkh\n     * @returns a PreparedOperation object\n     */\n    transaction({ fee, storageLimit, gasLimit, ...rest }: TransferParams): Promise<PreparedOperation>;\n    /**\n     *\n     * @description Method to prepare a stake pseudo-operation\n     * @param operation RPCOperation object or RPCOperation array\n     * @param source string or undefined source pkh\n     * @returns a PreparedOperation object\n     */\n    stake({ fee, storageLimit, gasLimit, ...rest }: StakeParams): Promise<PreparedOperation>;\n    /**\n     *\n     * @description Method to prepare a unstake pseudo-operation\n     * @param operation RPCOperation object or RPCOperation array\n     * @param source string or undefined source pkh\n     * @returns a PreparedOperation object\n     */\n    unstake({ fee, storageLimit, gasLimit, ...rest }: UnstakeParams): Promise<PreparedOperation>;\n    /**\n     *\n     * @description Method to prepare a finalize_unstake pseudo-operation\n     * @param operation RPCOperation object or RPCOperation array\n     * @param source string or undefined source pkh\n     * @returns a PreparedOperation object\n     */\n    finalizeUnstake({ fee, storageLimit, gasLimit, to, ...rest }: FinalizeUnstakeParams): Promise<PreparedOperation>;\n    /**\n     *\n     * @description Method to prepare a delegation operation\n     * @param operation RPCOperation object or RPCOperation array\n     * @param source string or undefined source pkh\n     * @returns a PreparedOperation object\n     */\n    delegation({ fee, storageLimit, gasLimit, ...rest }: DelegateParams): Promise<PreparedOperation>;\n    /**\n     *\n     * @description Method to prepare a register delegate operation\n     * @param operation RPCOperation object or RPCOperation array\n     * @param source string or undefined source pkh\n     * @returns a PreparedOperation object\n     */\n    registerDelegate({ fee, storageLimit, gasLimit }: RegisterDelegateParams, source?: string): Promise<PreparedOperation>;\n    /**\n     *\n     * @description Method to prepare a register_global_constant operation\n     * @param operation RPCOperation object or RPCOperation array\n     * @param source string or undefined source pkh\n     * @returns a PreparedOperation object\n     */\n    registerGlobalConstant({ fee, storageLimit, gasLimit, ...rest }: RegisterGlobalConstantParams): Promise<PreparedOperation>;\n    /**\n     *\n     * @description Method to prepare an update_consensus_key operation\n     * @param operation RPCOperation object or RPCOperation array\n     * @param source string or undefined source pkh\n     * @returns a PreparedOperation object\n     */\n    updateConsensusKey({ fee, storageLimit, gasLimit, ...rest }: UpdateConsensusKeyParams, source?: string): Promise<PreparedOperation>;\n    /**\n     *\n     * @description Method to prepare an update_companion_key operation\n     * @param operation RPCOperation object or RPCOperation array\n     * @param source string or undefined source pkh\n     * @returns a PreparedOperation object\n     */\n    updateCompanionKey({ fee, storageLimit, gasLimit, ...rest }: UpdateCompanionKeyParams, source?: string): Promise<PreparedOperation>;\n    /**\n     *\n     * @description Method to prepare an increase_paid_storage operation\n     * @param operation RPCOperation object or RPCOperation array\n     * @param source string or undefined source pkh\n     * @returns a PreparedOperation object\n     */\n    increasePaidStorage({ fee, storageLimit, gasLimit, ...rest }: IncreasePaidStorageParams): Promise<PreparedOperation>;\n    /**\n     *\n     * @description Method to prepare a ballot operation\n     * @param operation RPCOperation object or RPCOperation array\n     * @returns a PreparedOperation object\n     */\n    ballot(params: BallotParams): Promise<PreparedOperation>;\n    /**\n     *\n     * @description Method to prepare a proposals operation\n     * @param operation RPCOperation object or RPCOperation array\n     * @returns a PreparedOperation object\n     */\n    proposals(params: ProposalsParams): Promise<PreparedOperation>;\n    /**\n     *\n     * @description Method to prepare a drain_delegate operation\n     * @param operation RPCOperation object or RPCOperation array\n     * @returns a PreparedOperation object\n     */\n    drainDelegate(params: DrainDelegateParams, source?: string): Promise<PreparedOperation>;\n    /**\n     *\n     * @description Method to prepare a transfer_ticket operation\n     * @param operation RPCOperation object or RPCOperation array\n     * @param source string or undefined source pkh\n     * @returns a PreparedOperation object\n     */\n    transferTicket({ fee, storageLimit, gasLimit, ...rest }: TransferTicketParams): Promise<PreparedOperation>;\n    /**\n     *\n     * @description Method to prepare a smart_rollup_add_messages operation\n     * @param operation RPCOperation object or RPCOperation array\n     * @param source string or undefined source pkh\n     * @returns a PreparedOperation object\n     */\n    smartRollupAddMessages({ fee, storageLimit, gasLimit, ...rest }: SmartRollupAddMessagesParams): Promise<PreparedOperation>;\n    /**\n     *\n     * @description Method to prepare a smart_rollup_originate operation\n     * @param operation RPCOperation object or RPCOperation array\n     * @returns a PreparedOperation object\n     */\n    smartRollupOriginate({ fee, storageLimit, gasLimit, ...rest }: SmartRollupOriginateParams): Promise<PreparedOperation>;\n    /**\n     *\n     * @description Method to prepare a smart_rollup_execute_outbox_message operation\n     * @param operation RPCOperation object or RPCOperation array\n     * @param source string or undefined source pkh\n     * @returns a PreparedOperation object\n     */\n    smartRollupExecuteOutboxMessage({ fee, storageLimit, gasLimit, ...rest }: SmartRollupExecuteOutboxMessageParams): Promise<PreparedOperation>;\n    /**\n     *\n     * @description Method to prepare a batch operation\n     * @param operation RPCOperation object or RPCOperation array\n     * @returns a PreparedOperation object\n     */\n    batch(batchParams: ParamsWithKind[], estimates?: Estimate[]): Promise<PreparedOperation>;\n    /**\n     *\n     * @description Method to prepare a batch operation\n     * @param operation RPCOperation object or RPCOperation array\n     * @returns a PreparedOperation object\n     */\n    contractCall(contractMethod: ContractMethod<ContractProvider> | ContractMethodObject<ContractProvider>): Promise<PreparedOperation>;\n    /**\n     *\n     * @description Method to convert a PreparedOperation to the params needed for the preapplyOperation method\n     * @param prepared a Prepared Operation\n     * @returns a PreapplyParams object\n     */\n    toPreapply(prepared: PreparedOperation): Promise<PreapplyParams>;\n    /**\n     *\n     * @description Method to convert a PreparedOperation to the params needed for forging\n     * @param param a Prepared Operation\n     * @returns a ForgeParams object\n     */\n    toForge({ opOb: { contents, branch } }: PreparedOperation): ForgeParams;\n}\n"},{name:"@taquito/read-provider/interface.d.ts",dts:"import { BlockResponse, EntrypointsResponse, MichelsonV1Expression, SaplingDiffResponse, ScriptedContracts, AILaunchCycleResponse } from '@taquito/rpc';\nimport BigNumber from 'bignumber.js';\nexport type BigMapQuery = {\n    id: string;\n    expr: string;\n};\nexport type SaplingStateQuery = {\n    id: string;\n};\nexport type BlockIdentifier = 'head' | `head~${number}` | `B${string}` | number;\nexport interface TzReadProvider {\n    /**\n     * @description The spendable balance of a contract (in mutez), also known as liquid balance. Corresponds to tez owned by the contract that are neither staked, nor in unstaked requests, nor in frozen bonds. Identical to the 'spendable' RPC.\n     * @param address address from which we want to retrieve the spendable balance\n     * @param block from which we want to retrieve the balance\n     * @returns the balance in mutez\n     */\n    getBalance(address: string, block: BlockIdentifier): Promise<BigNumber>;\n    /**\n     * @description The spendable balance of a contract (in mutez), also known as liquid balance. Corresponds to tez owned by the contract that are neither staked, nor in unstaked requests, nor in frozen bonds. Identical to the 'balance' RPC.\n     * @param address address from which we want to retrieve the spendable balance\n     * @param block from which we want to retrieve the balance\n     * @returns the balance in mutez\n     */\n    getSpendable(address: string, block: BlockIdentifier): Promise<BigNumber>;\n    /**\n     * @description Access the delegate of a contract, if any.\n     * @param address contract address from which we want to retrieve the delegate (baker)\n     * @param block from which we want to retrieve the delegate\n     * @returns the public key hash of the delegate or null if no delegate\n     */\n    getDelegate(address: string, block: BlockIdentifier): Promise<string | null>;\n    /**\n     * @description Access the next protocol hash\n     * @param block from which we want to retrieve the next protocol hash\n     */\n    getNextProtocol(block: BlockIdentifier): Promise<string>;\n    /**\n     * @description Access protocol constants used in Taquito\n     * @param block from which we want to retrieve the constants\n     */\n    getProtocolConstants(block: BlockIdentifier): Promise<{\n        time_between_blocks?: BigNumber[];\n        minimal_block_delay?: BigNumber;\n        hard_gas_limit_per_operation: BigNumber;\n        hard_gas_limit_per_block: BigNumber;\n        hard_storage_limit_per_operation: BigNumber;\n        cost_per_byte: BigNumber;\n        smart_rollup_origination_size: number;\n    }>;\n    /**\n     * @description Access the script (code and storage) of a smart contract\n     * @param contract contract address from which we want to retrieve the script\n     * @param block from which we want to retrieve the storage value\n     * @returns Note: The code must be in the JSON format and not contain global constant\n     */\n    getScript(contract: string, block: BlockIdentifier): Promise<ScriptedContracts>;\n    /**\n     * @description Access the storage of a contract\n     * @param contract contract address from which we want to retrieve the storage\n     * @param block from which we want to retrieve the storage value\n     */\n    getStorage(contract: string, block: BlockIdentifier): Promise<MichelsonV1Expression>;\n    /**\n     * @description Access the block hash\n     */\n    getBlockHash(block: BlockIdentifier): Promise<string>;\n    /**\n     * @description Access the block level\n     */\n    getBlockLevel(block: BlockIdentifier): Promise<number>;\n    /**\n     * @description Access the counter of an address\n     * @param pkh from which we want to retrieve the counter\n     * @param block from which we want to retrieve the counter\n     */\n    getCounter(pkh: string, block: BlockIdentifier): Promise<string>;\n    /**\n     * @description Access the timestamp of a block\n     * @param block from which we want to retrieve the timestamp\n     * @returns date ISO format zero UTC offset (\"2022-01-19T22:37:07Z\")\n     */\n    getBlockTimestamp(block: BlockIdentifier): Promise<string>;\n    /**\n     * @description Access the value associated with a key in a big map.\n     * @param bigMapQuery Big Map ID and Expression hash to query (A b58check encoded Blake2b hash of the expression)\n     * @param block from which we want to retrieve the big map value\n     */\n    getBigMapValue(bigMapQuery: BigMapQuery, block: BlockIdentifier): Promise<MichelsonV1Expression>;\n    /**\n     * @description Access the value associated with a sapling state ID.\n     * @param id Sapling state ID\n     * @param block from which we want to retrieve the sapling state\n     */\n    getSaplingDiffById(saplingStateQuery: SaplingStateQuery, block: BlockIdentifier): Promise<SaplingDiffResponse>;\n    /**\n     * @description Access the sapling state of a smart contract.\n     * @param contractAddress The address of the smart contract\n     * @param block The block you want to retrieve the sapling state from\n     */\n    getSaplingDiffByContract(contractAddress: string, block: BlockIdentifier): Promise<SaplingDiffResponse>;\n    /**\n     * @description Return the list of entrypoints of the contract\n     * @param contract address of the contract we want to get the entrypoints of\n     */\n    getEntrypoints(contract: string): Promise<EntrypointsResponse>;\n    /**\n     * @description Access the chain id\n     */\n    getChainId(): Promise<string>;\n    /**\n     * @description Indicate if an account is revealed\n     * @param publicKeyHash of the account\n     * @param block from which we want to know if the account is revealed\n     */\n    isAccountRevealed(publicKeyHash: string, block: BlockIdentifier): Promise<boolean>;\n    /**\n     * @description Return all the information about a block\n     * @param block from which we want to retrieve the information\n     */\n    getBlock(block: BlockIdentifier): Promise<BlockResponse>;\n    /**\n     * @description Return a list of the ancestors of the given block which, if referred to as the branch in an operation header, are recent enough for that operation to be included in the current block.\n     * @param block from which we want to retrieve the information\n     */\n    getLiveBlocks(block: BlockIdentifier): Promise<string[]>;\n    /**\n     * @description Returns the cycle at which the launch of the Adaptive Issuance feature is set to happen. A result of null means that the feature is not yet set to launch.\n     * @param block from which we want to retrieve the information\n     */\n    getAdaptiveIssuanceLaunchCycle(block: BlockIdentifier): Promise<AILaunchCycleResponse>;\n}\n"},{name:"@taquito/read-provider/rpc-read-adapter.d.ts",dts:"import { BlockResponse, EntrypointsResponse, MichelsonV1Expression, RpcClientInterface, SaplingDiffResponse, ScriptedContracts, AILaunchCycleResponse } from '@taquito/rpc';\nimport BigNumber from 'bignumber.js';\nimport { BigMapQuery, BlockIdentifier, SaplingStateQuery, TzReadProvider } from './interface';\n/**\n * @description Converts calls from TzReadProvider into calls to the wrapped RpcClient in a format it can understand.\n */\nexport declare class RpcReadAdapter implements TzReadProvider {\n    private rpc;\n    constructor(rpc: RpcClientInterface);\n    /**\n     * @description The spendable balance of a contract (in mutez), also known as liquid balance. Corresponds to tez owned by the contract that are neither staked, nor in unstaked requests, nor in frozen bonds. Identical to the 'spendable' RPC.\n     * @param address address from which we want to retrieve the spendable balance\n     * @param block from which we want to retrieve the balance\n     * @returns the balance in mutez\n     */\n    getBalance(address: string, block: BlockIdentifier): Promise<BigNumber>;\n    /**\n     * @description The spendable balance of a contract (in mutez), also known as liquid balance. Corresponds to tez owned by the contract that are neither staked, nor in unstaked requests, nor in frozen bonds. Identical to the 'balance' RPC.\n     * @param address address from which we want to retrieve the spendable balance\n     * @param block from which we want to retrieve the balance\n     * @returns the balance in mutez\n     */\n    getSpendable(address: string, block: BlockIdentifier): Promise<BigNumber>;\n    /**\n     * @description Access the delegate of a contract, if any.\n     * @param address contract address from which we want to retrieve the delegate (baker)\n     * @param block from which we want to retrieve the delegate\n     * @returns the public key hash of the delegate or null if no delegate\n     */\n    getDelegate(address: string, block: BlockIdentifier): Promise<string | null>;\n    /**\n     * @description Access the next protocol hash\n     * @param block from which we want to retrieve the next protocol hash\n     */\n    getNextProtocol(block: BlockIdentifier): Promise<string>;\n    /**\n     * @description Access protocol constants used in Taquito\n     * @param block from which we want to retrieve the constants\n     */\n    getProtocolConstants(block: BlockIdentifier): Promise<{\n        time_between_blocks?: BigNumber[];\n        minimal_block_delay?: BigNumber | undefined;\n        hard_gas_limit_per_operation: BigNumber;\n        hard_gas_limit_per_block: BigNumber;\n        hard_storage_limit_per_operation: BigNumber;\n        cost_per_byte: BigNumber;\n        smart_rollup_origination_size: number;\n    }>;\n    /**\n     * @description Access the script (code and storage) of a smart contract\n     * @param contract contract address from which we want to retrieve the script\n     * @param block from which we want to retrieve the storage value\n     * @returns Note: The code must be in the JSON format and not contain global constant\n     */\n    getScript(contract: string, block: BlockIdentifier): Promise<ScriptedContracts>;\n    /**\n     * @description Access the storage value of a contract\n     * @param contract contract address from which we want to retrieve the storage\n     * @param block from which we want to retrieve the storage value\n     */\n    getStorage(contract: string, block: BlockIdentifier): Promise<MichelsonV1Expression>;\n    /**\n     * @description Access the block hash\n     */\n    getBlockHash(block: BlockIdentifier): Promise<string>;\n    /**\n     * @description Access the block level\n     */\n    getBlockLevel(block: BlockIdentifier): Promise<number>;\n    /**\n     * @description Access the counter of an address\n     * @param pkh from which we want to retrieve the counter\n     * @param block from which we want to retrieve the counter\n     */\n    getCounter(pkh: string, block: BlockIdentifier): Promise<string>;\n    /**\n     * @description Access the timestamp of a block\n     * @param block from which we want to retrieve the timestamp\n     * @returns date ISO format zero UTC offset (\"2022-01-19T22:37:07Z\")\n     */\n    getBlockTimestamp(block: BlockIdentifier): Promise<string>;\n    /**\n     * @description Access the value associated with a key in a big map.\n     * @param bigMapQuery Big Map ID and Expression hash to query (A b58check encoded Blake2b hash of the expression)\n     * @param block from which we want to retrieve the big map value\n     */\n    getBigMapValue(bigMapQuery: BigMapQuery, block: BlockIdentifier): Promise<MichelsonV1Expression>;\n    /**\n     * @description Access the value associated with a sapling state ID.\n     * @param id Sapling state ID\n     * @param block from which we want to retrieve the sapling state\n     */\n    getSaplingDiffById(saplingStateQuery: SaplingStateQuery, block: BlockIdentifier): Promise<SaplingDiffResponse>;\n    /**\n     * @description Access the sapling state of a smart contract.\n     * @param contractAddress The address of the smart contract\n     * @param block The block you want to retrieve the sapling state from\n     */\n    getSaplingDiffByContract(contractAddress: string, block: BlockIdentifier): Promise<SaplingDiffResponse>;\n    /**\n     * @description Return the list of entrypoints of the contract\n     * @param contract address of the contract we want to get the entrypoints of\n     */\n    getEntrypoints(contract: string): Promise<EntrypointsResponse>;\n    /**\n     * @description Access the chain id\n     */\n    getChainId(): Promise<string>;\n    /**\n     * @description Indicate if an account is revealed\n     * @param publicKeyHash of the account\n     * @param block from which we want to know if the account is revealed\n     */\n    isAccountRevealed(publicKeyHash: string, block: BlockIdentifier): Promise<boolean>;\n    /**\n     * @description Return all the information about a block\n     * @param block from which we want to retrieve the information\n     */\n    getBlock(block: BlockIdentifier): Promise<BlockResponse>;\n    /**\n     * @description Return a list of the ancestors of the given block which, if referred to as the branch in an operation header, are recent enough for that operation to be included in the current block.\n     * @param block from which we want to retrieve the information\n     */\n    getLiveBlocks(block: BlockIdentifier): Promise<string[]>;\n    /**\n     * @description Returns the cycle at which the launch of the Adaptive Issuance feature is set to happen. A result of null means that the feature is not yet set to launch.\n     * @param block from which we want to retrieve the information\n     */\n    getAdaptiveIssuanceLaunchCycle(block: BlockIdentifier): Promise<AILaunchCycleResponse>;\n}\n"},{name:"@taquito/signer/errors.d.ts",dts:"import { TezosToolkitConfigError } from '@taquito/core';\n/**\n *  @category Error\n *  @description Error that indicates no signer has been configured in the TezosToolkit instance\n */\nexport declare class UnconfiguredSignerError extends TezosToolkitConfigError {\n    constructor();\n}\n"},{name:"@taquito/signer/noop.d.ts",dts:"import { Signer } from '@taquito/core';\n/**\n * @description Default signer implementation which does nothing and produce invalid signature\n * @throw {@link UnconfiguredSignerError}\n */\nexport declare class NoopSigner implements Signer {\n    publicKey(): Promise<string>;\n    publicKeyHash(): Promise<string>;\n    secretKey(): Promise<string>;\n    sign(_bytes: string, _watermark?: Uint8Array): Promise<any>;\n}\n"},{name:"@taquito/subscribe/create-observable-from-subscription.d.ts",dts:"import { BlockResponse } from '@taquito/rpc';\nimport { Observable } from 'rxjs';\nimport { OperationContent, Subscription } from './interface';\nexport declare function createObservableFromSubscription<T extends BlockResponse | string | OperationContent>(sub: Subscription<T>): Observable<T>;\n"},{name:"@taquito/subscribe/errors.d.ts",dts:"import { ParameterValidationError } from '@taquito/core';\nimport { FilterExpression } from '../taquito';\n/**\n *  @category Error\n *  @description Error that indicates an unsupported event being passed or used\n */\nexport declare class UnsupportedEventError extends ParameterValidationError {\n    readonly type: string;\n    constructor(type: string);\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid filter expression being passed or used\n */\nexport declare class InvalidFilterExpressionError extends ParameterValidationError {\n    readonly invalidExpression: FilterExpression;\n    constructor(invalidExpression: FilterExpression);\n}\n"},{name:"@taquito/subscribe/filters.d.ts",dts:"import { OpFilter, FilterExpression, Filter, OperationContent } from './interface';\nimport { InternalOperationResult } from '@taquito/rpc';\nexport declare const eventFilter: (result: InternalOperationResult, address?: string, tag?: string, excludeFailedOperations?: boolean) => boolean;\nexport declare const evaluateOpFilter: (op: OperationContent, filter: OpFilter) => boolean | undefined;\nexport declare const evaluateExpression: (op: OperationContent, exp: FilterExpression) => boolean;\nexport declare const evaluateFilter: (op: OperationContent, filter: Filter) => boolean;\n"},{name:"@taquito/subscribe/interface.d.ts",dts:"import { BlockResponse, InternalOperationResult, OperationEntry } from '@taquito/rpc';\nexport type FilterExpression = {\n    or?: ExpressionOrOpFilter[];\n    and?: ExpressionOrOpFilter[];\n};\nexport interface OpHashFilter {\n    opHash: string;\n}\nexport interface SourceFilter {\n    source: string;\n}\nexport interface KindFilter {\n    kind: string;\n}\nexport interface DestinationFilter {\n    destination: string;\n}\nexport interface EventFilter {\n    address?: string;\n    tag?: string;\n    excludeFailedOperations?: boolean;\n}\nexport interface EventSubscription extends InternalOperationResult {\n    opHash: string;\n    blockHash: string;\n    level: number;\n}\nexport type OpFilter = OpHashFilter | SourceFilter | KindFilter | DestinationFilter | EventFilter;\nexport type ExpressionOrOpFilter = OpFilter | FilterExpression;\nexport type Filter = ExpressionOrOpFilter | ExpressionOrOpFilter[];\nexport type OperationContent = OperationEntry['contents'][0] & {\n    hash: string;\n};\nexport interface SubscribeProvider {\n    subscribe(filter: 'head'): Subscription<string>;\n    subscribeBlock(filter: 'head'): Subscription<BlockResponse>;\n    subscribeOperation(filter: Filter): Subscription<OperationContent>;\n    subscribeEvent(filter?: EventFilter): Subscription<InternalOperationResult>;\n}\nexport interface Subscription<T> {\n    on(type: 'error', cb: (error: Error) => void): void;\n    on(type: 'data', cb: (data: T) => void): void;\n    on(type: 'close', cb: () => void): void;\n    off(type: 'error', cb: (error: Error) => void): void;\n    off(type: 'data', cb: (data: T) => void): void;\n    off(type: 'close', cb: () => void): void;\n    close(): void;\n}\n"},{name:"@taquito/subscribe/observable-subscription.d.ts",dts:"import { Observable, OperatorFunction } from 'rxjs';\nimport { Subscription } from './interface';\nexport { UnsupportedEventError } from './errors';\nexport declare class ObservableSubscription<T> implements Subscription<T> {\n    private shouldRetry;\n    private operatorFunction;\n    private errorListeners;\n    private messageListeners;\n    private closeListeners;\n    private completed$;\n    constructor(obs: Observable<T>, shouldRetry?: boolean, operatorFunction?: OperatorFunction<T, T>);\n    private call;\n    private remove;\n    on(type: 'error', cb: (error: Error) => void): void;\n    on(type: 'data', cb: (data: T) => void): void;\n    on(type: 'close', cb: () => void): void;\n    off(type: 'error', cb: (error: Error) => void): void;\n    off(type: 'data', cb: (data: T) => void): void;\n    off(type: 'close', cb: () => void): void;\n    close(): void;\n}\n"},{name:"@taquito/subscribe/polling-subcribe-provider.d.ts",dts:"import { BlockResponse, InternalOperationResult } from '@taquito/rpc';\nimport { OperatorFunction } from 'rxjs';\nimport { Context } from '../context';\nimport { Filter, EventFilter, SubscribeProvider, Subscription, OperationContent } from './interface';\nexport interface PollingSubscribeProviderConfig {\n    pollingIntervalMilliseconds?: number;\n    shouldObservableSubscriptionRetry: boolean;\n    observableSubscriptionRetryFunction: OperatorFunction<any, any>;\n}\nexport declare const defaultConfigStreamer: PollingSubscribeProviderConfig;\nexport declare class PollingSubscribeProvider implements SubscribeProvider {\n    private context;\n    private _config$;\n    private timer$;\n    private newBlock$;\n    constructor(context: Context, config?: Partial<PollingSubscribeProviderConfig>);\n    get config(): PollingSubscribeProviderConfig;\n    private getConfirmationPollingInterval;\n    subscribeBlock(_filter: 'head'): Subscription<BlockResponse>;\n    subscribe(_filter: 'head'): Subscription<string>;\n    subscribeOperation(filter: Filter): Subscription<OperationContent>;\n    subscribeEvent(eventFilter?: EventFilter): Subscription<InternalOperationResult>;\n}\n"},{name:"@taquito/tz/interface.d.ts",dts:"import BigNumber from 'bignumber.js';\nimport { Operation } from '../operations/operations';\nexport interface TzProvider {\n    /**\n     *\n     * @param address Tezos address you want to get the spendable balance for (eg tz1...)\n     */\n    getBalance(address: string): Promise<BigNumber>;\n    /**\n     *\n     * @param address Tezos address you want to get the spendable balance for (eg tz1...)\n     */\n    getSpendable(address: string): Promise<BigNumber>;\n    /**\n     *\n     * @param address Tezos address you want to get the delegate for (eg tz1...)\n     */\n    getDelegate(address: string): Promise<string | null>;\n    activate(pkh: string, secret: string): Promise<Operation>;\n}\n"},{name:"@taquito/tz/rpc-tz-provider.d.ts",dts:"import BigNumber from 'bignumber.js';\nimport { Context } from '../context';\nimport { Operation } from '../operations/operations';\nimport { TzProvider } from './interface';\nimport { Provider } from '../provider';\nexport declare class RpcTzProvider extends Provider implements TzProvider {\n    constructor(context: Context);\n    private prepare;\n    getBalance(address: string): Promise<BigNumber>;\n    getSpendable(address: string): Promise<BigNumber>;\n    getDelegate(address: string): Promise<string | null>;\n    activate(pkh: string, secret: string): Promise<Operation>;\n}\n"},{name:"@taquito/wallet/batch-operation.d.ts",dts:"import { BlockResponse, OperationContentsAndResultReveal } from '@taquito/rpc';\nimport { Observable } from 'rxjs';\nimport { Context } from '../context';\nimport { WalletOperation, OperationStatus } from './operation';\nexport declare class BatchWalletOperation extends WalletOperation {\n    readonly opHash: string;\n    protected readonly context: Context;\n    constructor(opHash: string, context: Context, newHead$: Observable<BlockResponse>);\n    revealOperation(): Promise<OperationContentsAndResultReveal | undefined>;\n    getOriginatedContractAddresses: () => Promise<string[]>;\n    status(): Promise<OperationStatus>;\n}\n"},{name:"@taquito/wallet/delegation-operation.d.ts",dts:"import { BlockResponse, OperationContentsAndResultDelegation, OperationContentsAndResultReveal } from '@taquito/rpc';\nimport { Observable } from 'rxjs';\nimport { Context } from '../context';\nimport { WalletOperation, OperationStatus } from './operation';\nexport declare class DelegationWalletOperation extends WalletOperation {\n    readonly opHash: string;\n    protected readonly context: Context;\n    constructor(opHash: string, context: Context, newHead$: Observable<BlockResponse>);\n    revealOperation(): Promise<OperationContentsAndResultReveal | undefined>;\n    delegationOperation(): Promise<OperationContentsAndResultDelegation | undefined>;\n    status(): Promise<OperationStatus>;\n}\n"},{name:"@taquito/wallet/errors.d.ts",dts:"import { TezosToolkitConfigError, NetworkError } from '@taquito/core';\n/**\n *  @category Error\n *  @description Error that indicates undefined confirmation has not been specified or configured\n */\nexport declare class ConfirmationUndefinedError extends TezosToolkitConfigError {\n    constructor();\n}\n/**\n *  @category Error\n *  @description Error that indicates a generic failure when trying to fetch an observable\n */\nexport declare class ObservableError extends NetworkError {\n    readonly message: string;\n    constructor(message: string);\n}\n"},{name:"@taquito/wallet/increase-paid-storage-operation.d.ts",dts:"import { WalletOperation, OperationStatus } from './operation';\nimport { Context } from '../context';\nimport { Observable } from 'rxjs';\nimport { BlockResponse, OperationContentsAndResultReveal, OperationContentsAndResultIncreasePaidStorage } from '@taquito/rpc';\nexport declare class IncreasePaidStorageWalletOperation extends WalletOperation {\n    readonly opHash: string;\n    protected readonly context: Context;\n    constructor(opHash: string, context: Context, newHead$: Observable<BlockResponse>);\n    revealOperation(): Promise<OperationContentsAndResultReveal | undefined>;\n    increasePaidStorageOperation(): Promise<OperationContentsAndResultIncreasePaidStorage | undefined>;\n    status(): Promise<OperationStatus>;\n}\n"},{name:"@taquito/wallet/index.d.ts",dts:"export * from './wallet';\nexport * from './operation';\nexport * from './transaction-operation';\nexport * from './origination-operation';\nexport * from './delegation-operation';\nexport * from './transfer-ticket-operation';\nexport * from './interface';\nexport * from './legacy';\n"},{name:"@taquito/wallet/interface.d.ts",dts:"import { DelegateParams, FailingNoopParams, IncreasePaidStorageParams, OriginateParams, TransferParams, StakeParams, UnstakeParams, FinalizeUnstakeParams, TransferTicketParams } from '../operations/types';\nexport type WalletDefinedFields = 'source';\nexport type WalletTransferParams = Omit<TransferParams, WalletDefinedFields>;\nexport type WalletStakeParams = Omit<StakeParams, WalletDefinedFields>;\nexport type WalletUnstakeParams = Omit<UnstakeParams, WalletDefinedFields>;\nexport type WalletFinalizeUnstakeParams = Omit<FinalizeUnstakeParams, WalletDefinedFields>;\nexport type WalletOriginateParams<TStorage = any> = Omit<OriginateParams<TStorage>, WalletDefinedFields>;\nexport type WalletDelegateParams = Omit<DelegateParams, WalletDefinedFields>;\nexport type WalletFailingNoopParams = Omit<FailingNoopParams, WalletDefinedFields>;\nexport type WalletIncreasePaidStorageParams = Omit<IncreasePaidStorageParams, WalletDefinedFields>;\nexport type WalletTransferTicketParams = Omit<TransferTicketParams, WalletDefinedFields>;\nexport interface WalletProvider {\n    /**\n     * @description Request the public key hash from the wallet\n     */\n    getPKH: () => Promise<string>;\n    /**\n     * @description Get the public key from the wallet\n     */\n    getPK: () => Promise<string>;\n    /**\n     * @description Transform WalletTransferParams into a format compliant with the underlying wallet\n     */\n    mapTransferParamsToWalletParams: (params: () => Promise<WalletTransferParams>) => Promise<any>;\n    /**\n     * @description Transform WalletTransferTicketParams into a format compliant with the underlying wallet\n     */\n    mapTransferTicketParamsToWalletParams: (params: () => Promise<WalletTransferTicketParams>) => Promise<any>;\n    /**\n     * @description Transform WalletStakeParams into a format compliant with the underlying wallet\n     */\n    mapStakeParamsToWalletParams: (params: () => Promise<WalletStakeParams>) => Promise<any>;\n    /**\n     * @description Transform WalletUnstakeParams into a format compliant with the underlying wallet\n     */\n    mapUnstakeParamsToWalletParams: (params: () => Promise<WalletUnstakeParams>) => Promise<any>;\n    /**\n     * @description Transform WalletFinalizeUnstakeParams into a format compliant with the underlying wallet\n     */\n    mapFinalizeUnstakeParamsToWalletParams: (params: () => Promise<WalletFinalizeUnstakeParams>) => Promise<any>;\n    /**\n     * @description Transform WalletOriginateParams into a format compliant with the underlying wallet\n     */\n    mapOriginateParamsToWalletParams: (params: () => Promise<WalletOriginateParams>) => Promise<any>;\n    /**\n     * @description Transform WalletDelegateParams into a format compliant with the underlying wallet\n     */\n    mapDelegateParamsToWalletParams: (params: () => Promise<WalletDelegateParams>) => Promise<any>;\n    /**\n     * @description Transform WalletIncreasePaidStorageParams into a format compliant with the underlying wallet\n     */\n    mapIncreasePaidStorageWalletParams: (params: () => Promise<WalletIncreasePaidStorageParams>) => Promise<any>;\n    /**\n     * @description Request the wallet to send an operation batch\n     */\n    sendOperations: (params: any[]) => Promise<string>;\n    /**\n     * @description Request the wallet to sign a payload\n     */\n    sign(bytes: string, watermark?: Uint8Array): Promise<string>;\n}\n"},{name:"@taquito/wallet/legacy.d.ts",dts:'import { Context } from \'../context\';\nimport { OpKind } from \'../operations/types\';\nimport { WalletDelegateParams, WalletIncreasePaidStorageParams, WalletOriginateParams, WalletProvider, WalletTransferParams, WalletStakeParams, WalletUnstakeParams, WalletFinalizeUnstakeParams, WalletTransferTicketParams } from \'./interface\';\nimport { WalletParamsWithKind } from \'./wallet\';\nexport declare class LegacyWalletProvider implements WalletProvider {\n    private context;\n    constructor(context: Context);\n    getPKH(): Promise<string>;\n    getPK(): Promise<string>;\n    mapTransferParamsToWalletParams(params: () => Promise<WalletTransferParams>): Promise<import("../operations/types").withKind<WalletTransferParams, OpKind.TRANSACTION>>;\n    mapStakeParamsToWalletParams(params: () => Promise<WalletStakeParams>): Promise<import("../operations/types").withKind<WalletStakeParams, OpKind.TRANSACTION>>;\n    mapUnstakeParamsToWalletParams(params: () => Promise<WalletUnstakeParams>): Promise<import("../operations/types").withKind<WalletUnstakeParams, OpKind.TRANSACTION>>;\n    mapFinalizeUnstakeParamsToWalletParams(params: () => Promise<WalletFinalizeUnstakeParams>): Promise<import("../operations/types").withKind<WalletFinalizeUnstakeParams, OpKind.TRANSACTION>>;\n    mapOriginateParamsToWalletParams(params: () => Promise<WalletOriginateParams>): Promise<import("../operations/types").withKind<WalletOriginateParams, OpKind.ORIGINATION>>;\n    mapDelegateParamsToWalletParams(params: () => Promise<WalletDelegateParams>): Promise<import("../operations/types").withKind<WalletDelegateParams, OpKind.DELEGATION>>;\n    mapIncreasePaidStorageWalletParams(params: () => Promise<WalletIncreasePaidStorageParams>): Promise<import("../operations/types").withKind<WalletIncreasePaidStorageParams, OpKind.INCREASE_PAID_STORAGE>>;\n    mapTransferTicketParamsToWalletParams(params: () => Promise<WalletTransferTicketParams>): Promise<import("../operations/types").withKind<WalletTransferTicketParams, OpKind.TRANSFER_TICKET>>;\n    sendOperations(params: WalletParamsWithKind[]): Promise<string>;\n    sign(bytes: string, watermark?: Uint8Array): Promise<string>;\n}\n'},{name:"@taquito/wallet/operation-factory.d.ts",dts:"import { BlockResponse } from '@taquito/rpc';\nimport { Observable, SchedulerLike } from 'rxjs';\nimport { Context } from '../context';\nimport { BatchWalletOperation } from './batch-operation';\nimport { DelegationWalletOperation } from './delegation-operation';\nimport { IncreasePaidStorageWalletOperation } from './increase-paid-storage-operation';\nimport { WalletOperation } from './operation';\nimport { OriginationWalletOperation } from './origination-operation';\nimport { TransactionWalletOperation } from './transaction-operation';\nimport { TransferTicketWalletOperation } from './transfer-ticket-operation';\nexport declare function timeoutAfter<T>(timeoutMillisec: number): (source: Observable<T>) => Observable<T>;\nexport declare const createNewPollingBasedHeadObservable: (sharedHeadOb: Observable<BlockResponse>, context: Context, _scheduler?: SchedulerLike) => Observable<BlockResponse>;\nexport interface OperationFactoryConfig {\n    blockIdentifier?: string;\n}\nexport declare class OperationFactory {\n    private context;\n    constructor(context: Context);\n    private sharedHeadObs;\n    private createNewHeadObservable;\n    private createPastBlockWalker;\n    private createHeadObservableFromConfig;\n    createOperation(hash: string, config?: OperationFactoryConfig): Promise<WalletOperation>;\n    createBatchOperation(hash: string, config?: OperationFactoryConfig): Promise<BatchWalletOperation>;\n    createTransactionOperation(hash: string, config?: OperationFactoryConfig): Promise<TransactionWalletOperation>;\n    createTransferTicketOperation(hash: string, config?: OperationFactoryConfig): Promise<TransferTicketWalletOperation>;\n    createDelegationOperation(hash: string, config?: OperationFactoryConfig): Promise<DelegationWalletOperation>;\n    createOriginationOperation(hash: string, config?: OperationFactoryConfig): Promise<OriginationWalletOperation>;\n    createIncreasePaidStorageOperation(hash: string, config?: OperationFactoryConfig): Promise<IncreasePaidStorageWalletOperation>;\n}\n"},{name:"@taquito/wallet/operation.d.ts",dts:"import { BlockResponse, OperationContentsAndResult, OperationResultStatusEnum } from '@taquito/rpc';\nimport { Observable, ReplaySubject } from 'rxjs';\nimport { Context } from '../context';\nimport { Receipt } from './receipt';\nimport { BlockIdentifier } from '../read-provider/interface';\nexport type OperationStatus = 'pending' | 'unknown' | OperationResultStatusEnum;\n/**\n * @description WalletOperation allows to monitor operation inclusion on chains and surface information related to the operation\n */\nexport declare class WalletOperation {\n    readonly opHash: string;\n    protected readonly context: Context;\n    private _newHead$;\n    protected _operationResult: ReplaySubject<OperationContentsAndResult[]>;\n    protected _includedInBlock: ReplaySubject<BlockResponse>;\n    protected _included: boolean;\n    private lastHead;\n    protected newHead$: Observable<BlockResponse>;\n    private confirmed$;\n    operationResults(): Promise<OperationContentsAndResult[] | undefined>;\n    /**\n     * @description Receipt expose the total amount of tezos token burn and spent on fees\n     * The promise returned by receipt will resolve only once the transaction is included\n     */\n    receipt(): Promise<Receipt>;\n    /**\n     *\n     * @param opHash Operation hash\n     * @param raw Raw operation that was injected\n     * @param context Taquito context allowing access to rpc and signer\n     * @throws {InvalidOperationHashError}\n     */\n    constructor(opHash: string, context: Context, _newHead$: Observable<BlockResponse>);\n    getCurrentConfirmation(): Promise<number | undefined>;\n    isInCurrentBranch(tipBlockIdentifier?: BlockIdentifier): Promise<boolean>;\n    confirmationObservable(confirmations?: number): Observable<{\n        block: BlockResponse;\n        expectedConfirmation: number;\n        currentConfirmation: number;\n        completed: boolean;\n        isInCurrentBranch: () => Promise<boolean>;\n    }>;\n    /**\n     *\n     * @param confirmations [0] Number of confirmation to wait for\n     */\n    confirmation(confirmations?: number): Promise<{\n        block: BlockResponse;\n        expectedConfirmation: number;\n        currentConfirmation: number;\n        completed: boolean;\n        isInCurrentBranch: () => Promise<boolean>;\n    } | undefined>;\n}\n"},{name:"@taquito/wallet/origination-operation.d.ts",dts:"import { BlockResponse, OperationContentsAndResultOrigination, OperationContentsAndResultReveal } from '@taquito/rpc';\nimport { Observable } from 'rxjs';\nimport { Context } from '../context';\nimport { DefaultWalletType } from '../contract/contract';\nimport { WalletOperation, OperationStatus } from './operation';\nexport declare class OriginationWalletOperation<TWallet extends DefaultWalletType = DefaultWalletType> extends WalletOperation {\n    readonly opHash: string;\n    protected readonly context: Context;\n    constructor(opHash: string, context: Context, newHead$: Observable<BlockResponse>);\n    originationOperation(): Promise<OperationContentsAndResultOrigination | undefined>;\n    revealOperation(): Promise<OperationContentsAndResultReveal | undefined>;\n    status(): Promise<OperationStatus>;\n    contract(): Promise<TWallet>;\n}\n"},{name:"@taquito/wallet/receipt.d.ts",dts:"import { OperationContentsAndResult } from '@taquito/rpc';\nimport BigNumber from 'bignumber.js';\nexport interface Receipt {\n    totalFee: BigNumber;\n    totalGas: BigNumber;\n    totalMilliGas: BigNumber;\n    totalStorage: BigNumber;\n    totalAllocationBurn: BigNumber;\n    totalOriginationBurn: BigNumber;\n    totalPaidStorageDiff: BigNumber;\n    totalStorageBurn: BigNumber;\n}\nexport declare const receiptFromOperation: (op: OperationContentsAndResult[], { ALLOCATION_BURN, ORIGINATION_BURN }?: {\n    ALLOCATION_BURN: number;\n    ORIGINATION_BURN: number;\n}) => Receipt;\n"},{name:"@taquito/wallet/transaction-operation.d.ts",dts:"import { WalletOperation, OperationStatus } from './operation';\nimport { Context } from '../context';\nimport { Observable } from 'rxjs';\nimport { BlockResponse, OperationContentsAndResultReveal, OperationContentsAndResultTransaction } from '@taquito/rpc';\nexport declare class TransactionWalletOperation extends WalletOperation {\n    readonly opHash: string;\n    protected readonly context: Context;\n    constructor(opHash: string, context: Context, newHead$: Observable<BlockResponse>);\n    revealOperation(): Promise<OperationContentsAndResultReveal | undefined>;\n    transactionOperation(): Promise<OperationContentsAndResultTransaction | undefined>;\n    status(): Promise<OperationStatus>;\n}\n"},{name:"@taquito/wallet/transfer-ticket-operation.d.ts",dts:"import { WalletOperation, OperationStatus } from './operation';\nimport { Context } from '../context';\nimport { Observable } from 'rxjs';\nimport { BlockResponse, OperationContentsAndResultReveal, OperationContentsAndResultTransferTicket } from '@taquito/rpc';\nexport declare class TransferTicketWalletOperation extends WalletOperation {\n    readonly opHash: string;\n    protected readonly context: Context;\n    constructor(opHash: string, context: Context, newHead$: Observable<BlockResponse>);\n    revealOperation(): Promise<OperationContentsAndResultReveal | undefined>;\n    transferTicketOperation(): Promise<OperationContentsAndResultTransferTicket | undefined>;\n    status(): Promise<OperationStatus>;\n}\n"},{name:"@taquito/wallet/wallet.d.ts",dts:'import { Context } from \'../context\';\nimport { ContractAbstraction, ContractStorageType, DefaultWalletType, SendParams } from \'../contract\';\nimport { ContractMethod } from \'../contract/contract-methods/contract-method-flat-param\';\nimport { ContractMethodObject } from \'../contract/contract-methods/contract-method-object-param\';\nimport { OpKind, withKind } from \'../operations/types\';\nimport { OriginationWalletOperation } from \'./origination-operation\';\nimport { WalletDelegateParams, WalletFailingNoopParams, WalletIncreasePaidStorageParams, WalletOriginateParams, WalletProvider, WalletTransferParams, WalletStakeParams, WalletUnstakeParams, WalletFinalizeUnstakeParams, WalletTransferTicketParams } from \'./interface\';\nexport interface PKHOption {\n    forceRefetch?: boolean;\n}\nexport type WalletParamsWithKind = withKind<WalletTransferParams, OpKind.TRANSACTION> | withKind<WalletOriginateParams, OpKind.ORIGINATION> | withKind<WalletDelegateParams, OpKind.DELEGATION> | withKind<WalletIncreasePaidStorageParams, OpKind.INCREASE_PAID_STORAGE> | withKind<WalletTransferTicketParams, OpKind.TRANSFER_TICKET>;\nexport declare class WalletOperationBatch {\n    private walletProvider;\n    private context;\n    private operations;\n    constructor(walletProvider: WalletProvider, context: Context);\n    /**\n     * @description Add a transaction operation to the batch\n     * @param params Transfer operation parameter\n     */\n    withTransfer(params: WalletTransferParams): this;\n    /**\n     * @description Add a contract call to the batch\n     * @param params Call a contract method\n     * @param options Generic operation parameters\n     */\n    withContractCall(params: ContractMethod<Wallet> | ContractMethodObject<Wallet>, options?: Partial<SendParams>): this;\n    /**\n     * @description Add a delegation operation to the batch\n     * @param params Delegation operation parameter\n     */\n    withDelegation(params: WalletDelegateParams): this;\n    /**\n     * @description Add an origination operation to the batch\n     * @param params Origination operation parameter\n     */\n    withOrigination<TWallet extends DefaultWalletType = DefaultWalletType>(params: WalletOriginateParams<ContractStorageType<TWallet>>): this;\n    /**\n     * @description Add an IncreasePaidStorage operation to the batch\n     * @param param IncreasePaidStorage operation parameter\n     */\n    withIncreasePaidStorage(params: WalletIncreasePaidStorageParams): this;\n    /**\n     * @description Add an TransferTicket operation to the batch\n     * @param param TransferTicket operation parameter\n     */\n    withTransferTicket(params: WalletTransferTicketParams): this;\n    private mapOperation;\n    /**\n     * @description Add a group operation to the batch. Operation will be applied in the order they are in the params array\n     * @param params Operations parameter\n     * @throws {@link InvalidOperationKindError}\n     */\n    with(params: WalletParamsWithKind[]): this;\n    /**\n     * @description Submit batch operation to wallet\n     */\n    send(): Promise<import("./batch-operation").BatchWalletOperation>;\n}\nexport declare class Wallet {\n    private context;\n    constructor(context: Context);\n    private get walletProvider();\n    private _pkh?;\n    private _pk?;\n    /**\n     * @description Retrieve the PKH of the account that is currently in use by the wallet\n     * @param option Option to use while fetching the PKH.\n     * If forceRefetch is specified the wallet provider implementation will refetch the PKH from the wallet\n     */\n    pkh({ forceRefetch }?: PKHOption): Promise<string>;\n    /**\n     * @description Retrieve the PK of the account that is currently in use by the wallet\n     * @param option Option to use while fetching the PK.\n     * If forceRefetch is specified the wallet provider implementation will refetch the PK from the wallet\n     */\n    pk({ forceRefetch }?: PKHOption): Promise<string>;\n    private walletCommand;\n    /**\n     * @description Originate a new contract according to the script in parameters.\n     * @returns a OriginationWalletOperation promise object when followed by .send()\n     * @param originateParams Originate operation parameter\n     */\n    originate<TWallet extends DefaultWalletType = DefaultWalletType>(params: WalletOriginateParams<ContractStorageType<TWallet>>): {\n        send: () => Promise<OriginationWalletOperation<TWallet>>;\n    };\n    /**\n     * @description Set the delegate for a contract.\n     * @returns a WalletDelegateParams promise object when followed by .send()\n     * @param delegateParams operation parameter\n     */\n    setDelegate(params: WalletDelegateParams): {\n        send: () => Promise<import("./delegation-operation").DelegationWalletOperation>;\n    };\n    /**\n     * @description failing_noop operation that is guaranteed to fail. DISCLAIMER: Not all wallets support signing failing_noop operations.\n     * @returns Signature for a failing_noop\n     * @param params operation parameter\n     */\n    signFailingNoop(params: WalletFailingNoopParams): Promise<{\n        signature: string;\n        bytes: string;\n        signedContent: {\n            branch: string;\n            contents: {\n                kind: OpKind;\n                arbitrary: string;\n            }[];\n        };\n    }>;\n    /**\n     * @description Register the current address as delegate.\n     * @returns a DelegationWalletOperation promise object when followed by .send()\n     */\n    registerDelegate(): {\n        send: () => Promise<import("./delegation-operation").DelegationWalletOperation>;\n    };\n    /**\n     * @description Transfer tezos tokens from current address to a specific address or call a smart contract.\n     * @returns a TransactionWalletOperation promise object when followed by .send()\n     * @param params operation parameter\n     */\n    transfer(params: WalletTransferParams): {\n        send: () => Promise<import("./transaction-operation").TransactionWalletOperation>;\n    };\n    /**\n     * @description Transfer tezos tickets from current address to a specific address or a smart contract\n     * @returns a TransferTicketWalletOperation promise object when followed by .send()\n     * @param params operation parameter\n     */\n    transferTicket(params: WalletTransferTicketParams): {\n        send: () => Promise<import("./transfer-ticket-operation").TransferTicketWalletOperation>;\n    };\n    /**\n     * @description Stake a given amount for the source address\n     * @returns a TransactionWalletOperation promise object when followed by .send()\n     * @param Stake pseudo-operation parameter\n     */\n    stake(params: WalletStakeParams): {\n        send: () => Promise<import("./transaction-operation").TransactionWalletOperation>;\n    };\n    /**\n     * @description Unstake the given amount. If "everything" is given as amount, unstakes everything from the staking balance.\n     * Unstaked tez remains frozen for a set amount of cycles (the slashing period) after the operation. Once this period is over,\n     * the operation "finalize unstake" must be called for the funds to appear in the liquid balance.\n     * @returns a TransactionWalletOperation promise object when followed by .send()\n     * @param Unstake pseudo-operation parameter\n     */\n    unstake(params: WalletUnstakeParams): {\n        send: () => Promise<import("./transaction-operation").TransactionWalletOperation>;\n    };\n    /**\n     * @description Transfer all the finalizable unstaked funds of the source to their liquid balance\n     * @returns a TransactionWalletOperation promise object when followed by .send()\n     * @param Finalize_unstake pseudo-operation parameter\n     */\n    finalizeUnstake(params: WalletFinalizeUnstakeParams): {\n        send: () => Promise<import("./transaction-operation").TransactionWalletOperation>;\n    };\n    /**\n     * @description Increase the paid storage of a smart contract.\n     * @returns a IncreasePaidStorageWalletOperation promise object when followed by .send()\n     * @param params operation parameter\n     */\n    increasePaidStorage(params: WalletIncreasePaidStorageParams): {\n        send: () => Promise<import("./increase-paid-storage-operation").IncreasePaidStorageWalletOperation>;\n    };\n    /**\n     * @description Create a batch of operation\n     * @returns A batch object from which we can add more operation or send a command to the wallet to execute the batch\n     * @param params List of operation to initialize the batch with\n     */\n    batch(params?: Parameters<WalletOperationBatch[\'with\']>[0]): WalletOperationBatch;\n    /**\n     * @description Create an smart contract abstraction for the address specified. Calling entrypoints with the returned\n     * smart contract abstraction will leverage the wallet provider to make smart contract calls\n     * @param address Smart contract address\n     * @throws {@link InvalidContractAddressError} If the contract address is not valid\n     */\n    at<T extends ContractAbstraction<Wallet>>(address: string, contractAbstractionComposer?: (abs: ContractAbstraction<Wallet>, context: Context) => T): Promise<T>;\n    /**\n     * @deprecated Deprecated in favor of {@link Wallet.pk} will be removed in v19.1\n     * @description Retrieve the PK of the account that is currently in use by the wallet\n     */\n    getPK(): Promise<string>;\n}\n'},{name:"@taquito/constants.d.ts",dts:'/**\n * @deprecated default reveal gasLimit please use getRevealGasLimit(address) instead, removing hardcoded gasLimit of delegation, origination and transfer\n */\nexport declare const DEFAULT_GAS_LIMIT: {\n    DELEGATION: number;\n    ORIGINATION: number;\n    TRANSFER: number;\n    REVEAL_TZ1: number;\n    REVEAL_TZ2: number;\n    REVEAL_TZ3: number;\n    REVEAL_TZ4: number;\n};\n/**\n * @deprecated default reveal fee please use getRevealFee(address) instead, removing hardcoded fee of delegation, origination and transfer\n */\nexport declare const DEFAULT_FEE: {\n    DELEGATION: number;\n    ORIGINATION: number;\n    TRANSFER: number;\n    REVEAL: number;\n};\n/**\n * @deprecated default reveal storageLimit please use REVEAL_STORAGE_LIMIT instead, removing hardcoded storageLimit of delegation, origination and transfer\n */\nexport declare const DEFAULT_STORAGE_LIMIT: {\n    DELEGATION: number;\n    ORIGINATION: number;\n    TRANSFER: number;\n    REVEAL: number;\n};\nexport declare const REVEAL_STORAGE_LIMIT = 0;\nexport declare const ORIGINATION_SIZE = 257;\nexport declare const COST_PER_BYTE = 250;\nexport declare enum Protocols {\n    Pt24m4xi = "Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd",\n    PsBABY5H = "PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU",\n    PsBabyM1 = "PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS",\n    PsCARTHA = "PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb",\n    PsDELPH1 = "PsDELPH1Kxsxt8f9eWbxQeRxkjfbxoqM52jvs5Y5fBxWWh4ifpo",\n    PtEdo2Zk = "PtEdo2ZkT9oKpimTah6x2embF25oss54njMuPzkJTEi5RqfdZFA",\n    PsFLorena = "PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i",\n    PtGRANADs = "PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV",\n    PtHangz2 = "PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx",\n    PsiThaCa = "PsiThaCaT47Zboaw71QWScM8sXeMM7bbQFncK9FLqYc6EKdpjVP",\n    Psithaca2 = "Psithaca2MLRFYargivpo7YvUr7wUDqyxrdhC5CQq78mRvimz6A",\n    PtJakart2 = "PtJakart2xVj7pYXJBXrqHgd82rdkLey5ZeeGwDgPp9rhQUbSqY",\n    PtKathman = "PtKathmankSpLLDALzWw7CGD2j2MtyveTwboEYokqUCP4a1LxMg",\n    PtLimaPtL = "PtLimaPtLMwfNinJi9rCfDPWea8dFgTZ1MeJ9f1m2SRic6ayiwW",\n    PtMumbaii = "PtMumbaiiFFEGbew1rRjzSPyzRbA51Tm3RVZL5suHPxSZYDhCEc",\n    PtMumbai2 = "PtMumbai2TmsJHNGRkD8v8YDbtao7BLUC3wjASn1inAKLFCjaH1",\n    PtNairobi = "PtNairobiyssHuh87hEhfVBGCVrK3WnS8Z2FT4ymB5tAa4r1nQf",\n    ProxfordY = "ProxfordYmVfjWnRcgjWH36fW6PArwqykTFzotUxRs6gmTcZDuH",\n    PtParisBx = "PtParisBxoLz5gzMmn3d9WBQNoPSZakgnkMC2VNuQ3KXfUtUQeZ",\n    PsParisCZ = "PsParisCZo7KAh1Z1smVd9ZMZ1HHn5gkzbM94V3PLCpknFWhUAi",\n    PsQuebecn = "PsQuebecnLByd3JwTiGadoG4nGWi3HYiLXUjkibeFV8dCFeVMUg",\n    PsRiotuma = "PsRiotumaAMotcRoDWW1bysEhQy2n1M5fy8JgRp8jjRfHGmfeA7",\n    PtSeouLou = "PtSeouLouXkxhg39oWzjxDWaCydNfR3RxCUrNe4Q9Ro8BTehcbh",\n    ProtoALpha = "ProtoALphaALphaALphaALphaALphaALphaALphaALphaDdp3zK"\n}\nexport declare const protocols: {\n    \'004\': Protocols[];\n    \'005\': Protocols[];\n    \'006\': Protocols[];\n    \'007\': Protocols[];\n    \'008\': Protocols[];\n    \'009\': Protocols[];\n    \'010\': Protocols[];\n    \'011\': Protocols[];\n    \'012\': Protocols[];\n    \'013\': Protocols[];\n    \'014\': Protocols[];\n    \'015\': Protocols[];\n    \'016\': Protocols[];\n    \'017\': Protocols[];\n    \'019\': Protocols[];\n    \'020\': Protocols[];\n    \'021\': Protocols[];\n    \'022\': Protocols[];\n    \'023\': Protocols[];\n    \'024\': Protocols[];\n};\nexport declare enum ChainIds {\n    MAINNET = "NetXdQprcVkpaWU",\n    GHOSTNET = "NetXnHfVqm9iesp",\n    SHADOWNET = "NetXsqzbfFenSTS",\n    CARTHAGENET = "NetXjD3HPJJjmcd",\n    DELPHINET = "NetXm8tYqnMWky1",\n    EDONET = "NetXSgo1ZT2DRUG",\n    FLORENCENET = "NetXxkAx4woPLyu",\n    GRANADANET = "NetXz969SFaFn8k",\n    HANGZHOUNET = "NetXZSsxBpMQeAT",\n    ITHACANET = "NetXbhmtAbMukLc",\n    JAKARTANET2 = "NetXLH1uAxK7CCh",\n    KATHMANDUNET = "NetXazhm4yetmff",\n    LIMANET = "NetXizpkH94bocH",\n    MUMBAINET = "NetXQw6nWSnrJ5t",\n    MUMBAINET2 = "NetXgbcrNtXD2yA",\n    NAIROBINET = "NetXyuzvDo2Ugzb",\n    OXFORDNET2 = "NetXxWsskGahzQB",\n    PARISBNET = "NetXo8SqH1c38SS",\n    PARISCNET = "NetXXWAHLEvre9b",\n    QUEBECNET = "NetXuTeGinLEqxp",\n    RIONET = "NetXPdgaoabtBth",\n    SEOULNET = "NetXd56aBs1aeW3"\n}\nexport declare const getRevealGasLimit: (address: string) => number;\nexport declare const getRevealFee: (address: string) => number;\nexport declare const getRevealFeeInternal: (address: string) => number;\n'},{name:"@taquito/context.d.ts",dts:"import { RpcClientInterface } from '@taquito/rpc';\nimport { Protocols } from './constants';\nimport { Forger } from '@taquito/local-forging';\nimport { Injector } from './injector/interface';\nimport { Signer } from '@taquito/core';\nimport { OperationFactory } from './wallet/operation-factory';\nimport { RpcTzProvider } from './tz/rpc-tz-provider';\nimport { RPCEstimateProvider } from './estimate/rpc-estimate-provider';\nimport { RpcContractProvider } from './contract/rpc-contract-provider';\nimport { RPCBatchProvider } from './batch/rpc-batch-provider';\nimport { Wallet, WalletProvider } from './wallet';\nimport { ParserProvider } from './parser/interface';\nimport { Packer } from './packer/interface';\nimport { BehaviorSubject } from 'rxjs';\nimport { GlobalConstantsProvider } from './global-constants/interface-global-constants-provider';\nimport { TzReadProvider } from './read-provider/interface';\nimport { SubscribeProvider } from './subscribe/interface';\nimport { PrepareProvider } from './prepare/prepare-provider';\nexport interface TaquitoProvider<T, K extends Array<any>> {\n    new (context: Context, ...rest: K): T;\n}\nexport interface ConfigConfirmation {\n    confirmationPollingTimeoutSecond: number;\n    defaultConfirmationCount: number;\n}\nexport declare const defaultConfigConfirmation: ConfigConfirmation;\n/**\n * @description Encapsulate common service used throughout different part of the library\n */\nexport declare class Context {\n    private _rpc;\n    private _signer;\n    private _proto?;\n    readonly _config: BehaviorSubject<{\n        confirmationPollingTimeoutSecond: number;\n        defaultConfirmationCount: number;\n    }>;\n    private _rpcClient;\n    private _forger;\n    private _parser;\n    private _injector;\n    private _walletProvider;\n    readonly operationFactory: OperationFactory;\n    private _packer;\n    private providerDecorator;\n    private _globalConstantsProvider;\n    private _readProvider;\n    private _stream;\n    readonly tz: RpcTzProvider;\n    readonly estimate: RPCEstimateProvider;\n    readonly contract: RpcContractProvider;\n    readonly prepare: PrepareProvider;\n    readonly batch: RPCBatchProvider;\n    readonly wallet: Wallet;\n    constructor(_rpc: RpcClientInterface | string, _signer?: Signer, _proto?: Protocols | undefined, _config?: BehaviorSubject<{\n        confirmationPollingTimeoutSecond: number;\n        defaultConfirmationCount: number;\n    }>, forger?: Forger, injector?: Injector, packer?: Packer, wallet?: WalletProvider, parser?: ParserProvider, globalConstantsProvider?: GlobalConstantsProvider, readProvider?: TzReadProvider, stream?: SubscribeProvider);\n    get config(): ConfigConfirmation;\n    set config(value: ConfigConfirmation);\n    setPartialConfig(value: Partial<ConfigConfirmation>): void;\n    get rpc(): RpcClientInterface;\n    set rpc(value: RpcClientInterface);\n    get injector(): Injector;\n    set injector(value: Injector);\n    get forger(): Forger;\n    set forger(value: Forger);\n    get signer(): Signer;\n    set signer(value: Signer);\n    get walletProvider(): WalletProvider;\n    set walletProvider(value: WalletProvider);\n    set proto(value: Protocols | undefined);\n    get proto(): Protocols | undefined;\n    get parser(): ParserProvider;\n    set parser(value: ParserProvider);\n    get packer(): Packer;\n    set packer(value: Packer);\n    get globalConstantsProvider(): GlobalConstantsProvider;\n    set globalConstantsProvider(value: GlobalConstantsProvider);\n    get readProvider(): TzReadProvider;\n    set readProvider(value: TzReadProvider);\n    get stream(): SubscribeProvider;\n    set stream(value: SubscribeProvider);\n    isAnyProtocolActive(protocol?: string[]): Promise<boolean>;\n    isAnySignerConfigured(): boolean;\n    /**\n     * @description Create a copy of the current context. Useful when you have long running operation and you do not want a context change to affect the operation\n     */\n    clone(): Context;\n    /**\n     * @description Allows extensions set on the TezosToolkit to inject logic into the context\n     */\n    registerProviderDecorator(fx: (context: Context) => Context): void;\n    /**\n     * @description Applies the decorators on a cloned instance of the context and returned this cloned instance.\n     * The decorators are functions that inject logic into the context.\n     * They are provided by the extensions set on the TezosToolkit by calling the registerProviderDecorator method.\n     */\n    withExtensions: () => Context;\n}\n"},{name:"@taquito/errors.d.ts",dts:"import { ParameterValidationError, RpcError, NetworkError } from '@taquito/core';\n/**\n *  @category Error\n *  @description Error that indicates invalid confirmation count has been passed or configured\n */\nexport declare class InvalidConfirmationCountError extends ParameterValidationError {\n    readonly invalidConfirmations: number;\n    constructor(invalidConfirmations: number);\n}\n/**\n *  @category Error\n *  @description Error that indicates that confirmation polling timed out\n */\nexport declare class ConfirmationTimeoutError extends NetworkError {\n    readonly message: string;\n    constructor(message: string);\n}\n/**\n *  @category Error\n *  @description Error that indicates an error being returned from the RPC response\n */\nexport declare class RPCResponseError extends RpcError {\n    readonly message: string;\n    readonly cause?: any;\n    constructor(message: string, cause?: any);\n}\n"},{name:"@taquito/provider.d.ts",dts:'import { OperationContentsAndResult, RPCRunOperationParam, RPCSimulateOperationParam, RpcClientInterface } from \'@taquito/rpc\';\nimport { Context } from \'./context\';\nimport { ForgedBytes, ParamsWithKind, RPCOperation } from \'./operations/types\';\nimport { PreparedOperation } from \'./prepare\';\nimport { Estimate } from \'./estimate\';\nexport declare abstract class Provider {\n    protected context: Context;\n    get rpc(): RpcClientInterface;\n    get signer(): import("@taquito/core").Signer;\n    constructor(context: Context);\n    protected forge({ opOb: { branch, contents, protocol }, counter }: PreparedOperation): Promise<{\n        opbytes: string;\n        opOb: {\n            branch: string;\n            contents: import("@taquito/rpc").OperationContents[];\n            protocol: string;\n        };\n        counter: number;\n    }>;\n    protected estimate<T extends {\n        fee?: number;\n        gasLimit?: number;\n        storageLimit?: number;\n    }>({ fee, gasLimit, storageLimit, ...rest }: T, estimator: (param: T) => Promise<Estimate>): Promise<{\n        fee: number | undefined;\n        gasLimit: number | undefined;\n        storageLimit: number | undefined;\n    }>;\n    getRPCOp(param: ParamsWithKind): Promise<import("./operations/types").RPCTransferOperation | import("./operations/types").RPCOriginationOperation | import("./operations/types").RPCDelegateOperation | import("./operations/types").RPCRegisterGlobalConstantOperation | import("./operations/types").RPCIncreasePaidStorageOperation | import("./operations/types").RPCUpdateConsensusKeyOperation | import("./operations/types").RPCUpdateCompanionKeyOperation | import("./operations/types").RPCTransferTicketOperation | import("./operations/types").RPCSmartRollupAddMessagesOperation | import("./operations/types").RPCSmartRollupOriginateOperation | import("./operations/types").RPCSmartRollupOutboxMessageOperation>;\n    protected runOperation(op: RPCRunOperationParam): Promise<{\n        opResponse: import("@taquito/rpc").PreapplyResponse;\n        op: RPCRunOperationParam;\n        context: Context;\n    }>;\n    protected simulate(op: RPCSimulateOperationParam): Promise<{\n        opResponse: import("@taquito/rpc").PreapplyResponse;\n        op: RPCSimulateOperationParam;\n        context: Context;\n    }>;\n    protected isRevealOpNeeded(op: RPCOperation[] | ParamsWithKind[], pkh: string): Promise<boolean>;\n    protected isAccountRevealRequired(publicKeyHash: string): Promise<boolean>;\n    protected isRevealRequiredForOpType(op: RPCOperation[] | ParamsWithKind[]): boolean;\n    protected signAndInject(forgedBytes: ForgedBytes): Promise<{\n        hash: string;\n        forgedBytes: ForgedBytes;\n        opResponse: OperationContentsAndResult[];\n        context: Context;\n    }>;\n}\n'},{name:"@taquito/taquito.d.ts",dts:"/**\n * @packageDocumentation\n * @module @taquito/taquito\n */\nimport { RpcClientInterface } from '@taquito/rpc';\nimport { Forger } from '@taquito/local-forging';\nimport { RPCBatchProvider } from './batch/rpc-batch-provider';\nimport { Protocols } from './constants';\nimport { ConfigConfirmation, TaquitoProvider } from './context';\nimport { ContractProvider } from './contract/interface';\nimport { Extension } from './extension/extension';\nimport { format } from '@taquito/utils';\nimport { GlobalConstantsProvider } from './global-constants/interface-global-constants-provider';\nimport { Packer } from './packer/interface';\nimport { TzReadProvider } from './read-provider/interface';\nimport { PreparationProvider } from './prepare/interface';\nimport { Signer } from '@taquito/core';\nimport { SubscribeProvider } from './subscribe/interface';\nimport { TzProvider } from './tz/interface';\nimport { Wallet, WalletProvider } from './wallet';\nimport { OperationFactory } from './wallet/operation-factory';\nimport { EstimationProvider } from './estimate/estimate-provider-interface';\nimport { ParserProvider } from './parser/interface';\nimport { Injector } from './injector/interface';\nimport { FieldNumberingStrategy } from '@taquito/michelson-encoder';\nexport { FieldNumberingStrategy, Token, MichelsonMap, UnitValue } from '@taquito/michelson-encoder';\nexport { Forger, ForgeParams, ForgeResponse } from '@taquito/local-forging';\nexport * from './constants';\nexport * from './context';\nexport { TaquitoProvider } from './context';\nexport * from './contract';\nexport * from './contract/big-map';\nexport { CompositeForger } from './forger/composite-forger';\nexport { RpcForger } from './forger/rpc-forger';\nexport * from './operations';\nexport { OperationBatch } from './batch/rpc-batch-provider';\nexport { Signer } from '@taquito/core';\nexport * from './subscribe/interface';\nexport { SubscribeProvider } from './subscribe/interface';\nexport { PollingSubscribeProvider } from './subscribe/polling-subcribe-provider';\nexport { ObservableSubscription } from './subscribe/observable-subscription';\nexport * from './tz/interface';\nexport * from './wallet';\nexport { Extension } from './extension/extension';\nexport * from './injector/interface';\nexport * from './injector/rpc-injector';\nexport * from './parser/interface';\nexport * from './parser/michel-codec-parser';\nexport * from './parser/noop-parser';\nexport * from './packer/interface';\nexport * from './packer/michel-codec-packer';\nexport * from './packer/rpc-packer';\nexport * from './global-constants/default-global-constants-provider';\nexport * from './global-constants/errors';\nexport * from './global-constants/interface-global-constants-provider';\nexport { BigMapQuery, SaplingStateQuery, BlockIdentifier, TzReadProvider, } from './read-provider/interface';\nexport { RpcReadAdapter } from './read-provider/rpc-read-adapter';\nexport * from './estimate';\nexport { TaquitoLocalForger } from './forger/taquito-local-forger';\nexport * from './prepare';\nexport interface SetProviderOptions {\n    forger?: Forger;\n    wallet?: WalletProvider;\n    rpc?: string | RpcClientInterface;\n    readProvider?: TzReadProvider;\n    stream?: string | SubscribeProvider;\n    signer?: Signer;\n    protocol?: Protocols;\n    config?: Partial<ConfigConfirmation>;\n    packer?: Packer;\n    globalConstantsProvider?: GlobalConstantsProvider;\n    parserProvider?: ParserProvider;\n    injectorProvider?: Injector;\n}\nexport interface VersionInfo {\n    commitHash: string;\n    version: string;\n}\n/**\n * @description Facade class that surfaces all of the libraries capability and allow it's configuration\n *\n * @param _rpc The RPC server to use\n */\nexport declare class TezosToolkit {\n    private _rpc;\n    private _options;\n    private _rpcClient;\n    private _wallet;\n    private _context;\n    /**\n     * @deprecated TezosToolkit.batch has been deprecated in favor of TezosToolkit.contract.batch\n     *\n     */\n    batch: RPCBatchProvider['batch'];\n    readonly format: typeof format;\n    constructor(_rpc: RpcClientInterface | string);\n    /**\n     * @description Sets configuration on the Tezos Taquito instance. Allows user to choose which signer, rpc client, rpc url, forger and so forth\n     *\n     * @param options rpc url or rpcClient to use to interact with the Tezos network\n     *\n     * @example Tezos.setProvider({rpc: 'https://mainnet.tezos.ecadinfra.com/', signer: new InMemorySigner.fromSecretKey(\u201cedsk...\u201d)})\n     * @example Tezos.setProvider({ config: { confirmationPollingTimeoutSecond: 300 }})\n     *\n     */\n    setProvider({ rpc, stream, signer, protocol, config, forger, wallet, packer, globalConstantsProvider, readProvider, parserProvider, injectorProvider, }: SetProviderOptions): void;\n    /**\n     * @description Sets signer provider on the Tezos Taquito instance.\n     *\n     * @param options signer to use to interact with the Tezos network\n     *\n     * @example Tezos.setSignerProvider(new InMemorySigner.fromSecretKey('edsk...'))\n     *\n     */\n    setSignerProvider(signer?: SetProviderOptions['signer']): void;\n    /**\n     * @description Sets rpc provider on the Tezos Taquito instance\n     *\n     * @param options rpc url or rpcClient to use to interact with the Tezos network\n     *\n     * @example Tezos.setRpcProvider('https://mainnet.tezos.ecadinfra.com/')\n     *\n     */\n    setRpcProvider(rpc?: SetProviderOptions['rpc']): void;\n    /**\n     * @description Sets forger provider on the Tezos Taquito instance\n     * The `LocalForger` from `@taquito/local-forging` is set by default.\n     *\n     * @param options forger to use to interact with the Tezos network\n     *\n     * @example Tezos.setForgerProvider(this.getFactory(RpcForger)())\n     *\n     */\n    setForgerProvider(forger?: SetProviderOptions['forger']): void;\n    /**\n     * @description Sets stream provider on the Tezos Taquito instance\n     *\n     * @param options stream to use to interact with the Tezos network\n     *\n     * @example Tezos.setStreamProvider(...)\n     *\n     */\n    setStreamProvider(stream?: SetProviderOptions['stream']): void;\n    /**\n     * @description Sets wallet provider on the Tezos Taquito instance\n     *\n     * @param options wallet to use to interact with the Tezos network\n     *\n     * @example Tezos.setWalletProvider(...)\n     *\n     */\n    setWalletProvider(wallet?: SetProviderOptions['wallet']): void;\n    /**\n     * @description Sets Packer provider on the Tezos Taquito instance\n     *\n     * @param options packer to use to interact with the Tezos network\n     *\n     * @example Tezos.setPackerProvider(new MichelCodecPacker())\n     *\n     */\n    setPackerProvider(packer?: SetProviderOptions['packer']): void;\n    /**\n     * @description Sets global constants provider on the Tezos Taquito instance\n     *\n     * @param options globalConstantsProvider to use to interact with the Tezos network\n     *\n     * @example\n     * ```\n     * const globalConst = new DefaultGlobalConstantsProvider();\n     * globalConst.loadGlobalConstant({\n     *  \"expruu5BTdW7ajqJ9XPTF3kgcV78pRiaBW3Gq31mgp3WSYjjUBYxre\": { prim: \"int\" },\n     *  // ...\n     * })\n     * Tezos.setGlobalConstantsProvider(globalConst);\n     * ```\n     *\n     */\n    setGlobalConstantsProvider(globalConstantsProvider?: SetProviderOptions['globalConstantsProvider']): void;\n    /**\n     * @description Sets read provider on the Tezos Taquito instance\n     * By default reads are done from the RPC usign the RpcReadAdapter class, this can be overridden to read from an indexer that implements the TzReadProvider interface\n     *\n     * @param options TzReadProvider to use to interact with the Tezos network\n     *\n     */\n    setReadProvider(readProvider?: SetProviderOptions['readProvider']): void;\n    /**\n     * @description Sets parser provider on the Tezos Taquito instance\n     *\n     * @param options parserProvider to use to interact with the Tezos network\n     *\n     */\n    setParserProvider(parserProvider?: SetProviderOptions['parserProvider']): void;\n    /**\n     * @description Sets injector provider on the Tezos Taquito instance\n     *\n     * @param options Injector to use to interact with the Tezos network by default RpcInjector\n     *\n     */\n    setInjectorProvider(injectorProvider?: SetProviderOptions['injectorProvider']): void;\n    /**\n     * @description Sets the strategy used for field numbering in Token execute/encode/decode to convert Michelson values to/from javascript objects\n     * @param strategy a value of type FieldNumberingStrategy that controls how field numbers are calculated\n     */\n    setFieldNumberingStrategy(strategy: FieldNumberingStrategy): void;\n    /**\n     * @description Provide access to tezos account management\n     */\n    get tz(): TzProvider;\n    /**\n     * @description Provide access to smart contract utilities\n     */\n    get contract(): ContractProvider;\n    /**\n     * @description Provide access to tezos operation preparation utilities\n     */\n    get prepare(): PreparationProvider;\n    get wallet(): Wallet;\n    get operation(): OperationFactory;\n    /**\n     * @description Provide access to operation estimation utilities\n     */\n    get estimate(): EstimationProvider;\n    /**\n     * @description Provide access to streaming utilities backed by an streamer implementation\n     */\n    get stream(): SubscribeProvider;\n    /**\n     * @description Provide access to the currently used rpc client\n     */\n    get rpc(): RpcClientInterface;\n    /**\n     * @description Provide access to the currently used signer\n     */\n    get signer(): Signer;\n    /**\n     * @description Provide access to the currently used globalConstantsProvider\n     */\n    get globalConstants(): GlobalConstantsProvider;\n    /**\n     * @description Allow to add a module to the TezosToolkit instance. This method adds the appropriate Providers(s) required by the module to the internal context.\n     *\n     * @param module extension to add to the TezosToolkit instance\n     *\n     * @example Tezos.addExtension(new Tzip16Module());\n     */\n    addExtension(module: Extension | Extension[]): void;\n    getFactory<T, K extends Array<any>>(ctor: TaquitoProvider<T, K>): (...args: K) => T;\n    /**\n     * @description Gets an object containing the version of Taquito library and git sha of the commit this library is compiled from\n     */\n    getVersionInfo(): VersionInfo;\n}\n"},{name:"@taquito/version.d.ts",dts:"export declare const VERSION: {\n    commitHash: string;\n    version: string;\n};\n"},{name:"@taquito/utils/dist/types/constants.d.ts",dts:'/**\n * @deprecated use PrefixV2 instead, this enum will be removed in the next minor release\n * @description base58 prefix definition enum\n */\nexport declare enum Prefix {\n    TZ1 = "tz1",// ed25519_public_key_hash\n    TZ2 = "tz2",// secp256k1_public_key_hash\n    TZ3 = "tz3",// p256_public_key_hash\n    TZ4 = "tz4",// bls12_381_public_key_hash\n    KT = "KT",\n    KT1 = "KT1",\n    EDSK = "edsk",// ed25519_secret_key\n    EDSK2 = "edsk2",// ed25519_seed\n    SPSK = "spsk",// secp256k1_secret_key\n    P2SK = "p2sk",// p256_secret_key\n    BLSK = "BLsk",// bls12_381_secret_key\n    EDPK = "edpk",// ed25519_public_key\n    SPPK = "sppk",// secp256k1_public_key\n    P2PK = "p2pk",// p256_public_key\n    BLPK = "BLpk",// bls12_381_public_key\n    EDESK = "edesk",// ed25519_encrypted_seed\n    SPESK = "spesk",// secp256k1_encrypted_secret_key\n    P2ESK = "p2esk",// p256_encrypted_secret_key\n    BLESK = "BLesk",// bls12_381_encrypted_secret_key\n    EDSIG = "edsig",// ed25519_signature\n    SPSIG = "spsig",// secp256k1_signature\n    P2SIG = "p2sig",// p256_signature\n    BLSIG = "BLsig",// bls12_381_signature\n    SIG = "sig",// generic_signature\n    NET = "Net",// chain_id\n    NCE = "nce",\n    B = "B",// block_hash\n    O = "o",// operation_hash\n    LO = "Lo",// operation_list_hash\n    LLO = "LLo",// operation_list_list_hash\n    P = "P",// protocol_hash\n    CO = "Co",// context_hash\n    ID = "id",// cryptobox_public_key_hash\n    EXPR = "expr",\n    TZ = "TZ",\n    VH = "vh",// block_payload_hash\n    SASK = "sask",// sapling_spending_key\n    ZET1 = "zet1",// sapling_address\n    SR1 = "sr1",// smart_rollup_address\n    SRC1 = "src1",// smart_rollup_commitment\n    SH = "sh"\n}\n/**\n * @deprecated use prefixV2 instead this constant will be removed in the next minor release\n * @description base58 prefix to bytes mapping\n */\nexport declare const prefix: {\n    tz1: Uint8Array;\n    tz2: Uint8Array;\n    tz3: Uint8Array;\n    tz4: Uint8Array;\n    KT: Uint8Array;\n    KT1: Uint8Array;\n    edsk: Uint8Array;\n    edsk2: Uint8Array;\n    spsk: Uint8Array;\n    p2sk: Uint8Array;\n    BLsk: Uint8Array;\n    edpk: Uint8Array;\n    sppk: Uint8Array;\n    p2pk: Uint8Array;\n    BLpk: Uint8Array;\n    edesk: Uint8Array;\n    spesk: Uint8Array;\n    p2esk: Uint8Array;\n    BLesk: Uint8Array;\n    edsig: Uint8Array;\n    spsig: Uint8Array;\n    p2sig: Uint8Array;\n    BLsig: Uint8Array;\n    sig: Uint8Array;\n    Net: Uint8Array;\n    nce: Uint8Array;\n    B: Uint8Array;\n    o: Uint8Array;\n    Lo: Uint8Array;\n    LLo: Uint8Array;\n    P: Uint8Array;\n    Co: Uint8Array;\n    id: Uint8Array;\n    expr: Uint8Array;\n    TZ: Uint8Array;\n    vh: Uint8Array;\n    sask: Uint8Array;\n    zet1: Uint8Array;\n    sr1: Uint8Array;\n    src1: Uint8Array;\n    sh: Uint8Array;\n};\n/**\n * @deprecated use payloadLength instead this constant will be removed in the next minor release\n * @description base58 prefix to payload length mapping\n */\nexport declare const prefixLength: {\n    [key: string]: number;\n};\n/**\n * @description base58 name to prefix mapping\n */\nexport declare enum PrefixV2 {\n    BlockHash = "B",\n    OperationHash = "o",\n    OperationListHash = "Lo",\n    OperationListListHash = "LLo",\n    ProtocolHash = "P",\n    ContextHash = "Co",\n    BlockMetadataHash = "bm",\n    OperationMetadataHash = "r",\n    OperationMetadataListHash = "Lr",\n    OperationMetadataListListHash = "LLr",\n    Ed25519PublicKeyHash = "tz1",\n    Secp256k1PublicKeyHash = "tz2",\n    P256PublicKeyHash = "tz3",\n    ContractHash = "KT1",\n    BlindedPublicKeyHash = "btz1",\n    BLS12_381PublicKeyHash = "tz4",\n    TXRollupAddress = "txr1",\n    ZkRollupHash = "epx1",\n    ScRollupHash = "scr1",\n    SmartRollupHash = "sr1",\n    CryptoboxPublicKeyHash = "id",\n    Ed25519Seed = "edsk",\n    Ed25519PublicKey = "edpk",\n    Secp256k1SecretKey = "spsk",\n    P256SecretKey = "p2sk",\n    BLS12_381SecretKey = "BLsk",\n    ValueHash = "vh",\n    CycleNonce = "nce",\n    ScriptExpr = "expr",\n    InboxHash = "txi",\n    MessageHash = "txm",\n    CommitmentHash = "txc",\n    MessageResultHash = "txmr",\n    MessageResultListHash = "txM",\n    WithdrawListHash = "txw",\n    ScRollupStateHash = "scs1",\n    ScRollupCommitmentHash = "scc1",\n    SmartRollupStateHash = "srs1",\n    SmartRollupCommitmentHash = "src1",\n    Ed25519EncryptedSeed = "edesk",\n    Secp256k1EncryptedSecretKey = "spesk",\n    P256EncryptedSecretKey = "p2esk",\n    BLS12_381EncryptedSecretKey = "BLesk",\n    Secp256k1EncryptedScalar = "seesk",\n    Secp256k1PublicKey = "sppk",\n    P256PublicKey = "p2pk",\n    Secp256k1Scalar = "SSp",\n    Secp256k1Element = "GSp",\n    Ed25519SecretKey = "_edsk",\n    Ed25519Signature = "edsig",\n    Secp256k1Signature = "spsig1",\n    P256Signature = "p2sig",\n    GenericSignature = "sig",\n    ChainID = "Net",\n    SaplingSpendingKey = "sask",\n    EncryptedSaplingSpendingKey = "_sask",\n    SaplingAddress = "zet1",\n    GenericAggregateSignature = "asig",\n    BLS12_381Signature = "BLsig",\n    BLS12_381PublicKey = "BLpk",\n    SlotHeader = "sh"\n}\n/**\n * @description base58 prefix to bytes mapping\n */\nexport declare const prefixV2: {\n    [key in PrefixV2]: Uint8Array;\n};\n/**\n * @description base58 prefix to payload length mapping\n */\nexport declare const payloadLength: {\n    [key in PrefixV2]: number;\n};\n'},{name:"@taquito/utils/dist/types/errors.d.ts",dts:"import { ParameterValidationError, UnsupportedActionError, ValidationResult } from '@taquito/core';\nexport { InvalidAddressError, InvalidBlockHashError, InvalidHexStringError, InvalidMessageError, InvalidKeyError, InvalidPublicKeyError, InvalidSignatureError, InvalidContractAddressError, InvalidChainIdError, InvalidKeyHashError, InvalidOperationHashError, InvalidOperationKindError, DeprecationError, ProhibitedActionError, } from '@taquito/core';\n/**\n *  @category Error\n *  @description Error that indicates invalid protocol hash being passed or used\n */\nexport declare class InvalidProtocolHashError extends ParameterValidationError {\n    readonly protocolHash: string;\n    name: string;\n    constructor(protocolHash: string, errorDetails?: string | ValidationResult);\n}\n/**\n *  @category Error\n *  @description Error that indicates unable to convert data type from one to another\n */\nexport declare class ValueConversionError extends UnsupportedActionError {\n    readonly value: string;\n    readonly desiredType: string;\n    constructor(value: string, desiredType: string);\n}\n"},{name:"@taquito/utils/dist/types/format.d.ts",dts:"import BigNumber from 'bignumber.js';\ntype Format = 'tz' | 'mtz' | 'mutez';\nexport declare function format(from: Format | undefined, to: Format | undefined, amount: number | string | BigNumber): string | number | BigNumber;\nexport {};\n"},{name:"@taquito/utils/dist/types/taquito-utils.d.ts",dts:"/**\n * @packageDocumentation\n * @module @taquito/utils\n */\nimport { Buffer } from 'buffer';\nimport { PrefixV2 } from './constants';\nimport BigNumber from 'bignumber.js';\nexport * from './validators';\nexport { VERSION } from './version';\nexport { prefix, Prefix, prefixLength } from './constants';\nexport { PrefixV2, payloadLength } from './constants';\nexport { validatePkAndExtractPrefix } from './verify-signature';\nexport { verifySignature, BLS12_381_DST, POP_DST } from './verify-signature';\nexport * from './errors';\nexport { format } from './format';\n/**\n * @description list of prefixes that can be used to decode an address\n */\nexport declare const addressPrefixes: PrefixV2[];\n/**\n * @description list of prefixes that can be used to decode a public key\n */\nexport declare const publicKeyPrefixes: PrefixV2[];\n/**\n * @description list of prefixes that can be used to decode a public key hash\n */\nexport declare const publicKeyHashPrefixes: PrefixV2[];\n/**\n * @description list of prefixes that can be used to decode a signature\n */\nexport declare const signaturePrefixes: PrefixV2[];\n/**\n * @description Decodes Base58 string, looks for known prefix and strips it\n * @param src Base58 string\n * @returns Payload and prefix\n * @example b58DecodeAndCheckPrefix('tz1gvF4cD2dDtqitL3ZTraggSR1Mju2BKFEM') // returns [Uint8Array, PrefixV2.Ed25519PublicKeyHash]\n * @example b58DecodeAndCheckPrefix('tz1gvF4cD2dDtqitL3ZTraggSR1Mju2BKFEM', [PrefixV2.Ed25519PublicKeyHash]) // returns [Uint8Array, PrefixV2.Ed25519PublicKeyHash]\n * @example b58DecodeAndCheckPrefix('tz1gvF4cD2dDtqitL3ZTraggSR1Mju2BKFEM', [PrefixV2.Ed25519PublicKeyHash], true) // returns Uint8Array\n */\nexport declare function b58DecodeAndCheckPrefix<T extends readonly PrefixV2[]>(src: string, allowed?: T): [Uint8Array, T[number]];\nexport declare function b58DecodeAndCheckPrefix<T extends readonly PrefixV2[]>(src: string, allowed: T, payloadOnly: false): [Uint8Array, T[number]];\nexport declare function b58DecodeAndCheckPrefix<T extends readonly PrefixV2[]>(src: string, allowed: T, payloadOnly: true): Uint8Array;\n/**\n * @description Decode a Base58 public key and return its binary representation\n * @param value Value to decode\n * @param fmt optional format of the decoded return value, 'hex' or 'array'\n * @returns string or Uint8Array of bytes\n * @example b58DecodePublicKey('edpkuNjKKT48xBoT5asPrWdmuM1Yw8D93MwgFgVvtca8jb5pstzaCh') // return '0060842d4ba23a9940ef5dcf4404fdaa430cfaaccb5029fad06cb5ea894e4562ae'\n */\nexport declare function b58DecodePublicKey(value: string, fmt?: 'hex'): string;\nexport declare function b58DecodePublicKey(value: string, fmt: 'array'): Uint8Array;\n/**\n * @description Decode a Base58 public key hash and return its binary representation\n * @param value Value to decode\n * @param fmt optional format of the decoded return value, 'hex' or 'array'\n * @returns string or Uint8Array of bytes\n * @example b58DecodePublicKeyHash('tz2MVED1t9Jery77Bwm1m5YhUx8Wp5KWWRQe') // return '0001907d6a7e9f084df840d6e67ffa8db5464f87d4d1'\n */\nexport declare function b58DecodePublicKeyHash(value: string, fmt?: 'hex'): string;\nexport declare function b58DecodePublicKeyHash(value: string, fmt: 'array'): Uint8Array;\n/**\n * @description Decode a Base58 string and assert tz4 type\n * @param value a bls address(tz4) to decode\n * @param fmt optional format of the decoded return value, 'hex' or 'array'\n * @returns string or Uint8Array of bytes\n * @example b58DecodeBlsAddress('tz4QyWfEiv56CVDATV3DT3CDVhPaMKif2Ce8') // return 'af2dc3c40667abc0e89c0ef40171d22aed08d5eb'\n */\nexport declare function b58DecodeBlsAddress(value: string, fmt?: 'hex'): string;\nexport declare function b58DecodeBlsAddress(value: string, fmt: 'array'): Uint8Array;\n/**\n * @description Decode a Base58 contract ID and return its binary representation\n * @param value Value to decode\n * @param fmt optional format of the decoded return value, 'hex' or 'array'\n * @returns string or Uint8Array of bytes\n * @example b58DecodeAddress('tz1gvF4cD2dDtqitL3ZTraggSR1Mju2BKFEM') // return '0000e96b9f8b19af9c7ffa0c0480e1977b295850961f'\n */\nexport declare function b58DecodeAddress(value: string, fmt?: 'hex'): string;\nexport declare function b58DecodeAddress(value: string, fmt: 'array'): Uint8Array;\n/**\n *  @description Gets Tezos address (PKH) from Public Key\n *  @param publicKey Base58 Public Key\n *  @returns A string of the Tezos address (PKH) that was derived from the given Public Key\n *  @example getPkhfromPk('edpkuNjKKT48xBoT5asPrWdmuM1Yw8D93MwgFgVvtca8jb5pstzaCh') // return 'tz2MVED1t9Jery77Bwm1m5YhUx8Wp5KWWRQe'\n */\nexport declare function getPkhfromPk(publicKey: string): string;\n/**\n * @description Add the prefix to a hex string or Uint8Array and Base58 encode it\n * @param value Value to Base58 encode\n * @param pre prefix ID to append to the encoded string\n * @example b58Encode('e96b9f8b19af9c7ffa0c0480e1977b295850961f', PrefixV2.Ed25519PublicKeyHash) // returns 'tz1gvF4cD2dDtqitL3ZTraggSR1Mju2BKFEM'\n */\nexport declare function b58Encode(value: string | Uint8Array, pre: PrefixV2): string;\n/**\n * @description Parse binary public key and return Base58 representation\n * @param value Binary key data\n * @returns return prefixed public key\n * @example encodeKey('02033aba7da4a2e7b5dd9f074555c118829aff16213ea1b65859686bd5fcfeaf3616') // return 'p2pk66xmhjiN7LpfrDGFwpxPtJxkLtPjQ6HUxJbKmRbxSR7RMpamDwi'\n */\nexport declare function encodeKey(value: string | Uint8Array): string;\n/**\n * @description Parse binary public key hash and return Base58 representation\n * @param value Key hash to parse\n * @returns return prefixed public key hash\n * @example encodeKeyHash('0001907d6a7e9f084df840d6e67ffa8db5464f87d4d1') // return 'tz2MVED1t9Jery77Bwm1m5YhUx8Wp5KWWRQe'\n */\nexport declare function encodeKeyHash(value: string | Uint8Array): string;\n/**\n * @description Parse binary Contract ID and return Base58 representation\n * @param value Address to parse (tz1, tz2, tz3, KT1, or sr1).\n * @example encodeAddress('0000e96b9f8b19af9c7ffa0c0480e1977b295850961f') // return 'tz1gvF4cD2dDtqitL3ZTraggSR1Mju2BKFEM'\n */\nexport declare function encodeAddress(value: string | Uint8Array): string;\n/**\n * @description Base58 encode an address without predefined prefix\n * @param value Address to base58 encode (tz4) hex dec\n * @returns return address\n * @example encodeBlsAddress('af2dc3c40667abc0e89c0ef40171d22aed08d5eb') // return 'tz4QyWfEiv56CVDATV3DT3CDVhPaMKif2Ce8'\n */\nexport declare function encodeBlsAddress(value: string): string;\n/**\n * @description convert a fragment of Michelson code in hex string to an 'expr' prefix + base58 encoded BLAKE2b hash string\n * @param value a fragment of Michelson code in hex string\n * @returns return 'expr' prefix + base58 encoded BLAKE2b hash\n * @example encodeExpr('050a000000160000b2e19a9e74440d86c59f13dab8a18ff873e889ea') // return 'exprv6UsC1sN3Fk2XfgcJCL8NCerP5rCGy1PRESZAqr7L2JdzX55EN'\n */\nexport declare function encodeExpr(value: string): string;\n/**\n * @description convert a signed operation in hex string to an 'op' prefix + base58 encoded BLAKE2b hash string\n * @param value signed operation in hex string\n * @returns return 'op' prefix + base58 encoded BLAKE2b hash\n * @example encodeOpHash('0f185d8a30061e8134c162dbb7a6c3ab8f5fdb153363ccd6149b49a33481156a6c00b2e19a9e74440d86c59f13dab8a18ff873e889eaa304ab05da13000001f1585a7384f36e45fb43dc37e8ce172bced3e05700ff0000000002002110c033f3a990c2e46a3d6054ecc2f74072aae7a34b5ac4d9ce9edc11c2410a97695682108951786f05b361da03b97245dc9897e1955e08b5b8d9e153b0bdeb0d') // return 'opapqvVXmebRTCFd2GQFydr4tJj3V5QocQuTmuhbatcHm4Seo2t'\n */\nexport declare function encodeOpHash(value: string): string;\n/**\n * @description Convert an hex string to a Uint8Array\n * @param hex Hex string to convert\n * @throws {@link ValueConversionError}\n */\nexport declare function hex2buf(hex: string): Uint8Array;\n/**\n * @description Merge 2 buffers together\n * @param b1 First buffer\n * @param b2 Second buffer\n */\nexport declare function mergebuf(b1: Uint8Array, b2: Uint8Array): Uint8Array;\n/**\n * @description Flatten a michelson json representation to an array\n * @param s michelson json\n */\nexport declare function mic2arr(s: any): any;\n/**\n * @description Convert a Uint8Array to an hex string\n * @param buffer Uint8Array to convert\n */\nexport declare function buf2hex(bytes: ArrayLike<number>): string;\n/**\n * @description Convert a string to a byte string representation\n * @param str String to convert\n */\nexport declare function stringToBytes(str: string): string;\n/**\n * @description Convert byte string representation to string\n * @param hex byte string to convert\n */\nexport declare function bytesToString(hex: string): string;\n/**\n * @description Convert hex string/UintArray/Buffer to bytes\n * @param hex String value to convert to bytes\n */\nexport declare function hex2Bytes(hex: string): Buffer;\n/**\n * @description Converts a number or Bignumber to hexadecimal  string\n * @param val The value  that will be converted to a hexadecimal string value\n */\nexport declare function toHexBuf(val: number | BigNumber, bitLength?: number): Buffer;\nexport declare function numToHexBuffer(val: number | BigNumber, bitLength?: number): Buffer;\n/**\n * @description Converts a number or BigNumber to a padded hexadecimal string\n * @param val The value that will be converted into a padded hexadecimal string value\n * @param bitLength The length of bits\n *\n */\nexport declare function num2PaddedHex(val: number | BigNumber, bitLength?: number): string;\n/**\n *\n * @description Strips the first 2 characters of a hex string (0x)\n *\n * @param hex string to strip prefix from\n */\nexport declare function stripHexPrefix(hex: string): string;\nexport declare function splitAddress(addr: string): [string, string | null];\nexport declare function compareArrays(a: ArrayLike<number>, b: ArrayLike<number>): number;\n/**\n * @deprecated use b58DecodeAndCheckPrefix instead, this function will be removed in the next minor release\n * @description Base58 decode a string and remove the prefix from it\n * @param enc Value to base58 decode\n * @param prefixArg prefix to remove from the decoded string\n */\nexport declare function b58cdecode(enc: string, prefixArg: Uint8Array): Uint8Array;\n/**\n * @deprecated use b58Encode instead, this function will be removed in the next minor release\n * @description Base58 encode a string or a Uint8Array and append a prefix to it\n * @param value Value to base58 encode\n * @param prefix prefix to append to the encoded string\n */\nexport declare function b58cencode(value: string | Uint8Array, prefix: Uint8Array): string;\n/**\n * @deprecated use b58DecodePublicKey, b58DecodePublicKeyHash, b58DecodeBlsAddress, b58DecodeAddress instead, this function will be removed in the next minor release\n * @description Base58 decode a string with predefined prefix\n * @param payload Value to base58 decode\n */\nexport declare function b58decode(payload: string): string;\n/**\n * @deprecated use b58DecodeBlsAddress instead, this function will be removed in the next minor release\n * @description b58 decode a string without predefined prefix\n * @param payload Value to base58 decode\n * @returns string of bytes\n */\nexport declare function b58decodeL2Address(payload: string): string;\n/**\n * @deprecated use encodeAddress instead, this function will be removed in the next minor release\n * @description Base58 encode an address using predefined prefix\n * @param value Address to base58 encode (tz1, tz2, tz3 or KT1)\n */\nexport declare function encodePubKey(value: string): string;\n/**\n * @deprecated use encodeBlsAddress instead, this function will be removed in the next minor release\n * @description Base58 encode an address without predefined prefix\n * @param value Address to base58 encode (tz4) hex dec\n * @returns return address\n */\nexport declare function encodeL2Address(value: string): string;\n/**\n * @deprecated use stringToBytes instead, this function will be removed in the next minor release\n * @description Convert a string to bytes\n * @param str String to convert\n */\nexport declare function char2Bytes(str: string): string;\n/**\n * @deprecated use bytesToString instead, this function will be removed in the next minor release\n * @description Convert bytes to a string\n * @param hex Bytes to convert\n */\nexport declare function bytes2Char(hex: string): string;\n"},{name:"@taquito/utils/dist/types/validators.d.ts",dts:"import { PrefixV2 } from './constants';\nimport { ValidationResult } from './taquito-utils';\nexport { ValidationResult } from '@taquito/core';\n/**\n * @description Used to check if a value has one of the allowed prefixes.\n * @returns true if the value has one of the allowed prefixes, false otherwise\n * @example\n * ```\n * import { isValidPrefixedValue } from '@taquito/utils';\n * const value = 'tz1L9r8mWmRPndRhuvMCWESLGSVeFzQ9NAWx'\n * const isValid = isValidPrefixedValue(value, [PrefixV2.Ed25519PublicKeyHash])\n * console.log(isValid) // true\n * ```\n */\nexport declare function isValidPrefixedValue(value: string, prefixes?: PrefixV2[]): boolean;\n/**\n * @description Used to check if an address or a contract address is valid.\n *\n * @returns\n * 0 = NO_PREFIX_MATCHED, 1 = INVALID_CHECKSUM, 2 = INVALID_LENGTH, 3 = VALID, 4 = PREFIX_NOT_ALLOWED, 5 = INVALID_ENCODING, 6 = OTHER,\n *\n * @example\n * ```\n * import { validateAddress } from '@taquito/utils';\n * const pkh = 'tz1L9r8mWmRPndRhuvMCWESLGSVeFzQ9NAWx'\n * const validation = validateAddress(pkh)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport declare function validateAddress(value: string): ValidationResult;\n/**\n * @description Used to check if a chain id is valid.\n *\n * @returns\n * 0 = NO_PREFIX_MATCHED, 1 = INVALID_CHECKSUM, 2 = INVALID_LENGTH, 3 = VALID, 4 = PREFIX_NOT_ALLOWED, 5 = INVALID_ENCODING, 6 = OTHER,\n *\n * @example\n * ```\n * import { validateChain } from '@taquito/utils';\n * const chainId = 'NetXdQprcVkpaWU'\n * const validation = validateChain(chainId)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport declare function validateChain(value: string): ValidationResult;\n/**\n * @description Used to check if a contract address is valid.\n *\n * @returns\n * 0 = NO_PREFIX_MATCHED, 1 = INVALID_CHECKSUM, 2 = INVALID_LENGTH, 3 = VALID, 4 = PREFIX_NOT_ALLOWED, 5 = INVALID_ENCODING, 6 = OTHER,\n *\n * @example\n * ```\n * import { validateContractAddress } from '@taquito/utils';\n * const contractAddress = 'KT1JVErLYTgtY8uGGZ4mso2npTSxqVLDRVbC'\n * const validation = validateContractAddress(contractAddress)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport declare function validateContractAddress(value: string): ValidationResult;\n/**\n * @description Used to check if a key hash is valid.\n *\n * @returns\n * 0 = NO_PREFIX_MATCHED, 1 = INVALID_CHECKSUM, 2 = INVALID_LENGTH, 3 = VALID, 4 = PREFIX_NOT_ALLOWED, 5 = INVALID_ENCODING, 6 = OTHER,\n *\n * @example\n * ```\n * import { validateKeyHash } from '@taquito/utils';\n * const keyHashWithoutPrefix = '1L9r8mWmRPndRhuvMCWESLGSVeFzQ9NAWx'\n * const validation = validateKeyHash(keyHashWithoutPrefix)\n * console.log(validation)\n * // This example return 0 which correspond to NO_PREFIX_MATCHED\n * ```\n */\nexport declare function validateKeyHash(value: string): ValidationResult;\n/**\n * @description Used to check if a signature is valid.\n *\n * @returns\n * 0 = NO_PREFIX_MATCHED, 1 = INVALID_CHECKSUM, 2 = INVALID_LENGTH, 3 = VALID, 4 = PREFIX_NOT_ALLOWED, 5 = INVALID_ENCODING, 6 = OTHER,\n *\n * @example\n * ```\n * import { validateSignature } from '@taquito/utils';\n * const signature = 'edsigtkpiSSschcaCt9pUVrpNPf7TTcgvgDEDD6NCEHMy8NNQJCGnMfLZzYoQj74yLjo9wx6MPVV29CvVzgi7qEcEUok3k7AuMg'\n * const validation = validateSignature(signature)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport declare function validateSignature(value: string): ValidationResult;\n/**\n * @description Used to check if a public key is valid.\n *\n * @returns\n * 0 = NO_PREFIX_MATCHED, 1 = INVALID_CHECKSUM, 2 = INVALID_LENGTH, 3 = VALID, 4 = PREFIX_NOT_ALLOWED, 5 = INVALID_ENCODING, 6 = OTHER,\n *\n * @example\n * ```\n * import { validatePublicKey } from '@taquito/utils';\n * const publicKey = 'edpkvS5QFv7KRGfa3b87gg9DBpxSm3NpSwnjhUjNBQrRUUR66F7C9g'\n * const validation = validatePublicKey(publicKey)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport declare function validatePublicKey(value: string): ValidationResult;\n/**\n * @description Used to check if an operation hash is valid.\n *\n * @returns\n * 0 = NO_PREFIX_MATCHED, 1 = INVALID_CHECKSUM, 2 = INVALID_LENGTH, 3 = VALID, 4 = PREFIX_NOT_ALLOWED, 5 = INVALID_ENCODING, 6 = OTHER,\n *\n * @example\n * ```\n * import { validateOperation } from '@taquito/utils';\n * const operationHash = 'oo6JPEAy8VuMRGaFuMmLNFFGdJgiaKfnmT1CpHJfKP3Ye5ZahiP'\n * const validation = validateOperation(operationHash)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport declare function validateOperation(value: string): ValidationResult;\n/**\n * @description Used to check if a protocol hash is valid.\n *\n * @returns\n * 0 = NO_PREFIX_MATCHED, 1 = INVALID_CHECKSUM, 2 = INVALID_LENGTH, 3 = VALID, 4 = PREFIX_NOT_ALLOWED, 5 = INVALID_ENCODING, 6 = OTHER,\n *\n * @example\n * ```\n * import { validateProtocol } from '@taquito/utils';\n * const protocolHash = 'PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx'\n * const validation = validateProtocol(protocolHash)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport declare function validateProtocol(value: string): ValidationResult;\n/**\n * @description Used to check if a block hash is valid.\n *\n * @returns\n * 0 = NO_PREFIX_MATCHED, 1 = INVALID_CHECKSUM, 2 = INVALID_LENGTH, 3 = VALID, 4 = PREFIX_NOT_ALLOWED, 5 = INVALID_ENCODING, 6 = OTHER,\n *\n * @example\n * ```\n * import { validateBlock } from '@taquito/utils';\n * const blockHash = 'PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx'\n * const validation = validateBlock(blockHash)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport declare function validateBlock(value: string): ValidationResult;\n/**\n * @deprecated this function will be removed in the next minor release\n * @description generates a readable error string from a validation result\n */\nexport declare function invalidDetail(validation: ValidationResult): string;\n/**\n * @description Used to check if a spending key is valid.\n * @returns\n * 0 = NO_PREFIX_MATCHED, 1 = INVALID_CHECKSUM, 2 = INVALID_LENGTH, 3 = VALID, 4 = PREFIX_NOT_ALLOWED, 5 = INVALID_ENCODING, 6 = OTHER,\n *\n */\nexport declare function validateSpendingKey(value: string): ValidationResult;\nexport declare function validateSmartRollupAddress(value: string): ValidationResult;\n"},{name:"@taquito/utils/dist/types/verify-signature.d.ts",dts:"import { PrefixV2 } from './taquito-utils';\nexport declare const BLS12_381_DST = \"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_\";\nexport declare const POP_DST = \"BLS_POP_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_\";\n/**\n * @description Verify signature of a payload\n * @param message The forged message including the magic byte (11 for block, 12 for preattestation, 13 for attestation, 3 for generic, 5 for the PACK format of michelson) in string or Uint8Array\n * @param publicKey The public key to verify the signature against\n * @param signature The signature to verify\n * @param watermark Optional if not included in the message\n * @param pop Optional if verifying proof of possession signature\n * @returns A boolean indicating if the signature matches\n * @throws {@link InvalidPublicKeyError} | {@link InvalidSignatureError} | {@link InvalidMessageError}\n * @example\n * ```\n * const message = '03d0c10e3ed11d7c6e3357f6ef335bab9e8f2bd54d0ce20c482e241191a6e4b8ce6c01be917311d9ac46959750e405d57e268e2ed9e174a80794fbd504e12a4a000141eb3781afed2f69679ff2bbe1c5375950b0e40d00ff000000005e05050505050507070100000024747a32526773486e74516b72794670707352466261313652546656503539684b72654a4d07070100000024747a315a6672455263414c42776d4171776f6e525859565142445439426a4e6a42484a750001';\n * const pk = 'sppk7c7hkPj47yjYFEHX85q46sFJGw6RBrqoVSHwAJAT4e14KJwzoey';\n * const sig = 'spsig1cdLkp1RLgUHAp13aRFkZ6MQDPp7xCnjAExGL3MBSdMDmT6JgQSX8cufyDgJRM3sinFtiCzLbsyP6d365EHoNevxhT47nx'\n *\n * const response = verifySignature(message, pk, sig);\n * ```\n *\n */\nexport declare function verifySignature(message: string | Uint8Array, publicKey: string, signature: string, watermark?: Uint8Array, pop?: boolean): boolean;\ntype PkPrefix = PrefixV2.Ed25519PublicKey | PrefixV2.Secp256k1PublicKey | PrefixV2.P256PublicKey | PrefixV2.BLS12_381PublicKey;\n/**\n * @deprecated use b58DecodeAndCheckPrefix instead, this function will be removed in the next minor release\n * @description validates a public key and extracts the prefix\n */\nexport declare function validatePkAndExtractPrefix(publicKey: string): PkPrefix;\nexport {};\n"},{name:"@taquito/utils/dist/types/version.d.ts",dts:"export declare const VERSION: {\n    commitHash: string;\n    version: string;\n};\n"},{name:"@taquito/utils/node_modules/@stablelib/binary/lib/binary.d.ts",dts:'/**\n * Reads 2 bytes from array starting at offset as big-endian\n * signed 16-bit integer and returns it.\n */\nexport declare function readInt16BE(array: Uint8Array, offset?: number): number;\n/**\n * Reads 2 bytes from array starting at offset as big-endian\n * unsigned 16-bit integer and returns it.\n */\nexport declare function readUint16BE(array: Uint8Array, offset?: number): number;\n/**\n * Reads 2 bytes from array starting at offset as little-endian\n * signed 16-bit integer and returns it.\n */\nexport declare function readInt16LE(array: Uint8Array, offset?: number): number;\n/**\n * Reads 2 bytes from array starting at offset as little-endian\n * unsigned 16-bit integer and returns it.\n */\nexport declare function readUint16LE(array: Uint8Array, offset?: number): number;\n/**\n * Writes 2-byte big-endian representation of 16-bit unsigned\n * value to byte array starting at offset.\n *\n * If byte array is not given, creates a new 2-byte one.\n *\n * Returns the output byte array.\n */\nexport declare function writeUint16BE(value: number, out?: Uint8Array, offset?: number): Uint8Array;\nexport declare const writeInt16BE: typeof writeUint16BE;\n/**\n * Writes 2-byte little-endian representation of 16-bit unsigned\n * value to array starting at offset.\n *\n * If byte array is not given, creates a new 2-byte one.\n *\n * Returns the output byte array.\n */\nexport declare function writeUint16LE(value: number, out?: Uint8Array, offset?: number): Uint8Array;\nexport declare const writeInt16LE: typeof writeUint16LE;\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * signed 32-bit integer and returns it.\n */\nexport declare function readInt32BE(array: Uint8Array, offset?: number): number;\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * unsigned 32-bit integer and returns it.\n */\nexport declare function readUint32BE(array: Uint8Array, offset?: number): number;\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * signed 32-bit integer and returns it.\n */\nexport declare function readInt32LE(array: Uint8Array, offset?: number): number;\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * unsigned 32-bit integer and returns it.\n */\nexport declare function readUint32LE(array: Uint8Array, offset?: number): number;\n/**\n * Writes 4-byte big-endian representation of 32-bit unsigned\n * value to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nexport declare function writeUint32BE(value: number, out?: Uint8Array, offset?: number): Uint8Array;\nexport declare const writeInt32BE: typeof writeUint32BE;\n/**\n * Writes 4-byte little-endian representation of 32-bit unsigned\n * value to array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nexport declare function writeUint32LE(value: number, out?: Uint8Array, offset?: number): Uint8Array;\nexport declare const writeInt32LE: typeof writeUint32LE;\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * signed 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports exact\n * numbers in range -9007199254740991 to 9007199254740991.\n * If the number stored in the byte array is outside this range,\n * the result is not exact.\n */\nexport declare function readInt64BE(array: Uint8Array, offset?: number): number;\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * unsigned 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.\n */\nexport declare function readUint64BE(array: Uint8Array, offset?: number): number;\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * signed 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports exact\n * numbers in range -9007199254740991 to 9007199254740991.\n * If the number stored in the byte array is outside this range,\n * the result is not exact.\n */\nexport declare function readInt64LE(array: Uint8Array, offset?: number): number;\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * unsigned 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.\n */\nexport declare function readUint64LE(array: Uint8Array, offset?: number): number;\n/**\n * Writes 8-byte big-endian representation of 64-bit unsigned\n * value to byte array starting at offset.\n *\n * Due to JavaScript limitation, supports values up to 2^53-1.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nexport declare function writeUint64BE(value: number, out?: Uint8Array, offset?: number): Uint8Array;\nexport declare const writeInt64BE: typeof writeUint64BE;\n/**\n * Writes 8-byte little-endian representation of 64-bit unsigned\n * value to byte array starting at offset.\n *\n * Due to JavaScript limitation, supports values up to 2^53-1.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nexport declare function writeUint64LE(value: number, out?: Uint8Array, offset?: number): Uint8Array;\nexport declare const writeInt64LE: typeof writeUint64LE;\n/**\n * Reads bytes from array starting at offset as big-endian\n * unsigned bitLen-bit integer and returns it.\n *\n * Supports bit lengths divisible by 8, up to 48.\n */\nexport declare function readUintBE(bitLength: number, array: Uint8Array, offset?: number): number;\n/**\n * Reads bytes from array starting at offset as little-endian\n * unsigned bitLen-bit integer and returns it.\n *\n * Supports bit lengths divisible by 8, up to 48.\n */\nexport declare function readUintLE(bitLength: number, array: Uint8Array, offset?: number): number;\n/**\n * Writes a big-endian representation of bitLen-bit unsigned\n * value to array starting at offset.\n *\n * Supports bit lengths divisible by 8, up to 48.\n *\n * If byte array is not given, creates a new one.\n *\n * Returns the output byte array.\n */\nexport declare function writeUintBE(bitLength: number, value: number, out?: Uint8Array, offset?: number): Uint8Array;\n/**\n * Writes a little-endian representation of bitLen-bit unsigned\n * value to array starting at offset.\n *\n * Supports bit lengths divisible by 8, up to 48.\n *\n * If byte array is not given, creates a new one.\n *\n * Returns the output byte array.\n */\nexport declare function writeUintLE(bitLength: number, value: number, out?: Uint8Array, offset?: number): Uint8Array;\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * 32-bit floating-point number and returns it.\n */\nexport declare function readFloat32BE(array: Uint8Array, offset?: number): number;\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * 32-bit floating-point number and returns it.\n */\nexport declare function readFloat32LE(array: Uint8Array, offset?: number): number;\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * 64-bit floating-point number ("double") and returns it.\n */\nexport declare function readFloat64BE(array: Uint8Array, offset?: number): number;\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * 64-bit floating-point number ("double") and returns it.\n */\nexport declare function readFloat64LE(array: Uint8Array, offset?: number): number;\n/**\n * Writes 4-byte big-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nexport declare function writeFloat32BE(value: number, out?: Uint8Array, offset?: number): Uint8Array;\n/**\n * Writes 4-byte little-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\nexport declare function writeFloat32LE(value: number, out?: Uint8Array, offset?: number): Uint8Array;\n/**\n * Writes 8-byte big-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nexport declare function writeFloat64BE(value: number, out?: Uint8Array, offset?: number): Uint8Array;\n/**\n * Writes 8-byte little-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\nexport declare function writeFloat64LE(value: number, out?: Uint8Array, offset?: number): Uint8Array;\n'},{name:"@taquito/utils/node_modules/@stablelib/binary/lib/binary.test.d.ts",dts:"export {};\n"},{name:"@taquito/utils/node_modules/@stablelib/blake2b/lib/blake2b.bench.d.ts",dts:"export {};\n"},{name:"@taquito/utils/node_modules/@stablelib/blake2b/lib/blake2b.d.ts",dts:'/**\n * Package blake2b implements BLAKE2b cryptographic hash function.\n */\nimport { SerializableHash } from "@stablelib/hash";\nexport declare const BLOCK_SIZE = 128;\nexport declare const DIGEST_LENGTH = 64;\nexport declare const KEY_LENGTH = 64;\nexport declare const PERSONALIZATION_LENGTH = 16;\nexport declare const SALT_LENGTH = 16;\nexport declare const MAX_LEAF_SIZE: number;\nexport declare const MAX_FANOUT = 255;\nexport declare const MAX_MAX_DEPTH = 255;\n/**\n * Configuration for hash function.\n */\nexport declare type Config = {\n    key?: Uint8Array;\n    salt?: Uint8Array;\n    personalization?: Uint8Array;\n    tree?: Tree;\n};\n/**\n * Tree hashing parameters.\n */\nexport declare type Tree = {\n    fanout: number;\n    maxDepth: number;\n    leafSize: number;\n    nodeOffsetHighBits: number;\n    nodeOffsetLowBits: number;\n    nodeDepth: number;\n    innerDigestLength: number;\n    lastNode: boolean;\n};\n/**\n * BLAKE2b hash function.\n */\nexport declare class BLAKE2b implements SerializableHash {\n    digestLength: number;\n    readonly blockSize = 128;\n    private _state;\n    private _buffer;\n    private _bufferLength;\n    private _ctr;\n    private _flag;\n    private _lastNode;\n    private _finished;\n    private _vtmp;\n    private _mtmp;\n    private _paddedKey;\n    private _initialState;\n    constructor(digestLength?: number, config?: Config);\n    reset(): this;\n    validateConfig(config: Config): void;\n    update(data: Uint8Array, dataLength?: number): this;\n    finish(out: Uint8Array): this;\n    digest(): Uint8Array;\n    clean(): void;\n    saveState(): SavedState;\n    restoreState(savedState: SavedState): this;\n    cleanSavedState(savedState: SavedState): void;\n    private _G;\n    private _incrementCounter;\n    private _processBlock;\n}\nexport declare type SavedState = {\n    state: Uint32Array;\n    buffer: Uint8Array;\n    bufferLength: number;\n    ctr: Uint32Array;\n    flag: Uint32Array;\n    lastNode: boolean;\n    paddedKey: Uint8Array | undefined;\n    initialState: Uint32Array;\n};\nexport declare function hash(data: Uint8Array, digestLength?: number, config?: Config): Uint8Array;\n'},{name:"@taquito/utils/node_modules/@stablelib/blake2b/lib/blake2b.test.d.ts",dts:"export {};\n"},{name:"@taquito/utils/node_modules/@stablelib/ed25519/lib/ed25519.bench.d.ts",dts:"export {};\n"},{name:"@taquito/utils/node_modules/@stablelib/ed25519/lib/ed25519.d.ts",dts:'/**\n * Package ed25519 implements Ed25519 public-key signature algorithm.\n */\nimport { RandomSource } from "@stablelib/random";\nexport declare const SIGNATURE_LENGTH = 64;\nexport declare const PUBLIC_KEY_LENGTH = 32;\nexport declare const SECRET_KEY_LENGTH = 64;\nexport declare const SEED_LENGTH = 32;\nexport interface KeyPair {\n    publicKey: Uint8Array;\n    secretKey: Uint8Array;\n}\nexport declare function generateKeyPairFromSeed(seed: Uint8Array): KeyPair;\nexport declare function generateKeyPair(prng?: RandomSource): KeyPair;\nexport declare function extractPublicKeyFromSecretKey(secretKey: Uint8Array): Uint8Array;\nexport declare function sign(secretKey: Uint8Array, message: Uint8Array): Uint8Array;\nexport declare function verify(publicKey: Uint8Array, message: Uint8Array, signature: Uint8Array): boolean;\n/**\n * Convert Ed25519 public key to X25519 public key.\n *\n * Throws if given an invalid public key.\n */\nexport declare function convertPublicKeyToX25519(publicKey: Uint8Array): Uint8Array;\n/**\n *  Convert Ed25519 secret (private) key to X25519 secret key.\n */\nexport declare function convertSecretKeyToX25519(secretKey: Uint8Array): Uint8Array;\n'},{name:"@taquito/utils/node_modules/@stablelib/ed25519/lib/ed25519.test.d.ts",dts:"export {};\n"},{name:"@taquito/utils/node_modules/@stablelib/hash/lib/hash.d.ts",dts:"/**\n * Package hash provides interface for hash functions.\n */\n/**\n * Hash interface describes properties of\n * cryptographic hash functions.\n */\nexport interface Hash {\n    readonly digestLength: number;\n    readonly blockSize: number;\n    update(data: Uint8Array): this;\n    reset(): this;\n    finish(out: Uint8Array): this;\n    digest(): Uint8Array;\n    clean(): void;\n}\nexport interface SerializableHash extends Hash {\n    saveState(): any;\n    restoreState(savedState: any): this;\n    cleanSavedState(savedState: any): void;\n}\nexport declare function isSerializableHash(h: Hash): h is SerializableHash;\n"},{name:"@taquito/utils/node_modules/@stablelib/int/lib/int.d.ts",dts:"/** 32-bit integer multiplication.  */\nexport declare const mul: (a: number, b: number) => number;\n/** 32-bit integer addition.  */\nexport declare function add(a: number, b: number): number;\n/**  32-bit integer subtraction.  */\nexport declare function sub(a: number, b: number): number;\n/** 32-bit integer left rotation */\nexport declare function rotl(x: number, n: number): number;\n/** 32-bit integer left rotation */\nexport declare function rotr(x: number, n: number): number;\n/**\n * Returns true if the argument is an integer number.\n *\n * In ES2015, Number.isInteger.\n */\nexport declare const isInteger: (n: number) => boolean;\n/**\n *  Math.pow(2, 53) - 1\n *\n *  In ES2015 Number.MAX_SAFE_INTEGER.\n */\nexport declare const MAX_SAFE_INTEGER = 9007199254740991;\n/**\n * Returns true if the argument is a safe integer number\n * (-MIN_SAFE_INTEGER < number <= MAX_SAFE_INTEGER)\n *\n * In ES2015, Number.isSafeInteger.\n */\nexport declare const isSafeInteger: (n: number) => boolean;\n"},{name:"@taquito/utils/node_modules/@stablelib/int/lib/int.test.d.ts",dts:"export {};\n"},{name:"@taquito/utils/node_modules/@stablelib/random/lib/source/browser.d.ts",dts:'import { RandomSource } from "./";\nexport declare class BrowserRandomSource implements RandomSource {\n    isAvailable: boolean;\n    isInstantiated: boolean;\n    private _crypto?;\n    constructor();\n    randomBytes(length: number): Uint8Array;\n}\n'},{name:"@taquito/utils/node_modules/@stablelib/random/lib/source/index.d.ts",dts:"export interface RandomSource {\n    /**\n     * Returns the availability of random source.\n     * A source can only be used if isAvailable returns true.\n     */\n    isAvailable: boolean;\n    /**\n     * Returns a byte array of the given length filled with random bytes.\n     */\n    randomBytes(length: number): Uint8Array;\n}\n"},{name:"@taquito/utils/node_modules/@stablelib/random/lib/source/node.d.ts",dts:'import { RandomSource } from "./";\nexport declare class NodeRandomSource implements RandomSource {\n    isAvailable: boolean;\n    isInstantiated: boolean;\n    private _crypto;\n    constructor();\n    randomBytes(length: number): Uint8Array;\n}\n'},{name:"@taquito/utils/node_modules/@stablelib/random/lib/source/system.d.ts",dts:'import { RandomSource } from "./";\nexport declare class SystemRandomSource implements RandomSource {\n    isAvailable: boolean;\n    name: string;\n    private _source;\n    constructor();\n    randomBytes(length: number): Uint8Array;\n}\n'},{name:"@taquito/utils/node_modules/@stablelib/random/lib/source/system.test.d.ts",dts:"export {};\n"},{name:"@taquito/utils/node_modules/@stablelib/random/lib/random.d.ts",dts:'/**\n * Package random provides functions to access system\'s\n * cryptographically secure random byte generator.\n */\nimport { RandomSource } from "./source";\nimport { SystemRandomSource } from "./source/system";\nexport { RandomSource } from "./source";\nexport declare const defaultRandomSource: SystemRandomSource;\nexport declare function randomBytes(length: number, prng?: RandomSource): Uint8Array;\n/**\n * Returns a uniformly random unsigned 32-bit integer.\n */\nexport declare function randomUint32(prng?: RandomSource): number;\n/**\n * Returns a uniform random string of the given length\n * with characters from the given charset.\n *\n * Charset must not have more than 256 characters.\n *\n * Default charset generates case-sensitive alphanumeric\n * strings (0-9, A-Z, a-z).\n */\nexport declare function randomString(length: number, charset?: string, prng?: RandomSource): string;\n/**\n * Returns uniform random string containing at least the given\n * number of bits of entropy.\n *\n * For example, randomStringForEntropy(128) will return a 22-character\n * alphanumeric string, while randomStringForEntropy(128, "0123456789")\n * will return a 39-character numeric string, both will contain at\n * least 128 bits of entropy.\n *\n * Default charset generates case-sensitive alphanumeric\n * strings (0-9, A-Z, a-z).\n */\nexport declare function randomStringForEntropy(bits: number, charset?: string, prng?: RandomSource): string;\n'},{name:"@taquito/utils/node_modules/@stablelib/random/lib/random.test.d.ts",dts:"export {};\n"},{name:"@taquito/utils/node_modules/@stablelib/sha512/lib/sha512.bench.d.ts",dts:"export {};\n"},{name:"@taquito/utils/node_modules/@stablelib/sha512/lib/sha512.d.ts",dts:'/**\n * Package sha512 implements SHA-2-512 cryptographic hash function.\n */\nimport { SerializableHash } from "@stablelib/hash";\nexport declare const DIGEST_LENGTH = 64;\nexport declare const BLOCK_SIZE = 128;\n/**\n * SHA-2-512 cryptographic hash algorithm.\n */\nexport declare class SHA512 implements SerializableHash {\n    /** Length of hash output */\n    readonly digestLength: number;\n    /** Block size */\n    readonly blockSize: number;\n    protected _stateHi: Int32Array;\n    protected _stateLo: Int32Array;\n    private _tempHi;\n    private _tempLo;\n    private _buffer;\n    private _bufferLength;\n    private _bytesHashed;\n    private _finished;\n    constructor();\n    protected _initState(): void;\n    /**\n     * Resets hash state making it possible\n     * to re-use this instance to hash other data.\n     */\n    reset(): this;\n    /**\n     * Cleans internal buffers and resets hash state.\n     */\n    clean(): void;\n    /**\n     * Updates hash state with the given data.\n     *\n     * Throws error when trying to update already finalized hash:\n     * instance must be reset to update it again.\n     */\n    update(data: Uint8Array, dataLength?: number): this;\n    /**\n     * Finalizes hash state and puts hash into out.\n     * If hash was already finalized, puts the same value.\n     */\n    finish(out: Uint8Array): this;\n    /**\n     * Returns the final hash digest.\n     */\n    digest(): Uint8Array;\n    /**\n     * Function useful for HMAC/PBKDF2 optimization. Returns hash state to be\n     * used with restoreState(). Only chain value is saved, not buffers or\n     * other state variables.\n     */\n    saveState(): SavedState;\n    /**\n     * Function useful for HMAC/PBKDF2 optimization. Restores state saved by\n     * saveState() and sets bytesHashed to the given value.\n     */\n    restoreState(savedState: SavedState): this;\n    /**\n     * Cleans state returned by saveState().\n     */\n    cleanSavedState(savedState: SavedState): void;\n}\nexport declare type SavedState = {\n    stateHi: Int32Array;\n    stateLo: Int32Array;\n    buffer: Uint8Array | undefined;\n    bufferLength: number;\n    bytesHashed: number;\n};\nexport declare function hash(data: Uint8Array): Uint8Array;\n'},{name:"@taquito/utils/node_modules/@stablelib/sha512/lib/sha512.test.d.ts",dts:"export {};\n"},{name:"@taquito/utils/node_modules/@stablelib/wipe/lib/wipe.d.ts",dts:"/**\n * Package wipe implements functions for zeroing arrays.\n */\nexport declare type NumericArray = number[] | Uint8Array | Int8Array | Uint16Array | Int16Array | Uint32Array | Int32Array | Float32Array | Float64Array;\n/**\n * Sets all values in the given array to zero and returns it.\n *\n * The fact that it sets bytes to zero can be relied on.\n *\n * There is no guarantee that this function makes data disappear from memory,\n * as runtime implementation can, for example, have copying garbage collector\n * that will make copies of sensitive data before we wipe it. Or that an\n * operating system will write our data to swap or sleep image. Another thing\n * is that an optimizing compiler can remove calls to this function or make it\n * no-op. There's nothing we can do with it, so we just do our best and hope\n * that everything will be okay and good will triumph over evil.\n */\nexport declare function wipe(array: NumericArray): NumericArray;\n"},{name:"@taquito/utils/node_modules/@stablelib/wipe/lib/wipe.test.d.ts",dts:"export {};\n"},{name:"@taquito/utils/node_modules/base-x/src/index.d.ts",dts:"declare function base(ALPHABET: string): base.BaseConverter;\nexport = base;\ndeclare namespace base {\n    interface BaseConverter {\n        encode(buffer: Uint8Array | number[]): string;\n        decodeUnsafe(string: string): Uint8Array | undefined;\n        decode(string: string): Uint8Array;\n    }\n}\n"},{name:"@taquito/utils/node_modules/bs58/index.d.ts",dts:"import { BaseConverter } from 'base-x';\n\ndeclare const base58: BaseConverter;\n\nexport = base58;\n"},{name:"@taquito/utils/node_modules/bs58check/index.d.ts",dts:'/// <reference types="node" />\n\ndeclare const bs58check: {\n    encode(buffer: Buffer | number[] | Uint8Array): string;\n    decodeUnsafe(string: string): Uint8Array | undefined;\n    decode(string: string): Uint8Array;\n};\n\nexport = bs58check;\n'}];var s=t(68553),i=t(74848);const p=function(e){let n;const{colorMode:t}=(0,o.G)();return(0,i.jsx)(r.Suspense,{fallback:(0,i.jsx)("div",{children:"Loading"}),children:(0,i.jsx)(s.Ay,{...e,defaultLanguage:"typescript",beforeMount:function(t){n=t,t.editor.defineTheme("vs-dark",{base:"vs-dark",inherit:!0,rules:[{background:"121212"}],colors:{"editor.background":"#121212"}}),t.languages.typescript.typescriptDefaults.setCompilerOptions({target:t.languages.typescript.ScriptTarget.ES2017,allowNonTsExtensions:!0,moduleResolution:t.languages.typescript.ModuleResolutionKind.NodeJs,module:t.languages.typescript.ModuleKind.ESNext,typeRoots:["node_modules/@types"]}),a.forEach(e=>{const n=`file:///node_modules/${e.name}`;t.languages.typescript.typescriptDefaults.addExtraLib(e.dts,n)}),e.editorWillMount&&e.editorWillMount(t)},onMount:function(t){t.setModel(n.editor.createModel(e.value,e.language,n.Uri.parse(`file:///main-${Math.random()}.ts`)))},theme:"dark"===t?"vs-dark":"light"})})}},78952:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{copyShareUrl:()=>copyShareUrl,reset:()=>reset,runBeaconCode:()=>runBeaconCode});var _node_modules_beacon_sdk_dist_cjs__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(98455),_node_modules_beacon_sdk_dist_cjs__WEBPACK_IMPORTED_MODULE_0___default=__webpack_require__.n(_node_modules_beacon_sdk_dist_cjs__WEBPACK_IMPORTED_MODULE_0__),typescript__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(58843),typescript__WEBPACK_IMPORTED_MODULE_1___default=__webpack_require__.n(typescript__WEBPACK_IMPORTED_MODULE_1__),_taquito_taquito__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(79230),_taquito_beacon_wallet__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(9238),console=__webpack_require__(96763);function replaceAll(e,n,t){return e.split(n).join(t)}const removeImports=e=>{const n=e.split("\n");let t=!0;return n.map(e=>{e.trim().startsWith("import")&&(t=!1);const n=t?e:void 0;return(e.indexOf("@airgap/beacon-sdk")>=0||e.indexOf("@taquito")>=0)&&(t=!0),n}).filter(e=>!!e).join("\n")},runBeaconCode=(rawCode,setOutput)=>{let code=rawCode,output="";const appendOutput=e=>{output+="\n"+e,setOutput(output.trim())},myLog=(...e)=>{console.log("CODE_RUNNER:",...e),appendOutput(e.map(e=>"object"==typeof e?JSON.stringify(e,null,2):e).join(" "))};let runnable;return code=replaceAll(code,"console.log(","progress("),code=removeImports(code),code=typescript__WEBPACK_IMPORTED_MODULE_1__.transpile(`({\n      run: async (beacon: any, taquito: any, taquitoWallet: any, progress: any): string => {\n        Object.keys(beacon).forEach(key => {\n          window[key] = beacon[key]\n        })\n        Object.keys(taquito).forEach(key => {\n          window[key] = taquito[key]\n        })\n        Object.keys(taquitoWallet).forEach(key => {\n          window[key] = taquitoWallet[key]\n        })\n        return (async () => {\n          ${code};\n          if (typeof result !== 'undefined') {\n            return result\n          }\n        })()\n      })`),new Promise(resolve=>{try{runnable=eval(code),runnable.run(_node_modules_beacon_sdk_dist_cjs__WEBPACK_IMPORTED_MODULE_0__,_taquito_taquito__WEBPACK_IMPORTED_MODULE_2__,_taquito_beacon_wallet__WEBPACK_IMPORTED_MODULE_3__,myLog).then(e=>{e&&appendOutput("Returned:\n"+JSON.stringify(e,null,2)),resolve(e)}).catch(e=>{console.warn(e),appendOutput(JSON.stringify(e,null,2)),resolve(e)})}catch(e){appendOutput(e),console.error(e),resolve(e)}})},copyShareUrl=e=>{const n=`https://${window.location.host}/playground?code=${btoa(e)}`;navigator.clipboard.writeText(n).catch(e=>console.error("Failed to copy to url!",e))},reset=async()=>{const e=new _node_modules_beacon_sdk_dist_cjs__WEBPACK_IMPORTED_MODULE_0__.DAppClient({name:"Cleanup"});await e.destroy()}},79838:()=>{},82202:()=>{},84021:()=>{},89387:e=>{function n(e){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}n.keys=()=>[],n.resolve=n,n.id=89387,e.exports=n},91848:()=>{},92668:()=>{},96486:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>f});var r=t(96540),o=t(46942),a=t.n(o),s=t(17409),i=t(16864);const p="runbox__boR",c="row_BFIh";let l=function(e){return e[e.INIT=0]="INIT",e[e.STARTED=1]="STARTED",e[e.ENDED=2]="ENDED",e}({});var d=t(78478),m=t(67489),g=t(99418),u=t(74848);const f=function(){if("undefined"==typeof window)return null;const e=new URLSearchParams(window.location.search),n=g.A.sanitize(e.has("code")?atob(e.get("code")):'import { DAppClient, BeaconEvent } from "@airgap/beacon-sdk";\n\nconst dAppClient = new DAppClient({ name: "Beacon Docs" });\n\n// Listen for all the active account changes\ndAppClient.subscribeToEvent(BeaconEvent.ACTIVE_ACCOUNT_SET, async (account) => {\n  // An active account has been set, update the dApp UI\n  console.log(BeaconEvent.ACTIVE_ACCOUNT_SET, "triggered:", account);\n});\n\ntry {\n  console.log("Requesting permissions...");\n  const permissions = await dAppClient.requestPermissions();\n  console.log("Got permissions:", permissions.address);\n} catch (error) {\n  console.error("Got error:", error);\n}',{USE_PROFILES:{html:!0}}),[o,f]=(0,r.useState)(n),[h,y]=(0,r.useState)(""),[b,T]=(0,r.useState)(l.INIT),P=(0,i.A)(),E=e=>{f(e)},R=100,x={width:P.width,height:200},O={width:.6*P.width,height:P.height-R},v={width:P.width,height:P.height-R-x.height},S={width:(.4-.05)*P.width,height:P.height};return(0,u.jsx)(d.A,{fallback:(0,u.jsx)(u.Fragment,{}),children:()=>{const{DAppClient:e}=t(21291),n=t(76450).A,{copyShareUrl:r,runBeaconCode:i}=t(78952),d=async()=>{y(""),T(l.INIT)};return(0,u.jsxs)(s.A,{title:"Beacon",description:"Beacon Playground",noFooter:!0,children:[(0,u.jsxs)("div",{className:a()(p),children:[(0,u.jsx)("button",{onClick:async()=>{b!==l.STARTED&&(await d(),T(l.STARTED),await i(o,y),T(l.ENDED))},className:"button button--primary margin-bottom--lg margin-right--xs",children:"Run Code"}),(0,u.jsx)("button",{onClick:async()=>{d();const n=new e({name:"Cleanup"});await n.destroy()},className:"button button--secondary margin-bottom--lg margin-right--xs",children:"Reset"}),(0,u.jsx)("button",{onClick:d,className:"button button--secondary margin-bottom--lg margin-right--xs",children:"Clear Output"}),(0,u.jsx)("button",{onClick:()=>{r(o)},className:"button button--secondary margin-bottom--lg margin-right--xs",children:"Share Code (Copy to Clipboard)"})]}),(0,u.jsx)("div",{className:a()(c),children:(0,u.jsxs)(m.A,{fallback:({error:e,tryAgain:n})=>(0,u.jsxs)("div",{children:[(0,u.jsxs)("p",{children:["This editor crashed because of error: ",e.message,"."]}),(0,u.jsx)("button",{onClick:n,children:"Try Again!"})]}),children:[(0,u.jsx)(n,{...P.width>600?O:x,language:"typescript",value:o,onChange:E,options:{minimap:{enabled:!1},wordWrap:"on"}}),(0,u.jsx)(n,{...P.width>600?S:v,language:"shell",value:h,options:{readOnly:!0,minimap:{enabled:!1},wordWrap:"on"}})]})})]})}})}},97664:()=>{},98285:()=>{}}]);